[ {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVDuplicateHeaderTest.java",
  "methodName" : "testCSVFormat",
  "sourceCode" : "/**\r\n * Tests duplicate headers with the CSVFormat.\r\n *\r\n * @param duplicateHeaderMode the duplicate header mode\r\n * @param allowMissingColumnNames the allow missing column names flag (only used for parsing)\r\n * @param ignoreHeaderCase the ignore header case flag (only used for parsing)\r\n * @param headers the headers\r\n * @param valid true if the settings are expected to be valid, otherwise expect a IllegalArgumentException\r\n */\r\n@ParameterizedTest\r\n@MethodSource(value = { \"duplicateHeaderAllowsMissingColumnsNamesData\" })\r\nvoid testCSVFormat(final DuplicateHeaderMode duplicateHeaderMode, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final String[] headers, final boolean valid) {\r\n    final CSVFormat.Builder builder = CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(duplicateHeaderMode).setAllowMissingColumnNames(allowMissingColumnNames).setIgnoreHeaderCase(ignoreHeaderCase).setHeader(headers);\r\n    if (valid) {\r\n        final CSVFormat format = builder.get();\r\n        Assertions.assertEquals(duplicateHeaderMode, format.getDuplicateHeaderMode(), \"DuplicateHeaderMode\");\r\n        Assertions.assertEquals(allowMissingColumnNames, format.getAllowMissingColumnNames(), \"AllowMissingColumnNames\");\r\n        Assertions.assertArrayEquals(headers, format.getHeader(), \"Header\");\r\n    } else {\r\n        Assertions.assertThrows(IllegalArgumentException.class, builder::get);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVDuplicateHeaderTest.java",
  "methodName" : "testCSVParser",
  "sourceCode" : "/**\r\n * Tests duplicate headers with the CSVParser.\r\n *\r\n * @param duplicateHeaderMode the duplicate header mode\r\n * @param allowMissingColumnNames the allow missing column names flag (only used for parsing)\r\n * @param ignoreHeaderCase the ignore header case flag (only used for parsing)\r\n * @param headers the headers (joined with the CSVFormat delimiter to create a string input)\r\n * @param valid true if the settings are expected to be valid, otherwise expect a IllegalArgumentException\r\n * @throws IOException Signals that an I/O exception has occurred.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(value = { \"duplicateHeaderData\" })\r\nvoid testCSVParser(final DuplicateHeaderMode duplicateHeaderMode, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final String[] headers, final boolean valid) throws IOException {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(duplicateHeaderMode).setAllowMissingColumnNames(allowMissingColumnNames).setIgnoreHeaderCase(ignoreHeaderCase).setNullString(\"NULL\").setHeader().get();\r\n    // @formatter:on\r\n    final String input = Arrays.stream(headers).map(s -> s == null ? format.getNullString() : s).collect(Collectors.joining(format.getDelimiterString()));\r\n    // @formatter:off\r\n    if (valid) {\r\n        try (CSVParser parser = CSVParser.parse(input, format)) {\r\n            // Parser ignores null headers\r\n            final List<String> expected = Arrays.stream(headers).filter(s -> s != null).collect(Collectors.toList());\r\n            Assertions.assertEquals(expected, parser.getHeaderNames(), \"HeaderNames\");\r\n        }\r\n    } else {\r\n        Assertions.assertThrows(IllegalArgumentException.class, () -> CSVParser.parse(input, format));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFileParserTest.java",
  "methodName" : "testCSVFile",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"generateData\")\r\nvoid testCSVFile(final File testFile) throws Exception {\r\n    try (FileReader fr = new FileReader(testFile);\r\n        BufferedReader testDataReader = new BufferedReader(fr)) {\r\n        String line = readTestData(testDataReader);\r\n        assertNotNull(\"file must contain config line\", line);\r\n        final String[] split = line.split(\" \");\r\n        assertTrue(split.length >= 1, testFile.getName() + \" require 1 param\");\r\n        // first line starts with csv data file name\r\n        CSVFormat format = CSVFormat.newFormat(',').withQuote('\"');\r\n        boolean checkComments = false;\r\n        for (int i = 1; i < split.length; i++) {\r\n            final String option = split[i];\r\n            final String[] optionParts = option.split(\"=\", 2);\r\n            if (\"IgnoreEmpty\".equalsIgnoreCase(optionParts[0])) {\r\n                format = format.withIgnoreEmptyLines(Boolean.parseBoolean(optionParts[1]));\r\n            } else if (\"IgnoreSpaces\".equalsIgnoreCase(optionParts[0])) {\r\n                format = format.withIgnoreSurroundingSpaces(Boolean.parseBoolean(optionParts[1]));\r\n            } else if (\"CommentStart\".equalsIgnoreCase(optionParts[0])) {\r\n                format = format.withCommentMarker(optionParts[1].charAt(0));\r\n            } else if (\"CheckComments\".equalsIgnoreCase(optionParts[0])) {\r\n                checkComments = true;\r\n            } else {\r\n                fail(testFile.getName() + \" unexpected option: \" + option);\r\n            }\r\n        }\r\n        // get string version of format\r\n        line = readTestData(testDataReader);\r\n        assertEquals(line, format.toString(), testFile.getName() + \" Expected format \");\r\n        // Now parse the file and compare against the expected results\r\n        // We use a buffered reader internally so no need to create one here.\r\n        try (CSVParser parser = CSVParser.parse(new File(BASE_DIR, split[0]), Charset.defaultCharset(), format)) {\r\n            for (final CSVRecord record : parser) {\r\n                String parsed = Arrays.toString(record.values());\r\n                final String comment = record.getComment();\r\n                if (checkComments && comment != null) {\r\n                    parsed += \"#\" + comment.replace(\"\\n\", \"\\\\n\");\r\n                }\r\n                final int count = record.size();\r\n                assertEquals(readTestData(testDataReader), count + \":\" + parsed, testFile.getName());\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFileParserTest.java",
  "methodName" : "testCSVUrl",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"generateData\")\r\nvoid testCSVUrl(final File testFile) throws Exception {\r\n    try (FileReader fr = new FileReader(testFile);\r\n        BufferedReader testData = new BufferedReader(fr)) {\r\n        String line = readTestData(testData);\r\n        assertNotNull(\"file must contain config line\", line);\r\n        final String[] split = line.split(\" \");\r\n        assertTrue(split.length >= 1, testFile.getName() + \" require 1 param\");\r\n        // first line starts with csv data file name\r\n        CSVFormat format = CSVFormat.newFormat(',').withQuote('\"');\r\n        boolean checkComments = false;\r\n        for (int i = 1; i < split.length; i++) {\r\n            final String option = split[i];\r\n            final String[] optionParts = option.split(\"=\", 2);\r\n            if (\"IgnoreEmpty\".equalsIgnoreCase(optionParts[0])) {\r\n                format = format.withIgnoreEmptyLines(Boolean.parseBoolean(optionParts[1]));\r\n            } else if (\"IgnoreSpaces\".equalsIgnoreCase(optionParts[0])) {\r\n                format = format.withIgnoreSurroundingSpaces(Boolean.parseBoolean(optionParts[1]));\r\n            } else if (\"CommentStart\".equalsIgnoreCase(optionParts[0])) {\r\n                format = format.withCommentMarker(optionParts[1].charAt(0));\r\n            } else if (\"CheckComments\".equalsIgnoreCase(optionParts[0])) {\r\n                checkComments = true;\r\n            } else {\r\n                fail(testFile.getName() + \" unexpected option: \" + option);\r\n            }\r\n        }\r\n        // get string version of format\r\n        line = readTestData(testData);\r\n        assertEquals(line, format.toString(), testFile.getName() + \" Expected format \");\r\n        // Now parse the file and compare against the expected results\r\n        final URL resource = ClassLoader.getSystemResource(\"org/apache/commons/csv/CSVFileParser/\" + split[0]);\r\n        try (CSVParser parser = CSVParser.parse(resource, StandardCharsets.UTF_8, format)) {\r\n            for (final CSVRecord record : parser) {\r\n                String parsed = Arrays.toString(record.values());\r\n                final String comment = record.getComment();\r\n                if (checkComments && comment != null) {\r\n                    parsed += \"#\" + comment.replace(\"\\n\", \"\\\\n\");\r\n                }\r\n                final int count = record.size();\r\n                assertEquals(readTestData(testData), count + \":\" + parsed, testFile.getName());\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testDefault",
  "sourceCode" : "@Test\r\nvoid testDefault() {\r\n    test(CSVFormat.DEFAULT, \"Default\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testExcel",
  "sourceCode" : "@Test\r\nvoid testExcel() {\r\n    test(CSVFormat.EXCEL, \"Excel\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testMongoDbCsv",
  "sourceCode" : "@Test\r\nvoid testMongoDbCsv() {\r\n    test(CSVFormat.MONGODB_CSV, \"MongoDBCsv\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testMongoDbTsv",
  "sourceCode" : "@Test\r\nvoid testMongoDbTsv() {\r\n    test(CSVFormat.MONGODB_TSV, \"MongoDBTsv\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testMySQL",
  "sourceCode" : "@Test\r\nvoid testMySQL() {\r\n    test(CSVFormat.MYSQL, \"MySQL\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testOracle",
  "sourceCode" : "@Test\r\nvoid testOracle() {\r\n    test(CSVFormat.ORACLE, \"Oracle\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testPostgreSqlCsv",
  "sourceCode" : "@Test\r\nvoid testPostgreSqlCsv() {\r\n    test(CSVFormat.POSTGRESQL_CSV, \"PostgreSQLCsv\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testPostgreSqlText",
  "sourceCode" : "@Test\r\nvoid testPostgreSqlText() {\r\n    test(CSVFormat.POSTGRESQL_TEXT, \"PostgreSQLText\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testRFC4180",
  "sourceCode" : "@Test\r\nvoid testRFC4180() {\r\n    test(CSVFormat.RFC4180, \"RFC4180\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatPredefinedTest.java",
  "methodName" : "testTDF",
  "sourceCode" : "@Test\r\nvoid testTDF() {\r\n    test(CSVFormat.TDF, \"TDF\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testBuildVsGet",
  "sourceCode" : "@Test\r\nvoid testBuildVsGet() {\r\n    final Builder builder = CSVFormat.DEFAULT.builder();\r\n    assertNotSame(builder.get(), builder.build());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterCharLineBreakCrThrowsException1",
  "sourceCode" : "@Test\r\nvoid testDelimiterCharLineBreakCrThrowsException1() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(Constants.CR).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterCharLineBreakLfThrowsException1",
  "sourceCode" : "@Test\r\nvoid testDelimiterCharLineBreakLfThrowsException1() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(Constants.LF).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterEmptyStringThrowsException1",
  "sourceCode" : "@Test\r\nvoid testDelimiterEmptyStringThrowsException1() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(\"\").get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterSameAsCommentStartThrowsException_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testDelimiterSameAsCommentStartThrowsException_Deprecated() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withCommentMarker('!'));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterSameAsCommentStartThrowsException1",
  "sourceCode" : "@Test\r\nvoid testDelimiterSameAsCommentStartThrowsException1() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setCommentMarker('!').get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterSameAsEscapeThrowsException_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testDelimiterSameAsEscapeThrowsException_Deprecated() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withEscape('!'));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterSameAsEscapeThrowsException1",
  "sourceCode" : "@Test\r\nvoid testDelimiterSameAsEscapeThrowsException1() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setEscape('!').get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterSameAsRecordSeparatorThrowsException",
  "sourceCode" : "@Test\r\nvoid testDelimiterSameAsRecordSeparatorThrowsException() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat(CR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterStringLineBreakCrThrowsException1",
  "sourceCode" : "@Test\r\nvoid testDelimiterStringLineBreakCrThrowsException1() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(String.valueOf(Constants.CR)).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDelimiterStringLineBreakLfThrowsException1",
  "sourceCode" : "@Test\r\nvoid testDelimiterStringLineBreakLfThrowsException1() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(String.valueOf(Constants.LF)).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElements",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeaderElements() {\r\n    final String[] header = { \"A\", \"A\" };\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(header).get();\r\n    assertEquals(2, format.getHeader().length);\r\n    assertArrayEquals(header, format.getHeader());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElements_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testDuplicateHeaderElements_Deprecated() {\r\n    final String[] header = { \"A\", \"A\" };\r\n    final CSVFormat format = CSVFormat.DEFAULT.withHeader(header);\r\n    assertEquals(2, format.getHeader().length);\r\n    assertArrayEquals(header, format.getHeader());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElementsFalse",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeaderElementsFalse() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"A\").get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElementsFalse_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testDuplicateHeaderElementsFalse_Deprecated() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false).withHeader(\"A\", \"A\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElementsTrue",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeaderElementsTrue() {\r\n    CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"A\", \"A\").get();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElementsTrue_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testDuplicateHeaderElementsTrue_Deprecated() {\r\n    CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(true).withHeader(\"A\", \"A\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElementsTrueContainsEmpty1",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeaderElementsTrueContainsEmpty1() {\r\n    CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElementsTrueContainsEmpty2",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeaderElementsTrueContainsEmpty2() {\r\n    CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testDuplicateHeaderElementsTrueContainsEmpty3",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeaderElementsTrueContainsEmpty3() {\r\n    CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setAllowMissingColumnNames(true).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEquals",
  "sourceCode" : "@Test\r\nvoid testEquals() {\r\n    final CSVFormat right = CSVFormat.DEFAULT;\r\n    final CSVFormat left = copy(right);\r\n    Assertions.assertNotEquals(null, right);\r\n    Assertions.assertNotEquals(\"A String Instance\", right);\r\n    assertEquals(right, right);\r\n    assertEquals(right, left);\r\n    assertEquals(left, right);\r\n    assertEquals(right.hashCode(), right.hashCode());\r\n    assertEquals(right.hashCode(), left.hashCode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsCommentStart",
  "sourceCode" : "@Test\r\nvoid testEqualsCommentStart() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setQuoteMode(QuoteMode.ALL).get();\r\n    final CSVFormat left = right.builder().setCommentMarker('!').get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsCommentStart_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsCommentStart_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withQuoteMode(QuoteMode.ALL);\r\n    final CSVFormat left = right.withCommentMarker('!');\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsDelimiter",
  "sourceCode" : "@Test\r\nvoid testEqualsDelimiter() {\r\n    final CSVFormat right = CSVFormat.newFormat('!');\r\n    final CSVFormat left = CSVFormat.newFormat('?');\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsEscape",
  "sourceCode" : "@Test\r\nvoid testEqualsEscape() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setEscape('+').setQuoteMode(QuoteMode.ALL).get();\r\n    final CSVFormat left = right.builder().setEscape('!').get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsEscape_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsEscape_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withEscape('+').withQuoteMode(QuoteMode.ALL);\r\n    final CSVFormat left = right.withEscape('!');\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsHash",
  "sourceCode" : "@Test\r\nvoid testEqualsHash() throws Exception {\r\n    final Method[] methods = CSVFormat.class.getDeclaredMethods();\r\n    for (final Method method : methods) {\r\n        if (Modifier.isPublic(method.getModifiers())) {\r\n            final String name = method.getName();\r\n            if (name.startsWith(\"with\")) {\r\n                for (final Class<?> cls : method.getParameterTypes()) {\r\n                    final String type = cls.getCanonicalName();\r\n                    switch(type) {\r\n                        case \"boolean\":\r\n                            {\r\n                                final Object defTrue = method.invoke(CSVFormat.DEFAULT, Boolean.TRUE);\r\n                                final Object defFalse = method.invoke(CSVFormat.DEFAULT, Boolean.FALSE);\r\n                                assertNotEquals(name, type, defTrue, defFalse);\r\n                                break;\r\n                            }\r\n                        case \"char\":\r\n                            {\r\n                                final Object a = method.invoke(CSVFormat.DEFAULT, 'a');\r\n                                final Object b = method.invoke(CSVFormat.DEFAULT, 'b');\r\n                                assertNotEquals(name, type, a, b);\r\n                                break;\r\n                            }\r\n                        case \"java.lang.Character\":\r\n                            {\r\n                                final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\r\n                                final Object b = method.invoke(CSVFormat.DEFAULT, Character.valueOf('d'));\r\n                                assertNotEquals(name, type, a, b);\r\n                                break;\r\n                            }\r\n                        case \"java.lang.String\":\r\n                            {\r\n                                final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\r\n                                final Object b = method.invoke(CSVFormat.DEFAULT, \"e\");\r\n                                assertNotEquals(name, type, a, b);\r\n                                break;\r\n                            }\r\n                        case \"java.lang.String[]\":\r\n                            {\r\n                                final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { null, null } });\r\n                                final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { \"f\", \"g\" } });\r\n                                assertNotEquals(name, type, a, b);\r\n                                break;\r\n                            }\r\n                        case \"org.apache.commons.csv.QuoteMode\":\r\n                            {\r\n                                final Object a = method.invoke(CSVFormat.DEFAULT, QuoteMode.MINIMAL);\r\n                                final Object b = method.invoke(CSVFormat.DEFAULT, QuoteMode.ALL);\r\n                                assertNotEquals(name, type, a, b);\r\n                                break;\r\n                            }\r\n                        case \"org.apache.commons.csv.DuplicateHeaderMode\":\r\n                            {\r\n                                final Object a = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.ALLOW_ALL);\r\n                                final Object b = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.DISALLOW);\r\n                                assertNotEquals(name, type, a, b);\r\n                                break;\r\n                            }\r\n                        case \"java.lang.Object[]\":\r\n                            {\r\n                                final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { null, null } });\r\n                                final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { new Object(), new Object() } });\r\n                                assertNotEquals(name, type, a, b);\r\n                                break;\r\n                            }\r\n                        default:\r\n                            if (\"withHeader\".equals(name)) {\r\n                                // covered above by String[]\r\n                                // ignored\r\n                            } else {\r\n                                fail(\"Unhandled method: \" + name + \"(\" + type + \")\");\r\n                            }\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsHeader",
  "sourceCode" : "@Test\r\nvoid testEqualsHeader() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setHeader(\"One\", \"Two\", \"Three\").setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n    final CSVFormat left = right.builder().setHeader(\"Three\", \"Two\", \"One\").get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsHeader_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsHeader_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withHeader(\"One\", \"Two\", \"Three\").withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n    final CSVFormat left = right.withHeader(\"Three\", \"Two\", \"One\");\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsIgnoreEmptyLines",
  "sourceCode" : "@Test\r\nvoid testEqualsIgnoreEmptyLines() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n    final CSVFormat left = right.builder().setIgnoreEmptyLines(false).get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsIgnoreEmptyLines_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsIgnoreEmptyLines_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n    final CSVFormat left = right.withIgnoreEmptyLines(false);\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsIgnoreSurroundingSpaces",
  "sourceCode" : "@Test\r\nvoid testEqualsIgnoreSurroundingSpaces() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n    final CSVFormat left = right.builder().setIgnoreSurroundingSpaces(false).get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsIgnoreSurroundingSpaces_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsIgnoreSurroundingSpaces_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n    final CSVFormat left = right.withIgnoreSurroundingSpaces(false);\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsLeftNoQuoteRightQuote",
  "sourceCode" : "@Test\r\nvoid testEqualsLeftNoQuoteRightQuote() {\r\n    final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\r\n    final CSVFormat right = left.builder().setQuote('#').get();\r\n    assertNotEquals(left, right);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsLeftNoQuoteRightQuote_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsLeftNoQuoteRightQuote_Deprecated() {\r\n    final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\r\n    final CSVFormat right = left.withQuote('#');\r\n    assertNotEquals(left, right);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsNoQuotes",
  "sourceCode" : "@Test\r\nvoid testEqualsNoQuotes() {\r\n    final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\r\n    final CSVFormat right = left.builder().setQuote(null).get();\r\n    assertEquals(left, right);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsNoQuotes_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsNoQuotes_Deprecated() {\r\n    final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\r\n    final CSVFormat right = left.withQuote(null);\r\n    assertEquals(left, right);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsNullString",
  "sourceCode" : "@Test\r\nvoid testEqualsNullString() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").get();\r\n    final CSVFormat left = right.builder().setNullString(\"---\").get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsNullString_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsNullString_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\");\r\n    final CSVFormat left = right.withNullString(\"---\");\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsOne",
  "sourceCode" : "@Test\r\nvoid testEqualsOne() {\r\n    final CSVFormat csvFormatOne = CSVFormat.INFORMIX_UNLOAD;\r\n    final CSVFormat csvFormatTwo = CSVFormat.MYSQL;\r\n    assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\r\n    assertEquals('\\\\', csvFormatOne.getEscapeChar());\r\n    assertNull(csvFormatOne.getQuoteMode());\r\n    assertTrue(csvFormatOne.getIgnoreEmptyLines());\r\n    assertFalse(csvFormatOne.getSkipHeaderRecord());\r\n    assertFalse(csvFormatOne.getIgnoreHeaderCase());\r\n    assertNull(csvFormatOne.getCommentMarker());\r\n    assertFalse(csvFormatOne.isCommentMarkerSet());\r\n    assertTrue(csvFormatOne.isQuoteCharacterSet());\r\n    assertEquals('|', csvFormatOne.getDelimiter());\r\n    assertFalse(csvFormatOne.getAllowMissingColumnNames());\r\n    assertTrue(csvFormatOne.isEscapeCharacterSet());\r\n    assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\r\n    assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\r\n    assertFalse(csvFormatOne.getTrailingDelimiter());\r\n    assertFalse(csvFormatOne.getTrim());\r\n    assertFalse(csvFormatOne.isNullStringSet());\r\n    assertNull(csvFormatOne.getNullString());\r\n    assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\r\n    assertTrue(csvFormatTwo.isEscapeCharacterSet());\r\n    assertNull(csvFormatTwo.getQuoteCharacter());\r\n    assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n    assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\r\n    assertEquals('\\t', csvFormatTwo.getDelimiter());\r\n    assertArrayEquals(new char[] { '\\t' }, csvFormatTwo.getDelimiterCharArray());\r\n    assertEquals(\"\\t\", csvFormatTwo.getDelimiterString());\r\n    assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\r\n    assertFalse(csvFormatTwo.isQuoteCharacterSet());\r\n    assertTrue(csvFormatTwo.isNullStringSet());\r\n    assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\r\n    assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n    assertFalse(csvFormatTwo.getTrim());\r\n    assertFalse(csvFormatTwo.getIgnoreEmptyLines());\r\n    assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\r\n    assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n    assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n    assertNull(csvFormatTwo.getCommentMarker());\r\n    assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n    assertNotSame(csvFormatTwo, csvFormatOne);\r\n    Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n    assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\r\n    assertNull(csvFormatOne.getQuoteMode());\r\n    assertTrue(csvFormatOne.getIgnoreEmptyLines());\r\n    assertFalse(csvFormatOne.getSkipHeaderRecord());\r\n    assertFalse(csvFormatOne.getIgnoreHeaderCase());\r\n    assertNull(csvFormatOne.getCommentMarker());\r\n    assertFalse(csvFormatOne.isCommentMarkerSet());\r\n    assertTrue(csvFormatOne.isQuoteCharacterSet());\r\n    assertEquals('|', csvFormatOne.getDelimiter());\r\n    assertFalse(csvFormatOne.getAllowMissingColumnNames());\r\n    assertTrue(csvFormatOne.isEscapeCharacterSet());\r\n    assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\r\n    assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\r\n    assertFalse(csvFormatOne.getTrailingDelimiter());\r\n    assertFalse(csvFormatOne.getTrim());\r\n    assertFalse(csvFormatOne.isNullStringSet());\r\n    assertNull(csvFormatOne.getNullString());\r\n    assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\r\n    assertTrue(csvFormatTwo.isEscapeCharacterSet());\r\n    assertNull(csvFormatTwo.getQuoteCharacter());\r\n    assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n    assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\r\n    assertEquals('\\t', csvFormatTwo.getDelimiter());\r\n    assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\r\n    assertFalse(csvFormatTwo.isQuoteCharacterSet());\r\n    assertTrue(csvFormatTwo.isNullStringSet());\r\n    assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\r\n    assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n    assertFalse(csvFormatTwo.getTrim());\r\n    assertFalse(csvFormatTwo.getIgnoreEmptyLines());\r\n    assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\r\n    assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n    assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n    assertNull(csvFormatTwo.getCommentMarker());\r\n    assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n    assertNotSame(csvFormatOne, csvFormatTwo);\r\n    assertNotSame(csvFormatTwo, csvFormatOne);\r\n    Assertions.assertNotEquals(csvFormatOne, csvFormatTwo);\r\n    Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n    Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsQuoteChar",
  "sourceCode" : "@Test\r\nvoid testEqualsQuoteChar() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').get();\r\n    final CSVFormat left = right.builder().setQuote('!').get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsQuoteChar_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsQuoteChar_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"');\r\n    final CSVFormat left = right.withQuote('!');\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsQuotePolicy",
  "sourceCode" : "@Test\r\nvoid testEqualsQuotePolicy() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n    final CSVFormat left = right.builder().setQuoteMode(QuoteMode.MINIMAL).get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsQuotePolicy_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsQuotePolicy_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n    final CSVFormat left = right.withQuoteMode(QuoteMode.MINIMAL);\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsRecordSeparator",
  "sourceCode" : "@Test\r\nvoid testEqualsRecordSeparator() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n    final CSVFormat left = right.builder().setRecordSeparator(LF).get();\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsRecordSeparator_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsRecordSeparator_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n    final CSVFormat left = right.withRecordSeparator(LF);\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsSkipHeaderRecord_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEqualsSkipHeaderRecord_Deprecated() {\r\n    final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\").withSkipHeaderRecord();\r\n    final CSVFormat left = right.withSkipHeaderRecord(false);\r\n    assertNotEquals(right, left);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEqualsWithNull",
  "sourceCode" : "@Test\r\nvoid testEqualsWithNull() {\r\n    final CSVFormat csvFormat = CSVFormat.POSTGRESQL_TEXT;\r\n    assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.isQuoteCharacterSet());\r\n    assertEquals(\"\\\\N\", csvFormat.getNullString());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertTrue(csvFormat.isEscapeCharacterSet());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\r\n    assertEquals('\\t', csvFormat.getDelimiter());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertEquals(\"\\n\", csvFormat.getRecordSeparator());\r\n    assertFalse(csvFormat.getIgnoreEmptyLines());\r\n    assertNull(csvFormat.getQuoteCharacter());\r\n    assertTrue(csvFormat.isNullStringSet());\r\n    assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.isQuoteCharacterSet());\r\n    assertEquals(\"\\\\N\", csvFormat.getNullString());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertTrue(csvFormat.isEscapeCharacterSet());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\r\n    assertEquals('\\t', csvFormat.getDelimiter());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertEquals(\"\\n\", csvFormat.getRecordSeparator());\r\n    assertFalse(csvFormat.getIgnoreEmptyLines());\r\n    assertNull(csvFormat.getQuoteCharacter());\r\n    assertTrue(csvFormat.isNullStringSet());\r\n    Assertions.assertNotEquals(null, csvFormat);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEscapeSameAsCommentStartThrowsException",
  "sourceCode" : "@Test\r\nvoid testEscapeSameAsCommentStartThrowsException() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setEscape('!').setCommentMarker('!').get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEscapeSameAsCommentStartThrowsException_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEscapeSameAsCommentStartThrowsException_Deprecated() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape('!').withCommentMarker('!'));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEscapeSameAsCommentStartThrowsExceptionForWrapperType",
  "sourceCode" : "@Test\r\nvoid testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\r\n    // Cannot assume that callers won't use different Character objects\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setEscape(Character.valueOf('!')).setCommentMarker(Character.valueOf('!')).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testEscapeSameAsCommentStartThrowsExceptionForWrapperType_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testEscapeSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\r\n    // Cannot assume that callers won't use different Character objects\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(Character.valueOf('!')).withCommentMarker(Character.valueOf('!')));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testFormat",
  "sourceCode" : "@Test\r\nvoid testFormat() {\r\n    final CSVFormat format = CSVFormat.DEFAULT;\r\n    assertEquals(\"\", format.format());\r\n    assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\r\n    assertEquals(\"\\\"x,y\\\",z\", format.format(\"x,y\", \"z\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testFormatThrowsNullPointerException",
  "sourceCode" : "// I assume this to be a defect.\r\n@Test\r\nvoid testFormatThrowsNullPointerException() {\r\n    final CSVFormat csvFormat = CSVFormat.MYSQL;\r\n    final NullPointerException e = assertThrows(NullPointerException.class, () -> csvFormat.format((Object[]) null));\r\n    assertEquals(Objects.class.getName(), e.getStackTrace()[0].getClassName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testFormatToString",
  "sourceCode" : "@Test\r\nvoid testFormatToString() {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuoteMode(QuoteMode.MINIMAL).withRecordSeparator(CRLF).withQuote('\"').withNullString(\"\").withIgnoreHeaderCase(true).withHeaderComments(\"This is HeaderComments\").withHeader(\"col1\", \"col2\", \"col3\");\r\n    // @formatter:on\r\n    assertEquals(\"Delimiter=<,> Escape=<?> QuoteChar=<\\\"> QuoteMode=<MINIMAL> NullString=<> RecordSeparator=<\" + CRLF + \"> IgnoreHeaderCase:ignored SkipHeaderRecord:false HeaderComments:[This is HeaderComments] Header:[col1, col2, col3]\", format.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testGetAllowDuplicateHeaderNames",
  "sourceCode" : "@Test\r\nvoid testGetAllowDuplicateHeaderNames() {\r\n    final Builder builder = CSVFormat.DEFAULT.builder();\r\n    assertTrue(builder.get().getAllowDuplicateHeaderNames());\r\n    assertTrue(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getAllowDuplicateHeaderNames());\r\n    assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getAllowDuplicateHeaderNames());\r\n    assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getAllowDuplicateHeaderNames());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testGetDuplicateHeaderMode",
  "sourceCode" : "@Test\r\nvoid testGetDuplicateHeaderMode() {\r\n    final Builder builder = CSVFormat.DEFAULT.builder();\r\n    assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.get().getDuplicateHeaderMode());\r\n    assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getDuplicateHeaderMode());\r\n    assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getDuplicateHeaderMode());\r\n    assertEquals(DuplicateHeaderMode.DISALLOW, builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getDuplicateHeaderMode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testGetHeader",
  "sourceCode" : "@Test\r\nvoid testGetHeader() {\r\n    final String[] header = { \"one\", \"two\", \"three\" };\r\n    final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\r\n    // getHeader() makes a copy of the header array.\r\n    final String[] headerCopy = formatWithHeader.getHeader();\r\n    headerCopy[0] = \"A\";\r\n    headerCopy[1] = \"B\";\r\n    headerCopy[2] = \"C\";\r\n    assertFalse(Arrays.equals(formatWithHeader.getHeader(), headerCopy));\r\n    assertNotSame(formatWithHeader.getHeader(), headerCopy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testHashCodeAndWithIgnoreHeaderCase",
  "sourceCode" : "@Test\r\nvoid testHashCodeAndWithIgnoreHeaderCase() {\r\n    final CSVFormat csvFormat = CSVFormat.INFORMIX_UNLOAD_CSV;\r\n    final CSVFormat csvFormatTwo = csvFormat.withIgnoreHeaderCase();\r\n    csvFormatTwo.hashCode();\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    // now different\r\n    assertTrue(csvFormatTwo.getIgnoreHeaderCase());\r\n    assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n    // CSV-244 - should not be equal\r\n    Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n    assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n    assertFalse(csvFormatTwo.getTrim());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testJiraCsv236",
  "sourceCode" : "@Test\r\nvoid testJiraCsv236() {\r\n    CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"CC\", \"VV\", \"VV\").get();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testJiraCsv236__Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testJiraCsv236__Deprecated() {\r\n    CSVFormat.DEFAULT.withAllowDuplicateHeaderNames().withHeader(\"CC\", \"VV\", \"VV\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testNewFormat",
  "sourceCode" : "@Test\r\nvoid testNewFormat() {\r\n    final CSVFormat csvFormat = CSVFormat.newFormat('X');\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertFalse(csvFormat.isEscapeCharacterSet());\r\n    assertNull(csvFormat.getRecordSeparator());\r\n    assertNull(csvFormat.getQuoteMode());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.isNullStringSet());\r\n    assertNull(csvFormat.getEscapeCharacter());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertEquals('X', csvFormat.getDelimiter());\r\n    assertNull(csvFormat.getNullString());\r\n    assertFalse(csvFormat.isQuoteCharacterSet());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertNull(csvFormat.getQuoteCharacter());\r\n    assertFalse(csvFormat.getIgnoreEmptyLines());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertFalse(csvFormat.isEscapeCharacterSet());\r\n    assertNull(csvFormat.getRecordSeparator());\r\n    assertNull(csvFormat.getQuoteMode());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.isNullStringSet());\r\n    assertNull(csvFormat.getEscapeCharacter());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertEquals('X', csvFormat.getDelimiter());\r\n    assertNull(csvFormat.getNullString());\r\n    assertFalse(csvFormat.isQuoteCharacterSet());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertNull(csvFormat.getQuoteCharacter());\r\n    assertFalse(csvFormat.getIgnoreEmptyLines());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testNullRecordSeparatorCsv106",
  "sourceCode" : "@Test\r\nvoid testNullRecordSeparatorCsv106() {\r\n    final CSVFormat format = CSVFormat.newFormat(';').builder().setSkipHeaderRecord(true).setHeader(\"H1\", \"H2\").get();\r\n    final String formatStr = format.format(\"A\", \"B\");\r\n    assertNotNull(formatStr);\r\n    assertFalse(formatStr.endsWith(\"null\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testNullRecordSeparatorCsv106__Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testNullRecordSeparatorCsv106__Deprecated() {\r\n    final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord().withHeader(\"H1\", \"H2\");\r\n    final String formatStr = format.format(\"A\", \"B\");\r\n    assertNotNull(formatStr);\r\n    assertFalse(formatStr.endsWith(\"null\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testPrintRecord",
  "sourceCode" : "@Test\r\nvoid testPrintRecord() throws IOException {\r\n    final Appendable out = new StringBuilder();\r\n    final CSVFormat format = CSVFormat.RFC4180;\r\n    format.printRecord(out, \"a\", \"b\", \"c\");\r\n    assertEquals(\"a,b,c\" + format.getRecordSeparator(), out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testPrintRecordEmpty",
  "sourceCode" : "@Test\r\nvoid testPrintRecordEmpty() throws IOException {\r\n    final Appendable out = new StringBuilder();\r\n    final CSVFormat format = CSVFormat.RFC4180;\r\n    format.printRecord(out);\r\n    assertEquals(format.getRecordSeparator(), out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testPrintWithEscapesEndWithCRLF",
  "sourceCode" : "@Test\r\nvoid testPrintWithEscapesEndWithCRLF() throws IOException {\r\n    final Reader in = new StringReader(\"x,y,x\\r\\na,?b,c\\r\\n\");\r\n    final Appendable out = new StringBuilder();\r\n    final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\r\n    format.print(in, out, true);\r\n    assertEquals(\"x?,y?,x?r?na?,??b?,c?r?n\", out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testPrintWithEscapesEndWithoutCRLF",
  "sourceCode" : "@Test\r\nvoid testPrintWithEscapesEndWithoutCRLF() throws IOException {\r\n    final Reader in = new StringReader(\"x,y,x\");\r\n    final Appendable out = new StringBuilder();\r\n    final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\r\n    format.print(in, out, true);\r\n    assertEquals(\"x?,y?,x\", out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testPrintWithoutQuotes",
  "sourceCode" : "@Test\r\nvoid testPrintWithoutQuotes() throws IOException {\r\n    final Reader in = new StringReader(\"\");\r\n    final Appendable out = new StringBuilder();\r\n    final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\r\n    format.print(in, out, true);\r\n    assertEquals(\"\\\"\\\"\", out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testPrintWithQuoteModeIsNONE",
  "sourceCode" : "@Test\r\nvoid testPrintWithQuoteModeIsNONE() throws IOException {\r\n    final Reader in = new StringReader(\"a,b,c\");\r\n    final Appendable out = new StringBuilder();\r\n    final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NONE);\r\n    format.print(in, out, true);\r\n    assertEquals(\"a?,b?,c\", out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testPrintWithQuotes",
  "sourceCode" : "@Test\r\nvoid testPrintWithQuotes() throws IOException {\r\n    final Reader in = new StringReader(\"\\\"a,b,c\\r\\nx,y,z\");\r\n    final Appendable out = new StringBuilder();\r\n    final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\r\n    format.print(in, out, true);\r\n    assertEquals(\"\\\"\\\"\\\"a,b,c\\r\\nx,y,z\\\"\", out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuoteCharSameAsCommentStartThrowsException",
  "sourceCode" : "@Test\r\nvoid testQuoteCharSameAsCommentStartThrowsException() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setCommentMarker('!').get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuoteCharSameAsCommentStartThrowsException_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testQuoteCharSameAsCommentStartThrowsException_Deprecated() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withCommentMarker('!'));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType",
  "sourceCode" : "@Test\r\nvoid testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\r\n    // Cannot assume that callers won't use different Character objects\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote(Character.valueOf('!')).setCommentMarker('!').get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\r\n    // Cannot assume that callers won't use different Character objects\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(Character.valueOf('!')).withCommentMarker('!'));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuoteCharSameAsDelimiterThrowsException",
  "sourceCode" : "@Test\r\nvoid testQuoteCharSameAsDelimiterThrowsException() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setDelimiter('!').get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuoteCharSameAsDelimiterThrowsException_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testQuoteCharSameAsDelimiterThrowsException_Deprecated() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withDelimiter('!'));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuoteModeNoneShouldReturnMeaningfulExceptionMessage",
  "sourceCode" : "@Test\r\nvoid testQuoteModeNoneShouldReturnMeaningfulExceptionMessage() {\r\n    final Exception exception = assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setHeader(\"Col1\", \"Col2\", \"Col3\", \"Col4\").setQuoteMode(QuoteMode.NONE).get());\r\n    final String actualMessage = exception.getMessage();\r\n    final String expectedMessage = \"Quote mode set to NONE but no escape character is set\";\r\n    assertEquals(expectedMessage, actualMessage);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuotePolicyNoneWithoutEscapeThrowsException",
  "sourceCode" : "@Test\r\nvoid testQuotePolicyNoneWithoutEscapeThrowsException() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').builder().setQuoteMode(QuoteMode.NONE).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testQuotePolicyNoneWithoutEscapeThrowsException_Deprecated",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testQuotePolicyNoneWithoutEscapeThrowsException_Deprecated() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').withQuoteMode(QuoteMode.NONE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testRFC4180",
  "sourceCode" : "@Test\r\nvoid testRFC4180() {\r\n    assertNull(RFC4180.getCommentMarker());\r\n    assertEquals(',', RFC4180.getDelimiter());\r\n    assertNull(RFC4180.getEscapeCharacter());\r\n    assertFalse(RFC4180.getIgnoreEmptyLines());\r\n    assertEquals(Character.valueOf('\"'), RFC4180.getQuoteCharacter());\r\n    assertNull(RFC4180.getQuoteMode());\r\n    assertEquals(\"\\r\\n\", RFC4180.getRecordSeparator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testSerialization",
  "sourceCode" : "// no need to worry about boxing here\r\n@SuppressWarnings(\"boxing\")\r\n@Test\r\nvoid testSerialization() throws Exception {\r\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(out)) {\r\n        oos.writeObject(CSVFormat.DEFAULT);\r\n        oos.flush();\r\n    }\r\n    final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\r\n    final CSVFormat format = (CSVFormat) in.readObject();\r\n    assertNotNull(format);\r\n    assertEquals(CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter(), \"delimiter\");\r\n    assertEquals(CSVFormat.DEFAULT.getQuoteCharacter(), format.getQuoteCharacter(), \"encapsulator\");\r\n    assertEquals(CSVFormat.DEFAULT.getCommentMarker(), format.getCommentMarker(), \"comment start\");\r\n    assertEquals(CSVFormat.DEFAULT.getRecordSeparator(), format.getRecordSeparator(), \"record separator\");\r\n    assertEquals(CSVFormat.DEFAULT.getEscapeCharacter(), format.getEscapeCharacter(), \"escape\");\r\n    assertEquals(CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces(), \"trim\");\r\n    assertEquals(CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines(), \"empty lines\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testToString",
  "sourceCode" : "@Test\r\nvoid testToString() {\r\n    final String string = CSVFormat.INFORMIX_UNLOAD.toString();\r\n    assertEquals(\"Delimiter=<|> Escape=<\\\\> QuoteChar=<\\\"> RecordSeparator=<\\n> EmptyLines:ignored SkipHeaderRecord:false\", string);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testToStringAndWithCommentMarkerTakingCharacter",
  "sourceCode" : "@Test\r\nvoid testToStringAndWithCommentMarkerTakingCharacter() {\r\n    final CSVFormat.Predefined csvFormatPredefined = CSVFormat.Predefined.Default;\r\n    final CSVFormat csvFormat = csvFormatPredefined.getFormat();\r\n    assertNull(csvFormat.getEscapeCharacter());\r\n    assertTrue(csvFormat.isQuoteCharacterSet());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertEquals(',', csvFormat.getDelimiter());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertFalse(csvFormat.isNullStringSet());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertFalse(csvFormat.isEscapeCharacterSet());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertNull(csvFormat.getNullString());\r\n    assertNull(csvFormat.getQuoteMode());\r\n    assertTrue(csvFormat.getIgnoreEmptyLines());\r\n    assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n    final Character character = Character.valueOf('n');\r\n    final CSVFormat csvFormatTwo = csvFormat.withCommentMarker(character);\r\n    assertNull(csvFormat.getEscapeCharacter());\r\n    assertTrue(csvFormat.isQuoteCharacterSet());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertEquals(',', csvFormat.getDelimiter());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertFalse(csvFormat.isNullStringSet());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertFalse(csvFormat.isEscapeCharacterSet());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertNull(csvFormat.getNullString());\r\n    assertNull(csvFormat.getQuoteMode());\r\n    assertTrue(csvFormat.getIgnoreEmptyLines());\r\n    assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n    assertFalse(csvFormatTwo.isNullStringSet());\r\n    assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n    assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n    assertNull(csvFormatTwo.getNullString());\r\n    assertEquals(',', csvFormatTwo.getDelimiter());\r\n    assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n    assertTrue(csvFormatTwo.isCommentMarkerSet());\r\n    assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n    assertFalse(csvFormatTwo.getTrim());\r\n    assertNull(csvFormatTwo.getEscapeCharacter());\r\n    assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n    assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n    assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n    assertNull(csvFormatTwo.getQuoteMode());\r\n    assertEquals('n', (char) csvFormatTwo.getCommentMarker());\r\n    assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n    assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n    assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n    assertNotSame(csvFormat, csvFormatTwo);\r\n    assertNotSame(csvFormatTwo, csvFormat);\r\n    Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n    assertNull(csvFormat.getEscapeCharacter());\r\n    assertTrue(csvFormat.isQuoteCharacterSet());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertEquals(',', csvFormat.getDelimiter());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertFalse(csvFormat.isNullStringSet());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertFalse(csvFormat.isEscapeCharacterSet());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertNull(csvFormat.getNullString());\r\n    assertNull(csvFormat.getQuoteMode());\r\n    assertTrue(csvFormat.getIgnoreEmptyLines());\r\n    assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n    assertFalse(csvFormatTwo.isNullStringSet());\r\n    assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n    assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n    assertNull(csvFormatTwo.getNullString());\r\n    assertEquals(',', csvFormatTwo.getDelimiter());\r\n    assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n    assertTrue(csvFormatTwo.isCommentMarkerSet());\r\n    assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n    assertFalse(csvFormatTwo.getTrim());\r\n    assertNull(csvFormatTwo.getEscapeCharacter());\r\n    assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n    assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n    assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n    assertNull(csvFormatTwo.getQuoteMode());\r\n    assertEquals('n', (char) csvFormatTwo.getCommentMarker());\r\n    assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n    assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n    assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n    assertNotSame(csvFormat, csvFormatTwo);\r\n    assertNotSame(csvFormatTwo, csvFormat);\r\n    Assertions.assertNotEquals(csvFormat, csvFormatTwo);\r\n    Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n    assertEquals(\"Delimiter=<,> QuoteChar=<\\\"> CommentStart=<n> RecordSeparator=<\\r\\n> EmptyLines:ignored SkipHeaderRecord:false\", csvFormatTwo.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testTrim",
  "sourceCode" : "@Test\r\nvoid testTrim() throws IOException {\r\n    final CSVFormat formatWithTrim = CSVFormat.DEFAULT.withDelimiter(',').withTrim().withQuote(null).withRecordSeparator(CRLF);\r\n    CharSequence in = \"a,b,c\";\r\n    final StringBuilder out = new StringBuilder();\r\n    formatWithTrim.print(in, out, true);\r\n    assertEquals(\"a,b,c\", out.toString());\r\n    in = new StringBuilder(\" x,y,z\");\r\n    out.setLength(0);\r\n    formatWithTrim.print(in, out, true);\r\n    assertEquals(\"x,y,z\", out.toString());\r\n    in = new StringBuilder(\"\");\r\n    out.setLength(0);\r\n    formatWithTrim.print(in, out, true);\r\n    assertEquals(\"\", out.toString());\r\n    in = new StringBuilder(\"header\\r\\n\");\r\n    out.setLength(0);\r\n    formatWithTrim.print(in, out, true);\r\n    assertEquals(\"header\", out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithCommentStart",
  "sourceCode" : "@Test\r\nvoid testWithCommentStart() {\r\n    final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentMarker('#');\r\n    assertEquals(Character.valueOf('#'), formatWithCommentStart.getCommentMarker());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithCommentStartCRThrowsException",
  "sourceCode" : "@Test\r\nvoid testWithCommentStartCRThrowsException() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withCommentMarker(CR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithDelimiter",
  "sourceCode" : "@Test\r\nvoid testWithDelimiter() {\r\n    final CSVFormat formatWithDelimiter = CSVFormat.DEFAULT.withDelimiter('!');\r\n    assertEquals('!', formatWithDelimiter.getDelimiter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithDelimiterLFThrowsException",
  "sourceCode" : "@Test\r\nvoid testWithDelimiterLFThrowsException() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(LF));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithEmptyDuplicates",
  "sourceCode" : "@Test\r\nvoid testWithEmptyDuplicates() {\r\n    final CSVFormat formatWithEmptyDuplicates = CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get();\r\n    assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, formatWithEmptyDuplicates.getDuplicateHeaderMode());\r\n    assertFalse(formatWithEmptyDuplicates.getAllowDuplicateHeaderNames());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithEmptyEnum",
  "sourceCode" : "@Test\r\nvoid testWithEmptyEnum() {\r\n    final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(EmptyEnum.class);\r\n    assertEquals(0, formatWithHeader.getHeader().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithEscape",
  "sourceCode" : "@Test\r\nvoid testWithEscape() {\r\n    final CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\r\n    assertEquals(Character.valueOf('&'), formatWithEscape.getEscapeCharacter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithEscapeCRThrowsExceptions",
  "sourceCode" : "@Test\r\nvoid testWithEscapeCRThrowsExceptions() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(CR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithFirstRecordAsHeader",
  "sourceCode" : "@Test\r\nvoid testWithFirstRecordAsHeader() {\r\n    final CSVFormat formatWithFirstRecordAsHeader = CSVFormat.DEFAULT.withFirstRecordAsHeader();\r\n    assertTrue(formatWithFirstRecordAsHeader.getSkipHeaderRecord());\r\n    assertEquals(0, formatWithFirstRecordAsHeader.getHeader().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithHeader",
  "sourceCode" : "@Test\r\nvoid testWithHeader() {\r\n    final String[] header = { \"one\", \"two\", \"three\" };\r\n    // withHeader() makes a copy of the header array.\r\n    final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\r\n    assertArrayEquals(header, formatWithHeader.getHeader());\r\n    assertNotSame(header, formatWithHeader.getHeader());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithHeaderComments",
  "sourceCode" : "@Test\r\nvoid testWithHeaderComments() {\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n    assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertFalse(csvFormat.isEscapeCharacterSet());\r\n    assertTrue(csvFormat.isQuoteCharacterSet());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertNull(csvFormat.getQuoteMode());\r\n    assertEquals(',', csvFormat.getDelimiter());\r\n    assertTrue(csvFormat.getIgnoreEmptyLines());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.isNullStringSet());\r\n    assertNull(csvFormat.getNullString());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertNull(csvFormat.getEscapeCharacter());\r\n    final Object[] objectArray = new Object[8];\r\n    final CSVFormat csvFormatTwo = csvFormat.withHeaderComments(objectArray);\r\n    assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertFalse(csvFormat.isEscapeCharacterSet());\r\n    assertTrue(csvFormat.isQuoteCharacterSet());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertNull(csvFormat.getQuoteMode());\r\n    assertEquals(',', csvFormat.getDelimiter());\r\n    assertTrue(csvFormat.getIgnoreEmptyLines());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.isNullStringSet());\r\n    assertNull(csvFormat.getNullString());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertNull(csvFormat.getEscapeCharacter());\r\n    assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n    assertNull(csvFormatTwo.getQuoteMode());\r\n    assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n    assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n    assertNull(csvFormatTwo.getEscapeCharacter());\r\n    assertFalse(csvFormatTwo.getTrim());\r\n    assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n    assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n    assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n    assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n    assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n    assertNull(csvFormatTwo.getNullString());\r\n    assertFalse(csvFormatTwo.isNullStringSet());\r\n    assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n    assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n    assertEquals(',', csvFormatTwo.getDelimiter());\r\n    assertNull(csvFormatTwo.getCommentMarker());\r\n    assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n    assertNotSame(csvFormat, csvFormatTwo);\r\n    assertNotSame(csvFormatTwo, csvFormat);\r\n    // CSV-244 - should not be equal\r\n    Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n    final String string = csvFormatTwo.format(objectArray);\r\n    assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n    assertFalse(csvFormat.isCommentMarkerSet());\r\n    assertFalse(csvFormat.isEscapeCharacterSet());\r\n    assertTrue(csvFormat.isQuoteCharacterSet());\r\n    assertFalse(csvFormat.getSkipHeaderRecord());\r\n    assertNull(csvFormat.getQuoteMode());\r\n    assertEquals(',', csvFormat.getDelimiter());\r\n    assertTrue(csvFormat.getIgnoreEmptyLines());\r\n    assertFalse(csvFormat.getIgnoreHeaderCase());\r\n    assertNull(csvFormat.getCommentMarker());\r\n    assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n    assertFalse(csvFormat.getTrailingDelimiter());\r\n    assertFalse(csvFormat.getAllowMissingColumnNames());\r\n    assertFalse(csvFormat.getTrim());\r\n    assertFalse(csvFormat.isNullStringSet());\r\n    assertNull(csvFormat.getNullString());\r\n    assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n    assertNull(csvFormat.getEscapeCharacter());\r\n    assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n    assertNull(csvFormatTwo.getQuoteMode());\r\n    assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n    assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n    assertNull(csvFormatTwo.getEscapeCharacter());\r\n    assertFalse(csvFormatTwo.getTrim());\r\n    assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n    assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n    assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n    assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n    assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n    assertNull(csvFormatTwo.getNullString());\r\n    assertFalse(csvFormatTwo.isNullStringSet());\r\n    assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n    assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n    assertEquals(',', csvFormatTwo.getDelimiter());\r\n    assertNull(csvFormatTwo.getCommentMarker());\r\n    assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n    assertNotSame(csvFormat, csvFormatTwo);\r\n    assertNotSame(csvFormatTwo, csvFormat);\r\n    assertNotNull(string);\r\n    // CSV-244 - should not be equal\r\n    Assertions.assertNotEquals(csvFormat, csvFormatTwo);\r\n    // CSV-244 - should not be equal\r\n    Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n    assertEquals(\",,,,,,,\", string);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithHeaderEnum",
  "sourceCode" : "@Test\r\nvoid testWithHeaderEnum() {\r\n    final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(Header.class);\r\n    assertArrayEquals(new String[] { \"Name\", \"Email\", \"Phone\" }, formatWithHeader.getHeader());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithHeaderEnumNull",
  "sourceCode" : "@Test\r\nvoid testWithHeaderEnumNull() {\r\n    final CSVFormat format = CSVFormat.DEFAULT;\r\n    final Class<Enum<?>> simpleName = null;\r\n    format.withHeader(simpleName);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithHeaderResultSetNull",
  "sourceCode" : "@Test\r\nvoid testWithHeaderResultSetNull() throws SQLException {\r\n    final CSVFormat format = CSVFormat.DEFAULT;\r\n    final ResultSet resultSet = null;\r\n    format.withHeader(resultSet);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithIgnoreEmptyLines",
  "sourceCode" : "@Test\r\nvoid testWithIgnoreEmptyLines() {\r\n    assertFalse(CSVFormat.DEFAULT.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\r\n    assertTrue(CSVFormat.DEFAULT.withIgnoreEmptyLines().getIgnoreEmptyLines());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithIgnoreSurround",
  "sourceCode" : "@Test\r\nvoid testWithIgnoreSurround() {\r\n    assertFalse(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\r\n    assertTrue(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces().getIgnoreSurroundingSpaces());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithNullString",
  "sourceCode" : "@Test\r\nvoid testWithNullString() {\r\n    final CSVFormat formatWithNullString = CSVFormat.DEFAULT.withNullString(\"null\");\r\n    assertEquals(\"null\", formatWithNullString.getNullString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithQuoteChar",
  "sourceCode" : "@Test\r\nvoid testWithQuoteChar() {\r\n    final CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuote('\"');\r\n    assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteCharacter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithQuoteLFThrowsException",
  "sourceCode" : "@Test\r\nvoid testWithQuoteLFThrowsException() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(LF));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithQuotePolicy",
  "sourceCode" : "@Test\r\nvoid testWithQuotePolicy() {\r\n    final CSVFormat formatWithQuotePolicy = CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL);\r\n    assertEquals(QuoteMode.ALL, formatWithQuotePolicy.getQuoteMode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithRecordSeparatorCR",
  "sourceCode" : "@Test\r\nvoid testWithRecordSeparatorCR() {\r\n    final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CR);\r\n    assertEquals(String.valueOf(CR), formatWithRecordSeparator.getRecordSeparator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithRecordSeparatorCRLF",
  "sourceCode" : "@Test\r\nvoid testWithRecordSeparatorCRLF() {\r\n    final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CRLF);\r\n    assertEquals(CRLF, formatWithRecordSeparator.getRecordSeparator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithRecordSeparatorLF",
  "sourceCode" : "@Test\r\nvoid testWithRecordSeparatorLF() {\r\n    final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(LF);\r\n    assertEquals(String.valueOf(LF), formatWithRecordSeparator.getRecordSeparator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVFormatTest.java",
  "methodName" : "testWithSystemRecordSeparator",
  "sourceCode" : "@Test\r\nvoid testWithSystemRecordSeparator() {\r\n    final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withSystemRecordSeparator();\r\n    assertEquals(System.lineSeparator(), formatWithRecordSeparator.getRecordSeparator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testBackslashEscaping",
  "sourceCode" : "@Test\r\nvoid testBackslashEscaping() throws IOException {\r\n    // To avoid confusion over the need for escaping chars in java code,\r\n    // We will test with a forward slash as the escape char, and a single\r\n    // quote as the encapsulator.\r\n    // @formatter:off\r\n    final String code = // 0\r\n    \"one,two,three\\n\" + // 1) empty encapsulators\r\n    \"'',''\\n\" + // 2) single encapsulators\r\n    \"/',/'\\n\" + // 3) single encapsulators encapsulated via escape\r\n    \"'/'','/''\\n\" + // 4) single encapsulators encapsulated via doubling\r\n    \"'''',''''\\n\" + // 5) separator escaped\r\n    \"/,,/,\\n\" + // 6) escape escaped\r\n    \"//,//\\n\" + // 7) escape escaped in encapsulation\r\n    \"'//','//'\\n\" + // don't eat spaces\r\n    \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\" + // escaped newline\r\n    \"9,   /\\n   \\n\" + \"\";\r\n    final String[][] res = { // 0\r\n    { \"one\", \"two\", \"three\" }, // 1\r\n    { \"\", \"\" }, // 2\r\n    { \"'\", \"'\" }, // 3\r\n    { \"'\", \"'\" }, // 4\r\n    { \"'\", \"'\" }, // 5\r\n    { \",\", \",\" }, // 6\r\n    { \"/\", \"/\" }, // 7\r\n    { \"/\", \"/\" }, { \"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \" }, { \"9\", \"   \\n   \" } };\r\n    // @formatter:on\r\n    final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\r\n    try (CSVParser parser = CSVParser.parse(code, format)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertFalse(records.isEmpty());\r\n        Utils.compare(\"Records do not match expected result\", res, records, -1);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testBackslashEscaping2",
  "sourceCode" : "@Test\r\nvoid testBackslashEscaping2() throws IOException {\r\n    // To avoid confusion over the need for escaping chars in java code,\r\n    // We will test with a forward slash as the escape char, and a single\r\n    // quote as the encapsulator.\r\n    // @formatter:off\r\n    final String code = // 1)\r\n    \" , , \\n\" + // 2)\r\n    \" \\t ,  , \\n\" + // 3)\r\n    \" // , /, , /,\\n\" + \"\";\r\n    final String[][] res = { // 1\r\n    { \" \", \" \", \" \" }, // 2\r\n    { \" \\t \", \"  \", \" \" }, // 3\r\n    { \" / \", \" , \", \" ,\" } };\r\n    // @formatter:on\r\n    final CSVFormat format = CSVFormat.newFormat(',').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\r\n    try (CSVParser parser = CSVParser.parse(code, format)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertFalse(records.isEmpty());\r\n        Utils.compare(\"\", res, records, -1);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testBackslashEscapingOld",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testBackslashEscapingOld() throws IOException {\r\n    // @formatter:off\r\n    final String code = \"one,two,three\\n\" + \"on\\\\\\\"e,two\\n\" + \"on\\\"e,two\\n\" + \"one,\\\"tw\\\\\\\"o\\\"\\n\" + \"one,\\\"t\\\\,wo\\\"\\n\" + \"one,two,\\\"th,ree\\\"\\n\" + \"\\\"a\\\\\\\\\\\"\\n\" + \"a\\\\,b\\n\" + \"\\\"a\\\\\\\\,b\\\"\";\r\n    // @formatter:on\r\n    final String[][] res = { // backslash in\r\n    { \"one\", \"two\", \"three\" }, // backslash in\r\n    { \"on\\\\\\\"e\", \"two\" }, // backslash in\r\n    { \"on\\\"e\", \"two\" }, // backslash in\r\n    { \"one\", \"tw\\\"o\" }, // backslash in\r\n    { \"one\", \"t\\\\,wo\" }, // quotes only\r\n    // escapes a\r\n    // delimiter\r\n    // (\",\")\r\n    // backslash in quotes only escapes a delimiter (\",\")\r\n    { \"one\", \"two\", \"th,ree\" }, // backslash in quotes only escapes a delimiter (\",\")\r\n    { \"a\\\\\\\\\" }, // a backslash must be returned\r\n    { \"a\\\\\", \"b\" }, // backslash in quotes only escapes a delimiter (\",\")\r\n    { \"a\\\\\\\\,b\" } };\r\n    try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(res.length, records.size());\r\n        assertFalse(records.isEmpty());\r\n        for (int i = 0; i < res.length; i++) {\r\n            assertValuesEquals(res[i], records.get(i));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testBOM",
  "sourceCode" : "@Test\r\n@Disabled(\"CSV-107\")\r\nvoid testBOM() throws IOException {\r\n    final URL url = ClassLoader.getSystemClassLoader().getResource(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\r\n    try (CSVParser parser = CSVParser.parse(url, StandardCharsets.UTF_8, EXCEL_WITH_HEADER)) {\r\n        parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testBOMInputStreamParserWithInputStream",
  "sourceCode" : "@Test\r\nvoid testBOMInputStreamParserWithInputStream() throws IOException {\r\n    try (BOMInputStream inputStream = createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\r\n        CSVParser parser = CSVParser.parse(inputStream, UTF_8, EXCEL_WITH_HEADER)) {\r\n        parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testBOMInputStreamParserWithReader",
  "sourceCode" : "@Test\r\nvoid testBOMInputStreamParserWithReader() throws IOException {\r\n    try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\r\n        CSVParser parser = CSVParser.builder().setReader(reader).setFormat(EXCEL_WITH_HEADER).get()) {\r\n        parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testBOMInputStreamParseWithReader",
  "sourceCode" : "@Test\r\nvoid testBOMInputStreamParseWithReader() throws IOException {\r\n    try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\r\n        CSVParser parser = CSVParser.builder().setReader(reader).setFormat(EXCEL_WITH_HEADER).get()) {\r\n        parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCarriageReturnEndings",
  "sourceCode" : "@Test\r\nvoid testCarriageReturnEndings() throws IOException {\r\n    final String string = \"foo\\rbaar,\\rhello,world\\r,kanu\";\r\n    try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(4, records.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCarriageReturnLineFeedEndings",
  "sourceCode" : "@Test\r\nvoid testCarriageReturnLineFeedEndings() throws IOException {\r\n    final String string = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\r\n    try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(4, records.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testClose",
  "sourceCode" : "@Test\r\nvoid testClose() throws Exception {\r\n    final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\r\n    final Iterator<CSVRecord> records;\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\r\n        records = parser.iterator();\r\n        assertTrue(records.hasNext());\r\n    }\r\n    assertFalse(records.hasNext());\r\n    assertThrows(NoSuchElementException.class, records::next);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV141CSVFormat_DEFAULT",
  "sourceCode" : "@Test\r\nvoid testCSV141CSVFormat_DEFAULT() throws Exception {\r\n    testCSV141Failure(CSVFormat.DEFAULT, 3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV141CSVFormat_INFORMIX_UNLOAD",
  "sourceCode" : "@Test\r\nvoid testCSV141CSVFormat_INFORMIX_UNLOAD() throws Exception {\r\n    testCSV141Failure(CSVFormat.INFORMIX_UNLOAD, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV141CSVFormat_INFORMIX_UNLOAD_CSV",
  "sourceCode" : "@Test\r\nvoid testCSV141CSVFormat_INFORMIX_UNLOAD_CSV() throws Exception {\r\n    testCSV141Failure(CSVFormat.INFORMIX_UNLOAD_CSV, 3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV141CSVFormat_ORACLE",
  "sourceCode" : "@Test\r\nvoid testCSV141CSVFormat_ORACLE() throws Exception {\r\n    testCSV141Failure(CSVFormat.ORACLE, 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV141CSVFormat_POSTGRESQL_CSV",
  "sourceCode" : "@Test\r\nvoid testCSV141CSVFormat_POSTGRESQL_CSV() throws Exception {\r\n    testCSV141Failure(CSVFormat.POSTGRESQL_CSV, 3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV141Excel",
  "sourceCode" : "@Test\r\nvoid testCSV141Excel() throws Exception {\r\n    testCSV141Ok(CSVFormat.EXCEL);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV141RFC4180",
  "sourceCode" : "@Test\r\nvoid testCSV141RFC4180() throws Exception {\r\n    testCSV141Failure(CSVFormat.RFC4180, 3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV235",
  "sourceCode" : "@Test\r\nvoid testCSV235() throws IOException {\r\n    // \"aaa\",\"b\"\"bb\",\"ccc\"\r\n    final String dqString = \"\\\"aaa\\\",\\\"b\\\"\\\"bb\\\",\\\"ccc\\\"\";\r\n    try (CSVParser parser = CSVFormat.RFC4180.parse(new StringReader(dqString))) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        assertFalse(records.hasNext());\r\n        assertEquals(3, record.size());\r\n        assertEquals(\"aaa\", record.get(0));\r\n        assertEquals(\"b\\\"bb\", record.get(1));\r\n        assertEquals(\"ccc\", record.get(2));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testCSV57",
  "sourceCode" : "@Test\r\nvoid testCSV57() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\r\n        final List<CSVRecord> list = parser.getRecords();\r\n        assertNotNull(list);\r\n        assertEquals(0, list.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testDefaultFormat",
  "sourceCode" : "@Test\r\nvoid testDefaultFormat() throws IOException {\r\n    // @formatter:off\r\n    final String code = // 1)\r\n    \"a,b#\\n\" + // 2)\r\n    \"\\\"\\n\\\",\\\" \\\",#\\n\" + // 3)\r\n    \"#,\\\"\\\"\\n\" + // 4)\r\n    \"# Final comment\\n\";\r\n    // @formatter:on\r\n    final String[][] res = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, { \"#\", \"\" }, { \"# Final comment\" } };\r\n    CSVFormat format = CSVFormat.DEFAULT;\r\n    assertFalse(format.isCommentMarkerSet());\r\n    final String[][] resComments = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" } };\r\n    try (CSVParser parser = CSVParser.parse(code, format)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertFalse(records.isEmpty());\r\n        Utils.compare(\"Failed to parse without comments\", res, records, -1);\r\n        format = CSVFormat.DEFAULT.withCommentMarker('#');\r\n    }\r\n    try (CSVParser parser = CSVParser.parse(code, format)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        Utils.compare(\"Failed to parse with comments\", resComments, records, -1);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testDuplicateHeadersAllowedByDefault",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeadersAllowedByDefault() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader())) {\r\n        // noop\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testDuplicateHeadersNotAllowed",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeadersNotAllowed() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(false)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testEmptyFile",
  "sourceCode" : "@Test\r\nvoid testEmptyFile() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(Paths.get(\"src/test/resources/org/apache/commons/csv/empty.txt\"), StandardCharsets.UTF_8, CSVFormat.DEFAULT)) {\r\n        assertNull(parser.nextRecord());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testEmptyFileHeaderParsing",
  "sourceCode" : "@Test\r\nvoid testEmptyFileHeaderParsing() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT.withFirstRecordAsHeader())) {\r\n        assertNull(parser.nextRecord());\r\n        assertTrue(parser.getHeaderNames().isEmpty());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testEmptyLineBehaviorCSV",
  "sourceCode" : "@Test\r\nvoid testEmptyLineBehaviorCSV() throws Exception {\r\n    final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n    final String[][] res = { // CSV format ignores empty lines\r\n    { \"hello\", \"\" } };\r\n    for (final String code : codes) {\r\n        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n            final List<CSVRecord> records = parser.getRecords();\r\n            assertEquals(res.length, records.size());\r\n            assertFalse(records.isEmpty());\r\n            for (int i = 0; i < res.length; i++) {\r\n                assertValuesEquals(res[i], records.get(i));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testEmptyLineBehaviorExcel",
  "sourceCode" : "@Test\r\nvoid testEmptyLineBehaviorExcel() throws Exception {\r\n    final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n    final String[][] res = { // Excel format does not ignore empty lines\r\n    { \"hello\", \"\" }, // Excel format does not ignore empty lines\r\n    { \"\" }, { \"\" } };\r\n    for (final String code : codes) {\r\n        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n            final List<CSVRecord> records = parser.getRecords();\r\n            assertEquals(res.length, records.size());\r\n            assertFalse(records.isEmpty());\r\n            for (int i = 0; i < res.length; i++) {\r\n                assertValuesEquals(res[i], records.get(i));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testEmptyString",
  "sourceCode" : "@Test\r\nvoid testEmptyString() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\r\n        assertNull(parser.nextRecord());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testEndOfFileBehaviorCSV",
  "sourceCode" : "@Test\r\nvoid testEndOfFileBehaviorCSV() throws Exception {\r\n    final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\", \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\r\n    final String[][] res = { // CSV format ignores empty lines\r\n    { \"hello\", \"\" }, { \"world\", \"\" } };\r\n    for (final String code : codes) {\r\n        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n            final List<CSVRecord> records = parser.getRecords();\r\n            assertEquals(res.length, records.size());\r\n            assertFalse(records.isEmpty());\r\n            for (int i = 0; i < res.length; i++) {\r\n                assertValuesEquals(res[i], records.get(i));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testEndOfFileBehaviorExcel",
  "sourceCode" : "@Test\r\nvoid testEndOfFileBehaviorExcel() throws Exception {\r\n    final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\", \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\r\n    final String[][] res = { // Excel format does not ignore empty lines\r\n    { \"hello\", \"\" }, // Excel format does not ignore empty lines\r\n    { \"\" }, { \"world\", \"\" } };\r\n    for (final String code : codes) {\r\n        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n            final List<CSVRecord> records = parser.getRecords();\r\n            assertEquals(res.length, records.size());\r\n            assertFalse(records.isEmpty());\r\n            for (int i = 0; i < res.length; i++) {\r\n                assertValuesEquals(res[i], records.get(i));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testExcelFormat1",
  "sourceCode" : "@Test\r\nvoid testExcelFormat1() throws IOException {\r\n    final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\r\n    final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" }, { \"  x\", \"\", \"\", \"\" }, { \"\" }, { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };\r\n    try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(res.length, records.size());\r\n        assertFalse(records.isEmpty());\r\n        for (int i = 0; i < res.length; i++) {\r\n            assertValuesEquals(res[i], records.get(i));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testExcelFormat2",
  "sourceCode" : "@Test\r\nvoid testExcelFormat2() throws Exception {\r\n    final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\r\n    final String[][] res = { { \"foo\", \"baar\" }, { \"\" }, { \"hello\", \"\" }, { \"\" }, { \"world\", \"\" } };\r\n    try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(res.length, records.size());\r\n        assertFalse(records.isEmpty());\r\n        for (int i = 0; i < res.length; i++) {\r\n            assertValuesEquals(res[i], records.get(i));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testExcelHeaderCountLessThanData",
  "sourceCode" : "/**\r\n * Tests an exported Excel worksheet with a header row and rows that have more columns than the headers\r\n */\r\n@Test\r\nvoid testExcelHeaderCountLessThanData() throws Exception {\r\n    final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\r\n    try (CSVParser parser = CSVParser.parse(code, EXCEL_WITH_HEADER)) {\r\n        parser.getRecords().forEach(record -> {\r\n            assertEquals(\"a\", record.get(\"A\"));\r\n            assertEquals(\"b\", record.get(\"B\"));\r\n            assertEquals(\"c\", record.get(\"C\"));\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testFirstEndOfLineCr",
  "sourceCode" : "@Test\r\nvoid testFirstEndOfLineCr() throws IOException {\r\n    final String data = \"foo\\rbaar,\\rhello,world\\r,kanu\";\r\n    try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(4, records.size());\r\n        assertEquals(\"\\r\", parser.getFirstEndOfLine());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testFirstEndOfLineCrLf",
  "sourceCode" : "@Test\r\nvoid testFirstEndOfLineCrLf() throws IOException {\r\n    final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\r\n    try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(4, records.size());\r\n        assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testFirstEndOfLineLf",
  "sourceCode" : "@Test\r\nvoid testFirstEndOfLineLf() throws IOException {\r\n    final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\r\n    try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(4, records.size());\r\n        assertEquals(\"\\n\", parser.getFirstEndOfLine());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testForEach",
  "sourceCode" : "@Test\r\nvoid testForEach() throws Exception {\r\n    try (Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n        CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n        final List<CSVRecord> records = new ArrayList<>();\r\n        for (final CSVRecord record : parser) {\r\n            records.add(record);\r\n        }\r\n        assertEquals(3, records.size());\r\n        assertValuesEquals(new String[] { \"a\", \"b\", \"c\" }, records.get(0));\r\n        assertValuesEquals(new String[] { \"1\", \"2\", \"3\" }, records.get(1));\r\n        assertValuesEquals(new String[] { \"x\", \"y\", \"z\" }, records.get(2));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderComment_HeaderComment1",
  "sourceCode" : "@Test\r\nvoid testGetHeaderComment_HeaderComment1() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n        parser.getRecords();\r\n        // Expect a header comment\r\n        assertTrue(parser.hasHeaderComment());\r\n        assertEquals(\"header comment\", parser.getHeaderComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderComment_HeaderComment2",
  "sourceCode" : "@Test\r\nvoid testGetHeaderComment_HeaderComment2() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n        parser.getRecords();\r\n        // Expect a header comment\r\n        assertTrue(parser.hasHeaderComment());\r\n        assertEquals(\"header comment\", parser.getHeaderComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderComment_HeaderComment3",
  "sourceCode" : "@Test\r\nvoid testGetHeaderComment_HeaderComment3() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n        parser.getRecords();\r\n        // Expect no header comment - the text \"comment\" is attached to the first record\r\n        assertFalse(parser.hasHeaderComment());\r\n        assertNull(parser.getHeaderComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderComment_HeaderTrailerComment",
  "sourceCode" : "@Test\r\nvoid testGetHeaderComment_HeaderTrailerComment() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n        parser.getRecords();\r\n        // Expect a header comment\r\n        assertTrue(parser.hasHeaderComment());\r\n        assertEquals(\"multi-line\" + LF + \"header comment\", parser.getHeaderComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderComment_NoComment1",
  "sourceCode" : "@Test\r\nvoid testGetHeaderComment_NoComment1() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_AUTO_HEADER)) {\r\n        parser.getRecords();\r\n        // Expect no header comment\r\n        assertFalse(parser.hasHeaderComment());\r\n        assertNull(parser.getHeaderComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderComment_NoComment2",
  "sourceCode" : "@Test\r\nvoid testGetHeaderComment_NoComment2() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n        parser.getRecords();\r\n        // Expect no header comment\r\n        assertFalse(parser.hasHeaderComment());\r\n        assertNull(parser.getHeaderComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderComment_NoComment3",
  "sourceCode" : "@Test\r\nvoid testGetHeaderComment_NoComment3() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n        parser.getRecords();\r\n        // Expect no header comment\r\n        assertFalse(parser.hasHeaderComment());\r\n        assertNull(parser.getHeaderComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderMap",
  "sourceCode" : "@Test\r\nvoid testGetHeaderMap() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n        final Map<String, Integer> headerMap = parser.getHeaderMap();\r\n        final Iterator<String> columnNames = headerMap.keySet().iterator();\r\n        // Headers are iterated in column order.\r\n        assertEquals(\"A\", columnNames.next());\r\n        assertEquals(\"B\", columnNames.next());\r\n        assertEquals(\"C\", columnNames.next());\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        // Parse to make sure getHeaderMap did not have a side-effect.\r\n        for (int i = 0; i < 3; i++) {\r\n            assertTrue(records.hasNext());\r\n            final CSVRecord record = records.next();\r\n            assertEquals(record.get(0), record.get(\"A\"));\r\n            assertEquals(record.get(1), record.get(\"B\"));\r\n            assertEquals(record.get(2), record.get(\"C\"));\r\n        }\r\n        assertFalse(records.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderNames",
  "sourceCode" : "@Test\r\nvoid testGetHeaderNames() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n        final Map<String, Integer> nameIndexMap = parser.getHeaderMap();\r\n        final List<String> headerNames = parser.getHeaderNames();\r\n        assertNotNull(headerNames);\r\n        assertEquals(nameIndexMap.size(), headerNames.size());\r\n        for (int i = 0; i < headerNames.size(); i++) {\r\n            final String name = headerNames.get(i);\r\n            assertEquals(i, nameIndexMap.get(name).intValue());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetHeaderNamesReadOnly",
  "sourceCode" : "@Test\r\nvoid testGetHeaderNamesReadOnly() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n        final List<String> headerNames = parser.getHeaderNames();\r\n        assertNotNull(headerNames);\r\n        assertThrows(UnsupportedOperationException.class, () -> headerNames.add(\"This is a read-only list.\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetLine",
  "sourceCode" : "@Test\r\nvoid testGetLine() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n        for (final String[] re : RESULT) {\r\n            assertValuesEquals(re, parser.nextRecord());\r\n        }\r\n        assertNull(parser.nextRecord());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetLineNumberWithCR",
  "sourceCode" : "@Test\r\nvoid testGetLineNumberWithCR() throws Exception {\r\n    validateLineNumbers(String.valueOf(CR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetLineNumberWithCRLF",
  "sourceCode" : "@Test\r\nvoid testGetLineNumberWithCRLF() throws Exception {\r\n    validateLineNumbers(CRLF);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetLineNumberWithLF",
  "sourceCode" : "@Test\r\nvoid testGetLineNumberWithLF() throws Exception {\r\n    validateLineNumbers(String.valueOf(LF));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetOneLine",
  "sourceCode" : "@Test\r\nvoid testGetOneLine() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT)) {\r\n        final CSVRecord record = parser.getRecords().get(0);\r\n        assertValuesEquals(RESULT[0], record);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetOneLineOneParser",
  "sourceCode" : "/**\r\n * Tests reusing a parser to process new string records one at a time as they are being discovered. See [CSV-110].\r\n *\r\n * @throws IOException when an I/O error occurs.\r\n */\r\n@Test\r\nvoid testGetOneLineOneParser() throws IOException {\r\n    final CSVFormat format = CSVFormat.DEFAULT;\r\n    try (PipedWriter writer = new PipedWriter();\r\n        PipedReader origin = new PipedReader(writer);\r\n        CSVParser parser = CSVParser.builder().setReader(origin).setFormat(format).get()) {\r\n        writer.append(CSV_INPUT_1);\r\n        writer.append(format.getRecordSeparator());\r\n        final CSVRecord record1 = parser.nextRecord();\r\n        assertValuesEquals(RESULT[0], record1);\r\n        writer.append(CSV_INPUT_2);\r\n        writer.append(format.getRecordSeparator());\r\n        final CSVRecord record2 = parser.nextRecord();\r\n        assertValuesEquals(RESULT[1], record2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordFourBytesRead",
  "sourceCode" : "@Test\r\nvoid testGetRecordFourBytesRead() throws Exception {\r\n    final String code = \"id,a,b,c\\n\" + \"1,\uD83D\uDE0A,\uD83E\uDD14,\uD83D\uDE02\\n\" + \"2,\uD83D\uDE0A,\uD83E\uDD14,\uD83D\uDE02\\n\" + \"3,\uD83D\uDE0A,\uD83E\uDD14,\uD83D\uDE02\\n\";\r\n    final CSVFormat format = CSVFormat.Builder.create().setDelimiter(',').setQuote('\\'').get();\r\n    try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\r\n        CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n        assertEquals(0, parser.getRecordNumber());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(1, record.getRecordNumber());\r\n        assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n        assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(2, record.getRecordNumber());\r\n        assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n        assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(3, record.getRecordNumber());\r\n        assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n        assertEquals(record.getBytePosition(), 26);\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(4, record.getRecordNumber());\r\n        assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n        assertEquals(record.getBytePosition(), 43);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordNumberWithCR",
  "sourceCode" : "@Test\r\nvoid testGetRecordNumberWithCR() throws Exception {\r\n    validateRecordNumbers(String.valueOf(CR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordNumberWithCRLF",
  "sourceCode" : "@Test\r\nvoid testGetRecordNumberWithCRLF() throws Exception {\r\n    validateRecordNumbers(CRLF);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordNumberWithLF",
  "sourceCode" : "@Test\r\nvoid testGetRecordNumberWithLF() throws Exception {\r\n    validateRecordNumbers(String.valueOf(LF));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordPositionWithCRLF",
  "sourceCode" : "@Test\r\nvoid testGetRecordPositionWithCRLF() throws Exception {\r\n    validateRecordPosition(CRLF);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordPositionWithLF",
  "sourceCode" : "@Test\r\nvoid testGetRecordPositionWithLF() throws Exception {\r\n    validateRecordPosition(String.valueOf(LF));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecords",
  "sourceCode" : "@Test\r\nvoid testGetRecords() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(RESULT.length, records.size());\r\n        assertFalse(records.isEmpty());\r\n        for (int i = 0; i < RESULT.length; i++) {\r\n            assertValuesEquals(RESULT[i], records.get(i));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordsFromBrokenInputStream",
  "sourceCode" : "@Test\r\nvoid testGetRecordsFromBrokenInputStream() throws IOException {\r\n    // We also get an exception on close, which is OK but can't assert in a try.\r\n    @SuppressWarnings(\"resource\")\r\n    final CSVParser parser = CSVParser.parse(new BrokenInputStream(), UTF_8, CSVFormat.DEFAULT);\r\n    assertThrows(UncheckedIOException.class, parser::getRecords);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordsMaxRows",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(longs = { -1, 0, 1, 2, 3, 4, Long.MAX_VALUE })\r\nvoid testGetRecordsMaxRows(final long maxRows) throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.builder().setIgnoreSurroundingSpaces(true).setMaxRows(maxRows).get())) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        final long expectedLength = maxRows <= 0 || maxRows > RESULT.length ? RESULT.length : maxRows;\r\n        assertEquals(expectedLength, records.size());\r\n        assertFalse(records.isEmpty());\r\n        for (int i = 0; i < expectedLength; i++) {\r\n            assertValuesEquals(RESULT[i], records.get(i));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordThreeBytesRead",
  "sourceCode" : "@Test\r\nvoid testGetRecordThreeBytesRead() throws Exception {\r\n    final String code = \"id,date,val5,val4\\n\" + \"11111111111111,'4017-09-01',,v4\\n\" + \"22222222222222,'4017-01-01',,v4\\n\" + \"33333333333333,'4017-01-01',,v4\\n\";\r\n    final CSVFormat format = CSVFormat.Builder.create().setDelimiter(',').setQuote('\\'').get();\r\n    try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\r\n        CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n        assertEquals(0, parser.getRecordNumber());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(1, record.getRecordNumber());\r\n        assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n        assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(2, record.getRecordNumber());\r\n        assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n        assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(3, record.getRecordNumber());\r\n        assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n        assertEquals(record.getBytePosition(), 95);\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(4, record.getRecordNumber());\r\n        assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n        assertEquals(record.getBytePosition(), 154);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetRecordWithMultiLineValues",
  "sourceCode" : "@Test\r\nvoid testGetRecordWithMultiLineValues() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\", CSVFormat.DEFAULT.withRecordSeparator(CRLF))) {\r\n        CSVRecord record;\r\n        assertEquals(0, parser.getRecordNumber());\r\n        assertEquals(0, parser.getCurrentLineNumber());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(3, parser.getCurrentLineNumber());\r\n        assertEquals(1, record.getRecordNumber());\r\n        assertEquals(1, parser.getRecordNumber());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(6, parser.getCurrentLineNumber());\r\n        assertEquals(2, record.getRecordNumber());\r\n        assertEquals(2, parser.getRecordNumber());\r\n        assertNotNull(record = parser.nextRecord());\r\n        assertEquals(9, parser.getCurrentLineNumber());\r\n        assertEquals(3, record.getRecordNumber());\r\n        assertEquals(3, parser.getRecordNumber());\r\n        assertNull(record = parser.nextRecord());\r\n        assertEquals(9, parser.getCurrentLineNumber());\r\n        assertEquals(3, parser.getRecordNumber());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetTrailerComment_HeaderComment1",
  "sourceCode" : "@Test\r\nvoid testGetTrailerComment_HeaderComment1() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n        parser.getRecords();\r\n        assertFalse(parser.hasTrailerComment());\r\n        assertNull(parser.getTrailerComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetTrailerComment_HeaderComment2",
  "sourceCode" : "@Test\r\nvoid testGetTrailerComment_HeaderComment2() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n        parser.getRecords();\r\n        assertFalse(parser.hasTrailerComment());\r\n        assertNull(parser.getTrailerComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetTrailerComment_HeaderComment3",
  "sourceCode" : "@Test\r\nvoid testGetTrailerComment_HeaderComment3() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n        parser.getRecords();\r\n        assertFalse(parser.hasTrailerComment());\r\n        assertNull(parser.getTrailerComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetTrailerComment_HeaderTrailerComment1",
  "sourceCode" : "@Test\r\nvoid testGetTrailerComment_HeaderTrailerComment1() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n        parser.getRecords();\r\n        assertTrue(parser.hasTrailerComment());\r\n        assertEquals(\"comment\", parser.getTrailerComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetTrailerComment_HeaderTrailerComment2",
  "sourceCode" : "@Test\r\nvoid testGetTrailerComment_HeaderTrailerComment2() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n        parser.getRecords();\r\n        assertTrue(parser.hasTrailerComment());\r\n        assertEquals(\"comment\", parser.getTrailerComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetTrailerComment_HeaderTrailerComment3",
  "sourceCode" : "@Test\r\nvoid testGetTrailerComment_HeaderTrailerComment3() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n        parser.getRecords();\r\n        assertTrue(parser.hasTrailerComment());\r\n        assertEquals(\"comment\", parser.getTrailerComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testGetTrailerComment_MultilineComment",
  "sourceCode" : "@Test\r\nvoid testGetTrailerComment_MultilineComment() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n        parser.getRecords();\r\n        assertTrue(parser.hasTrailerComment());\r\n        assertEquals(\"multi-line\" + LF + \"comment\", parser.getTrailerComment());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testHeader",
  "sourceCode" : "@Test\r\nvoid testHeader() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        for (int i = 0; i < 2; i++) {\r\n            assertTrue(records.hasNext());\r\n            final CSVRecord record = records.next();\r\n            assertEquals(record.get(0), record.get(\"a\"));\r\n            assertEquals(record.get(1), record.get(\"b\"));\r\n            assertEquals(record.get(2), record.get(\"c\"));\r\n        }\r\n        assertFalse(records.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testHeaderComment",
  "sourceCode" : "@Test\r\nvoid testHeaderComment() throws Exception {\r\n    final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        for (int i = 0; i < 2; i++) {\r\n            assertTrue(records.hasNext());\r\n            final CSVRecord record = records.next();\r\n            assertEquals(record.get(0), record.get(\"a\"));\r\n            assertEquals(record.get(1), record.get(\"b\"));\r\n            assertEquals(record.get(2), record.get(\"c\"));\r\n        }\r\n        assertFalse(records.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testHeaderMissing",
  "sourceCode" : "@Test\r\nvoid testHeaderMissing() throws Exception {\r\n    final Reader in = new StringReader(\"a,,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        for (int i = 0; i < 2; i++) {\r\n            assertTrue(records.hasNext());\r\n            final CSVRecord record = records.next();\r\n            assertEquals(record.get(0), record.get(\"a\"));\r\n            assertEquals(record.get(2), record.get(\"c\"));\r\n        }\r\n        assertFalse(records.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testHeaderMissingWithNull",
  "sourceCode" : "@Test\r\nvoid testHeaderMissingWithNull() throws Exception {\r\n    final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"\").withAllowMissingColumnNames().parse(in)) {\r\n        parser.iterator();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testHeadersMissing",
  "sourceCode" : "@Test\r\nvoid testHeadersMissing() throws Exception {\r\n    try (Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n        CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\r\n        parser.iterator();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testHeadersMissingException",
  "sourceCode" : "@Test\r\nvoid testHeadersMissingException() {\r\n    final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testHeadersMissingOneColumnException",
  "sourceCode" : "@Test\r\nvoid testHeadersMissingOneColumnException() {\r\n    final Reader in = new StringReader(\"a,,c,d,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testHeadersWithNullColumnName",
  "sourceCode" : "@Test\r\nvoid testHeadersWithNullColumnName() throws IOException {\r\n    final Reader in = new StringReader(\"header1,null,header3\\n1,2,3\\n4,5,6\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"null\").withAllowMissingColumnNames().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        // Expect the null header to be missing\r\n        @SuppressWarnings(\"resource\")\r\n        final CSVParser recordParser = record.getParser();\r\n        assertEquals(Arrays.asList(\"header1\", \"header3\"), recordParser.getHeaderNames());\r\n        assertEquals(2, recordParser.getHeaderMap().size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testIgnoreCaseHeaderMapping",
  "sourceCode" : "@Test\r\nvoid testIgnoreCaseHeaderMapping() throws Exception {\r\n    final Reader reader = new StringReader(\"1,2,3\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"One\", \"TWO\", \"three\").withIgnoreHeaderCase().parse(reader)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        assertEquals(\"1\", record.get(\"one\"));\r\n        assertEquals(\"2\", record.get(\"two\"));\r\n        assertEquals(\"3\", record.get(\"THREE\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testIgnoreEmptyLines",
  "sourceCode" : "@Test\r\nvoid testIgnoreEmptyLines() throws IOException {\r\n    final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\r\n    // String code = \"world\\r\\n\\n\";\r\n    // String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\r\n    try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(3, records.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testInvalidFormat",
  "sourceCode" : "@Test\r\nvoid testInvalidFormat() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testIterator",
  "sourceCode" : "@Test\r\nvoid testIterator() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n        final Iterator<CSVRecord> iterator = parser.iterator();\r\n        assertTrue(iterator.hasNext());\r\n        assertThrows(UnsupportedOperationException.class, iterator::remove);\r\n        assertValuesEquals(new String[] { \"a\", \"b\", \"c\" }, iterator.next());\r\n        assertValuesEquals(new String[] { \"1\", \"2\", \"3\" }, iterator.next());\r\n        assertTrue(iterator.hasNext());\r\n        assertTrue(iterator.hasNext());\r\n        assertTrue(iterator.hasNext());\r\n        assertValuesEquals(new String[] { \"x\", \"y\", \"z\" }, iterator.next());\r\n        assertFalse(iterator.hasNext());\r\n        assertThrows(NoSuchElementException.class, iterator::next);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testIteratorMaxRows",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(longs = { -1, 0, 1, 2, 3, 4, 5, Long.MAX_VALUE })\r\nvoid testIteratorMaxRows(final long maxRows) throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.builder().setMaxRows(maxRows).get().parse(in)) {\r\n        final Iterator<CSVRecord> iterator = parser.iterator();\r\n        assertTrue(iterator.hasNext());\r\n        assertThrows(UnsupportedOperationException.class, iterator::remove);\r\n        assertValuesEquals(new String[] { \"a\", \"b\", \"c\" }, iterator.next());\r\n        final boolean noLimit = maxRows <= 0;\r\n        final int fixtureLen = 3;\r\n        final long expectedLen = noLimit ? fixtureLen : Math.min(fixtureLen, maxRows);\r\n        if (expectedLen > 1) {\r\n            assertTrue(iterator.hasNext());\r\n            assertValuesEquals(new String[] { \"1\", \"2\", \"3\" }, iterator.next());\r\n        }\r\n        assertEquals(expectedLen > 2, iterator.hasNext());\r\n        // again\r\n        assertEquals(expectedLen > 2, iterator.hasNext());\r\n        if (expectedLen == fixtureLen) {\r\n            assertTrue(iterator.hasNext());\r\n            assertValuesEquals(new String[] { \"x\", \"y\", \"z\" }, iterator.next());\r\n        }\r\n        assertFalse(iterator.hasNext());\r\n        assertThrows(NoSuchElementException.class, iterator::next);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testIteratorSequenceBreaking",
  "sourceCode" : "@Test\r\nvoid testIteratorSequenceBreaking() throws IOException {\r\n    final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\r\n    // Iterator hasNext() shouldn't break sequence\r\n    try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n        final Iterator<CSVRecord> iter = parser.iterator();\r\n        int recordNumber = 0;\r\n        while (iter.hasNext()) {\r\n            final CSVRecord record = iter.next();\r\n            recordNumber++;\r\n            assertEquals(String.valueOf(recordNumber), record.get(0));\r\n            if (recordNumber >= 2) {\r\n                break;\r\n            }\r\n        }\r\n        iter.hasNext();\r\n        while (iter.hasNext()) {\r\n            final CSVRecord record = iter.next();\r\n            recordNumber++;\r\n            assertEquals(String.valueOf(recordNumber), record.get(0));\r\n        }\r\n    }\r\n    // Consecutive enhanced for loops shouldn't break sequence\r\n    try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n        int recordNumber = 0;\r\n        for (final CSVRecord record : parser) {\r\n            recordNumber++;\r\n            assertEquals(String.valueOf(recordNumber), record.get(0));\r\n            if (recordNumber >= 2) {\r\n                break;\r\n            }\r\n        }\r\n        for (final CSVRecord record : parser) {\r\n            recordNumber++;\r\n            assertEquals(String.valueOf(recordNumber), record.get(0));\r\n        }\r\n    }\r\n    // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\r\n    try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n        int recordNumber = 0;\r\n        for (final CSVRecord record : parser) {\r\n            recordNumber++;\r\n            assertEquals(String.valueOf(recordNumber), record.get(0));\r\n            if (recordNumber >= 2) {\r\n                break;\r\n            }\r\n        }\r\n        parser.iterator().hasNext();\r\n        for (final CSVRecord record : parser) {\r\n            recordNumber++;\r\n            assertEquals(String.valueOf(recordNumber), record.get(0));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testLineFeedEndings",
  "sourceCode" : "@Test\r\nvoid testLineFeedEndings() throws IOException {\r\n    final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\r\n    try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(4, records.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testMappedButNotSetAsOutlook2007ContactExport",
  "sourceCode" : "@Test\r\nvoid testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        CSVRecord record;\r\n        // 1st record\r\n        record = records.next();\r\n        assertTrue(record.isMapped(\"A\"));\r\n        assertTrue(record.isMapped(\"B\"));\r\n        assertTrue(record.isMapped(\"C\"));\r\n        assertTrue(record.isSet(\"A\"));\r\n        assertTrue(record.isSet(\"B\"));\r\n        assertFalse(record.isSet(\"C\"));\r\n        assertEquals(\"1\", record.get(\"A\"));\r\n        assertEquals(\"2\", record.get(\"B\"));\r\n        assertFalse(record.isConsistent());\r\n        // 2nd record\r\n        record = records.next();\r\n        assertTrue(record.isMapped(\"A\"));\r\n        assertTrue(record.isMapped(\"B\"));\r\n        assertTrue(record.isMapped(\"C\"));\r\n        assertTrue(record.isSet(\"A\"));\r\n        assertTrue(record.isSet(\"B\"));\r\n        assertTrue(record.isSet(\"C\"));\r\n        assertEquals(\"x\", record.get(\"A\"));\r\n        assertEquals(\"y\", record.get(\"B\"));\r\n        assertEquals(\"z\", record.get(\"C\"));\r\n        assertTrue(record.isConsistent());\r\n        // end\r\n        assertFalse(records.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testMongoDbCsv",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testMongoDbCsv() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"\\\"a a\\\",b,c\" + LF + \"d,e,f\", CSVFormat.MONGODB_CSV)) {\r\n        final Iterator<CSVRecord> itr1 = parser.iterator();\r\n        final Iterator<CSVRecord> itr2 = parser.iterator();\r\n        final CSVRecord first = itr1.next();\r\n        assertEquals(\"a a\", first.get(0));\r\n        assertEquals(\"b\", first.get(1));\r\n        assertEquals(\"c\", first.get(2));\r\n        final CSVRecord second = itr2.next();\r\n        assertEquals(\"d\", second.get(0));\r\n        assertEquals(\"e\", second.get(1));\r\n        assertEquals(\"f\", second.get(2));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testMultipleIterators",
  "sourceCode" : "@Test\r\n// TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\r\nvoid testMultipleIterators() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"a,b,c\" + CRLF + \"d,e,f\", CSVFormat.DEFAULT)) {\r\n        final Iterator<CSVRecord> itr1 = parser.iterator();\r\n        final CSVRecord first = itr1.next();\r\n        assertEquals(\"a\", first.get(0));\r\n        assertEquals(\"b\", first.get(1));\r\n        assertEquals(\"c\", first.get(2));\r\n        final CSVRecord second = itr1.next();\r\n        assertEquals(\"d\", second.get(0));\r\n        assertEquals(\"e\", second.get(1));\r\n        assertEquals(\"f\", second.get(2));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testNewCSVParserNullReaderFormat",
  "sourceCode" : "@Test\r\nvoid testNewCSVParserNullReaderFormat() {\r\n    assertThrows(NullPointerException.class, () -> new CSVParser(null, CSVFormat.DEFAULT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testNewCSVParserReaderNullFormat",
  "sourceCode" : "@Test\r\nvoid testNewCSVParserReaderNullFormat() {\r\n    assertThrows(NullPointerException.class, () -> new CSVParser(new StringReader(\"\"), null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testNoHeaderMap",
  "sourceCode" : "@Test\r\nvoid testNoHeaderMap() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT)) {\r\n        assertNull(parser.getHeaderMap());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testNotValueCSV",
  "sourceCode" : "@Test\r\nvoid testNotValueCSV() throws IOException {\r\n    final String source = \"#\";\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.withCommentMarker('#');\r\n    try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n        final CSVRecord csvRecord = csvParser.nextRecord();\r\n        assertNull(csvRecord);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParse",
  "sourceCode" : "@Test\r\nvoid testParse() throws Exception {\r\n    final URL url = ClassLoader.getSystemClassLoader().getResource(\"org/apache/commons/csv/CSVFileParser/test.csv\");\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(\"A\", \"B\", \"C\", \"D\").get();\r\n    final Charset charset = StandardCharsets.UTF_8;\r\n    // Reader\r\n    try (CSVParser parser = CSVParser.parse(new InputStreamReader(url.openStream(), charset), format)) {\r\n        parseFully(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\r\n        parseFully(parser);\r\n    }\r\n    // String\r\n    final Path path = Paths.get(url.toURI());\r\n    final String string = new String(Files.readAllBytes(path), charset);\r\n    try (CSVParser parser = CSVParser.parse(string, format)) {\r\n        parseFully(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.builder().setCharSequence(string).setFormat(format).get()) {\r\n        parseFully(parser);\r\n    }\r\n    // File\r\n    final File file = new File(url.toURI());\r\n    try (CSVParser parser = CSVParser.parse(file, charset, format)) {\r\n        parseFully(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.builder().setFile(file).setCharset(charset).setFormat(format).get()) {\r\n        parseFully(parser);\r\n    }\r\n    // InputStream\r\n    try (CSVParser parser = CSVParser.parse(url.openStream(), charset, format)) {\r\n        parseFully(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.builder().setInputStream(url.openStream()).setCharset(charset).setFormat(format).get()) {\r\n        parseFully(parser);\r\n    }\r\n    // Path\r\n    try (CSVParser parser = CSVParser.parse(path, charset, format)) {\r\n        parseFully(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.builder().setPath(path).setCharset(charset).setFormat(format).get()) {\r\n        parseFully(parser);\r\n    }\r\n    // URL\r\n    try (CSVParser parser = CSVParser.parse(url, charset, format)) {\r\n        parseFully(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.builder().setURI(url.toURI()).setCharset(charset).setFormat(format).get()) {\r\n        parseFully(parser);\r\n    }\r\n    // InputStreamReader\r\n    try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format)) {\r\n        parseFully(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\r\n        parseFully(parser);\r\n    }\r\n    // InputStreamReader with longs\r\n    try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format, /* characterOffset= */\r\n    0, /* recordNumber= */\r\n    1)) {\r\n        parseFully(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).setCharacterOffset(0).setRecordNumber(0).get()) {\r\n        parseFully(parser);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseFileCharsetNullFormat",
  "sourceCode" : "@Test\r\nvoid testParseFileCharsetNullFormat() throws IOException {\r\n    final File file = new File(\"src/test/resources/org/apache/commons/csv/CSVFileParser/test.csv\");\r\n    try (CSVParser parser = CSVParser.parse(file, Charset.defaultCharset(), null)) {\r\n        // null maps to DEFAULT.\r\n        parseFully(parser);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseInputStreamCharsetNullFormat",
  "sourceCode" : "@Test\r\nvoid testParseInputStreamCharsetNullFormat() throws IOException {\r\n    try (InputStream in = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/commons/csv/CSVFileParser/test.csv\"));\r\n        CSVParser parser = CSVParser.parse(in, Charset.defaultCharset(), null)) {\r\n        // null maps to DEFAULT.\r\n        parseFully(parser);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseNullFileFormat",
  "sourceCode" : "@Test\r\nvoid testParseNullFileFormat() {\r\n    assertThrows(NullPointerException.class, () -> CSVParser.parse((File) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseNullPathFormat",
  "sourceCode" : "@Test\r\nvoid testParseNullPathFormat() {\r\n    assertThrows(NullPointerException.class, () -> CSVParser.parse((Path) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseNullStringFormat",
  "sourceCode" : "@Test\r\nvoid testParseNullStringFormat() {\r\n    assertThrows(NullPointerException.class, () -> CSVParser.parse((String) null, CSVFormat.DEFAULT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseNullUrlCharsetFormat",
  "sourceCode" : "@Test\r\nvoid testParseNullUrlCharsetFormat() {\r\n    assertThrows(NullPointerException.class, () -> CSVParser.parse((URL) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParsePathCharsetNullFormat",
  "sourceCode" : "@Test\r\nvoid testParsePathCharsetNullFormat() throws IOException {\r\n    final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSVFileParser/test.csv\");\r\n    try (CSVParser parser = CSVParser.parse(path, Charset.defaultCharset(), null)) {\r\n        // null maps to DEFAULT.\r\n        parseFully(parser);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParserUrlNullCharsetFormat",
  "sourceCode" : "@Test\r\nvoid testParserUrlNullCharsetFormat() throws IOException {\r\n    final URL url = ClassLoader.getSystemClassLoader().getResource(\"org/apache/commons/csv/CSVFileParser/test.csv\");\r\n    try (CSVParser parser = CSVParser.parse(url, null, CSVFormat.DEFAULT)) {\r\n        // null maps to DEFAULT.\r\n        parseFully(parser);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseStringNullFormat",
  "sourceCode" : "@Test\r\nvoid testParseStringNullFormat() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(\"1,2,3\", null)) {\r\n        // null maps to DEFAULT.\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertEquals(1, records.size());\r\n        final CSVRecord record = records.get(0);\r\n        assertEquals(3, record.size());\r\n        assertEquals(\"1\", record.get(0));\r\n        assertEquals(\"2\", record.get(1));\r\n        assertEquals(\"3\", record.get(2));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseUrlCharsetNullFormat",
  "sourceCode" : "@Test\r\nvoid testParseUrlCharsetNullFormat() throws IOException {\r\n    final URL url = ClassLoader.getSystemClassLoader().getResource(\"org/apache/commons/csv/CSVFileParser/test.csv\");\r\n    try (CSVParser parser = CSVParser.parse(url, Charset.defaultCharset(), null)) {\r\n        // null maps to DEFAULT.\r\n        parseFully(parser);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseWithDelimiterStringWithEscape",
  "sourceCode" : "@Test\r\nvoid testParseWithDelimiterStringWithEscape() throws IOException {\r\n    final String source = \"a![!|!]b![|]c[|]xyz\\r\\nabc[abc][|]xyz\";\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').get();\r\n    try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n        CSVRecord csvRecord = csvParser.nextRecord();\r\n        assertEquals(\"a[|]b![|]c\", csvRecord.get(0));\r\n        assertEquals(\"xyz\", csvRecord.get(1));\r\n        csvRecord = csvParser.nextRecord();\r\n        assertEquals(\"abc[abc]\", csvRecord.get(0));\r\n        assertEquals(\"xyz\", csvRecord.get(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseWithDelimiterStringWithQuote",
  "sourceCode" : "@Test\r\nvoid testParseWithDelimiterStringWithQuote() throws IOException {\r\n    final String source = \"'a[|]b[|]c'[|]xyz\\r\\nabc[abc][|]xyz\";\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get();\r\n    try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n        CSVRecord csvRecord = csvParser.nextRecord();\r\n        assertEquals(\"a[|]b[|]c\", csvRecord.get(0));\r\n        assertEquals(\"xyz\", csvRecord.get(1));\r\n        csvRecord = csvParser.nextRecord();\r\n        assertEquals(\"abc[abc]\", csvRecord.get(0));\r\n        assertEquals(\"xyz\", csvRecord.get(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseWithDelimiterWithEscape",
  "sourceCode" : "@Test\r\nvoid testParseWithDelimiterWithEscape() throws IOException {\r\n    final String source = \"a!,b!,c,xyz\";\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.withEscape('!');\r\n    try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n        final CSVRecord csvRecord = csvParser.nextRecord();\r\n        assertEquals(\"a,b,c\", csvRecord.get(0));\r\n        assertEquals(\"xyz\", csvRecord.get(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseWithDelimiterWithQuote",
  "sourceCode" : "@Test\r\nvoid testParseWithDelimiterWithQuote() throws IOException {\r\n    final String source = \"'a,b,c',xyz\";\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\r\n    try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n        final CSVRecord csvRecord = csvParser.nextRecord();\r\n        assertEquals(\"a,b,c\", csvRecord.get(0));\r\n        assertEquals(\"xyz\", csvRecord.get(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseWithQuoteThrowsException",
  "sourceCode" : "@Test\r\nvoid testParseWithQuoteThrowsException() {\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\r\n    assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c','\")).nextRecord());\r\n    assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c'abc,xyz\")).nextRecord());\r\n    assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'abc'a,b,c',xyz\")).nextRecord());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParseWithQuoteWithEscape",
  "sourceCode" : "@Test\r\nvoid testParseWithQuoteWithEscape() throws IOException {\r\n    final String source = \"'a?,b?,c?d',xyz\";\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'').withEscape('?');\r\n    try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n        final CSVRecord csvRecord = csvParser.nextRecord();\r\n        assertEquals(\"a,b,c?d\", csvRecord.get(0));\r\n        assertEquals(\"xyz\", csvRecord.get(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testParsingPrintedEmptyFirstColumn",
  "sourceCode" : "@ParameterizedTest\r\n@EnumSource(CSVFormat.Predefined.class)\r\nvoid testParsingPrintedEmptyFirstColumn(final CSVFormat.Predefined format) throws Exception {\r\n    final String[][] lines = { { \"a\", \"b\" }, { \"\", \"x\" } };\r\n    final StringWriter buf = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(buf, format.getFormat())) {\r\n        printer.printRecords(Stream.of(lines));\r\n    }\r\n    try (CSVParser csvRecords = CSVParser.builder().setReader(new StringReader(buf.toString())).setFormat(format.getFormat()).get()) {\r\n        for (final String[] line : lines) {\r\n            assertValuesEquals(line, csvRecords.nextRecord());\r\n        }\r\n        assertNull(csvRecords.nextRecord());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testProvidedHeader",
  "sourceCode" : "@Test\r\nvoid testProvidedHeader() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        for (int i = 0; i < 3; i++) {\r\n            assertTrue(records.hasNext());\r\n            final CSVRecord record = records.next();\r\n            assertTrue(record.isMapped(\"A\"));\r\n            assertTrue(record.isMapped(\"B\"));\r\n            assertTrue(record.isMapped(\"C\"));\r\n            assertFalse(record.isMapped(\"NOT MAPPED\"));\r\n            assertEquals(record.get(0), record.get(\"A\"));\r\n            assertEquals(record.get(1), record.get(\"B\"));\r\n            assertEquals(record.get(2), record.get(\"C\"));\r\n        }\r\n        assertFalse(records.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testProvidedHeaderAuto",
  "sourceCode" : "@Test\r\nvoid testProvidedHeaderAuto() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        for (int i = 0; i < 2; i++) {\r\n            assertTrue(records.hasNext());\r\n            final CSVRecord record = records.next();\r\n            assertTrue(record.isMapped(\"a\"));\r\n            assertTrue(record.isMapped(\"b\"));\r\n            assertTrue(record.isMapped(\"c\"));\r\n            assertFalse(record.isMapped(\"NOT MAPPED\"));\r\n            assertEquals(record.get(0), record.get(\"a\"));\r\n            assertEquals(record.get(1), record.get(\"b\"));\r\n            assertEquals(record.get(2), record.get(\"c\"));\r\n        }\r\n        assertFalse(records.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testRepeatedHeadersAreReturnedInCSVRecordHeaderNames",
  "sourceCode" : "@Test\r\nvoid testRepeatedHeadersAreReturnedInCSVRecordHeaderNames() throws IOException {\r\n    final Reader in = new StringReader(\"header1,header2,header1\\n1,2,3\\n4,5,6\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withFirstRecordAsHeader().withTrim().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        @SuppressWarnings(\"resource\")\r\n        final CSVParser recordParser = record.getParser();\r\n        assertEquals(Arrays.asList(\"header1\", \"header2\", \"header1\"), recordParser.getHeaderNames());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testRoundtrip",
  "sourceCode" : "@Test\r\nvoid testRoundtrip() throws Exception {\r\n    final StringWriter out = new StringWriter();\r\n    final String data = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\r\n    try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\r\n        CSVParser parse = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n        for (final CSVRecord record : parse) {\r\n            printer.printRecord(record);\r\n        }\r\n        assertEquals(data, out.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testSkipAutoHeader",
  "sourceCode" : "@Test\r\nvoid testSkipAutoHeader() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        assertEquals(\"1\", record.get(\"a\"));\r\n        assertEquals(\"2\", record.get(\"b\"));\r\n        assertEquals(\"3\", record.get(\"c\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testSkipHeaderOverrideDuplicateHeaders",
  "sourceCode" : "@Test\r\nvoid testSkipHeaderOverrideDuplicateHeaders() throws Exception {\r\n    final Reader in = new StringReader(\"a,a,a\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        assertEquals(\"1\", record.get(\"X\"));\r\n        assertEquals(\"2\", record.get(\"Y\"));\r\n        assertEquals(\"3\", record.get(\"Z\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testSkipSetAltHeaders",
  "sourceCode" : "@Test\r\nvoid testSkipSetAltHeaders() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        assertEquals(\"1\", record.get(\"X\"));\r\n        assertEquals(\"2\", record.get(\"Y\"));\r\n        assertEquals(\"3\", record.get(\"Z\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testSkipSetHeader",
  "sourceCode" : "@Test\r\nvoid testSkipSetHeader() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        assertEquals(\"1\", record.get(\"a\"));\r\n        assertEquals(\"2\", record.get(\"b\"));\r\n        assertEquals(\"3\", record.get(\"c\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testStartWithEmptyLinesThenHeaders",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testStartWithEmptyLinesThenHeaders() throws Exception {\r\n    final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n    final String[][] res = { // Excel format does not ignore empty lines\r\n    { \"hello\", \"\" }, // Excel format does not ignore empty lines\r\n    { \"\" }, { \"\" } };\r\n    for (final String code : codes) {\r\n        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n            final List<CSVRecord> records = parser.getRecords();\r\n            assertEquals(res.length, records.size());\r\n            assertFalse(records.isEmpty());\r\n            for (int i = 0; i < res.length; i++) {\r\n                assertValuesEquals(res[i], records.get(i));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testStream",
  "sourceCode" : "@Test\r\nvoid testStream() throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n        final List<CSVRecord> list = parser.stream().collect(Collectors.toList());\r\n        assertFalse(list.isEmpty());\r\n        assertValuesEquals(new String[] { \"a\", \"b\", \"c\" }, list.get(0));\r\n        assertValuesEquals(new String[] { \"1\", \"2\", \"3\" }, list.get(1));\r\n        assertValuesEquals(new String[] { \"x\", \"y\", \"z\" }, list.get(2));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testStreamMaxRows",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(longs = { -1, 0, 1, 2, 3, 4, Long.MAX_VALUE })\r\nvoid testStreamMaxRows(final long maxRows) throws Exception {\r\n    final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.builder().setMaxRows(maxRows).get().parse(in)) {\r\n        final List<CSVRecord> list = parser.stream().collect(Collectors.toList());\r\n        assertFalse(list.isEmpty());\r\n        assertValuesEquals(new String[] { \"a\", \"b\", \"c\" }, list.get(0));\r\n        if (maxRows <= 0 || maxRows > 1) {\r\n            assertValuesEquals(new String[] { \"1\", \"2\", \"3\" }, list.get(1));\r\n        }\r\n        if (maxRows <= 0 || maxRows > 2) {\r\n            assertValuesEquals(new String[] { \"x\", \"y\", \"z\" }, list.get(2));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testThrowExceptionWithLineAndPosition",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionWithLineAndPosition() throws IOException {\r\n    final String csvContent = \"col1,col2,col3,col4,col5,col6,col7,col8,col9,col10\\nrec1,rec2,rec3,rec4,rec5,rec6,rec7,rec8,\\\"\\\"rec9\\\"\\\",rec10\";\r\n    final StringReader stringReader = new StringReader(csvContent);\r\n    // @formatter:off\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setHeader().setSkipHeaderRecord(true).get();\r\n    // @formatter:on\r\n    try (CSVParser csvParser = csvFormat.parse(stringReader)) {\r\n        final UncheckedIOException exception = assertThrows(UncheckedIOException.class, csvParser::getRecords);\r\n        assertInstanceOf(CSVException.class, exception.getCause());\r\n        assertTrue(exception.getMessage().contains(\"Invalid character between encapsulated token and delimiter at line: 2, position: 94\"), exception::getMessage);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testTrailingDelimiter",
  "sourceCode" : "@Test\r\nvoid testTrailingDelimiter() throws Exception {\r\n    final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        assertEquals(\"1\", record.get(\"X\"));\r\n        assertEquals(\"2\", record.get(\"Y\"));\r\n        assertEquals(\"3\", record.get(\"Z\"));\r\n        assertEquals(3, record.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVParserTest.java",
  "methodName" : "testTrim",
  "sourceCode" : "@Test\r\nvoid testTrim() throws Exception {\r\n    final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim().parse(in)) {\r\n        final Iterator<CSVRecord> records = parser.iterator();\r\n        final CSVRecord record = records.next();\r\n        assertEquals(\"1\", record.get(\"X\"));\r\n        assertEquals(\"2\", record.get(\"Y\"));\r\n        assertEquals(\"3\", record.get(\"Z\"));\r\n        assertEquals(3, record.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testCloseBackwardCompatibility",
  "sourceCode" : "@Test\r\nvoid testCloseBackwardCompatibility() throws IOException {\r\n    try (Writer writer = mock(Writer.class)) {\r\n        final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n        try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n            assertInitialState(printer);\r\n        }\r\n        verify(writer, never()).flush();\r\n        verify(writer, times(1)).close();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testCloseWithCsvFormatAutoFlushOff",
  "sourceCode" : "@Test\r\nvoid testCloseWithCsvFormatAutoFlushOff() throws IOException {\r\n    try (Writer writer = mock(Writer.class)) {\r\n        final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(false);\r\n        try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n            assertInitialState(printer);\r\n        }\r\n        verify(writer, never()).flush();\r\n        verify(writer, times(1)).close();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testCloseWithCsvFormatAutoFlushOn",
  "sourceCode" : "@Test\r\nvoid testCloseWithCsvFormatAutoFlushOn() throws IOException {\r\n    // System.out.println(\"start method\");\r\n    try (Writer writer = mock(Writer.class)) {\r\n        final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(true);\r\n        try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n            assertInitialState(printer);\r\n        }\r\n        verify(writer, times(1)).flush();\r\n        verify(writer, times(1)).close();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testCloseWithFlushOff",
  "sourceCode" : "@Test\r\nvoid testCloseWithFlushOff() throws IOException {\r\n    try (Writer writer = mock(Writer.class)) {\r\n        final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n        @SuppressWarnings(\"resource\")\r\n        final CSVPrinter printer = new CSVPrinter(writer, csvFormat);\r\n        assertInitialState(printer);\r\n        printer.close(false);\r\n        assertEquals(0, printer.getRecordCount());\r\n        verify(writer, never()).flush();\r\n        verify(writer, times(1)).close();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testCloseWithFlushOn",
  "sourceCode" : "@Test\r\nvoid testCloseWithFlushOn() throws IOException {\r\n    try (Writer writer = mock(Writer.class)) {\r\n        @SuppressWarnings(\"resource\")\r\n        final CSVPrinter printer = new CSVPrinter(writer, CSVFormat.DEFAULT);\r\n        assertInitialState(printer);\r\n        printer.close(true);\r\n        assertEquals(0, printer.getRecordCount());\r\n        verify(writer, times(1)).flush();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testCRComment",
  "sourceCode" : "@Test\r\nvoid testCRComment() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final Object value = \"abc\";\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n        assertInitialState(printer);\r\n        printer.print(value);\r\n        assertEquals(0, printer.getRecordCount());\r\n        printer.printComment(\"This is a comment\\r\\non multiple lines\\rthis is next comment\\r\");\r\n        assertEquals(\"abc\" + RECORD_SEPARATOR + \"# This is a comment\" + RECORD_SEPARATOR + \"# on multiple lines\" + RECORD_SEPARATOR + \"# this is next comment\" + RECORD_SEPARATOR + \"# \" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(0, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testCSV135",
  "sourceCode" : "@Test\r\nvoid testCSV135() throws IOException {\r\n    final List<String> list = new LinkedList<>();\r\n    // \"\"\r\n    list.add(\"\\\"\\\"\");\r\n    // \\\\\r\n    list.add(\"\\\\\\\\\");\r\n    // \\\"\\\r\n    list.add(\"\\\\\\\"\\\\\");\r\n    //\r\n    // \"\",\\\\,\\\"\\ (unchanged)\r\n    tryFormat(list, null, null, \"\\\"\\\",\\\\\\\\,\\\\\\\"\\\\\");\r\n    //\r\n    // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, and embedded DQ doubled)\r\n    tryFormat(list, '\"', null, \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\r\n    //\r\n    // \"\",\\\\\\\\,\\\\\"\\\\ (escapes escaped, not quoted)\r\n    tryFormat(list, null, '\\\\', \"\\\"\\\",\\\\\\\\\\\\\\\\,\\\\\\\\\\\"\\\\\\\\\");\r\n    //\r\n    // \"\\\"\\\"\",\"\\\\\\\\\",\"\\\\\\\"\\\\\" (quoted, and embedded DQ & escape escaped)\r\n    tryFormat(list, '\"', '\\\\', \"\\\"\\\\\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\\\\\\\\\",\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\"\");\r\n    //\r\n    // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, embedded DQ escaped)\r\n    tryFormat(list, '\"', '\"', \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testCSV259",
  "sourceCode" : "@Test\r\nvoid testCSV259() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (Reader reader = new FileReader(\"src/test/resources/org/apache/commons/csv/CSV-259/sample.txt\");\r\n        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(reader);\r\n        assertEquals(\"x!,y!,z\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDelimeterQuoted",
  "sourceCode" : "@Test\r\nvoid testDelimeterQuoted() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a,b,c\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"'a,b,c',xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDelimeterQuoteNone",
  "sourceCode" : "@Test\r\nvoid testDelimeterQuoteNone() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a,b,c\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"a!,b!,c,xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDelimeterStringQuoted",
  "sourceCode" : "@Test\r\nvoid testDelimeterStringQuoted() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get())) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a[|]b[|]c\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"'a[|]b[|]c'[|]xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDelimeterStringQuoteNone",
  "sourceCode" : "@Test\r\nvoid testDelimeterStringQuoteNone() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').setQuoteMode(QuoteMode.NONE).get();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a[|]b[|]c\");\r\n        printer.print(\"xyz\");\r\n        printer.print(\"a[xy]bc[]\");\r\n        assertEquals(\"a![!|!]b![!|!]c[|]xyz[|]a[xy]bc[]\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDelimiterEscaped",
  "sourceCode" : "@Test\r\nvoid testDelimiterEscaped() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a,b,c\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"a!,b!,c,xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDelimiterPlain",
  "sourceCode" : "@Test\r\nvoid testDelimiterPlain() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a,b,c\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"a,b,c,xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDelimiterStringEscaped",
  "sourceCode" : "@Test\r\nvoid testDelimiterStringEscaped() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"|||\").setEscape('!').setQuote(null).get())) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a|||b|||c\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"a!|!|!|b!|!|!|c|||xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDisabledComment",
  "sourceCode" : "@Test\r\nvoid testDisabledComment() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printComment(\"This is a comment\");\r\n        assertEquals(\"\", sw.toString());\r\n        assertEquals(0, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testDontQuoteEuroFirstChar",
  "sourceCode" : "@Test\r\nvoid testDontQuoteEuroFirstChar() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(EURO_CH, \"Deux\");\r\n        assertEquals(EURO_CH + \",Deux\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEolEscaped",
  "sourceCode" : "@Test\r\nvoid testEolEscaped() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a\\rb\\nc\");\r\n        printer.print(\"x\\fy\\bz\");\r\n        assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEolPlain",
  "sourceCode" : "@Test\r\nvoid testEolPlain() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a\\rb\\nc\");\r\n        printer.print(\"x\\fy\\bz\");\r\n        assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEolQuoted",
  "sourceCode" : "@Test\r\nvoid testEolQuoted() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"a\\rb\\nc\");\r\n        printer.print(\"x\\by\\fz\");\r\n        assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEquals",
  "sourceCode" : "@SuppressWarnings(\"unlikely-arg-type\")\r\n@Test\r\nvoid testEquals() throws IOException {\r\n    // Don't use assertNotEquals here\r\n    assertFalse(CSVFormat.DEFAULT.equals(null));\r\n    // Don't use assertNotEquals here\r\n    assertFalse(CSVFormat.DEFAULT.equals(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeBackslash1",
  "sourceCode" : "@Test\r\nvoid testEscapeBackslash1() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"\\\\\");\r\n    }\r\n    assertEquals(\"\\\\\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeBackslash2",
  "sourceCode" : "@Test\r\nvoid testEscapeBackslash2() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"\\\\\\r\");\r\n    }\r\n    assertEquals(\"'\\\\\\r'\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeBackslash3",
  "sourceCode" : "@Test\r\nvoid testEscapeBackslash3() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"X\\\\\\r\");\r\n    }\r\n    assertEquals(\"'X\\\\\\r'\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeBackslash4",
  "sourceCode" : "@Test\r\nvoid testEscapeBackslash4() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"\\\\\\\\\");\r\n    }\r\n    assertEquals(\"\\\\\\\\\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeBackslash5",
  "sourceCode" : "@Test\r\nvoid testEscapeBackslash5() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"\\\\\\\\\");\r\n    }\r\n    assertEquals(\"\\\\\\\\\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeNull1",
  "sourceCode" : "@Test\r\nvoid testEscapeNull1() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"\\\\\");\r\n    }\r\n    assertEquals(\"\\\\\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeNull2",
  "sourceCode" : "@Test\r\nvoid testEscapeNull2() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"\\\\\\r\");\r\n    }\r\n    assertEquals(\"\\\"\\\\\\r\\\"\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeNull3",
  "sourceCode" : "@Test\r\nvoid testEscapeNull3() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"X\\\\\\r\");\r\n    }\r\n    assertEquals(\"\\\"X\\\\\\r\\\"\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeNull4",
  "sourceCode" : "@Test\r\nvoid testEscapeNull4() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"\\\\\\\\\");\r\n    }\r\n    assertEquals(\"\\\\\\\\\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testEscapeNull5",
  "sourceCode" : "@Test\r\nvoid testEscapeNull5() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n        assertInitialState(printer);\r\n        printer.print(\"\\\\\\\\\");\r\n    }\r\n    assertEquals(\"\\\\\\\\\", sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllArrayOfArrays",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllArrayOfArrays() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords((Object[]) new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } });\r\n        assertEquals(\"r1c1,r1c2\" + RECORD_SEPARATOR + \"r2c1,r2c2\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllArrayOfArraysWithFirstEmptyValue2",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllArrayOfArraysWithFirstEmptyValue2() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords((Object[]) new String[][] { { \"\" } });\r\n        assertEquals(\"\\\"\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllArrayOfArraysWithFirstSpaceValue1",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllArrayOfArraysWithFirstSpaceValue1() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords((Object[]) new String[][] { { \" \", \"r1c2\" } });\r\n        assertEquals(\"\\\" \\\",r1c2\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllArrayOfArraysWithFirstTabValue1",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllArrayOfArraysWithFirstTabValue1() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords((Object[]) new String[][] { { \"\\t\", \"r1c2\" } });\r\n        assertEquals(\"\\\"\\t\\\",r1c2\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllArrayOfLists",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllArrayOfLists() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords((Object[]) new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") });\r\n        assertEquals(\"r1c1,r1c2\" + RECORD_SEPARATOR + \"r2c1,r2c2\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllArrayOfListsWithFirstEmptyValue2",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllArrayOfListsWithFirstEmptyValue2() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords((Object[]) new List[] { Arrays.asList(\"\") });\r\n        assertEquals(\"\\\"\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllIterableOfArrays",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllIterableOfArrays() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords(Arrays.asList(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\r\n        assertEquals(\"r1c1,r1c2\" + RECORD_SEPARATOR + \"r2c1,r2c2\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllIterableOfArraysWithFirstEmptyValue2",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllIterableOfArraysWithFirstEmptyValue2() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords(Arrays.asList(new String[][] { { \"\" } }));\r\n        assertEquals(\"\\\"\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllIterableOfLists",
  "sourceCode" : "@Test\r\nvoid testExcelPrintAllIterableOfLists() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords(Arrays.asList(Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\")));\r\n        assertEquals(\"r1c1,r1c2\" + RECORD_SEPARATOR + \"r2c1,r2c2\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrintAllStreamOfArrays",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(longs = { -1, 0, 1, 2, Long.MAX_VALUE })\r\nvoid testExcelPrintAllStreamOfArrays(final long maxRows) throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setMaxRows(maxRows).get();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords(Stream.of(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\r\n        String expected = \"r1c1,r1c2\" + RECORD_SEPARATOR;\r\n        if (maxRows != 1) {\r\n            expected += \"r2c1,r2c2\" + RECORD_SEPARATOR;\r\n        }\r\n        assertEquals(expected, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrinter1",
  "sourceCode" : "@Test\r\nvoid testExcelPrinter1() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", \"b\");\r\n        assertEquals(\"a,b\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testExcelPrinter2",
  "sourceCode" : "@Test\r\nvoid testExcelPrinter2() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a,b\", \"b\");\r\n        assertEquals(\"\\\"a,b\\\",b\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testHeader",
  "sourceCode" : "@Test\r\nvoid testHeader() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"))) {\r\n        assertEquals(1, printer.getRecordCount());\r\n        printer.printRecord(\"a\", \"b\", \"c\");\r\n        printer.printRecord(\"x\", \"y\", \"z\");\r\n        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testHeaderCommentExcel",
  "sourceCode" : "@Test\r\nvoid testHeaderCommentExcel() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final Date now = new Date();\r\n    final CSVFormat format = CSVFormat.EXCEL;\r\n    try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\r\n        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testHeaderCommentTdf",
  "sourceCode" : "@Test\r\nvoid testHeaderCommentTdf() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final Date now = new Date();\r\n    final CSVFormat format = CSVFormat.TDF;\r\n    try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\r\n        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testHeaderNotSet",
  "sourceCode" : "@Test\r\nvoid testHeaderNotSet() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", \"b\", \"c\");\r\n        printer.printRecord(\"x\", \"y\", \"z\");\r\n        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testInvalidFormat",
  "sourceCode" : "@Test\r\nvoid testInvalidFormat() {\r\n    assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJdbcPrinter",
  "sourceCode" : "@Test\r\nvoid testJdbcPrinter() throws IOException, ClassNotFoundException, SQLException {\r\n    final StringWriter sw = new StringWriter();\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n    try (Connection connection = getH2Connection()) {\r\n        setUpTable(connection);\r\n        try (Statement stmt = connection.createStatement();\r\n            CSVPrinter printer = new CSVPrinter(sw, csvFormat);\r\n            ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT, BIN_DATA from TEST\")) {\r\n            assertInitialState(printer);\r\n            printer.printRecords(resultSet);\r\n            assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\r\n        }\r\n    }\r\n    final String csv = sw.toString();\r\n    assertEquals(\"1,r1,\\\"long text 1\\\",\\\"YmluYXJ5IGRhdGEgMQ==\\r\\n\\\"\" + RECORD_SEPARATOR + \"2,r2,\\\"\" + longText2 + \"\\\",\\\"YmluYXJ5IGRhdGEgMg==\\r\\n\\\"\" + RECORD_SEPARATOR, csv);\r\n    // Round trip the data\r\n    try (StringReader reader = new StringReader(csv);\r\n        CSVParser csvParser = csvFormat.parse(reader)) {\r\n        // Row 1\r\n        CSVRecord record = csvParser.nextRecord();\r\n        assertEquals(\"1\", record.get(0));\r\n        assertEquals(\"r1\", record.get(1));\r\n        assertEquals(\"long text 1\", record.get(2));\r\n        assertEquals(\"YmluYXJ5IGRhdGEgMQ==\\r\\n\", record.get(3));\r\n        // Row 2\r\n        record = csvParser.nextRecord();\r\n        assertEquals(\"2\", record.get(0));\r\n        assertEquals(\"r2\", record.get(1));\r\n        assertEquals(\"YmluYXJ5IGRhdGEgMg==\\r\\n\", record.get(3));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJdbcPrinterWithFirstEmptyValue2",
  "sourceCode" : "@Test\r\nvoid testJdbcPrinterWithFirstEmptyValue2() throws IOException, ClassNotFoundException, SQLException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (Connection connection = getH2Connection()) {\r\n        try (Statement stmt = connection.createStatement();\r\n            ResultSet resultSet = stmt.executeQuery(\"select '' AS EMPTYVALUE from DUAL\");\r\n            CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\r\n            printer.printRecords(resultSet);\r\n        }\r\n    }\r\n    assertEquals(\"EMPTYVALUE\" + RECORD_SEPARATOR + \"\\\"\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJdbcPrinterWithResultSet",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(longs = { -1, 0, 1, 2, 3, 4, Long.MAX_VALUE })\r\nvoid testJdbcPrinterWithResultSet(final long maxRows) throws IOException, ClassNotFoundException, SQLException {\r\n    final StringWriter sw = new StringWriter();\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setMaxRows(maxRows).get();\r\n    try (Connection connection = getH2Connection()) {\r\n        setUpTable(connection);\r\n        try (Statement stmt = connection.createStatement();\r\n            ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\r\n            CSVPrinter printer = format.withHeader(resultSet).print(sw)) {\r\n            printer.printRecords(resultSet);\r\n        }\r\n    }\r\n    final String resultString = sw.toString();\r\n    final String header = \"ID,NAME,TEXT\";\r\n    final String headerRow1 = header + RECORD_SEPARATOR + \"1,r1,\\\"long text 1\\\"\" + RECORD_SEPARATOR;\r\n    final String allRows = headerRow1 + \"2,r2,\\\"\" + longText2 + \"\\\"\" + RECORD_SEPARATOR;\r\n    final int expectedRowsWithHeader;\r\n    if (maxRows == 1) {\r\n        assertEquals(headerRow1, resultString);\r\n        expectedRowsWithHeader = 2;\r\n    } else {\r\n        assertEquals(allRows, resultString);\r\n        expectedRowsWithHeader = TABLE_AND_HEADER_RECORD_COUNT;\r\n    }\r\n    assertRowCount(CSVFormat.DEFAULT, resultString, expectedRowsWithHeader);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJdbcPrinterWithResultSetHeader",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(longs = { -1, 0, 3, 4, Long.MAX_VALUE })\r\nvoid testJdbcPrinterWithResultSetHeader(final long maxRows) throws IOException, ClassNotFoundException, SQLException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (Connection connection = getH2Connection()) {\r\n        setUpTable(connection);\r\n        final CSVFormat format = CSVFormat.DEFAULT.builder().setMaxRows(maxRows).get();\r\n        try (Statement stmt = connection.createStatement();\r\n            CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n            try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\r\n                printer.printRecords(resultSet, true);\r\n                assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\r\n                assertEquals(\"ID,NAME\" + RECORD_SEPARATOR + \"1,r1\" + RECORD_SEPARATOR + \"2,r2\" + RECORD_SEPARATOR, sw.toString());\r\n            }\r\n            assertRowCount(format, sw.toString(), TABLE_AND_HEADER_RECORD_COUNT);\r\n            try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\r\n                printer.printRecords(resultSet, false);\r\n                assertEquals(TABLE_RECORD_COUNT * 2, printer.getRecordCount());\r\n                assertNotEquals(\"ID,NAME\" + RECORD_SEPARATOR + \"1,r1\" + RECORD_SEPARATOR + \"2,r2\" + RECORD_SEPARATOR, sw.toString());\r\n            }\r\n            assertRowCount(CSVFormat.DEFAULT, sw.toString(), TABLE_AND_HEADER_RECORD_COUNT + TABLE_RECORD_COUNT);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJdbcPrinterWithResultSetMetaData",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(longs = { -1, 0, 3, 4, Long.MAX_VALUE })\r\nvoid testJdbcPrinterWithResultSetMetaData(final long maxRows) throws IOException, ClassNotFoundException, SQLException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (Connection connection = getH2Connection()) {\r\n        setUpTable(connection);\r\n        final CSVFormat format = CSVFormat.DEFAULT.builder().setMaxRows(maxRows).get();\r\n        try (Statement stmt = connection.createStatement();\r\n            ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\r\n            CSVPrinter printer = format.withHeader(resultSet.getMetaData()).print(sw)) {\r\n            // The header is the first record.\r\n            assertEquals(1, printer.getRecordCount());\r\n            printer.printRecords(resultSet);\r\n            assertEquals(3, printer.getRecordCount());\r\n            assertEquals(\"ID,NAME,TEXT\" + RECORD_SEPARATOR + \"1,r1,\\\"long text 1\\\"\" + RECORD_SEPARATOR + \"2,r2,\\\"\" + longText2 + \"\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n        }\r\n        assertRowCount(format, sw.toString(), TABLE_AND_HEADER_RECORD_COUNT);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJira135_part1",
  "sourceCode" : "@Test\r\nvoid testJira135_part1() throws IOException {\r\n    final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n    final StringWriter sw = new StringWriter();\r\n    final List<String> list = new LinkedList<>();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        list.add(\"\\\"\");\r\n        printer.printRecord(list);\r\n    }\r\n    final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\r\n    assertEquals(expected, sw.toString());\r\n    final String[] record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJira135_part2",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testJira135_part2() throws IOException {\r\n    final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n    final StringWriter sw = new StringWriter();\r\n    final List<String> list = new LinkedList<>();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        list.add(\"\\n\");\r\n        printer.printRecord(list);\r\n    }\r\n    final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\r\n    assertEquals(expected, sw.toString());\r\n    final String[] record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJira135_part3",
  "sourceCode" : "@Test\r\nvoid testJira135_part3() throws IOException {\r\n    final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n    final StringWriter sw = new StringWriter();\r\n    final List<String> list = new LinkedList<>();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        list.add(\"\\\\\");\r\n        printer.printRecord(list);\r\n    }\r\n    final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\r\n    assertEquals(expected, sw.toString());\r\n    final String[] record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testJira135All",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testJira135All() throws IOException {\r\n    final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n    final StringWriter sw = new StringWriter();\r\n    final List<String> list = new LinkedList<>();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        list.add(\"\\\"\");\r\n        list.add(\"\\n\");\r\n        list.add(\"\\\\\");\r\n        printer.printRecord(list);\r\n    }\r\n    final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\r\n    assertEquals(expected, sw.toString());\r\n    final String[] record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMongoDbCsvBasic",
  "sourceCode" : "@Test\r\nvoid testMongoDbCsvBasic() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n        printer.printRecord(\"a\", \"b\");\r\n        assertEquals(\"a,b\" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(1, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMongoDbCsvCommaInValue",
  "sourceCode" : "@Test\r\nvoid testMongoDbCsvCommaInValue() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n        printer.printRecord(\"a,b\", \"c\");\r\n        assertEquals(\"\\\"a,b\\\",c\" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(1, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMongoDbCsvDoubleQuoteInValue",
  "sourceCode" : "@Test\r\nvoid testMongoDbCsvDoubleQuoteInValue() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n        printer.printRecord(\"a \\\"c\\\" b\", \"d\");\r\n        assertEquals(\"\\\"a \\\"\\\"c\\\"\\\" b\\\",d\" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(1, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMongoDbCsvTabInValue",
  "sourceCode" : "@Test\r\nvoid testMongoDbCsvTabInValue() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n        printer.printRecord(\"a\\tb\", \"c\");\r\n        assertEquals(\"a\\tb,c\" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(1, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMongoDbTsvBasic",
  "sourceCode" : "@Test\r\nvoid testMongoDbTsvBasic() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n        printer.printRecord(\"a\", \"b\");\r\n        assertEquals(\"a\\tb\" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(1, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMongoDbTsvCommaInValue",
  "sourceCode" : "@Test\r\nvoid testMongoDbTsvCommaInValue() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n        printer.printRecord(\"a,b\", \"c\");\r\n        assertEquals(\"a,b\\tc\" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(1, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMongoDbTsvTabInValue",
  "sourceCode" : "@Test\r\nvoid testMongoDbTsvTabInValue() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n        printer.printRecord(\"a\\tb\", \"c\");\r\n        assertEquals(\"\\\"a\\tb\\\"\\tc\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMultiLineComment",
  "sourceCode" : "@Test\r\nvoid testMultiLineComment() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n        printer.printComment(\"This is a comment\\non multiple lines\");\r\n        assertEquals(\"# This is a comment\" + RECORD_SEPARATOR + \"# on multiple lines\" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(0, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMySqlNullOutput",
  "sourceCode" : "@Test\r\nvoid testMySqlNullOutput() throws IOException {\r\n    Object[] s = new String[] { \"NULL\", null };\r\n    CSVFormat format = CSVFormat.MYSQL.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\r\n    StringWriter writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    String expected = \"\\\"NULL\\\"\\tNULL\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    String[] record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(s, record0);\r\n    s = new String[] { \"\\\\N\", null };\r\n    format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\N\", \"A\" };\r\n    format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\tA\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\n\", \"A\" };\r\n    format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\n\\tA\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\", null };\r\n    format = CSVFormat.MYSQL.withNullString(\"NULL\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\tNULL\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\", null };\r\n    format = CSVFormat.MYSQL;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\t\\\\N\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n    format = CSVFormat.MYSQL;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n    format = CSVFormat.MYSQL;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\\\r\" };\r\n    format = CSVFormat.MYSQL;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testMySqlNullStringDefault",
  "sourceCode" : "@Test\r\nvoid testMySqlNullStringDefault() {\r\n    assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testNewCsvPrinterAppendableNullFormat",
  "sourceCode" : "@Test\r\nvoid testNewCsvPrinterAppendableNullFormat() {\r\n    assertThrows(NullPointerException.class, () -> new CSVPrinter(new StringWriter(), null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testNewCsvPrinterNullAppendableFormat",
  "sourceCode" : "@Test\r\nvoid testNewCsvPrinterNullAppendableFormat() {\r\n    assertThrows(NullPointerException.class, () -> new CSVPrinter(null, CSVFormat.DEFAULT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testNotFlushable",
  "sourceCode" : "@Test\r\nvoid testNotFlushable() throws IOException {\r\n    final Appendable out = new StringBuilder();\r\n    try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT)) {\r\n        printer.printRecord(\"a\", \"b\", \"c\");\r\n        assertEquals(\"a,b,c\" + RECORD_SEPARATOR, out.toString());\r\n        printer.flush();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testParseCustomNullValues",
  "sourceCode" : "@Test\r\nvoid testParseCustomNullValues() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        printer.printRecord(\"a\", null, \"b\");\r\n    }\r\n    final String csvString = sw.toString();\r\n    assertEquals(\"a,NULL,b\" + RECORD_SEPARATOR, csvString);\r\n    try (CSVParser iterable = format.parse(new StringReader(csvString))) {\r\n        final Iterator<CSVRecord> iterator = iterable.iterator();\r\n        final CSVRecord record = iterator.next();\r\n        assertEquals(\"a\", record.get(0));\r\n        assertNull(record.get(1));\r\n        assertEquals(\"b\", record.get(2));\r\n        assertFalse(iterator.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPlainEscaped",
  "sourceCode" : "@Test\r\nvoid testPlainEscaped() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\r\n        printer.print(\"abc\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"abc,xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPlainPlain",
  "sourceCode" : "@Test\r\nvoid testPlainPlain() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n        printer.print(\"abc\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"abc,xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPlainQuoted",
  "sourceCode" : "@Test\r\nvoid testPlainQuoted() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n        printer.print(\"abc\");\r\n        assertEquals(\"abc\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPostgreSqlCsvNullOutput",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testPostgreSqlCsvNullOutput() throws IOException {\r\n    Object[] s = new String[] { \"NULL\", null };\r\n    CSVFormat format = CSVFormat.POSTGRESQL_CSV.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\r\n    StringWriter writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    String expected = \"\\\"NULL\\\",NULL\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    String[] record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(new Object[2], record0);\r\n    s = new String[] { \"\\\\N\", null };\r\n    format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\N\", \"A\" };\r\n    format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\tA\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\n\", \"A\" };\r\n    format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\n\\tA\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\", null };\r\n    format = CSVFormat.POSTGRESQL_CSV.withNullString(\"NULL\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\tNULL\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\", null };\r\n    format = CSVFormat.POSTGRESQL_CSV;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\t\\\\N\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n    format = CSVFormat.POSTGRESQL_CSV;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n    format = CSVFormat.POSTGRESQL_CSV;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\\\r\" };\r\n    format = CSVFormat.POSTGRESQL_CSV;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPostgreSqlCsvTextOutput",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testPostgreSqlCsvTextOutput() throws IOException {\r\n    Object[] s = new String[] { \"NULL\", null };\r\n    CSVFormat format = CSVFormat.POSTGRESQL_TEXT.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\r\n    StringWriter writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    String expected = \"\\\"NULL\\\"\\tNULL\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    String[] record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(new Object[2], record0);\r\n    s = new String[] { \"\\\\N\", null };\r\n    format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\N\", \"A\" };\r\n    format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\tA\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\n\", \"A\" };\r\n    format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\n\\tA\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\", null };\r\n    format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"NULL\");\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\tNULL\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\", null };\r\n    format = CSVFormat.POSTGRESQL_TEXT;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\t\\\\N\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n    format = CSVFormat.POSTGRESQL_TEXT;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n    format = CSVFormat.POSTGRESQL_TEXT;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n    s = new String[] { \"\\\\\\r\" };\r\n    format = CSVFormat.POSTGRESQL_TEXT;\r\n    writer = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n        printer.printRecord(s);\r\n    }\r\n    expected = \"\\\\\\\\\\\\r\\n\";\r\n    assertEquals(expected, writer.toString());\r\n    record0 = toFirstRecordValues(expected, format);\r\n    assertArrayEquals(expectNulls(s, format), record0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPostgreSqlNullStringDefaultCsv",
  "sourceCode" : "@Test\r\nvoid testPostgreSqlNullStringDefaultCsv() {\r\n    assertEquals(\"\", CSVFormat.POSTGRESQL_CSV.getNullString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPostgreSqlNullStringDefaultText",
  "sourceCode" : "@Test\r\nvoid testPostgreSqlNullStringDefaultText() {\r\n    assertEquals(\"\\\\N\", CSVFormat.POSTGRESQL_TEXT.getNullString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrint",
  "sourceCode" : "@Test\r\nvoid testPrint() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = CSVFormat.DEFAULT.print(sw)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", \"b\\\\c\");\r\n        assertEquals(\"a,b\\\\c\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintCSVParser",
  "sourceCode" : "@Test\r\nvoid testPrintCSVParser() throws IOException {\r\n    // @formatter:off\r\n    final String code = // 1)\r\n    \"a1,b1\\n\" + // 2)\r\n    \"a2,b2\\n\" + // 3)\r\n    \"a3,b3\\n\" + // 4)\r\n    \"a4,b4\\n\";\r\n    // @formatter:on\r\n    final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n    final CSVFormat format = CSVFormat.DEFAULT;\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = format.print(sw);\r\n        CSVParser parser = CSVParser.parse(code, format)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords(parser);\r\n    }\r\n    try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertFalse(records.isEmpty());\r\n        Utils.compare(\"Fail\", res, records, -1);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintCSVRecord",
  "sourceCode" : "@Test\r\nvoid testPrintCSVRecord() throws IOException {\r\n    // @formatter:off\r\n    final String code = // 1)\r\n    \"a1,b1\\n\" + // 2)\r\n    \"a2,b2\\n\" + // 3)\r\n    \"a3,b3\\n\" + // 4)\r\n    \"a4,b4\\n\";\r\n    // @formatter:on\r\n    final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n    final CSVFormat format = CSVFormat.DEFAULT;\r\n    final StringWriter sw = new StringWriter();\r\n    int row = 0;\r\n    try (CSVPrinter printer = format.print(sw);\r\n        CSVParser parser = CSVParser.parse(code, format)) {\r\n        assertInitialState(printer);\r\n        for (final CSVRecord record : parser) {\r\n            printer.printRecord(record);\r\n            assertEquals(++row, printer.getRecordCount());\r\n        }\r\n        assertEquals(row, printer.getRecordCount());\r\n    }\r\n    try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertFalse(records.isEmpty());\r\n        Utils.compare(\"Fail\", res, records, -1);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintCSVRecords",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(longs = { -1, 0, 3, 4, Long.MAX_VALUE })\r\nvoid testPrintCSVRecords(final long maxRows) throws IOException {\r\n    // @formatter:off\r\n    final String code = // 1)\r\n    \"a1,b1\\n\" + // 2)\r\n    \"a2,b2\\n\" + // 3)\r\n    \"a3,b3\\n\" + // 4)\r\n    \"a4,b4\\n\";\r\n    // @formatter:on\r\n    final String[][] expected = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setMaxRows(maxRows).get();\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = format.print(sw);\r\n        CSVParser parser = CSVParser.parse(code, format)) {\r\n        assertInitialState(printer);\r\n        printer.printRecords(parser.getRecords());\r\n    }\r\n    try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertFalse(records.isEmpty());\r\n        Utils.compare(\"Fail\", expected, records, maxRows);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintCustomNullValues",
  "sourceCode" : "@Test\r\nvoid testPrintCustomNullValues() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"))) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", null, \"b\");\r\n        assertEquals(\"a,NULL,b\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrinter1",
  "sourceCode" : "@Test\r\nvoid testPrinter1() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", \"b\");\r\n        assertEquals(1, printer.getRecordCount());\r\n        assertEquals(\"a,b\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrinter2",
  "sourceCode" : "@Test\r\nvoid testPrinter2() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a,b\", \"b\");\r\n        assertEquals(\"\\\"a,b\\\",b\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrinter3",
  "sourceCode" : "@Test\r\nvoid testPrinter3() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a, b\", \"b \");\r\n        assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrinter4",
  "sourceCode" : "@Test\r\nvoid testPrinter4() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", \"b\\\"c\");\r\n        assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrinter5",
  "sourceCode" : "@Test\r\nvoid testPrinter5() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", \"b\\nc\");\r\n        assertEquals(\"a,\\\"b\\nc\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrinter6",
  "sourceCode" : "@Test\r\nvoid testPrinter6() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", \"b\\r\\nc\");\r\n        assertEquals(\"a,\\\"b\\r\\nc\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrinter7",
  "sourceCode" : "@Test\r\nvoid testPrinter7() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", \"b\\\\c\");\r\n        assertEquals(\"a,b\\\\c\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintNullValues",
  "sourceCode" : "@Test\r\nvoid testPrintNullValues() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n        assertInitialState(printer);\r\n        printer.printRecord(\"a\", null, \"b\");\r\n        assertEquals(\"a,,b\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintOnePositiveInteger",
  "sourceCode" : "@Test\r\nvoid testPrintOnePositiveInteger() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.MINIMAL))) {\r\n        assertInitialState(printer);\r\n        printer.print(Integer.MAX_VALUE);\r\n        assertEquals(String.valueOf(Integer.MAX_VALUE), sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintReaderWithoutQuoteToAppendable",
  "sourceCode" : "/**\r\n * Test to target the use of {@link IOUtils#copy(java.io.Reader, Appendable)} which directly buffers the value from the Reader to the Appendable.\r\n *\r\n * <p>\r\n * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST NOT</em> be a {@link Writer Writer}\r\n * but some other Appendable.\r\n * </p>\r\n *\r\n * @throws IOException Not expected to happen\r\n */\r\n@Test\r\nvoid testPrintReaderWithoutQuoteToAppendable() throws IOException {\r\n    final StringBuilder sb = new StringBuilder();\r\n    final String content = \"testValue\";\r\n    try (CSVPrinter printer = new CSVPrinter(sb, CSVFormat.DEFAULT.withQuote(null))) {\r\n        assertInitialState(printer);\r\n        final StringReader value = new StringReader(content);\r\n        printer.print(value);\r\n    }\r\n    assertEquals(content, sb.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintReaderWithoutQuoteToWriter",
  "sourceCode" : "/**\r\n * Test to target the use of {@link IOUtils#copyLarge(java.io.Reader, Writer)} which directly buffers the value from the Reader to the Writer.\r\n *\r\n * <p>\r\n * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST</em> be a {@link Writer Writer}.\r\n * </p>\r\n *\r\n * @throws IOException Not expected to happen\r\n */\r\n@Test\r\nvoid testPrintReaderWithoutQuoteToWriter() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final String content = \"testValue\";\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n        final StringReader value = new StringReader(content);\r\n        printer.print(value);\r\n    }\r\n    assertEquals(content, sw.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintRecordStream",
  "sourceCode" : "@Test\r\nvoid testPrintRecordStream() throws IOException {\r\n    // @formatter:off\r\n    final String code = // 1)\r\n    \"a1,b1\\n\" + // 2)\r\n    \"a2,b2\\n\" + // 3)\r\n    \"a3,b3\\n\" + // 4)\r\n    \"a4,b4\\n\";\r\n    // @formatter:on\r\n    final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n    final CSVFormat format = CSVFormat.DEFAULT;\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = format.print(sw);\r\n        CSVParser parser = CSVParser.parse(code, format)) {\r\n        long count = 0;\r\n        for (final CSVRecord record : parser) {\r\n            printer.printRecord(record.stream());\r\n            assertEquals(++count, printer.getRecordCount());\r\n        }\r\n    }\r\n    try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n        final List<CSVRecord> records = parser.getRecords();\r\n        assertFalse(records.isEmpty());\r\n        Utils.compare(\"Fail\", res, records, -1);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintRecordsWithCSVRecord",
  "sourceCode" : "@Test\r\nvoid testPrintRecordsWithCSVRecord() throws IOException {\r\n    final String[] values = { \"A\", \"B\", \"C\" };\r\n    final String rowData = StringUtils.join(values, ',');\r\n    final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\r\n    try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(rowData));\r\n        CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\r\n        long count = 0;\r\n        for (final CSVRecord record : parser) {\r\n            printer.printRecord(record);\r\n            assertEquals(++count, printer.getRecordCount());\r\n        }\r\n    }\r\n    assertEquals(6, charArrayWriter.size());\r\n    assertEquals(\"A|B|C\" + CSVFormat.INFORMIX_UNLOAD.getRecordSeparator(), charArrayWriter.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintRecordsWithEmptyVector",
  "sourceCode" : "@Test\r\nvoid testPrintRecordsWithEmptyVector() throws IOException {\r\n    final PrintStream out = System.out;\r\n    try {\r\n        System.setOut(new PrintStream(NullOutputStream.INSTANCE));\r\n        try (CSVPrinter printer = CSVFormat.POSTGRESQL_TEXT.printer()) {\r\n            final Vector<CSVFormatTest.EmptyEnum> vector = new Vector<>();\r\n            final int expectedCapacity = 23;\r\n            vector.setSize(expectedCapacity);\r\n            printer.printRecords(vector);\r\n            assertEquals(expectedCapacity, vector.capacity());\r\n            assertEquals(expectedCapacity, printer.getRecordCount());\r\n        }\r\n    } finally {\r\n        System.setOut(out);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintRecordsWithObjectArray",
  "sourceCode" : "@Test\r\nvoid testPrintRecordsWithObjectArray() throws IOException {\r\n    final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\r\n    final Object[] objectArray = new Object[6];\r\n    try (CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\r\n        final HashSet<BatchUpdateException> hashSet = new HashSet<>();\r\n        objectArray[3] = hashSet;\r\n        printer.printRecords(objectArray);\r\n        assertEquals(objectArray.length, printer.getRecordCount());\r\n    }\r\n    assertEquals(6, charArrayWriter.size());\r\n    assertEquals(\"\\n\\n\\n\\n\\n\\n\", charArrayWriter.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintRecordsWithResultSetOneRow",
  "sourceCode" : "@Test\r\nvoid testPrintRecordsWithResultSetOneRow() throws IOException, SQLException {\r\n    try (CSVPrinter printer = CSVFormat.MYSQL.printer()) {\r\n        try (ResultSet resultSet = new SimpleResultSet()) {\r\n            assertInitialState(printer);\r\n            printer.printRecords(resultSet);\r\n            assertInitialState(printer);\r\n            assertEquals(0, resultSet.getRow());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintToFileWithCharsetUtf16Be",
  "sourceCode" : "@Test\r\nvoid testPrintToFileWithCharsetUtf16Be() throws IOException {\r\n    final File file = createTempFile();\r\n    try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, StandardCharsets.UTF_16BE)) {\r\n        printer.printRecord(\"a\", \"b\\\\c\");\r\n    }\r\n    assertEquals(\"a,b\\\\c\" + RECORD_SEPARATOR, FileUtils.readFileToString(file, StandardCharsets.UTF_16BE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintToFileWithDefaultCharset",
  "sourceCode" : "@Test\r\nvoid testPrintToFileWithDefaultCharset() throws IOException {\r\n    final File file = createTempFile();\r\n    try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\r\n        printer.printRecord(\"a\", \"b\\\\c\");\r\n    }\r\n    assertEquals(\"a,b\\\\c\" + RECORD_SEPARATOR, FileUtils.readFileToString(file, Charset.defaultCharset()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testPrintToPathWithDefaultCharset",
  "sourceCode" : "@Test\r\nvoid testPrintToPathWithDefaultCharset() throws IOException {\r\n    final Path file = createTempPath();\r\n    try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\r\n        printer.printRecord(\"a\", \"b\\\\c\");\r\n    }\r\n    assertEquals(\"a,b\\\\c\" + RECORD_SEPARATOR, new String(Files.readAllBytes(file), Charset.defaultCharset()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testQuoteAll",
  "sourceCode" : "@Test\r\nvoid testQuoteAll() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL))) {\r\n        printer.printRecord(\"a\", \"b\\nc\", \"d\");\r\n        assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testQuoteCommaFirstChar",
  "sourceCode" : "@Test\r\nvoid testQuoteCommaFirstChar() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\r\n        printer.printRecord(\",\");\r\n        assertEquals(\"\\\",\\\"\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testQuoteNonNumeric",
  "sourceCode" : "@Test\r\nvoid testQuoteNonNumeric() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC))) {\r\n        printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\r\n        assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + RECORD_SEPARATOR, sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomDefault",
  "sourceCode" : "@Test\r\nvoid testRandomDefault() throws Exception {\r\n    doRandom(CSVFormat.DEFAULT, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomExcel",
  "sourceCode" : "@Test\r\nvoid testRandomExcel() throws Exception {\r\n    doRandom(CSVFormat.EXCEL, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomMongoDbCsv",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testRandomMongoDbCsv() throws Exception {\r\n    doRandom(CSVFormat.MONGODB_CSV, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomMySql",
  "sourceCode" : "@Test\r\nvoid testRandomMySql() throws Exception {\r\n    doRandom(CSVFormat.MYSQL, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomOracle",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testRandomOracle() throws Exception {\r\n    doRandom(CSVFormat.ORACLE, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomPostgreSqlCsv",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testRandomPostgreSqlCsv() throws Exception {\r\n    doRandom(CSVFormat.POSTGRESQL_CSV, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomPostgreSqlText",
  "sourceCode" : "@Test\r\nvoid testRandomPostgreSqlText() throws Exception {\r\n    doRandom(CSVFormat.POSTGRESQL_TEXT, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomRfc4180",
  "sourceCode" : "@Test\r\nvoid testRandomRfc4180() throws Exception {\r\n    doRandom(CSVFormat.RFC4180, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testRandomTdf",
  "sourceCode" : "@Test\r\nvoid testRandomTdf() throws Exception {\r\n    doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testSingleLineComment",
  "sourceCode" : "@Test\r\nvoid testSingleLineComment() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n        printer.printComment(\"This is a comment\");\r\n        assertEquals(\"# This is a comment\" + RECORD_SEPARATOR, sw.toString());\r\n        assertEquals(0, printer.getRecordCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testSingleQuoteQuoted",
  "sourceCode" : "@Test\r\nvoid testSingleQuoteQuoted() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n        printer.print(\"a'b'c\");\r\n        printer.print(\"xyz\");\r\n        assertEquals(\"'a''b''c',xyz\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testSkipHeaderRecordFalse",
  "sourceCode" : "@Test\r\nvoid testSkipHeaderRecordFalse() throws IOException {\r\n    // functionally identical to testHeader, used to test CSV-153\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false))) {\r\n        printer.printRecord(\"a\", \"b\", \"c\");\r\n        printer.printRecord(\"x\", \"y\", \"z\");\r\n        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testSkipHeaderRecordTrue",
  "sourceCode" : "@Test\r\nvoid testSkipHeaderRecordTrue() throws IOException {\r\n    // functionally identical to testHeaderNotSet, used to test CSV-153\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(true))) {\r\n        printer.printRecord(\"a\", \"b\", \"c\");\r\n        printer.printRecord(\"x\", \"y\", \"z\");\r\n        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testTrailingDelimiterOnTwoColumns",
  "sourceCode" : "@Test\r\nvoid testTrailingDelimiterOnTwoColumns() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter())) {\r\n        printer.printRecord(\"A\", \"B\");\r\n        assertEquals(\"A,B,\\r\\n\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testTrimOffOneColumn",
  "sourceCode" : "@Test\r\nvoid testTrimOffOneColumn() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false))) {\r\n        printer.print(\" A \");\r\n        assertEquals(\"\\\" A \\\"\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testTrimOnOneColumn",
  "sourceCode" : "@Test\r\nvoid testTrimOnOneColumn() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\r\n        printer.print(\" A \");\r\n        assertEquals(\"A\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVPrinterTest.java",
  "methodName" : "testTrimOnTwoColumns",
  "sourceCode" : "@Test\r\nvoid testTrimOnTwoColumns() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\r\n        printer.print(\" A \");\r\n        printer.print(\" B \");\r\n        assertEquals(\"A,B\", sw.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testCSVRecordNULLValues",
  "sourceCode" : "@Test\r\nvoid testCSVRecordNULLValues() throws IOException {\r\n    try (CSVParser parser = CSVParser.parse(\"A,B\\r\\nONE,TWO\", CSVFormat.DEFAULT.withHeader())) {\r\n        final CSVRecord csvRecord = new CSVRecord(parser, null, null, 0L, 0L, 0L);\r\n        assertEquals(0, csvRecord.size());\r\n        assertThrows(IllegalArgumentException.class, () -> csvRecord.get(\"B\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testDuplicateHeaderGet",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeaderGet() throws IOException {\r\n    final String csv = \"A,A,B,B\\n1,2,5,6\\n\";\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader().get();\r\n    try (CSVParser parser = CSVParser.parse(csv, format)) {\r\n        final CSVRecord record = parser.nextRecord();\r\n        assertAll(\"Test that it gets the last instance of a column when there are duplicate headings\", () -> assertEquals(\"2\", record.get(\"A\")), () -> assertEquals(\"6\", record.get(\"B\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testDuplicateHeaderToMap",
  "sourceCode" : "@Test\r\nvoid testDuplicateHeaderToMap() throws IOException {\r\n    final String csv = \"A,A,B,B\\n1,2,5,6\\n\";\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader().get();\r\n    try (CSVParser parser = CSVParser.parse(csv, format)) {\r\n        final CSVRecord record = parser.nextRecord();\r\n        final Map<String, String> map = record.toMap();\r\n        assertAll(\"Test that it gets the last instance of a column when there are duplicate headings\", () -> assertEquals(\"2\", map.get(\"A\")), () -> assertEquals(\"6\", map.get(\"B\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetInt",
  "sourceCode" : "@Test\r\nvoid testGetInt() {\r\n    assertEquals(values[0], record.get(0));\r\n    assertEquals(values[1], record.get(1));\r\n    assertEquals(values[2], record.get(2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetNullEnum",
  "sourceCode" : "@Test\r\nvoid testGetNullEnum() {\r\n    assertThrows(IllegalArgumentException.class, () -> recordWithHeader.get((Enum<?>) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetString",
  "sourceCode" : "@Test\r\nvoid testGetString() {\r\n    assertEquals(values[0], recordWithHeader.get(EnumHeader.FIRST.name()));\r\n    assertEquals(values[1], recordWithHeader.get(EnumHeader.SECOND.name()));\r\n    assertEquals(values[2], recordWithHeader.get(EnumHeader.THIRD.name()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetStringInconsistentRecord",
  "sourceCode" : "@Test\r\nvoid testGetStringInconsistentRecord() {\r\n    headerMap.put(\"fourth\", Integer.valueOf(4));\r\n    assertThrows(IllegalArgumentException.class, () -> recordWithHeader.get(\"fourth\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetStringNoHeader",
  "sourceCode" : "@Test\r\nvoid testGetStringNoHeader() {\r\n    assertThrows(IllegalStateException.class, () -> record.get(\"first\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetUnmappedEnum",
  "sourceCode" : "@Test\r\nvoid testGetUnmappedEnum() {\r\n    assertThrows(IllegalArgumentException.class, () -> recordWithHeader.get(EnumFixture.UNKNOWN_COLUMN));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetUnmappedName",
  "sourceCode" : "@Test\r\nvoid testGetUnmappedName() {\r\n    assertThrows(IllegalArgumentException.class, () -> assertNull(recordWithHeader.get(\"fourth\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetUnmappedNegativeInt",
  "sourceCode" : "@Test\r\nvoid testGetUnmappedNegativeInt() {\r\n    assertThrows(ArrayIndexOutOfBoundsException.class, () -> recordWithHeader.get(Integer.MIN_VALUE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetUnmappedPositiveInt",
  "sourceCode" : "@Test\r\nvoid testGetUnmappedPositiveInt() {\r\n    assertThrows(ArrayIndexOutOfBoundsException.class, () -> recordWithHeader.get(Integer.MAX_VALUE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testGetWithEnum",
  "sourceCode" : "@Test\r\nvoid testGetWithEnum() {\r\n    assertEquals(recordWithHeader.get(\"FIRST\"), recordWithHeader.get(EnumHeader.FIRST));\r\n    assertEquals(recordWithHeader.get(\"SECOND\"), recordWithHeader.get(EnumHeader.SECOND));\r\n    assertThrows(IllegalArgumentException.class, () -> recordWithHeader.get(EnumFixture.UNKNOWN_COLUMN));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testIsConsistent",
  "sourceCode" : "@Test\r\nvoid testIsConsistent() {\r\n    assertTrue(record.isConsistent());\r\n    assertTrue(recordWithHeader.isConsistent());\r\n    final Map<String, Integer> map = recordWithHeader.getParser().getHeaderMap();\r\n    map.put(\"fourth\", Integer.valueOf(4));\r\n    // We are working on a copy of the map, so the record should still be OK.\r\n    assertTrue(recordWithHeader.isConsistent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testIsInconsistent",
  "sourceCode" : "@Test\r\nvoid testIsInconsistent() throws IOException {\r\n    final String[] headers = { \"first\", \"second\", \"third\" };\r\n    final String rowData = StringUtils.join(values, ',');\r\n    try (CSVParser parser = CSVFormat.DEFAULT.withHeader(headers).parse(new StringReader(rowData))) {\r\n        final Map<String, Integer> map = parser.getHeaderMapRaw();\r\n        final CSVRecord record1 = parser.iterator().next();\r\n        map.put(\"fourth\", Integer.valueOf(4));\r\n        assertFalse(record1.isConsistent());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testIsMapped",
  "sourceCode" : "@Test\r\nvoid testIsMapped() {\r\n    assertFalse(record.isMapped(\"first\"));\r\n    assertTrue(recordWithHeader.isMapped(EnumHeader.FIRST.name()));\r\n    assertFalse(recordWithHeader.isMapped(\"fourth\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testIsSetInt",
  "sourceCode" : "@Test\r\nvoid testIsSetInt() {\r\n    assertFalse(record.isSet(-1));\r\n    assertTrue(record.isSet(0));\r\n    assertTrue(record.isSet(2));\r\n    assertFalse(record.isSet(3));\r\n    assertTrue(recordWithHeader.isSet(1));\r\n    assertFalse(recordWithHeader.isSet(1000));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testIsSetString",
  "sourceCode" : "@Test\r\nvoid testIsSetString() {\r\n    assertFalse(record.isSet(\"first\"));\r\n    assertTrue(recordWithHeader.isSet(EnumHeader.FIRST.name()));\r\n    assertFalse(recordWithHeader.isSet(\"DOES NOT EXIST\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testIterator",
  "sourceCode" : "@Test\r\nvoid testIterator() {\r\n    int i = 0;\r\n    for (final String value : record) {\r\n        assertEquals(values[i], value);\r\n        i++;\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testPutInMap",
  "sourceCode" : "@Test\r\nvoid testPutInMap() {\r\n    final Map<String, String> map = new ConcurrentHashMap<>();\r\n    this.recordWithHeader.putIn(map);\r\n    validateMap(map, false);\r\n    // Test that we can compile with assignment to the same map as the param.\r\n    final TreeMap<String, String> map2 = recordWithHeader.putIn(new TreeMap<>());\r\n    validateMap(map2, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testRemoveAndAddColumns",
  "sourceCode" : "@Test\r\nvoid testRemoveAndAddColumns() throws IOException {\r\n    // do:\r\n    try (CSVPrinter printer = new CSVPrinter(new StringBuilder(), CSVFormat.DEFAULT)) {\r\n        final Map<String, String> map = recordWithHeader.toMap();\r\n        map.remove(\"OldColumn\");\r\n        map.put(\"ZColumn\", \"NewValue\");\r\n        // check:\r\n        final ArrayList<String> list = new ArrayList<>(map.values());\r\n        list.sort(null);\r\n        printer.printRecord(list);\r\n        assertEquals(\"A,B,C,NewValue\" + CSVFormat.DEFAULT.getRecordSeparator(), printer.getOut().toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testSerialization",
  "sourceCode" : "@Test\r\nvoid testSerialization() throws IOException, ClassNotFoundException {\r\n    final CSVRecord shortRec;\r\n    try (CSVParser parser = CSVParser.parse(\"A,B\\n#my comment\\nOne,Two\", CSVFormat.DEFAULT.withHeader().withCommentMarker('#'))) {\r\n        shortRec = parser.iterator().next();\r\n    }\r\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(out)) {\r\n        oos.writeObject(shortRec);\r\n    }\r\n    final ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());\r\n    try (ObjectInputStream ois = new ObjectInputStream(in)) {\r\n        final Object object = ois.readObject();\r\n        assertInstanceOf(CSVRecord.class, object);\r\n        final CSVRecord rec = (CSVRecord) object;\r\n        assertEquals(1L, rec.getRecordNumber());\r\n        assertEquals(\"One\", rec.get(0));\r\n        assertEquals(\"Two\", rec.get(1));\r\n        assertEquals(2, rec.size());\r\n        assertEquals(shortRec.getCharacterPosition(), rec.getCharacterPosition());\r\n        assertEquals(\"my comment\", rec.getComment());\r\n        // The parser is not serialized\r\n        assertNull(rec.getParser());\r\n        // Check all header map functionality is absent\r\n        assertTrue(rec.isConsistent());\r\n        assertFalse(rec.isMapped(\"A\"));\r\n        assertFalse(rec.isSet(\"A\"));\r\n        assertEquals(0, rec.toMap().size());\r\n        // This will throw\r\n        assertThrows(IllegalStateException.class, () -> rec.get(\"A\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testStream",
  "sourceCode" : "@Test\r\nvoid testStream() {\r\n    final AtomicInteger i = new AtomicInteger();\r\n    record.stream().forEach(value -> {\r\n        assertEquals(values[i.get()], value);\r\n        i.incrementAndGet();\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testToListAdd",
  "sourceCode" : "@Test\r\nvoid testToListAdd() {\r\n    final String[] expected = values.clone();\r\n    final List<String> list = record.toList();\r\n    list.add(\"Last\");\r\n    assertEquals(\"Last\", list.get(list.size() - 1));\r\n    assertEquals(list.size(), values.length + 1);\r\n    assertArrayEquals(expected, values);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testToListFor",
  "sourceCode" : "@Test\r\nvoid testToListFor() {\r\n    int i = 0;\r\n    for (final String value : record.toList()) {\r\n        assertEquals(values[i], value);\r\n        i++;\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testToListForEach",
  "sourceCode" : "@Test\r\nvoid testToListForEach() {\r\n    final AtomicInteger i = new AtomicInteger();\r\n    record.toList().forEach(e -> {\r\n        assertEquals(values[i.getAndIncrement()], e);\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testToListSet",
  "sourceCode" : "@Test\r\nvoid testToListSet() {\r\n    final String[] expected = values.clone();\r\n    final List<String> list = record.toList();\r\n    list.set(list.size() - 1, \"Last\");\r\n    assertEquals(\"Last\", list.get(list.size() - 1));\r\n    assertEquals(list.size(), values.length);\r\n    assertArrayEquals(expected, values);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testToMap",
  "sourceCode" : "@Test\r\nvoid testToMap() {\r\n    final Map<String, String> map = this.recordWithHeader.toMap();\r\n    validateMap(map, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testToMapWithNoHeader",
  "sourceCode" : "@Test\r\nvoid testToMapWithNoHeader() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"a,b\", CSVFormat.newFormat(','))) {\r\n        final CSVRecord shortRec = parser.iterator().next();\r\n        final Map<String, String> map = shortRec.toMap();\r\n        assertNotNull(map, \"Map is not null.\");\r\n        assertTrue(map.isEmpty(), \"Map is empty.\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testToMapWithShortRecord",
  "sourceCode" : "@Test\r\nvoid testToMapWithShortRecord() throws Exception {\r\n    try (CSVParser parser = CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n        final CSVRecord shortRec = parser.iterator().next();\r\n        shortRec.toMap();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\CSVRecordTest.java",
  "methodName" : "testToString",
  "sourceCode" : "@Test\r\nvoid testToString() {\r\n    assertNotNull(recordWithHeader.toString());\r\n    assertTrue(recordWithHeader.toString().contains(\"comment=\"));\r\n    assertTrue(recordWithHeader.toString().contains(\"recordNumber=\"));\r\n    assertTrue(recordWithHeader.toString().contains(\"values=\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\ExtendedBufferedReaderTest.java",
  "methodName" : "testEmptyInput",
  "sourceCode" : "@Test\r\nvoid testEmptyInput() throws Exception {\r\n    try (ExtendedBufferedReader br = createBufferedReader(\"\")) {\r\n        assertEquals(EOF, br.read());\r\n        assertEquals(EOF, br.peek());\r\n        assertEquals(EOF, br.getLastChar());\r\n        assertNull(br.readLine());\r\n        assertEquals(0, br.read(new char[10], 0, 0));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\ExtendedBufferedReaderTest.java",
  "methodName" : "testReadChar",
  "sourceCode" : "/*\r\n     * Test to illustrate https://issues.apache.org/jira/browse/CSV-75\r\n     */\r\n@Test\r\nvoid testReadChar() throws Exception {\r\n    final String test = \"a\" + LF + \"b\" + CR + \"c\" + LF + LF + \"d\" + CR + CR + \"e\" + LFCR + \"f \" + CRLF;\r\n    // EOL eol EOL EOL eol eol EOL+CR EOL\r\n    final int eolCount = 9;\r\n    try (ExtendedBufferedReader br = createBufferedReader(test)) {\r\n        assertEquals(0, br.getLineNumber());\r\n        int lineCount = 0;\r\n        while (br.readLine() != null) {\r\n            // consume all\r\n            lineCount++;\r\n        }\r\n        assertEquals(eolCount, br.getLineNumber());\r\n        assertEquals(lineCount, br.getLineNumber());\r\n    }\r\n    try (ExtendedBufferedReader br = createBufferedReader(test)) {\r\n        assertEquals(0, br.getLineNumber());\r\n        int readCount = 0;\r\n        while (br.read() != EOF) {\r\n            // consume all\r\n            readCount++;\r\n        }\r\n        assertEquals(eolCount, br.getLineNumber());\r\n        assertEquals(readCount, test.length());\r\n    }\r\n    try (ExtendedBufferedReader br = createBufferedReader(test)) {\r\n        assertEquals(0, br.getLineNumber());\r\n        final char[] buff = new char[10];\r\n        while (br.read(buff, 0, 3) != EOF) {\r\n            // consume all\r\n        }\r\n        assertEquals(eolCount, br.getLineNumber());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\ExtendedBufferedReaderTest.java",
  "methodName" : "testReadingInDifferentBuffer",
  "sourceCode" : "@Test\r\nvoid testReadingInDifferentBuffer() throws Exception {\r\n    final char[] tmp1 = new char[2];\r\n    final char[] tmp2 = new char[4];\r\n    try (ExtendedBufferedReader reader = createBufferedReader(\"1\\r\\n2\\r\\n\")) {\r\n        reader.read(tmp1, 0, 2);\r\n        reader.read(tmp2, 2, 2);\r\n        assertEquals(2, reader.getLineNumber());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\ExtendedBufferedReaderTest.java",
  "methodName" : "testReadLine",
  "sourceCode" : "@Test\r\nvoid testReadLine() throws Exception {\r\n    try (ExtendedBufferedReader br = createBufferedReader(\"\")) {\r\n        assertNull(br.readLine());\r\n    }\r\n    try (ExtendedBufferedReader br = createBufferedReader(\"\\n\")) {\r\n        assertEquals(\"\", br.readLine());\r\n        assertNull(br.readLine());\r\n    }\r\n    try (ExtendedBufferedReader br = createBufferedReader(\"foo\\n\\nhello\")) {\r\n        assertEquals(0, br.getLineNumber());\r\n        assertEquals(\"foo\", br.readLine());\r\n        assertEquals(1, br.getLineNumber());\r\n        assertEquals(\"\", br.readLine());\r\n        assertEquals(2, br.getLineNumber());\r\n        assertEquals(\"hello\", br.readLine());\r\n        assertEquals(3, br.getLineNumber());\r\n        assertNull(br.readLine());\r\n        assertEquals(3, br.getLineNumber());\r\n    }\r\n    try (ExtendedBufferedReader br = createBufferedReader(\"foo\\n\\nhello\")) {\r\n        assertEquals('f', br.read());\r\n        assertEquals('o', br.peek());\r\n        assertEquals(\"oo\", br.readLine());\r\n        assertEquals(1, br.getLineNumber());\r\n        assertEquals('\\n', br.peek());\r\n        assertEquals(\"\", br.readLine());\r\n        assertEquals(2, br.getLineNumber());\r\n        assertEquals('h', br.peek());\r\n        assertEquals(\"hello\", br.readLine());\r\n        assertNull(br.readLine());\r\n        assertEquals(3, br.getLineNumber());\r\n    }\r\n    try (ExtendedBufferedReader br = createBufferedReader(\"foo\\rbaar\\r\\nfoo\")) {\r\n        assertEquals(\"foo\", br.readLine());\r\n        assertEquals('b', br.peek());\r\n        assertEquals(\"baar\", br.readLine());\r\n        assertEquals('f', br.peek());\r\n        assertEquals(\"foo\", br.readLine());\r\n        assertNull(br.readLine());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\ExtendedBufferedReaderTest.java",
  "methodName" : "testReadLookahead1",
  "sourceCode" : "@Test\r\nvoid testReadLookahead1() throws Exception {\r\n    try (ExtendedBufferedReader br = createBufferedReader(\"1\\n2\\r3\\n\")) {\r\n        assertEquals(0, br.getLineNumber());\r\n        assertEquals('1', br.peek());\r\n        assertEquals(UNDEFINED, br.getLastChar());\r\n        assertEquals(0, br.getLineNumber());\r\n        // Start line 1\r\n        assertEquals('1', br.read());\r\n        assertEquals('1', br.getLastChar());\r\n        assertEquals(1, br.getLineNumber());\r\n        assertEquals('\\n', br.peek());\r\n        assertEquals(1, br.getLineNumber());\r\n        assertEquals('1', br.getLastChar());\r\n        assertEquals('\\n', br.read());\r\n        assertEquals(1, br.getLineNumber());\r\n        assertEquals('\\n', br.getLastChar());\r\n        assertEquals(1, br.getLineNumber());\r\n        assertEquals('2', br.peek());\r\n        assertEquals(1, br.getLineNumber());\r\n        assertEquals('\\n', br.getLastChar());\r\n        assertEquals(1, br.getLineNumber());\r\n        // Start line 2\r\n        assertEquals('2', br.read());\r\n        assertEquals(2, br.getLineNumber());\r\n        assertEquals('2', br.getLastChar());\r\n        assertEquals('\\r', br.peek());\r\n        assertEquals(2, br.getLineNumber());\r\n        assertEquals('2', br.getLastChar());\r\n        assertEquals('\\r', br.read());\r\n        assertEquals('\\r', br.getLastChar());\r\n        assertEquals(2, br.getLineNumber());\r\n        assertEquals('3', br.peek());\r\n        assertEquals('\\r', br.getLastChar());\r\n        // Start line 3\r\n        assertEquals('3', br.read());\r\n        assertEquals('3', br.getLastChar());\r\n        assertEquals(3, br.getLineNumber());\r\n        assertEquals('\\n', br.peek());\r\n        assertEquals(3, br.getLineNumber());\r\n        assertEquals('3', br.getLastChar());\r\n        assertEquals('\\n', br.read());\r\n        assertEquals(3, br.getLineNumber());\r\n        assertEquals('\\n', br.getLastChar());\r\n        assertEquals(3, br.getLineNumber());\r\n        assertEquals(EOF, br.peek());\r\n        assertEquals('\\n', br.getLastChar());\r\n        assertEquals(EOF, br.read());\r\n        assertEquals(EOF, br.getLastChar());\r\n        assertEquals(EOF, br.read());\r\n        assertEquals(EOF, br.peek());\r\n        assertEquals(3, br.getLineNumber());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\ExtendedBufferedReaderTest.java",
  "methodName" : "testReadLookahead2",
  "sourceCode" : "@Test\r\nvoid testReadLookahead2() throws Exception {\r\n    final char[] ref = new char[5];\r\n    final char[] res = new char[5];\r\n    try (ExtendedBufferedReader br = createBufferedReader(\"abcdefg\")) {\r\n        ref[0] = 'a';\r\n        ref[1] = 'b';\r\n        ref[2] = 'c';\r\n        assertEquals(3, br.read(res, 0, 3));\r\n        assertArrayEquals(ref, res);\r\n        assertEquals('c', br.getLastChar());\r\n        assertEquals('d', br.peek());\r\n        ref[4] = 'd';\r\n        assertEquals(1, br.read(res, 4, 1));\r\n        assertArrayEquals(ref, res);\r\n        assertEquals('d', br.getLastChar());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv148Test.java",
  "methodName" : "testWithIgnoreSurroundingSpacesEmpty",
  "sourceCode" : "@Test\r\nvoid testWithIgnoreSurroundingSpacesEmpty() {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setQuoteMode(QuoteMode.ALL).setIgnoreSurroundingSpaces(true).get();\r\n    // @formatter:on\r\n    assertEquals(\"\\\"\\\",\\\" \\\",\\\" Single space on the left\\\",\\\"Single space on the right \\\",\" + \"\\\" Single spaces on both sides \\\",\\\"   Multiple spaces on the left\\\",\" + \"\\\"Multiple spaces on the right   \\\",\\\"  Multiple spaces on both sides     \\\"\", format.format(\"\", \" \", \" Single space on the left\", \"Single space on the right \", \" Single spaces on both sides \", \"   Multiple spaces on the left\", \"Multiple spaces on the right   \", \"  Multiple spaces on both sides     \"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv148Test.java",
  "methodName" : "testWithTrimEmpty",
  "sourceCode" : "/**\r\n * The difference between withTrim()and withIgnoreSurroundingSpace() difference: withTrim() can remove the leading and trailing spaces and newlines in\r\n * quotation marks, while withIgnoreSurroundingSpace() cannot The same point: you can remove the leading and trailing spaces, tabs and other symbols.\r\n */\r\n@Test\r\nvoid testWithTrimEmpty() {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setQuoteMode(QuoteMode.ALL).setTrim(true).get();\r\n    // @formatter:on\r\n    assertEquals(\"\\\"\\\",\\\"\\\",\\\"Single space on the left\\\",\\\"Single space on the right\\\",\\\"Single spaces on both sides\\\",\\\"Multiple spaces on the left\\\",\" + \"\\\"Multiple spaces on the right\\\",\\\"Multiple spaces on both sides\\\"\", format.format(\"\", \" \", \" Single space on the left\", \"Single space on the right \", \" Single spaces on both sides \", \"   Multiple spaces on the left\", \"Multiple spaces on the right   \", \"  Multiple spaces on both sides     \"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv149Test.java",
  "methodName" : "testJiraCsv149EndWithEOL",
  "sourceCode" : "@Test\r\nvoid testJiraCsv149EndWithEOL() throws IOException {\r\n    testJiraCsv149EndWithEolAtEof(true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv149Test.java",
  "methodName" : "testJiraCsv149EndWithoutEOL",
  "sourceCode" : "@Test\r\nvoid testJiraCsv149EndWithoutEOL() throws IOException {\r\n    testJiraCsv149EndWithEolAtEof(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv150Test.java",
  "methodName" : "testDisableComment",
  "sourceCode" : "@Test\r\nvoid testDisableComment() throws IOException {\r\n    final StringReader stringReader = new StringReader(\"\\\"66\\u2441\\\",,\\\"\\\",\\\"DeutscheBK\\ufffe\\\",\\\"000\\\"\\r\\n\");\r\n    testDisable(CSVFormat.DEFAULT.builder().setCommentMarker(null).get(), stringReader);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv150Test.java",
  "methodName" : "testDisableEncapsulation",
  "sourceCode" : "@Test\r\nvoid testDisableEncapsulation() throws IOException {\r\n    final StringReader stringReader = new StringReader(\"66\\u2441,,\\\"\\\",\\ufffeDeutscheBK,\\\"000\\\"\\r\\n\");\r\n    testDisable(CSVFormat.DEFAULT.builder().setQuote(null).get(), stringReader);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv150Test.java",
  "methodName" : "testDisableEscaping",
  "sourceCode" : "@Test\r\nvoid testDisableEscaping() throws IOException {\r\n    final StringReader stringReader = new StringReader(\"\\\"66\\u2441\\\",,\\\"\\\",\\\"DeutscheBK\\ufffe\\\",\\\"000\\\"\\r\\n\");\r\n    testDisable(CSVFormat.DEFAULT.builder().setEscape(null).get(), stringReader);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv154Test.java",
  "methodName" : "testJiraCsv154_withCommentMarker",
  "sourceCode" : "@Test\r\nvoid testJiraCsv154_withCommentMarker() throws IOException {\r\n    final String comment = \"This is a header comment\";\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setHeader(\"H1\", \"H2\").setCommentMarker('#').setHeaderComments(comment).get();\r\n    // @formatter:on\r\n    final StringBuilder out = new StringBuilder();\r\n    try (CSVPrinter printer = format.print(out)) {\r\n        printer.print(\"A\");\r\n        printer.print(\"B\");\r\n    }\r\n    final String s = out.toString();\r\n    assertTrue(s.contains(comment), s);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv154Test.java",
  "methodName" : "testJiraCsv154_withHeaderComments",
  "sourceCode" : "@Test\r\nvoid testJiraCsv154_withHeaderComments() throws IOException {\r\n    final String comment = \"This is a header comment\";\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setHeader(\"H1\", \"H2\").setHeaderComments(comment).setCommentMarker('#').get();\r\n    // @formatter:on\r\n    final StringBuilder out = new StringBuilder();\r\n    try (CSVPrinter printer = format.print(out)) {\r\n        printer.print(\"A\");\r\n        printer.print(\"B\");\r\n    }\r\n    final String s = out.toString();\r\n    assertTrue(s.contains(comment), s);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv167Test.java",
  "methodName" : "testParse",
  "sourceCode" : "@Test\r\nvoid testParse() throws IOException {\r\n    int totcomment = 0;\r\n    int totrecs = 0;\r\n    try (Reader reader = getTestReader();\r\n        BufferedReader br = new BufferedReader(reader)) {\r\n        String s = null;\r\n        boolean lastWasComment = false;\r\n        while ((s = br.readLine()) != null) {\r\n            if (s.startsWith(\"#\")) {\r\n                if (!lastWasComment) {\r\n                    // comments are merged\r\n                    totcomment++;\r\n                }\r\n                lastWasComment = true;\r\n            } else {\r\n                totrecs++;\r\n                lastWasComment = false;\r\n            }\r\n        }\r\n    }\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().// @formatter:off\r\n    setAllowMissingColumnNames(false).setCommentMarker('#').setDelimiter(',').setEscape('\\\\').setHeader(\"author\", \"title\", \"publishDate\").setHeaderComments(\"headerComment\").setNullString(\"NULL\").setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setRecordSeparator('\\n').setSkipHeaderRecord(false).get();\r\n    // @formatter:on\r\n    int comments = 0;\r\n    int records = 0;\r\n    try (Reader reader = getTestReader();\r\n        CSVParser parser = format.parse(reader)) {\r\n        for (final CSVRecord csvRecord : parser) {\r\n            records++;\r\n            if (csvRecord.hasComment()) {\r\n                comments++;\r\n            }\r\n        }\r\n    }\r\n    // Comment lines are concatenated, in this example 4 lines become 2 comments.\r\n    assertEquals(totcomment, comments);\r\n    // records includes the header\r\n    assertEquals(totrecs, records);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv198Test.java",
  "methodName" : "test",
  "sourceCode" : "// @formatter:on\r\n@Test\r\nvoid test() throws UnsupportedEncodingException, IOException {\r\n    final InputStream pointsOfReference = getClass().getResourceAsStream(\"/org/apache/commons/csv/CSV-198/optd_por_public.csv\");\r\n    assertNotNull(pointsOfReference);\r\n    try (@SuppressWarnings(\"resource\") CSVParser parser = CSV_FORMAT.parse(new InputStreamReader(pointsOfReference, StandardCharsets.UTF_8))) {\r\n        parser.forEach(record -> assertNotNull(record.get(\"location_type\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv203Test.java",
  "methodName" : "testQuoteModeAll",
  "sourceCode" : "@Test\r\nvoid testQuoteModeAll() throws Exception {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setNullString(\"N/A\").setIgnoreSurroundingSpaces(true).setQuoteMode(QuoteMode.ALL).get();\r\n    // @formatter:on\r\n    final StringBuilder buffer = new StringBuilder();\r\n    try (CSVPrinter printer = new CSVPrinter(buffer, format)) {\r\n        printer.printRecord(null, \"Hello\", null, \"World\");\r\n    }\r\n    assertEquals(\"\\\"N/A\\\",\\\"Hello\\\",\\\"N/A\\\",\\\"World\\\"\\r\\n\", buffer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv203Test.java",
  "methodName" : "testQuoteModeAllNonNull",
  "sourceCode" : "@Test\r\nvoid testQuoteModeAllNonNull() throws Exception {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setNullString(\"N/A\").setIgnoreSurroundingSpaces(true).setQuoteMode(QuoteMode.ALL_NON_NULL).get();\r\n    // @formatter:on\r\n    final StringBuilder buffer = new StringBuilder();\r\n    try (CSVPrinter printer = new CSVPrinter(buffer, format)) {\r\n        printer.printRecord(null, \"Hello\", null, \"World\");\r\n    }\r\n    assertEquals(\"N/A,\\\"Hello\\\",N/A,\\\"World\\\"\\r\\n\", buffer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv203Test.java",
  "methodName" : "testQuoteModeMinimal",
  "sourceCode" : "@Test\r\nvoid testQuoteModeMinimal() throws Exception {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setNullString(\"N/A\").setIgnoreSurroundingSpaces(true).setQuoteMode(QuoteMode.MINIMAL).get();\r\n    // @formatter:on\r\n    final StringBuilder buffer = new StringBuilder();\r\n    try (CSVPrinter printer = new CSVPrinter(buffer, format)) {\r\n        printer.printRecord(null, \"Hello\", null, \"World\");\r\n    }\r\n    assertEquals(\"N/A,Hello,N/A,World\\r\\n\", buffer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv203Test.java",
  "methodName" : "testQuoteModeNonNumeric",
  "sourceCode" : "@Test\r\nvoid testQuoteModeNonNumeric() throws Exception {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setNullString(\"N/A\").setIgnoreSurroundingSpaces(true).setQuoteMode(QuoteMode.NON_NUMERIC).get();\r\n    // @formatter:on\r\n    final StringBuilder buffer = new StringBuilder();\r\n    try (CSVPrinter printer = new CSVPrinter(buffer, format)) {\r\n        printer.printRecord(null, \"Hello\", null, \"World\");\r\n    }\r\n    assertEquals(\"N/A,\\\"Hello\\\",N/A,\\\"World\\\"\\r\\n\", buffer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv203Test.java",
  "methodName" : "testWithEmptyValues",
  "sourceCode" : "@Test\r\nvoid testWithEmptyValues() throws Exception {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setNullString(\"N/A\").setIgnoreSurroundingSpaces(true).setQuoteMode(QuoteMode.ALL).get();\r\n    // @formatter:on\r\n    final StringBuilder buffer = new StringBuilder();\r\n    try (CSVPrinter printer = new CSVPrinter(buffer, format)) {\r\n        printer.printRecord(\"\", \"Hello\", \"\", \"World\");\r\n        // printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\r\n    }\r\n    assertEquals(\"\\\"\\\",\\\"Hello\\\",\\\"\\\",\\\"World\\\"\\r\\n\", buffer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv203Test.java",
  "methodName" : "testWithoutNullString",
  "sourceCode" : "@Test\r\nvoid testWithoutNullString() throws Exception {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().//.setNullString(\"N/A\")\r\n    setIgnoreSurroundingSpaces(true).setQuoteMode(QuoteMode.ALL).get();\r\n    // @formatter:on\r\n    final StringBuilder buffer = new StringBuilder();\r\n    try (CSVPrinter printer = new CSVPrinter(buffer, format)) {\r\n        printer.printRecord(null, \"Hello\", null, \"World\");\r\n    }\r\n    assertEquals(\",\\\"Hello\\\",,\\\"World\\\"\\r\\n\", buffer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv203Test.java",
  "methodName" : "testWithoutQuoteMode",
  "sourceCode" : "@Test\r\nvoid testWithoutQuoteMode() throws Exception {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.EXCEL.builder().setNullString(\"N/A\").setIgnoreSurroundingSpaces(true).get();\r\n    // @formatter:on\r\n    final StringBuilder buffer = new StringBuilder();\r\n    try (CSVPrinter printer = new CSVPrinter(buffer, format)) {\r\n        printer.printRecord(null, \"Hello\", null, \"World\");\r\n    }\r\n    assertEquals(\"N/A,Hello,N/A,World\\r\\n\", buffer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv206Test.java",
  "methodName" : "testJiraCsv206MultipleCharacterDelimiter",
  "sourceCode" : "@Test\r\nvoid testJiraCsv206MultipleCharacterDelimiter() throws IOException {\r\n    // Read with multiple character delimiter\r\n    final String source = \"FirstName[|]LastName[|]Address\\r\\nJohn[|]Smith[|]123 Main St.\";\r\n    final StringReader reader = new StringReader(source);\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").get();\r\n    CSVRecord record = null;\r\n    try (CSVParser csvParser = CSVParser.builder().setReader(reader).setFormat(format).get()) {\r\n        final Iterator<CSVRecord> iterator = csvParser.iterator();\r\n        record = iterator.next();\r\n        assertEquals(\"FirstName\", record.get(0));\r\n        assertEquals(\"LastName\", record.get(1));\r\n        assertEquals(\"Address\", record.get(2));\r\n        record = iterator.next();\r\n        assertEquals(\"John\", record.get(0));\r\n        assertEquals(\"Smith\", record.get(1));\r\n        assertEquals(\"123 Main St.\", record.get(2));\r\n    }\r\n    // Write with multiple character delimiter\r\n    // @formatter:off\r\n    final String outString = \"# Change delimiter to [I]\\r\\n\" + \"first name[I]last name[I]address\\r\\n\" + \"John[I]Smith[I]123 Main St.\";\r\n    // @formatter:on\r\n    final String comment = \"Change delimiter to [I]\";\r\n    // @formatter:off\r\n    final CSVFormat formatExcel = CSVFormat.EXCEL.builder().setDelimiter(\"[I]\").setHeader(\"first name\", \"last name\", \"address\").setCommentMarker('#').setHeaderComments(comment).get();\r\n    // @formatter:on\r\n    final StringBuilder out = new StringBuilder();\r\n    try (CSVPrinter printer = formatExcel.print(out)) {\r\n        printer.print(record.get(0));\r\n        printer.print(record.get(1));\r\n        printer.print(record.get(2));\r\n    }\r\n    final String s = out.toString();\r\n    assertEquals(outString, s);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv211Test.java",
  "methodName" : "testJiraCsv211Format",
  "sourceCode" : "@Test\r\nvoid testJiraCsv211Format() throws IOException {\r\n    // @formatter:off\r\n    final CSVFormat printFormat = CSVFormat.DEFAULT.builder().setDelimiter('\\t').setHeader(\"ID\", \"Name\", \"Country\", \"Age\").get();\r\n    // @formatter:on\r\n    final String formatted = printFormat.format(\"1\", \"Jane Doe\", \"USA\", \"\");\r\n    assertEquals(\"ID\\tName\\tCountry\\tAge\\r\\n1\\tJane Doe\\tUSA\\t\", formatted);\r\n    final CSVFormat parseFormat = CSVFormat.DEFAULT.builder().setDelimiter('\\t').setHeader().setSkipHeaderRecord(true).get();\r\n    try (CSVParser parser = parseFormat.parse(new StringReader(formatted))) {\r\n        parser.forEach(record -> {\r\n            assertEquals(\"1\", record.get(0));\r\n            assertEquals(\"Jane Doe\", record.get(1));\r\n            assertEquals(\"USA\", record.get(2));\r\n            assertEquals(\"\", record.get(3));\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv213Test.java",
  "methodName" : "test",
  "sourceCode" : "@Test\r\nvoid test() {\r\n    createEndChannel(new File(\"src/test/resources/org/apache/commons/csv/CSV-213/999751170.patch.csv\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv247Test.java",
  "methodName" : "testHeadersMissingOneColumnWhenAllowingMissingColumnNames",
  "sourceCode" : "@Test\r\nvoid testHeadersMissingOneColumnWhenAllowingMissingColumnNames() throws Exception {\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader().setAllowMissingColumnNames(true).get();\r\n    assertTrue(format.getAllowMissingColumnNames(), \"We should allow missing column names\");\r\n    final Reader in = new StringReader(\"a,,c,d,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n    try (CSVParser parser = format.parse(in)) {\r\n        assertEquals(Arrays.asList(\"a\", \"\", \"c\", \"d\", \"e\"), parser.getHeaderNames());\r\n        final Iterator<CSVRecord> iterator = parser.iterator();\r\n        CSVRecord record = iterator.next();\r\n        assertEquals(\"1\", record.get(0));\r\n        assertEquals(\"2\", record.get(1));\r\n        assertEquals(\"3\", record.get(2));\r\n        assertEquals(\"4\", record.get(3));\r\n        assertEquals(\"5\", record.get(4));\r\n        record = iterator.next();\r\n        assertEquals(\"v\", record.get(0));\r\n        assertEquals(\"w\", record.get(1));\r\n        assertEquals(\"x\", record.get(2));\r\n        assertEquals(\"y\", record.get(3));\r\n        assertEquals(\"z\", record.get(4));\r\n        assertFalse(iterator.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv247Test.java",
  "methodName" : "testHeadersMissingThrowsWhenNotAllowingMissingColumnNames",
  "sourceCode" : "@Test\r\nvoid testHeadersMissingThrowsWhenNotAllowingMissingColumnNames() {\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader().get();\r\n    assertFalse(format.getAllowMissingColumnNames(), \"By default we should not allow missing column names\");\r\n    assertThrows(IllegalArgumentException.class, () -> {\r\n        try (Reader reader = new StringReader(\"a,,c,d,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n            CSVParser parser = format.parse(reader)) {\r\n            // should fail\r\n        }\r\n    }, \"1 missing column header is not allowed\");\r\n    assertThrows(IllegalArgumentException.class, () -> {\r\n        try (Reader reader = new StringReader(\"a,,c,d,\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n            CSVParser parser = format.parse(reader)) {\r\n            // should fail\r\n        }\r\n    }, \"2+ missing column headers is not allowed!\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv248Test.java",
  "methodName" : "testJiraCsv248",
  "sourceCode" : "/**\r\n * Test deserialization of a CSVRecord created using version 1.6.\r\n *\r\n * <p>\r\n * This test asserts that serialization from 1.8 onwards is consistent with previous versions. Serialization was\r\n * broken in version 1.7.\r\n *\r\n * @throws IOException Signals that an I/O exception has occurred.\r\n * @throws ClassNotFoundException If the CSVRecord cannot be deserialized\r\n */\r\n@Test\r\nvoid testJiraCsv248() throws IOException, ClassNotFoundException {\r\n    // Record was originally created using CSV version 1.6 with the following code:\r\n    // try (CSVParser parser = CSVParser.parse(\"A,B\\n#my comment\\nOne,Two\",\r\n    // CSVFormat.DEFAULT.builder().setHeader().setCommentMarker('#'))) {\r\n    // CSVRecord rec = parser.iterator().next();\r\n    // }\r\n    try (InputStream in = getTestInput();\r\n        ObjectInputStream ois = new ObjectInputStream(in)) {\r\n        final Object object = ois.readObject();\r\n        assertInstanceOf(CSVRecord.class, object);\r\n        final CSVRecord rec = (CSVRecord) object;\r\n        assertEquals(1L, rec.getRecordNumber());\r\n        assertEquals(\"One\", rec.get(0));\r\n        assertEquals(\"Two\", rec.get(1));\r\n        assertEquals(2, rec.size());\r\n        // The comment and whitespace are ignored so this is not 17 but 4\r\n        assertEquals(4, rec.getCharacterPosition());\r\n        assertEquals(\"my comment\", rec.getComment());\r\n        // The parser is not serialized\r\n        assertNull(rec.getParser());\r\n        // Check all header map functionality is absent\r\n        assertTrue(rec.isConsistent());\r\n        assertFalse(rec.isMapped(\"A\"));\r\n        assertFalse(rec.isSet(\"A\"));\r\n        assertEquals(0, rec.toMap().size());\r\n        // This will throw\r\n        assertThrows(IllegalStateException.class, () -> rec.get(\"A\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv249Test.java",
  "methodName" : "testJiraCsv249",
  "sourceCode" : "@Test\r\nvoid testJiraCsv249() throws IOException {\r\n    final CSVFormat format = CSVFormat.DEFAULT.builder().setEscape('\\\\').get();\r\n    final StringWriter stringWriter = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(stringWriter, format)) {\r\n        printer.printRecord(\"foo \\\\\", \"bar\");\r\n    }\r\n    final StringReader reader = new StringReader(stringWriter.toString());\r\n    final List<CSVRecord> records;\r\n    try (CSVParser parser = CSVParser.builder().setReader(reader).setFormat(format).get()) {\r\n        records = parser.getRecords();\r\n    }\r\n    records.forEach(record -> {\r\n        assertEquals(\"foo \\\\\", record.get(0));\r\n        assertEquals(\"bar\", record.get(1));\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv253Test.java",
  "methodName" : "testHandleAbsentValues",
  "sourceCode" : "@Test\r\nvoid testHandleAbsentValues() throws IOException {\r\n    // @formatter:off\r\n    final String source = \"\\\"John\\\",,\\\"Doe\\\"\\n\" + \",\\\"AA\\\",123\\n\" + \"\\\"John\\\",90,\\n\" + \"\\\"\\\",,90\";\r\n    // @formatter:on\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setQuoteMode(QuoteMode.NON_NUMERIC).get();\r\n    try (CSVParser parser = csvFormat.parse(new StringReader(source))) {\r\n        final Iterator<CSVRecord> csvRecords = parser.iterator();\r\n        assertValuesEquals(new String[] { \"John\", null, \"Doe\" }, csvRecords.next());\r\n        assertValuesEquals(new String[] { null, \"AA\", \"123\" }, csvRecords.next());\r\n        assertValuesEquals(new String[] { \"John\", \"90\", null }, csvRecords.next());\r\n        assertValuesEquals(new String[] { \"\", null, \"90\" }, csvRecords.next());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv254Test.java",
  "methodName" : "test",
  "sourceCode" : "@Test\r\nvoid test() throws IOException {\r\n    final CSVFormat csvFormat = CSVFormat.POSTGRESQL_CSV;\r\n    try (BufferedReader reader = Files.newBufferedReader(Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-254/csv-254.csv\"), StandardCharsets.UTF_8);\r\n        CSVParser parser = csvFormat.parse(reader)) {\r\n        final Iterator<CSVRecord> csvRecords = parser.iterator();\r\n        assertValuesEquals(new String[] { \"AA\", \"33\", null }, csvRecords.next());\r\n        assertValuesEquals(new String[] { \"AA\", null, \"\" }, csvRecords.next());\r\n        assertValuesEquals(new String[] { null, \"33\", \"CC\" }, csvRecords.next());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv257Test.java",
  "methodName" : "testHeaderBuilder",
  "sourceCode" : "@Test\r\nvoid testHeaderBuilder() throws IOException {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.RFC4180.builder().setDelimiter(INPUT.charAt(0)).setHeader().setSkipHeaderRecord(true).setIgnoreSurroundingSpaces(true).get();\r\n    // @formatter:on\r\n    // Document the current behavior: Throw a IllegalArgumentException is a header name is missing.\r\n    assertThrows(IllegalArgumentException.class, () -> {\r\n        try (CSVParser parser = CSVParser.parse(INPUT, format)) {\r\n            // empty\r\n        }\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv257Test.java",
  "methodName" : "testHeaderDepreacted",
  "sourceCode" : "@Test\r\nvoid testHeaderDepreacted() throws IOException {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.RFC4180.withDelimiter(INPUT.charAt(0)).withFirstRecordAsHeader().withIgnoreSurroundingSpaces();\r\n    // @formatter:on\r\n    // Document the current behavior: Throw a IllegalArgumentException is a header name is missing.\r\n    assertThrows(IllegalArgumentException.class, () -> {\r\n        try (CSVParser parser = new CSVParser(new StringReader(INPUT), format)) {\r\n            // empty\r\n        }\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv257Test.java",
  "methodName" : "testNoHeaderBuilder",
  "sourceCode" : "@Test\r\nvoid testNoHeaderBuilder() throws IOException {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.RFC4180.builder().setDelimiter(INPUT.charAt(0)).setIgnoreSurroundingSpaces(true).get();\r\n    // @formatter:on\r\n    try (CSVParser parser = CSVParser.parse(INPUT, format)) {\r\n        // empty\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv263Test.java",
  "methodName" : "testPrintFromReaderWithQuotes",
  "sourceCode" : "@Test\r\nvoid testPrintFromReaderWithQuotes() throws IOException {\r\n    // @formatter:off\r\n    final CSVFormat format = CSVFormat.RFC4180.builder().setDelimiter(',').setQuote('\"').setEscape('?').setQuoteMode(QuoteMode.NON_NUMERIC).get();\r\n    // @formatter:on\r\n    final StringBuilder out = new StringBuilder();\r\n    final Reader atStartOnly = new StringReader(\"\\\"a,b,c\\r\\nx,y,z\");\r\n    format.print(atStartOnly, out, true);\r\n    assertEquals(\"\\\"\\\"\\\"a,b,c\\r\\nx,y,z\\\"\", out.toString());\r\n    final Reader atEndOnly = new StringReader(\"a,b,c\\r\\nx,y,z\\\"\");\r\n    out.setLength(0);\r\n    format.print(atEndOnly, out, true);\r\n    assertEquals(\"\\\"a,b,c\\r\\nx,y,z\\\"\\\"\\\"\", out.toString());\r\n    final Reader atBeginEnd = new StringReader(\"\\\"a,b,c\\r\\nx,y,z\\\"\");\r\n    out.setLength(0);\r\n    format.print(atBeginEnd, out, true);\r\n    assertEquals(\"\\\"\\\"\\\"a,b,c\\r\\nx,y,z\\\"\\\"\\\"\", out.toString());\r\n    final Reader embeddedBeginMiddle = new StringReader(\"\\\"a\\\",b,c\\r\\nx,\\\"y\\\",z\");\r\n    out.setLength(0);\r\n    format.print(embeddedBeginMiddle, out, true);\r\n    assertEquals(\"\\\"\\\"\\\"a\\\"\\\",b,c\\r\\nx,\\\"\\\"y\\\"\\\",z\\\"\", out.toString());\r\n    final Reader embeddedMiddleEnd = new StringReader(\"a,\\\"b\\\",c\\r\\nx,y,\\\"z\\\"\");\r\n    out.setLength(0);\r\n    format.print(embeddedMiddleEnd, out, true);\r\n    assertEquals(\"\\\"a,\\\"\\\"b\\\"\\\",c\\r\\nx,y,\\\"\\\"z\\\"\\\"\\\"\", out.toString());\r\n    final Reader nested = new StringReader(\"a,\\\"b \\\"and\\\" c\\\",d\");\r\n    out.setLength(0);\r\n    format.print(nested, out, true);\r\n    assertEquals(\"\\\"a,\\\"\\\"b \\\"\\\"and\\\"\\\" c\\\"\\\",d\\\"\", out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv264Test.java",
  "methodName" : "testJiraCsv264",
  "sourceCode" : "@Test\r\nvoid testJiraCsv264() {\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setHeader().setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).setAllowMissingColumnNames(true).get();\r\n    try (StringReader reader = new StringReader(CSV_STRING)) {\r\n        assertThrows(IllegalArgumentException.class, () -> csvFormat.parse(reader));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv264Test.java",
  "methodName" : "testJiraCsv264WithGapAllowEmpty",
  "sourceCode" : "@Test\r\nvoid testJiraCsv264WithGapAllowEmpty() throws IOException {\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setHeader().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).setAllowMissingColumnNames(true).get();\r\n    try (StringReader reader = new StringReader(CSV_STRING_GAP);\r\n        CSVParser parser = csvFormat.parse(reader)) {\r\n        // empty\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv264Test.java",
  "methodName" : "testJiraCsv264WithGapDisallow",
  "sourceCode" : "@Test\r\nvoid testJiraCsv264WithGapDisallow() {\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setHeader().setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).setAllowMissingColumnNames(true).get();\r\n    try (StringReader reader = new StringReader(CSV_STRING_GAP)) {\r\n        assertThrows(IllegalArgumentException.class, () -> csvFormat.parse(reader));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv265Test.java",
  "methodName" : "testCharacterPositionWithComments",
  "sourceCode" : "@Test\r\nvoid testCharacterPositionWithComments() throws IOException {\r\n    // @formatter:off\r\n    final String csv = \"# Comment1\\n\" + \"Header1,Header2\\n\" + \"# Comment2\\n\" + \"Value1,Value2\\n\" + \"# Comment3\\n\" + \"Value3,Value4\\n\" + \"# Comment4\\n\";\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setCommentMarker('#').setHeader().setSkipHeaderRecord(true).get();\r\n    // @formatter:on\r\n    try (CSVParser parser = csvFormat.parse(new StringReader(csv))) {\r\n        final Iterator<CSVRecord> itr = parser.iterator();\r\n        final CSVRecord record1 = itr.next();\r\n        assertEquals(csv.indexOf(\"# Comment2\"), record1.getCharacterPosition());\r\n        final CSVRecord record2 = itr.next();\r\n        assertEquals(csv.indexOf(\"# Comment3\"), record2.getCharacterPosition());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv265Test.java",
  "methodName" : "testCharacterPositionWithCommentsSpanningMultipleLines",
  "sourceCode" : "@Test\r\nvoid testCharacterPositionWithCommentsSpanningMultipleLines() throws IOException {\r\n    // @formatter:off\r\n    final String csv = \"# Comment1\\n\" + \"# Comment2\\n\" + \"Header1,Header2\\n\" + \"# Comment3\\n\" + \"# Comment4\\n\" + \"Value1,Value2\\n\" + \"# Comment5\\n\" + \"# Comment6\\n\" + \"Value3,Value4\";\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setCommentMarker('#').setHeader().setSkipHeaderRecord(true).get();\r\n    // @formatter:on\r\n    try (CSVParser parser = csvFormat.parse(new StringReader(csv))) {\r\n        final Iterator<CSVRecord> itr = parser.iterator();\r\n        final CSVRecord record1 = itr.next();\r\n        assertEquals(csv.indexOf(\"# Comment3\"), record1.getCharacterPosition());\r\n        final CSVRecord record2 = itr.next();\r\n        assertEquals(csv.indexOf(\"# Comment5\"), record2.getCharacterPosition());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv271Test.java",
  "methodName" : "testJiraCsv271_withArray",
  "sourceCode" : "@Test\r\nvoid testJiraCsv271_withArray() throws IOException {\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n    final StringWriter stringWriter = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(stringWriter, csvFormat)) {\r\n        printer.print(\"a\");\r\n        printer.printRecord(\"b\", \"c\");\r\n    }\r\n    assertEquals(\"a,b,c\\r\\n\", stringWriter.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv271Test.java",
  "methodName" : "testJiraCsv271_withList",
  "sourceCode" : "@Test\r\nvoid testJiraCsv271_withList() throws IOException {\r\n    final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n    final StringWriter stringWriter = new StringWriter();\r\n    try (CSVPrinter printer = new CSVPrinter(stringWriter, csvFormat)) {\r\n        printer.print(\"a\");\r\n        printer.printRecord(Arrays.asList(\"b\", \"c\"));\r\n    }\r\n    assertEquals(\"a,b,c\\r\\n\", stringWriter.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithABADelimiter",
  "sourceCode" : "@Test\r\n// Before fix:\r\n// expected: <a,b,c,d,,f> but was: <a,b,c,d,|f>\r\nvoid testParseWithABADelimiter() throws Exception {\r\n    final Reader in = new StringReader(\"a|~|b|~|c|~|d|~||~|f\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser parser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|~|\").get())) {\r\n        for (final CSVRecord csvRecord : parser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithDoublePipeDelimiter",
  "sourceCode" : "@Test\r\n// Before fix:\r\n// expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\r\nvoid testParseWithDoublePipeDelimiter() throws Exception {\r\n    final Reader in = new StringReader(\"a||b||c||d||||f\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithDoublePipeDelimiterDoubleCharValue",
  "sourceCode" : "@Test\r\n// Regression, already passed before fix\r\nvoid testParseWithDoublePipeDelimiterDoubleCharValue() throws Exception {\r\n    final Reader in = new StringReader(\"a||bb||cc||dd||f\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,bb,cc,dd,f\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithDoublePipeDelimiterEndsWithDelimiter",
  "sourceCode" : "@Test\r\n// Before fix:\r\n// expected: <a,b,c,d,,f,> but was: <a,b|c,d,|f>\r\nvoid testParseWithDoublePipeDelimiterEndsWithDelimiter() throws Exception {\r\n    final Reader in = new StringReader(\"a||b||c||d||||f||\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithDoublePipeDelimiterQuoted",
  "sourceCode" : "@Test\r\n// Before fix:\r\n// expected: <a,b||c,d,,f> but was: <a,b||c,d,|f>\r\nvoid testParseWithDoublePipeDelimiterQuoted() throws Exception {\r\n    final Reader in = new StringReader(\"a||\\\"b||c\\\"||d||||f\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b||c,d,,f\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithSinglePipeDelimiterEndsWithDelimiter",
  "sourceCode" : "@Test\r\n// Regression, already passed before fix\r\nvoid testParseWithSinglePipeDelimiterEndsWithDelimiter() throws Exception {\r\n    final Reader in = new StringReader(\"a|b|c|d||f|\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithTriplePipeDelimiter",
  "sourceCode" : "@Test\r\n// Before fix:\r\n// expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\r\nvoid testParseWithTriplePipeDelimiter() throws Exception {\r\n    final Reader in = new StringReader(\"a|||b|||c|||d||||||f\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|||\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithTwoCharDelimiter1",
  "sourceCode" : "@Test\r\n// Regression, already passed before fix\r\nvoid testParseWithTwoCharDelimiter1() throws Exception {\r\n    final Reader in = new StringReader(\"a~|b~|c~|d~|~|f\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithTwoCharDelimiter2",
  "sourceCode" : "@Test\r\n// Regression, already passed before fix\r\nvoid testParseWithTwoCharDelimiter2() throws Exception {\r\n    final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f~\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithTwoCharDelimiter3",
  "sourceCode" : "@Test\r\n// Regression, already passed before fix\r\nvoid testParseWithTwoCharDelimiter3() throws Exception {\r\n    final Reader in = new StringReader(\"a~|b~|c~|d~|~|f|\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f|\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithTwoCharDelimiter4",
  "sourceCode" : "@Test\r\n// Regression, already passed before fix\r\nvoid testParseWithTwoCharDelimiter4() throws Exception {\r\n    final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~~||g\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f~,|g\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv288Test.java",
  "methodName" : "testParseWithTwoCharDelimiterEndsWithDelimiter",
  "sourceCode" : "@Test\r\n// Before fix:\r\n// expected: <a,b,c,d,,f,> but was: <a,b,c,d,,f>\r\nvoid testParseWithTwoCharDelimiterEndsWithDelimiter() throws Exception {\r\n    final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~|\");\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n        CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n        for (final CSVRecord csvRecord : csvParser) {\r\n            print(csvRecord, csvPrinter);\r\n            assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv290Test.java",
  "methodName" : "testPostgresqlCsv",
  "sourceCode" : "@Test\r\nvoid testPostgresqlCsv() throws Exception {\r\n    testHelper(\"psql.csv\", CSVFormat.POSTGRESQL_CSV);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv290Test.java",
  "methodName" : "testPostgresqlText",
  "sourceCode" : "@Test\r\nvoid testPostgresqlText() throws Exception {\r\n    testHelper(\"psql.tsv\", CSVFormat.POSTGRESQL_TEXT);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv290Test.java",
  "methodName" : "testWriteThenRead",
  "sourceCode" : "@Test\r\nvoid testWriteThenRead() throws Exception {\r\n    final StringWriter sw = new StringWriter();\r\n    final CSVFormat format = CSVFormat.POSTGRESQL_CSV.builder().setHeader().setSkipHeaderRecord(true).get();\r\n    try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        printer.printRecord(\"column1\", \"column2\");\r\n        printer.printRecord(\"v11\", \"v12\");\r\n        printer.printRecord(\"v21\", \"v22\");\r\n        printer.close();\r\n        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(sw.toString())).setFormat(format).get()) {\r\n            assertArrayEquals(new Object[] { \"column1\", \"column2\" }, parser.getHeaderNames().toArray());\r\n            final Iterator<CSVRecord> i = parser.iterator();\r\n            assertArrayEquals(new String[] { \"v11\", \"v12\" }, i.next().toList().toArray());\r\n            assertArrayEquals(new String[] { \"v21\", \"v22\" }, i.next().toList().toArray());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv294Test.java",
  "methodName" : "testDefaultCsvFormatWithBackslashEscapeWorks",
  "sourceCode" : "@Test\r\nvoid testDefaultCsvFormatWithBackslashEscapeWorks() throws IOException {\r\n    testInternal(CSVFormat.Builder.create().setEscape('\\\\').get(), \",\\\"b \\\\\\\"\\\\\\\"\\\",\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv294Test.java",
  "methodName" : "testDefaultCsvFormatWithNullEscapeWorks",
  "sourceCode" : "@Test\r\nvoid testDefaultCsvFormatWithNullEscapeWorks() throws IOException {\r\n    testInternal(CSVFormat.Builder.create().setEscape(null).get(), \",\\\"b \\\"\\\"\\\"\\\"\\\",\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv294Test.java",
  "methodName" : "testDefaultCsvFormatWithQuoteEscapeWorks",
  "sourceCode" : "@Test\r\nvoid testDefaultCsvFormatWithQuoteEscapeWorks() throws IOException {\r\n    // this one doesn't actually work but should behave like setEscape(null)\r\n    // Printer is writing the expected content but Parser is unable to consume it\r\n    testInternal(CSVFormat.Builder.create().setEscape('\"').get(), \",\\\"b \\\"\\\"\\\"\\\"\\\",\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv294Test.java",
  "methodName" : "testDefaultCsvFormatWorks",
  "sourceCode" : "@Test\r\nvoid testDefaultCsvFormatWorks() throws IOException {\r\n    testInternal(CSVFormat.Builder.create().get(), \",\\\"b \\\"\\\"\\\"\\\"\\\",\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv93Test.java",
  "methodName" : "testWithNotSetNullString",
  "sourceCode" : "@Test\r\nvoid testWithNotSetNullString() throws IOException {\r\n    // @formatter:off\r\n    every(CSVFormat.DEFAULT, objects1, \"abc,,,\\\"a,b,c\\\",123\", new String[] { \"abc\", \"\", \"\", \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setQuoteMode(QuoteMode.ALL).get(), objects1, \"\\\"abc\\\",\\\"\\\",,\\\"a,b,c\\\",\\\"123\\\"\", new String[] { \"abc\", \"\", \"\", \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setQuoteMode(QuoteMode.ALL_NON_NULL).get(), objects1, \"\\\"abc\\\",\\\"\\\",,\\\"a,b,c\\\",\\\"123\\\"\", new String[] { \"abc\", \"\", null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setQuoteMode(QuoteMode.MINIMAL).get(), objects1, \"abc,,,\\\"a,b,c\\\",123\", new String[] { \"abc\", \"\", \"\", \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setEscape('?').setQuoteMode(QuoteMode.NONE).get(), objects1, \"abc,,,a?,b?,c,123\", new String[] { \"abc\", \"\", \"\", \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setQuoteMode(QuoteMode.NON_NUMERIC).get(), objects1, \"\\\"abc\\\",\\\"\\\",,\\\"a,b,c\\\",123\", new String[] { \"abc\", \"\", null, \"a,b,c\", \"123\" });\r\n    // @formatter:on\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv93Test.java",
  "methodName" : "testWithSetNullStringEmptyString",
  "sourceCode" : "@Test\r\nvoid testWithSetNullStringEmptyString() throws IOException {\r\n    // @formatter:off\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"\").get(), objects1, \"abc,,,\\\"a,b,c\\\",123\", new String[] { \"abc\", null, null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"\").setQuoteMode(QuoteMode.ALL).get(), objects1, \"\\\"abc\\\",\\\"\\\",\\\"\\\",\\\"a,b,c\\\",\\\"123\\\"\", new String[] { \"abc\", null, null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"\").setQuoteMode(QuoteMode.ALL_NON_NULL).get(), objects1, \"\\\"abc\\\",\\\"\\\",,\\\"a,b,c\\\",\\\"123\\\"\", new String[] { \"abc\", \"\", null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"\").setQuoteMode(QuoteMode.MINIMAL).get(), objects1, \"abc,,,\\\"a,b,c\\\",123\", new String[] { \"abc\", null, null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"\").setEscape('?').setQuoteMode(QuoteMode.NONE).get(), objects1, \"abc,,,a?,b?,c,123\", new String[] { \"abc\", null, null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"\").setQuoteMode(QuoteMode.NON_NUMERIC).get(), objects1, \"\\\"abc\\\",\\\"\\\",,\\\"a,b,c\\\",123\", new String[] { \"abc\", \"\", null, \"a,b,c\", \"123\" });\r\n    // @formatter:on\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\issues\\JiraCsv93Test.java",
  "methodName" : "testWithSetNullStringNULL",
  "sourceCode" : "@Test\r\nvoid testWithSetNullStringNULL() throws IOException {\r\n    // @formatter:off\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"NULL\").get(), objects2, \"abc,NULL,NULL,\\\"a,b,c\\\",123\", new String[] { \"abc\", null, null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"NULL\").setQuoteMode(QuoteMode.ALL).get(), objects2, \"\\\"abc\\\",\\\"NULL\\\",\\\"NULL\\\",\\\"a,b,c\\\",\\\"123\\\"\", new String[] { \"abc\", null, null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"NULL\").setQuoteMode(QuoteMode.ALL_NON_NULL).get(), objects2, \"\\\"abc\\\",\\\"NULL\\\",NULL,\\\"a,b,c\\\",\\\"123\\\"\", new String[] { \"abc\", \"NULL\", null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"NULL\").setQuoteMode(QuoteMode.MINIMAL).get(), objects2, \"abc,NULL,NULL,\\\"a,b,c\\\",123\", new String[] { \"abc\", null, null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"NULL\").setEscape('?').setQuoteMode(QuoteMode.NONE).get(), objects2, \"abc,NULL,NULL,a?,b?,c,123\", new String[] { \"abc\", null, null, \"a,b,c\", \"123\" });\r\n    every(CSVFormat.DEFAULT.builder().setNullString(\"NULL\").setQuoteMode(QuoteMode.NON_NUMERIC).get(), objects2, \"\\\"abc\\\",\\\"NULL\\\",NULL,\\\"a,b,c\\\",123\", new String[] { \"abc\", \"NULL\", null, \"a,b,c\", \"123\" });\r\n    // @formatter:on\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\JiraCsv196Test.java",
  "methodName" : "testParseFourBytes",
  "sourceCode" : "@Test\r\nvoid testParseFourBytes() throws IOException {\r\n    final CSVFormat format = CSVFormat.Builder.create().setDelimiter(',').setQuote('\\'').get();\r\n    // @formatter:off\r\n    try (// parser closes the reader.\r\n    @SuppressWarnings(\"resource\") CSVParser parser = new CSVParser.Builder().setFormat(format).setReader(getTestInput(\"org/apache/commons/csv/CSV-196/emoji.csv\")).setCharset(StandardCharsets.UTF_8).setTrackBytes(true).get()) {\r\n        // @formatter:on\r\n        final long[] charByteKey = { 0, 84, 701, 1318, 1935 };\r\n        int idx = 0;\r\n        for (final CSVRecord record : parser) {\r\n            assertEquals(charByteKey[idx++], record.getBytePosition(), \"At index \" + idx);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\JiraCsv196Test.java",
  "methodName" : "testParseThreeBytes",
  "sourceCode" : "@Test\r\nvoid testParseThreeBytes() throws IOException {\r\n    final CSVFormat format = CSVFormat.Builder.create().setDelimiter(',').setQuote('\\'').get();\r\n    // @formatter:off\r\n    try (// parser closes the reader.\r\n    @SuppressWarnings(\"resource\") CSVParser parser = new CSVParser.Builder().setFormat(format).setReader(getTestInput(\"org/apache/commons/csv/CSV-196/japanese.csv\")).setCharset(StandardCharsets.UTF_8).setTrackBytes(true).get()) {\r\n        // @formatter:on\r\n        final long[] charByteKey = { 0, 89, 242, 395 };\r\n        int idx = 0;\r\n        for (final CSVRecord record : parser) {\r\n            assertEquals(charByteKey[idx++], record.getBytePosition(), \"At index \" + idx);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\JiraCsv318Test.java",
  "methodName" : "testDefaultStream",
  "sourceCode" : "@Test\r\nvoid testDefaultStream() throws IOException {\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (CSVPrinter printer = newPrinter(baos)) {\r\n        printer.printRecord(newStream());\r\n    }\r\n    checkOutput(baos);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\JiraCsv318Test.java",
  "methodName" : "testParallelIOStream",
  "sourceCode" : "@SuppressWarnings(\"resource\")\r\n@Test\r\nvoid testParallelIOStream() throws IOException {\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (CSVPrinter printer = newPrinter(baos)) {\r\n        IOStream.adapt(newParallelStream()).forEachOrdered(printer::print);\r\n    }\r\n    // No EOR marker in this test intentionally, so checkOutput will trim.\r\n    checkOutput(baos);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\JiraCsv318Test.java",
  "methodName" : "testParallelIOStreamSynchronizedPrinterNotUsed",
  "sourceCode" : "@SuppressWarnings(\"resource\")\r\n@Test\r\nvoid testParallelIOStreamSynchronizedPrinterNotUsed() throws IOException {\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (CSVPrinter printer = newPrinter(baos)) {\r\n        synchronized (printer) {\r\n            IOStream.adapt(newParallelStream()).forEachOrdered(IOConsumer.noop());\r\n        }\r\n    }\r\n    final List<String> list = new ArrayList<>();\r\n    try (CSVPrinter printer = newPrinter(baos)) {\r\n        synchronized (printer) {\r\n            IOStream.adapt(newParallelStream()).forEachOrdered(list::add);\r\n        }\r\n    }\r\n    // No EOR marker in this test intentionally, so checkOutput will trim.\r\n    checkOutput(String.join(\",\", list.toArray(ArrayUtils.EMPTY_STRING_ARRAY)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\JiraCsv318Test.java",
  "methodName" : "testParallelStream",
  "sourceCode" : "@Test\r\nvoid testParallelStream() throws IOException {\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (CSVPrinter printer = newPrinter(baos)) {\r\n        printer.printRecord(newParallelStream());\r\n    }\r\n    checkOutput(baos);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\JiraCsv318Test.java",
  "methodName" : "testSequentialStream",
  "sourceCode" : "@Test\r\nvoid testSequentialStream() throws IOException {\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (CSVPrinter printer = newPrinter(baos)) {\r\n        printer.printRecord(newSequentialStream());\r\n    }\r\n    checkOutput(baos);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testBackslashWithEscaping",
  "sourceCode" : "// simple token with escaping enabled\r\n@Test\r\nvoid testBackslashWithEscaping() throws IOException {\r\n    /*\r\n         * file: a,\\,,b \\,,\r\n         */\r\n    final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\r\n    final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\r\n    assertTrue(format.isEscapeCharacterSet());\r\n    try (Lexer lexer = createLexer(code, format)) {\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(TOKEN, \",\", lexer);\r\n        assertNextToken(EORECORD, \"b\\\\\", lexer);\r\n        assertNextToken(TOKEN, \",\", lexer);\r\n        assertNextToken(TOKEN, \"\\nc\", lexer);\r\n        assertNextToken(EORECORD, \"d\\r\", lexer);\r\n        assertNextToken(EOF, \"e\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testBackslashWithoutEscaping",
  "sourceCode" : "// simple token with escaping not enabled\r\n@Test\r\nvoid testBackslashWithoutEscaping() throws IOException {\r\n    /*\r\n         * file: a,\\,,b \\,,\r\n         */\r\n    final String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\r\n    final CSVFormat format = CSVFormat.DEFAULT;\r\n    assertFalse(format.isEscapeCharacterSet());\r\n    try (Lexer lexer = createLexer(code, format)) {\r\n        // parser.nextToken(new Token())\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        // an unquoted single backslash is not an escape char\r\n        assertNextToken(TOKEN, \"\\\\\", lexer);\r\n        assertNextToken(TOKEN, \"\", lexer);\r\n        assertNextToken(EORECORD, \"b\\\\\", lexer);\r\n        // an unquoted single backslash is not an escape char\r\n        assertNextToken(TOKEN, \"\\\\\", lexer);\r\n        assertNextToken(TOKEN, \"\", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testBackspace",
  "sourceCode" : "@Test\r\nvoid testBackspace() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\" + BACKSPACE + \"NotEscaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\" + BACKSPACE + \"NotEscaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testComments",
  "sourceCode" : "@Test\r\nvoid testComments() throws IOException {\r\n    // @formatter:off\r\n    final String code = \"first,line,\\n\" + \"second,line,tokenWith#no-comment\\n\" + \"# comment line \\n\" + \"third,line,#no-comment\\n\" + \"# penultimate comment\\n\" + \"# Final comment\\n\";\r\n    // @formatter:on\r\n    final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#');\r\n    try (Lexer lexer = createLexer(code, format)) {\r\n        assertNextToken(TOKEN, \"first\", lexer);\r\n        assertNextToken(TOKEN, \"line\", lexer);\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        assertNextToken(TOKEN, \"second\", lexer);\r\n        assertNextToken(TOKEN, \"line\", lexer);\r\n        assertNextToken(EORECORD, \"tokenWith#no-comment\", lexer);\r\n        assertNextToken(COMMENT, \"comment line\", lexer);\r\n        assertNextToken(TOKEN, \"third\", lexer);\r\n        assertNextToken(TOKEN, \"line\", lexer);\r\n        assertNextToken(EORECORD, \"#no-comment\", lexer);\r\n        assertNextToken(COMMENT, \"penultimate comment\", lexer);\r\n        assertNextToken(COMMENT, \"Final comment\", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testCommentsAndEmptyLines",
  "sourceCode" : "@Test\r\nvoid testCommentsAndEmptyLines() throws IOException {\r\n    final String code = // 1\r\n    \"1,2,3,\\n\" + // 1b\r\n    \"\\n\" + // 1c\r\n    \"\\n\" + // 2\r\n    \"a,b x,c#no-comment\\n\" + // 3\r\n    \"#foo\\n\" + // 4\r\n    \"\\n\" + // 4b\r\n    \"\\n\" + // 5\r\n    \"d,e,#no-comment\\n\" + // 5b\r\n    \"\\n\" + // 5c\r\n    \"\\n\" + // 6\r\n    \"# penultimate comment\\n\" + // 6b\r\n    \"\\n\" + // 6c\r\n    \"\\n\" + // 7\r\n    \"# Final comment\\n\";\r\n    final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#').withIgnoreEmptyLines(false);\r\n    assertFalse(format.getIgnoreEmptyLines(), \"Should not ignore empty lines\");\r\n    try (Lexer lexer = createLexer(code, format)) {\r\n        assertNextToken(TOKEN, \"1\", lexer);\r\n        assertNextToken(TOKEN, \"2\", lexer);\r\n        assertNextToken(TOKEN, \"3\", lexer);\r\n        // 1\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        // 1b\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        // 1c\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(TOKEN, \"b x\", lexer);\r\n        // 2\r\n        assertNextToken(EORECORD, \"c#no-comment\", lexer);\r\n        // 3\r\n        assertNextToken(COMMENT, \"foo\", lexer);\r\n        // 4\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        // 4b\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        assertNextToken(TOKEN, \"d\", lexer);\r\n        assertNextToken(TOKEN, \"e\", lexer);\r\n        // 5\r\n        assertNextToken(EORECORD, \"#no-comment\", lexer);\r\n        // 5b\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        // 5c\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        // 6\r\n        assertNextToken(COMMENT, \"penultimate comment\", lexer);\r\n        // 6b\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        // 6c\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        // 7\r\n        assertNextToken(COMMENT, \"Final comment\", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testCR",
  "sourceCode" : "@Test\r\nvoid testCR() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\" + CR + \"NotEscaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\", lexer);\r\n        assertNextToken(\"NotEscaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testDelimiterIsWhitespace",
  "sourceCode" : "// From CSV-1\r\n@Test\r\nvoid testDelimiterIsWhitespace() throws IOException {\r\n    final String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\r\n    try (Lexer lexer = createLexer(code, CSVFormat.TDF)) {\r\n        assertNextToken(TOKEN, \"one\", lexer);\r\n        assertNextToken(TOKEN, \"two\", lexer);\r\n        assertNextToken(TOKEN, \"\", lexer);\r\n        assertNextToken(TOKEN, \"four\", lexer);\r\n        assertNextToken(TOKEN, \"five\", lexer);\r\n        assertNextToken(EOF, \"six\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEOFWithoutClosingQuote",
  "sourceCode" : "@Test\r\nvoid testEOFWithoutClosingQuote() throws Exception {\r\n    final String code = \"a,\\\"b\";\r\n    try (Lexer lexer = createLexer(code, CSVFormat.Builder.create().setLenientEof(true).get())) {\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(EOF, \"b\", lexer);\r\n    }\r\n    try (Lexer lexer = createLexer(code, CSVFormat.Builder.create().setLenientEof(false).get())) {\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertThrows(IOException.class, () -> lexer.nextToken(new Token()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedBackspace",
  "sourceCode" : "// TODO is this correct? Do we expect <esc>BACKSPACE to be unescaped?\r\n@Test\r\nvoid testEscapedBackspace() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\" + BACKSPACE + \"Escaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedCharacter",
  "sourceCode" : "@Test\r\nvoid testEscapedCharacter() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\\\\aEscaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\\\\aEscaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedControlCharacter",
  "sourceCode" : "@Test\r\nvoid testEscapedControlCharacter() throws Exception {\r\n    // we are explicitly using an escape different from \\ here\r\n    try (Lexer lexer = createLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'))) {\r\n        assertNextToken(\"character\" + CR + \"Escaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedControlCharacter2",
  "sourceCode" : "@Test\r\nvoid testEscapedControlCharacter2() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'))) {\r\n        assertNextToken(\"character\" + CR + \"Escaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedCR",
  "sourceCode" : "@Test\r\nvoid testEscapedCR() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\" + CR + \"Escaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedFF",
  "sourceCode" : "// TODO is this correct? Do we expect <esc>FF to be unescaped?\r\n@Test\r\nvoid testEscapedFF() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\" + FF + \"Escaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedLF",
  "sourceCode" : "@Test\r\nvoid testEscapedLF() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\" + LF + \"Escaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedMySqlNullValue",
  "sourceCode" : "@Test\r\nvoid testEscapedMySqlNullValue() throws Exception {\r\n    // MySQL uses \\N to symbolize null values. We have to restore this\r\n    try (Lexer lexer = createLexer(\"character\\\\NEscaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\\\\NEscaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapedTab",
  "sourceCode" : "// TODO is this correct? Do we expect <esc>TAB to be unescaped?\r\n@Test\r\nvoid testEscapedTab() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\" + TAB + \"Escaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testEscapingAtEOF",
  "sourceCode" : "@Test\r\nvoid testEscapingAtEOF() throws Exception {\r\n    final String code = \"escaping at EOF is evil\\\\\";\r\n    try (Lexer lexer = createLexer(code, formatWithEscaping)) {\r\n        assertThrows(IOException.class, () -> lexer.nextToken(new Token()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testFF",
  "sourceCode" : "@Test\r\nvoid testFF() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\" + FF + \"NotEscaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\" + FF + \"NotEscaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testIgnoreEmptyLines",
  "sourceCode" : "@Test\r\nvoid testIgnoreEmptyLines() throws IOException {\r\n    // @formatter:off\r\n    final String code = \"first,line,\\n\" + \"\\n\" + \"\\n\" + \"second,line\\n\" + \"\\n\" + \"\\n\" + \"third line \\n\" + \"\\n\" + \"\\n\" + \"last, line \\n\" + \"\\n\" + \"\\n\" + \"\\n\";\r\n    // @formatter:on\r\n    final CSVFormat format = CSVFormat.DEFAULT.withIgnoreEmptyLines();\r\n    try (Lexer lexer = createLexer(code, format)) {\r\n        assertNextToken(TOKEN, \"first\", lexer);\r\n        assertNextToken(TOKEN, \"line\", lexer);\r\n        assertNextToken(EORECORD, \"\", lexer);\r\n        assertNextToken(TOKEN, \"second\", lexer);\r\n        assertNextToken(EORECORD, \"line\", lexer);\r\n        assertNextToken(EORECORD, \"third line \", lexer);\r\n        assertNextToken(TOKEN, \"last\", lexer);\r\n        assertNextToken(EORECORD, \" line \", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testIsMetaCharCommentStart",
  "sourceCode" : "@Test\r\nvoid testIsMetaCharCommentStart() throws IOException {\r\n    try (Lexer lexer = createLexer(\"#\", CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n        final int ch = lexer.readEscape();\r\n        assertEquals('#', ch);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testLF",
  "sourceCode" : "@Test\r\nvoid testLF() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\" + LF + \"NotEscaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\", lexer);\r\n        assertNextToken(\"NotEscaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testNextToken4",
  "sourceCode" : "// encapsulator tokenizer (single line)\r\n@Test\r\nvoid testNextToken4() throws IOException {\r\n    /*\r\n         * file: a,\"foo\",b a, \" foo\",b a,\"foo \" ,b // whitespace after closing encapsulator a, \" foo \" ,b\r\n         */\r\n    final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\r\n    try (Lexer lexer = createLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(TOKEN, \"foo\", lexer);\r\n        assertNextToken(EORECORD, \"b\", lexer);\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(TOKEN, \" foo\", lexer);\r\n        assertNextToken(EORECORD, \"b\", lexer);\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(TOKEN, \"foo \", lexer);\r\n        assertNextToken(EORECORD, \"b\", lexer);\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(TOKEN, \" foo \", lexer);\r\n        // assertTokenEquals(EORECORD, \"b\", parser);\r\n        assertNextToken(EOF, \"b\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testNextToken5",
  "sourceCode" : "// encapsulator tokenizer (multi line, delimiter in string)\r\n@Test\r\nvoid testNextToken5() throws IOException {\r\n    final String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\r\n    try (Lexer lexer = createLexer(code, CSVFormat.DEFAULT)) {\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(TOKEN, \"foo\\n\", lexer);\r\n        assertNextToken(EORECORD, \"b\", lexer);\r\n        assertNextToken(EORECORD, \"foo\\n  baar ,,,\", lexer);\r\n        assertNextToken(EOF, \"\\n\\t \\n\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testNextToken6",
  "sourceCode" : "// change delimiters, comment, encapsulater\r\n@Test\r\nvoid testNextToken6() throws IOException {\r\n    /*\r\n         * file: a;'b and \\' more ' !comment;;;; ;;\r\n         */\r\n    final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\r\n    final CSVFormat format = CSVFormat.DEFAULT.withQuote('\\'').withCommentMarker('!').withDelimiter(';');\r\n    try (Lexer lexer = createLexer(code, format)) {\r\n        assertNextToken(TOKEN, \"a\", lexer);\r\n        assertNextToken(EORECORD, \"b and ' more\\n\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testReadEscapeBackspace",
  "sourceCode" : "@Test\r\nvoid testReadEscapeBackspace() throws IOException {\r\n    try (Lexer lexer = createLexer(\"b\", CSVFormat.DEFAULT.withEscape('\\b'))) {\r\n        final int ch = lexer.readEscape();\r\n        assertEquals(BACKSPACE, ch);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testReadEscapeFF",
  "sourceCode" : "@Test\r\nvoid testReadEscapeFF() throws IOException {\r\n    try (Lexer lexer = createLexer(\"f\", CSVFormat.DEFAULT.withEscape('\\f'))) {\r\n        final int ch = lexer.readEscape();\r\n        assertEquals(FF, ch);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testReadEscapeTab",
  "sourceCode" : "@Test\r\nvoid testReadEscapeTab() throws IOException {\r\n    try (Lexer lexer = createLexer(\"t\", CSVFormat.DEFAULT.withEscape('\\t'))) {\r\n        final int ch = lexer.readEscape();\r\n        assertNextToken(EOF, \"\", lexer);\r\n        assertEquals(TAB, ch);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testSurroundingSpacesAreDeleted",
  "sourceCode" : "@Test\r\nvoid testSurroundingSpacesAreDeleted() throws IOException {\r\n    final String code = \"noSpaces,  leadingSpaces,trailingSpaces  ,  surroundingSpaces  ,  ,,\";\r\n    try (Lexer lexer = createLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n        assertNextToken(TOKEN, \"noSpaces\", lexer);\r\n        assertNextToken(TOKEN, \"leadingSpaces\", lexer);\r\n        assertNextToken(TOKEN, \"trailingSpaces\", lexer);\r\n        assertNextToken(TOKEN, \"surroundingSpaces\", lexer);\r\n        assertNextToken(TOKEN, \"\", lexer);\r\n        assertNextToken(TOKEN, \"\", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testSurroundingTabsAreDeleted",
  "sourceCode" : "@Test\r\nvoid testSurroundingTabsAreDeleted() throws IOException {\r\n    final String code = \"noTabs,\\tleadingTab,trailingTab\\t,\\tsurroundingTabs\\t,\\t\\t,,\";\r\n    try (Lexer lexer = createLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n        assertNextToken(TOKEN, \"noTabs\", lexer);\r\n        assertNextToken(TOKEN, \"leadingTab\", lexer);\r\n        assertNextToken(TOKEN, \"trailingTab\", lexer);\r\n        assertNextToken(TOKEN, \"surroundingTabs\", lexer);\r\n        assertNextToken(TOKEN, \"\", lexer);\r\n        assertNextToken(TOKEN, \"\", lexer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testTab",
  "sourceCode" : "@Test\r\nvoid testTab() throws Exception {\r\n    try (Lexer lexer = createLexer(\"character\" + TAB + \"NotEscaped\", formatWithEscaping)) {\r\n        assertNextToken(\"character\" + TAB + \"NotEscaped\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testTrailingTextAfterQuote",
  "sourceCode" : "@Test\r\nvoid testTrailingTextAfterQuote() throws Exception {\r\n    final String code = \"\\\"a\\\" b,\\\"a\\\" \\\" b,\\\"a\\\" b \\\"\\\"\";\r\n    try (Lexer lexer = createLexer(code, CSVFormat.Builder.create().setTrailingData(true).get())) {\r\n        assertNextToken(TOKEN, \"a b\", lexer);\r\n        assertNextToken(TOKEN, \"a \\\" b\", lexer);\r\n        assertNextToken(EOF, \"a b \\\"\\\"\", lexer);\r\n    }\r\n    try (Lexer parser = createLexer(code, CSVFormat.Builder.create().setTrailingData(false).get())) {\r\n        assertThrows(IOException.class, () -> parser.nextToken(new Token()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\LexerTest.java",
  "methodName" : "testTrimTrailingSpacesZeroLength",
  "sourceCode" : "@Test\r\nvoid testTrimTrailingSpacesZeroLength() throws Exception {\r\n    final StringBuilder buffer = new StringBuilder(\"\");\r\n    try (Lexer lexer = createLexer(buffer.toString(), CSVFormat.DEFAULT)) {\r\n        lexer.trimTrailingSpaces(buffer);\r\n        assertNextToken(EOF, \"\", lexer);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\perf\\PerformanceTest.java",
  "methodName" : "testParseBigFileRepeat",
  "sourceCode" : "@Test\r\nvoid testParseBigFileRepeat() throws Exception {\r\n    long bestTime = Long.MAX_VALUE;\r\n    for (int i = 0; i < this.max; i++) {\r\n        bestTime = Math.min(testParseBigFile(false), bestTime);\r\n    }\r\n    println(String.format(\"Best time out of %,d is %,d milliseconds.\", this.max, bestTime));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\perf\\PerformanceTest.java",
  "methodName" : "testReadBigFile",
  "sourceCode" : "@Test\r\nvoid testReadBigFile() throws Exception {\r\n    long bestTime = Long.MAX_VALUE;\r\n    long count;\r\n    for (int i = 0; i < this.max; i++) {\r\n        final long startMillis;\r\n        try (BufferedReader in = createBufferedReader()) {\r\n            startMillis = System.currentTimeMillis();\r\n            count = readLines(in);\r\n        }\r\n        final long totalMillis = System.currentTimeMillis() - startMillis;\r\n        bestTime = Math.min(totalMillis, bestTime);\r\n        println(String.format(\"File read in %,d milliseconds: %,d lines.\", totalMillis, count));\r\n    }\r\n    println(String.format(\"Best time out of %,d is %,d milliseconds.\", this.max, bestTime));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\TokenTest.java",
  "methodName" : "testToString",
  "sourceCode" : "@ParameterizedTest\r\n@EnumSource(Token.Type.class)\r\nvoid testToString(final Token.Type type) {\r\n    // Should never blow up\r\n    final Token token = new Token();\r\n    final String resetName = Token.Type.INVALID.name();\r\n    assertTrue(token.toString().contains(resetName));\r\n    token.reset();\r\n    assertTrue(token.toString().contains(resetName));\r\n    token.type = null;\r\n    assertFalse(token.toString().isEmpty());\r\n    token.reset();\r\n    token.type = type;\r\n    assertTrue(token.toString().contains(type.name()));\r\n    token.content.setLength(1000);\r\n    assertTrue(token.toString().contains(type.name()));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\UserGuideTest.java",
  "methodName" : "testBomFull",
  "sourceCode" : "@Test\r\nvoid testBomFull() throws UnsupportedEncodingException, IOException {\r\n    final Path path = tempDir.resolve(\"test1.csv\");\r\n    Files.copy(Utils.createUtf8Input(\"ColumnA, ColumnB, ColumnC\\r\\nA, B, C\\r\\n\".getBytes(StandardCharsets.UTF_8), true), path);\r\n    // @formatter:off\r\n    try (Reader reader = new InputStreamReader(BOMInputStream.builder().setPath(path).get(), \"UTF-8\");\r\n        CSVParser parser = CSVFormat.EXCEL.builder().setHeader().get().parse(reader)) {\r\n        // @formatter:off\r\n        for (final CSVRecord record : parser) {\r\n            final String string = record.get(\"ColumnA\");\r\n            assertEquals(\"A\", string);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-csv\\src\\test\\java\\org\\apache\\commons\\csv\\UserGuideTest.java",
  "methodName" : "testBomUtil",
  "sourceCode" : "@Test\r\nvoid testBomUtil() throws UnsupportedEncodingException, IOException {\r\n    final Path path = tempDir.resolve(\"test2.csv\");\r\n    Files.copy(Utils.createUtf8Input(\"ColumnA, ColumnB, ColumnC\\r\\nA, B, C\\r\\n\".getBytes(StandardCharsets.UTF_8), true), path);\r\n    try (Reader reader = newReader(path);\r\n        // @formatter:off\r\n        CSVParser parser = CSVFormat.EXCEL.builder().setHeader().get().parse(reader)) {\r\n        // @formatter:off\r\n        for (final CSVRecord record : parser) {\r\n            final String string = record.get(\"ColumnA\");\r\n            assertEquals(\"A\", string);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
} ]