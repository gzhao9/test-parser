[ {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveReadTest.java",
  "methodName" : "testArchive",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\nvoid testArchive(final File file) throws Exception {\r\n    // fileList is correct type already\r\n    @SuppressWarnings(\"unchecked\")\r\n    final ArrayList<String> expected = (ArrayList<String>) FILE_LIST.clone();\r\n    assertDoesNotThrow(() -> checkArchiveContent(file, expected), \"Problem checking \" + file);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testCantReadAfterClose",
  "sourceCode" : "@Test\r\nvoid testCantReadAfterClose() throws Exception {\r\n    try (ArArchiveInputStream archive = ArArchiveInputStream.builder().setURI(getURI(\"bla.ar\")).get()) {\r\n        archive.close();\r\n        assertThrows(IllegalStateException.class, () -> archive.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testCantReadWithoutOpeningAnEntry",
  "sourceCode" : "@Test\r\nvoid testCantReadWithoutOpeningAnEntry() throws Exception {\r\n    try (ArArchiveInputStream archive = ArArchiveInputStream.builder().setURI(getURI(\"bla.ar\")).get()) {\r\n        assertThrows(IllegalStateException.class, () -> archive.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testCompress661",
  "sourceCode" : "@Test\r\nvoid testCompress661() throws IOException {\r\n    testCompress661(false);\r\n    testCompress661(true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testGetNextArEntry",
  "sourceCode" : "/**\r\n * Depending on your setup, this test may need a small stack size {@code -Xss1m}.\r\n */\r\n@Test\r\nvoid testGetNextArEntry() throws IOException {\r\n    try (ArArchiveInputStream inputStream = ArArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/ar/getNextArEntry.bin\")).get()) {\r\n        assertThrows(EOFException.class, inputStream::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testInvalidBadTableLength",
  "sourceCode" : "@Test\r\nvoid testInvalidBadTableLength() throws Exception {\r\n    try (ArArchiveInputStream archive = ArArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/ar/number_parsing/bad_table_length_gnu-fail.ar\")).get()) {\r\n        assertThrows(IOException.class, archive::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testInvalidLongNameLength",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { \"bad_long_namelen_bsd-fail.ar\", \"bad_long_namelen_gnu1-fail.ar\", \"bad_long_namelen_gnu2-fail.ar\", \"bad_long_namelen_gnu3-fail.ar\", \"bad_table_length_gnu-fail.ar\" })\r\nvoid testInvalidLongNameLength(final String testFileName) throws Exception {\r\n    try (ArArchiveInputStream archive = ArArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/ar/number_parsing/\" + testFileName)).get()) {\r\n        assertThrows(IOException.class, archive::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testInvalidNumericFields",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { \"bad_group-fail.ar\", \"bad_length-fail.ar\", \"bad_modified-fail.ar\", \"bad_user-fail.ar\" })\r\nvoid testInvalidNumericFields(final String testFileName) throws Exception {\r\n    try (ArArchiveInputStream archive = ArArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/ar/number_parsing/\" + testFileName)).get()) {\r\n        assertThrows(IOException.class, archive::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    final byte[] buf = new byte[2];\r\n    try (ArArchiveInputStream archive = ArArchiveInputStream.builder().setURI(getURI(\"bla.ar\")).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read(buf));\r\n        assertEquals(-1, archive.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testReadLongNamesBSD",
  "sourceCode" : "@Test\r\nvoid testReadLongNamesBSD() throws Exception {\r\n    checkLongNameEntry(\"longfile_bsd.ar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testReadLongNamesGNU",
  "sourceCode" : "@Test\r\nvoid testReadLongNamesGNU() throws Exception {\r\n    checkLongNameEntry(\"longfile_gnu.ar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testSimpleInputStream",
  "sourceCode" : "@Test\r\nvoid testSimpleInputStream() throws IOException {\r\n    try (InputStream fileInputStream = newInputStream(\"bla.ar\");\r\n        // This default implementation of InputStream.available() always returns zero,\r\n        // and there are many streams in practice where the total length of the stream is not known.\r\n        InputStream simpleInputStream = new InputStream() {\r\n\r\n            @Override\r\n            public int read() throws IOException {\r\n                return fileInputStream.read();\r\n            }\r\n        }) {\r\n        try (ArArchiveInputStream archiveInputStream = ArArchiveInputStream.builder().setInputStream(simpleInputStream).get()) {\r\n            final ArArchiveEntry entry1 = archiveInputStream.getNextEntry();\r\n            assertNotNull(entry1);\r\n            assertEquals(\"test1.xml\", entry1.getName());\r\n            assertEquals(610L, entry1.getLength());\r\n            final ArArchiveEntry entry2 = archiveInputStream.getNextEntry();\r\n            assertEquals(\"test2.xml\", entry2.getName());\r\n            assertEquals(82L, entry2.getLength());\r\n            assertNull(archiveInputStream.getNextEntry());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testSimpleInputStreamDeprecated",
  "sourceCode" : "@Test\r\nvoid testSimpleInputStreamDeprecated() throws IOException {\r\n    try (InputStream fileInputStream = newInputStream(\"bla.ar\");\r\n        // This default implementation of InputStream.available() always returns zero,\r\n        // and there are many streams in practice where the total length of the stream is not known.\r\n        InputStream simpleInputStream = new InputStream() {\r\n\r\n            @Override\r\n            public int read() throws IOException {\r\n                return fileInputStream.read();\r\n            }\r\n        }) {\r\n        try (ArArchiveInputStream archiveInputStream = ArArchiveInputStream.builder().setInputStream(simpleInputStream).get()) {\r\n            final ArArchiveEntry entry1 = archiveInputStream.getNextEntry();\r\n            assertNotNull(entry1);\r\n            assertEquals(\"test1.xml\", entry1.getName());\r\n            assertEquals(610L, entry1.getLength());\r\n            final ArArchiveEntry entry2 = archiveInputStream.getNextEntry();\r\n            assertEquals(\"test2.xml\", entry2.getName());\r\n            assertEquals(82L, entry2.getLength());\r\n            assertNull(archiveInputStream.getNextEntry());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testSingleArgumentConstructor",
  "sourceCode" : "@Test\r\nvoid testSingleArgumentConstructor() throws Exception {\r\n    final InputStream inputStream = mock(InputStream.class);\r\n    try (ArArchiveInputStream archiveStream = new ArArchiveInputStream(inputStream)) {\r\n        assertEquals(US_ASCII, archiveStream.getCharset());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    try (ArArchiveInputStream archive = ArArchiveInputStream.builder().setURI(getURI(\"bla.ar\")).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read());\r\n        assertEquals(-1, archive.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveOutputStreamTest.java",
  "methodName" : "testLongFileNamesCauseExceptionByDefault",
  "sourceCode" : "@Test\r\nvoid testLongFileNamesCauseExceptionByDefault() throws IOException {\r\n    final ArArchiveOutputStream ref;\r\n    try (ArArchiveOutputStream outputStream = new ArArchiveOutputStream(new ByteArrayOutputStream())) {\r\n        ref = outputStream;\r\n        final ArArchiveEntry ae = new ArArchiveEntry(\"this_is_a_long_name.txt\", 0);\r\n        final IOException ex = assertThrows(ArchiveException.class, () -> outputStream.putArchiveEntry(ae));\r\n        assertTrue(ex.getMessage().startsWith(\"File name too long\"));\r\n    }\r\n    assertTrue(ref.isClosed());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\ArArchiveOutputStreamTest.java",
  "methodName" : "testLongFileNamesWorkUsingBSDDialect",
  "sourceCode" : "@Test\r\nvoid testLongFileNamesWorkUsingBSDDialect() throws Exception {\r\n    final File file = createTempFile();\r\n    try (ArArchiveOutputStream outputStream = new ArArchiveOutputStream(Files.newOutputStream(file.toPath()))) {\r\n        outputStream.setLongFileMode(ArArchiveOutputStream.LONGFILE_BSD);\r\n        final ArArchiveEntry ae = new ArArchiveEntry(\"this_is_a_long_name.txt\", 14);\r\n        outputStream.putArchiveEntry(ae);\r\n        outputStream.write(new byte[] { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n' });\r\n        outputStream.closeArchiveEntry();\r\n        final List<String> expected = new ArrayList<>();\r\n        expected.add(\"this_is_a_long_name.txt\");\r\n        checkArchiveContent(file, expected);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\Compress678Test.java",
  "methodName" : "test_LONGFILE_BSD",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 15, 16, 17, 18, 32, 64, 128 })\r\nvoid test_LONGFILE_BSD(final int fileNameLen) throws IOException {\r\n    test_LONGFILE_BSD(StringUtils.repeat('x', fileNameLen));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\Compress678Test.java",
  "methodName" : "test_LONGFILE_BSD_with_spaces",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 15, 16, 17, 18, 32, 64, 128 })\r\nvoid test_LONGFILE_BSD_with_spaces(final int fileNameLen) throws IOException {\r\n    test_LONGFILE_BSD(StringUtils.repeat(\"x y\", fileNameLen / 3));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\Compress678Test.java",
  "methodName" : "test_LONGFILE_ERROR",
  "sourceCode" : "@Test\r\nvoid test_LONGFILE_ERROR() throws IOException {\r\n    final File file = new File(\"target/Compress678Test-a.ar\");\r\n    Files.deleteIfExists(file.toPath());\r\n    // First entry's name length is longer than 16 bytes and odd\r\n    final String name1 = \"01234567891234567\";\r\n    // data length is odd.\r\n    final byte[] data = { 1 };\r\n    try (ArArchiveOutputStream arOut = new ArArchiveOutputStream(new FileOutputStream(file))) {\r\n        arOut.setLongFileMode(ArArchiveOutputStream.LONGFILE_ERROR);\r\n        // java.io.IOException: File name too long, > 16 chars: 01234567891234567\r\n        assertThrows(ArchiveException.class, () -> arOut.putArchiveEntry(new ArArchiveEntry(name1, data.length)));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ar\\Compress678Test.java",
  "methodName" : "testShortName",
  "sourceCode" : "@Test\r\nvoid testShortName() throws IOException {\r\n    final File file = new File(\"target/Compress678Test-c.ar\");\r\n    Files.deleteIfExists(file.toPath());\r\n    // First entry's name length is <= than 16 bytes and odd\r\n    final String name1 = \"0123456789123456\";\r\n    // data length is odd.\r\n    final byte[] data = { 1 };\r\n    try (ArArchiveOutputStream arOut = new ArArchiveOutputStream(new FileOutputStream(file))) {\r\n        arOut.setLongFileMode(ArArchiveOutputStream.LONGFILE_BSD);\r\n        // entry 1\r\n        arOut.putArchiveEntry(new ArArchiveEntry(name1, data.length));\r\n        arOut.write(data);\r\n        arOut.closeArchiveEntry();\r\n        // entry 2\r\n        arOut.putArchiveEntry(new ArArchiveEntry(\"a\", data.length));\r\n        arOut.write(data);\r\n        arOut.closeArchiveEntry();\r\n    }\r\n    try (ArArchiveInputStream arIn = ArArchiveInputStream.builder().setFile(file).get()) {\r\n        final ArArchiveEntry entry = arIn.getNextEntry();\r\n        assertEquals(name1, entry.getName());\r\n        assertNotNull(arIn.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveOutputStreamTest.java",
  "methodName" : "testCallSequenceAr",
  "sourceCode" : "@Test\r\nvoid testCallSequenceAr() throws Exception {\r\n    doCallSequence(\"Ar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveOutputStreamTest.java",
  "methodName" : "testCallSequenceCpio",
  "sourceCode" : "@Test\r\nvoid testCallSequenceCpio() throws Exception {\r\n    doCallSequence(\"Cpio\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveOutputStreamTest.java",
  "methodName" : "testCallSequenceJar",
  "sourceCode" : "@Test\r\nvoid testCallSequenceJar() throws Exception {\r\n    doCallSequence(\"Jar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveOutputStreamTest.java",
  "methodName" : "testCallSequenceTar",
  "sourceCode" : "@Test\r\nvoid testCallSequenceTar() throws Exception {\r\n    doCallSequence(\"Tar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveOutputStreamTest.java",
  "methodName" : "testCallSequenceZip",
  "sourceCode" : "@Test\r\nvoid testCallSequenceZip() throws Exception {\r\n    doCallSequence(\"Zip\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveOutputStreamTest.java",
  "methodName" : "testFinish",
  "sourceCode" : "@Test\r\nvoid testFinish() throws Exception {\r\n    final OutputStream out1 = new ByteArrayOutputStream();\r\n    try (ArchiveOutputStream<? super ArchiveEntry> aios = factory.createArchiveOutputStream(\"zip\", out1)) {\r\n        aios.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\r\n        assertThrows(ArchiveException.class, () -> aios.finish(), \"After putArchiveEntry() should follow closeArchiveEntry()\");\r\n        aios.closeArchiveEntry();\r\n    }\r\n    try (ArchiveOutputStream<JarArchiveEntry> aios = factory.createArchiveOutputStream(\"jar\", out1)) {\r\n        aios.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\r\n        assertThrows(ArchiveException.class, () -> aios.finish(), \"After putArchiveEntry() should follow closeArchiveEntry()\");\r\n        aios.closeArchiveEntry();\r\n    }\r\n    try (ArchiveOutputStream<ArArchiveEntry> aios = factory.createArchiveOutputStream(\"ar\", out1)) {\r\n        aios.putArchiveEntry(new ArArchiveEntry(\"dummy\", 100));\r\n        assertThrows(ArchiveException.class, () -> aios.finish(), \"After putArchiveEntry() should follow closeArchiveEntry()\");\r\n        aios.closeArchiveEntry();\r\n    }\r\n    try (ArchiveOutputStream<CpioArchiveEntry> aios = factory.createArchiveOutputStream(\"cpio\", out1)) {\r\n        aios.putArchiveEntry(new CpioArchiveEntry(\"dummy\"));\r\n        assertThrows(ArchiveException.class, () -> aios.finish(), \"After putArchiveEntry() should follow closeArchiveEntry()\");\r\n        aios.closeArchiveEntry();\r\n    }\r\n    try (ArchiveOutputStream<TarArchiveEntry> aios = factory.createArchiveOutputStream(\"tar\", out1)) {\r\n        aios.putArchiveEntry(new TarArchiveEntry(\"dummy\"));\r\n        assertThrows(ArchiveException.class, () -> aios.finish(), \"After putArchiveEntry() should follow closeArchiveEntry()\");\r\n        aios.closeArchiveEntry();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveOutputStreamTest.java",
  "methodName" : "testOptionalFinish",
  "sourceCode" : "@Test\r\nvoid testOptionalFinish() throws Exception {\r\n    final OutputStream out1 = new ByteArrayOutputStream();\r\n    try (ArchiveOutputStream<ZipArchiveEntry> aos1 = factory.createArchiveOutputStream(\"zip\", out1)) {\r\n        aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\r\n        aos1.closeArchiveEntry();\r\n    }\r\n    final ArchiveOutputStream<JarArchiveEntry> finishTest;\r\n    try (ArchiveOutputStream<JarArchiveEntry> aos1 = factory.createArchiveOutputStream(\"jar\", out1)) {\r\n        finishTest = aos1;\r\n        aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\r\n        aos1.closeArchiveEntry();\r\n    }\r\n    assertThrows(ArchiveException.class, () -> finishTest.finish(), \"finish() cannot follow close()\");\r\n    finishTest.close();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveServiceLoaderTest.java",
  "methodName" : "testInputStream",
  "sourceCode" : "@Test\r\nvoid testInputStream() {\r\n    assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"ArchiveTestInput1\", new ByteArrayInputStream(new byte[] {})));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveServiceLoaderTest.java",
  "methodName" : "testOutputStream",
  "sourceCode" : "@Test\r\nvoid testOutputStream() {\r\n    assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"ArchiveTestOutput1\", new ByteArrayOutputStream()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testAiffFilesAreNoTARs",
  "sourceCode" : "/**\r\n * see https://issues.apache.org/jira/browse/COMPRESS-191\r\n */\r\n@Test\r\nvoid testAiffFilesAreNoTARs() throws Exception {\r\n    try (InputStream fis = newInputStream(\"testAIFF.aif\");\r\n        InputStream is = new BufferedInputStream(fis)) {\r\n        final ArchiveException ae = assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(is), \"created an input stream for a non-archive\");\r\n        assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testCantRead7zFromStream",
  "sourceCode" : "@Test\r\nvoid testCantRead7zFromStream() throws Exception {\r\n    assertThrows(StreamingNotSupportedException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(ArchiveStreamFactory.SEVEN_Z, new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testCantWrite7zToStream",
  "sourceCode" : "@Test\r\nvoid testCantWrite7zToStream() throws Exception {\r\n    assertThrows(StreamingNotSupportedException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(ArchiveStreamFactory.SEVEN_Z, new ByteArrayOutputStream()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testCOMPRESS209",
  "sourceCode" : "@Test\r\nvoid testCOMPRESS209() throws Exception {\r\n    try (InputStream fis = newInputStream(\"testCompress209.doc\");\r\n        InputStream bis = new BufferedInputStream(fis)) {\r\n        final ArchiveException ae = assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(bis), \"created an input stream for a non-archive\");\r\n        assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testDetect",
  "sourceCode" : "@Test\r\nvoid testDetect() throws Exception {\r\n    for (final String extension : new String[] { ArchiveStreamFactory.AR, ArchiveStreamFactory.ARJ, ArchiveStreamFactory.CPIO, ArchiveStreamFactory.DUMP, // Compress doesn't know how to detect JARs, see COMPRESS-91\r\n    // ArchiveStreamFactory.JAR,\r\n    ArchiveStreamFactory.SEVEN_Z, ArchiveStreamFactory.TAR, ArchiveStreamFactory.ZIP }) {\r\n        assertEquals(extension, detect(\"bla.\" + extension));\r\n    }\r\n    final ArchiveException e1 = assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY))), \"shouldn't be able to detect empty stream\");\r\n    assertEquals(\"No Archiver found for the stream signature\", e1.getMessage());\r\n    final IllegalArgumentException e2 = assertThrows(IllegalArgumentException.class, () -> ArchiveStreamFactory.detect(null), \"shouldn't be able to detect null stream\");\r\n    assertEquals(\"Stream must not be null.\", e2.getMessage());\r\n    final ArchiveException e3 = assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.detect(new BufferedInputStream(new BrokenInputStream())), \"Expected ArchiveException\");\r\n    assertEquals(\"Failure reading signature.\", e3.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testDetectsAndThrowsFor7z",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-267\">COMPRESS-267</a>.\r\n */\r\n@Test\r\nvoid testDetectsAndThrowsFor7z() throws Exception {\r\n    try (InputStream fis = newInputStream(\"bla.7z\");\r\n        InputStream bis = new BufferedInputStream(fis)) {\r\n        final StreamingNotSupportedException ex = assertThrows(StreamingNotSupportedException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(bis), \"Expected a StreamingNotSupportedException\");\r\n        assertEquals(ArchiveStreamFactory.SEVEN_Z, ex.getFormat());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testEncodingCtor",
  "sourceCode" : "@Test\r\nvoid testEncodingCtor() {\r\n    ArchiveStreamFactory fac = new ArchiveStreamFactory();\r\n    assertNull(fac.getEntryEncoding());\r\n    fac = new ArchiveStreamFactory(null);\r\n    assertNull(fac.getEntryEncoding());\r\n    fac = new ArchiveStreamFactory(StandardCharsets.UTF_8.name());\r\n    assertEquals(StandardCharsets.UTF_8.name(), fac.getEntryEncoding());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testEncodingDeprecated",
  "sourceCode" : "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid testEncodingDeprecated() {\r\n    final ArchiveStreamFactory fac1 = new ArchiveStreamFactory();\r\n    assertNull(fac1.getEntryEncoding());\r\n    fac1.setEntryEncoding(StandardCharsets.UTF_8.name());\r\n    assertEquals(StandardCharsets.UTF_8.name(), fac1.getEntryEncoding());\r\n    fac1.setEntryEncoding(StandardCharsets.US_ASCII.name());\r\n    assertEquals(StandardCharsets.US_ASCII.name(), fac1.getEntryEncoding());\r\n    final ArchiveStreamFactory fac2 = new ArchiveStreamFactory(StandardCharsets.UTF_8.name());\r\n    assertEquals(StandardCharsets.UTF_8.name(), fac2.getEntryEncoding());\r\n    fac2.setEntryEncoding(StandardCharsets.US_ASCII.name());\r\n    assertEquals(StandardCharsets.US_ASCII.name(), fac2.getEntryEncoding());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testEncodingInputStream",
  "sourceCode" : "@Test\r\nvoid testEncodingInputStream() throws Exception {\r\n    int failed = 0;\r\n    for (int i = 1; i <= TESTS.length; i++) {\r\n        final TestData test = TESTS[i - 1];\r\n        try (ArchiveInputStream<?> ais = getInputStream(test.type, test.testFile, test.fac)) {\r\n            final String field = getCharsetName(ais);\r\n            if (!Objects.equals(field, field)) {\r\n                System.err.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\r\n                failed++;\r\n            }\r\n        }\r\n    }\r\n    if (failed > 0) {\r\n        fail(\"Tests failed: \" + failed + \" out of \" + TESTS.length);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testEncodingInputStreamAutodetect",
  "sourceCode" : "@Test\r\nvoid testEncodingInputStreamAutodetect() throws Exception {\r\n    int failed = 0;\r\n    for (int i = 1; i <= TESTS.length; i++) {\r\n        final TestData test = TESTS[i - 1];\r\n        try (ArchiveInputStream<?> ais = getInputStream(test.testFile, test.fac)) {\r\n            final String field = getCharsetName(ais);\r\n            if (!Objects.equals(field, field)) {\r\n                System.err.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\r\n                failed++;\r\n            }\r\n        }\r\n    }\r\n    if (failed > 0) {\r\n        fail(\"Tests failed: \" + failed + \" out of \" + TESTS.length);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testEncodingOutputStream",
  "sourceCode" : "@Test\r\nvoid testEncodingOutputStream() throws Exception {\r\n    int failed = 0;\r\n    for (int i = 1; i <= TESTS.length; i++) {\r\n        final TestData test = TESTS[i - 1];\r\n        if (test.hasOutputStream) {\r\n            try (ArchiveOutputStream<?> ais = getOutputStream(test.type, test.fac)) {\r\n                final String field = getFieldAsString(ais, test.fieldName);\r\n                if (!Objects.equals(field, field)) {\r\n                    System.err.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\r\n                    failed++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (failed > 0) {\r\n        fail(\"Tests failed: \" + failed + \" out of \" + TESTS.length);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testIcoFilesAreNoTARs",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"getIcoPathStream\")\r\nvoid testIcoFilesAreNoTARs(final Path path) throws Exception {\r\n    try (InputStream fis = Files.newInputStream(path);\r\n        InputStream is = new BufferedInputStream(fis)) {\r\n        final ArchiveException ae = assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.detect(is), \"created an input stream for a non-archive\");\r\n        assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\r\n    }\r\n    try (InputStream fis = Files.newInputStream(path);\r\n        InputStream is = new BufferedInputStream(fis)) {\r\n        final ArchiveException ae = assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(is), \"created an input stream for a non-archive\");\r\n        assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testShortTextFilesAreNoTARs",
  "sourceCode" : "/**\r\n * See https://issues.apache.org/jira/browse/COMPRESS-171\r\n */\r\n@Test\r\nvoid testShortTextFilesAreNoTARs() {\r\n    final ArchiveException ae = assertThrows(ArchiveException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes())), \"created an input stream for a non-archive\");\r\n    assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testSkipsPK00Prefix",
  "sourceCode" : "/**\r\n * Tests case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-208\">COMPRESS-208</a>.\r\n */\r\n@Test\r\nvoid testSkipsPK00Prefix() throws Exception {\r\n    try (InputStream fis = newInputStream(\"COMPRESS-208.zip\")) {\r\n        try (InputStream bis = new BufferedInputStream(fis)) {\r\n            try (ArchiveInputStream<?> ais = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(bis)) {\r\n                assertInstanceOf(ZipArchiveInputStream.class, ais);\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testTarContainingDirWith1TxtFileIsTAR",
  "sourceCode" : "@Test\r\nvoid testTarContainingDirWith1TxtFileIsTAR() throws IOException, ArchiveException {\r\n    assertEquals(ArchiveStreamFactory.TAR, detect(\"dirWith1TxtFile.tar\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testTarContainingEmptyDirIsTAR",
  "sourceCode" : "@Test\r\nvoid testTarContainingEmptyDirIsTAR() throws IOException, ArchiveException {\r\n    assertEquals(ArchiveStreamFactory.TAR, detect(\"emptyDir.tar\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArchiveStreamFactoryTest.java",
  "methodName" : "testUtf16TextIsNotTAR",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-674\">COMPRESS-674</a>.\r\n */\r\n@Test\r\nvoid testUtf16TextIsNotTAR() {\r\n    final ArchiveException archiveException = assertThrows(ArchiveException.class, () -> detect(\"utf16-text.txt\"));\r\n    assertEquals(\"No Archiver found for the stream signature\", archiveException.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testFirstHeaderSizeSetToZero",
  "sourceCode" : "@Test\r\nvoid testFirstHeaderSizeSetToZero() {\r\n    final ArchiveException ex = assertThrows(ArchiveException.class, () -> {\r\n        try (ArjArchiveInputStream archive = ArjArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/arj/zero_sized_headers-fail.arj\")).get()) {\r\n            // Do nothing, ArchiveException already thrown\r\n            fail(\"ArchiveException not thrown.\");\r\n        }\r\n    });\r\n    assertTrue(ex.getCause() instanceof IOException);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testForEach",
  "sourceCode" : "@Test\r\nvoid testForEach() throws Exception {\r\n    final StringBuilder expected = new StringBuilder();\r\n    expected.append(\"test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>\\n\");\r\n    final StringBuilder result = new StringBuilder();\r\n    try (ArjArchiveInputStream in = ArjArchiveInputStream.builder().setURI(getURI(\"bla.arj\")).get()) {\r\n        in.forEach(entry -> {\r\n            result.append(entry.getName());\r\n            int tmp;\r\n            // read() one at a time\r\n            while ((tmp = in.read()) != -1) {\r\n                result.append((char) tmp);\r\n            }\r\n            assertFalse(entry.isDirectory());\r\n            assertArjArchiveEntry(entry);\r\n        });\r\n    }\r\n    assertEquals(expected.toString(), result.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testGetNextEntry",
  "sourceCode" : "@Test\r\nvoid testGetNextEntry() throws Exception {\r\n    final StringBuilder expected = new StringBuilder();\r\n    expected.append(\"test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>\\n\");\r\n    final StringBuilder result = new StringBuilder();\r\n    try (ArjArchiveInputStream in = ArjArchiveInputStream.builder().setURI(getURI(\"bla.arj\")).get()) {\r\n        ArjArchiveEntry entry;\r\n        while ((entry = in.getNextEntry()) != null) {\r\n            result.append(entry.getName());\r\n            int tmp;\r\n            // read() one at a time\r\n            while ((tmp = in.read()) != -1) {\r\n                result.append((char) tmp);\r\n            }\r\n            assertFalse(entry.isDirectory());\r\n            assertArjArchiveEntry(entry);\r\n        }\r\n    }\r\n    assertEquals(expected.toString(), result.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    final byte[] buf = new byte[2];\r\n    try (ArjArchiveInputStream archive = ArjArchiveInputStream.builder().setURI(getURI(\"bla.arj\")).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read(buf));\r\n        assertEquals(-1, archive.read(buf));\r\n        assertForEach(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testRead",
  "sourceCode" : "@Test\r\nvoid testRead() throws Exception {\r\n    final StringBuilder expected = new StringBuilder();\r\n    expected.append(\"test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>\\n\");\r\n    final Charset charset = Charset.defaultCharset();\r\n    try (ByteArrayOutputStream result = new ByteArrayOutputStream();\r\n        ArjArchiveInputStream in = ArjArchiveInputStream.builder().setURI(getURI(\"bla.arj\")).get()) {\r\n        ArjArchiveEntry entry;\r\n        while ((entry = in.getNextEntry()) != null) {\r\n            result.write(entry.getName().getBytes(charset));\r\n            int tmp;\r\n            // read() one at a time\r\n            while ((tmp = in.read()) != -1) {\r\n                result.write(tmp);\r\n            }\r\n            assertFalse(entry.isDirectory());\r\n            assertArjArchiveEntry(entry);\r\n        }\r\n        result.flush();\r\n        assertEquals(expected.toString(), result.toString(charset));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testReadByteArray",
  "sourceCode" : "@Test\r\nvoid testReadByteArray() throws Exception {\r\n    final StringBuilder expected = new StringBuilder();\r\n    expected.append(\"test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>\\n\");\r\n    final Charset charset = Charset.defaultCharset();\r\n    try (ByteArrayOutputStream result = new ByteArrayOutputStream();\r\n        ArjArchiveInputStream in = ArjArchiveInputStream.builder().setURI(getURI(\"bla.arj\")).get()) {\r\n        in.forEach(entry -> {\r\n            result.write(entry.getName().getBytes(charset));\r\n            final byte[] tmp = new byte[2];\r\n            // read(byte[]) at a time\r\n            int count;\r\n            while ((count = in.read(tmp)) != -1) {\r\n                result.write(tmp, 0, count);\r\n            }\r\n            assertFalse(entry.isDirectory());\r\n            assertArjArchiveEntry(entry);\r\n        });\r\n        result.flush();\r\n        assertEquals(expected.toString(), result.toString(charset));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testReadByteArrayIndex",
  "sourceCode" : "@Test\r\nvoid testReadByteArrayIndex() throws Exception {\r\n    final StringBuilder expected = new StringBuilder();\r\n    expected.append(\"test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>\\n\");\r\n    final Charset charset = Charset.defaultCharset();\r\n    try (ByteArrayOutputStream result = new ByteArrayOutputStream();\r\n        ArjArchiveInputStream in = ArjArchiveInputStream.builder().setURI(getURI(\"bla.arj\")).get()) {\r\n        in.forEach(entry -> {\r\n            result.write(entry.getName().getBytes(charset));\r\n            final byte[] tmp = new byte[10];\r\n            // read(byte[],int,int) at a time\r\n            int count;\r\n            while ((count = in.read(tmp, 0, 2)) != -1) {\r\n                result.write(tmp, 0, count);\r\n            }\r\n            assertFalse(entry.isDirectory());\r\n            assertArjArchiveEntry(entry);\r\n        });\r\n        result.flush();\r\n        assertEquals(expected.toString(), result.toString(charset));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testReadingOfAttributesDosVersion",
  "sourceCode" : "@Test\r\nvoid testReadingOfAttributesDosVersion() throws Exception {\r\n    try (ArjArchiveInputStream archive = ArjArchiveInputStream.builder().setURI(getURI(\"bla.arj\")).get()) {\r\n        final ArjArchiveEntry entry = archive.getNextEntry();\r\n        assertEquals(\"test1.xml\", entry.getName());\r\n        assertEquals(30, entry.getSize());\r\n        assertEquals(0, entry.getUnixMode());\r\n        final Calendar cal = Calendar.getInstance();\r\n        cal.set(2008, 9, 6, 23, 50, 52);\r\n        cal.set(Calendar.MILLISECOND, 0);\r\n        assertEquals(cal.getTime(), entry.getLastModifiedDate());\r\n        assertForEach(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testReadingOfAttributesUnixVersion",
  "sourceCode" : "@Test\r\nvoid testReadingOfAttributesUnixVersion() throws Exception {\r\n    try (ArjArchiveInputStream in = ArjArchiveInputStream.builder().setURI(getURI(\"bla.unix.arj\")).get()) {\r\n        final ArjArchiveEntry entry = in.getNextEntry();\r\n        assertEquals(\"test1.xml\", entry.getName());\r\n        assertEquals(30, entry.getSize());\r\n        assertEquals(0664, entry.getUnixMode() & 07777);\r\n        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT+0000\"));\r\n        cal.set(2008, 9, 6, 21, 50, 52);\r\n        cal.set(Calendar.MILLISECOND, 0);\r\n        assertEquals(cal.getTime(), entry.getLastModifiedDate());\r\n        assertForEach(in);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testSingleArgumentConstructor",
  "sourceCode" : "@Test\r\nvoid testSingleArgumentConstructor() throws Exception {\r\n    try (InputStream inputStream = Files.newInputStream(getPath(\"bla.arj\"));\r\n        ArjArchiveInputStream archiveStream = new ArjArchiveInputStream(inputStream)) {\r\n        assertEquals(Charset.forName(\"CP437\"), archiveStream.getCharset());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\ArjArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    try (ArjArchiveInputStream archive = ArjArchiveInputStream.builder().setURI(getURI(\"bla.arj\")).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read());\r\n        assertEquals(-1, archive.read());\r\n        assertForEach(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\CoverageTest.java",
  "methodName" : "testCallLFHToString",
  "sourceCode" : "@Test\r\nvoid testCallLFHToString() {\r\n    final LocalFileHeader lfh = new LocalFileHeader();\r\n    assertNotNull(lfh.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\CoverageTest.java",
  "methodName" : "testHeaderInstances",
  "sourceCode" : "@Test\r\nvoid testHeaderInstances() {\r\n    assertNotNull(new LocalFileHeader.FileTypes());\r\n    assertNotNull(new LocalFileHeader.Methods());\r\n    assertNotNull(new LocalFileHeader.Flags());\r\n    assertNotNull(new MainHeader.Flags());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\arj\\CoverageTest.java",
  "methodName" : "testHostOsInstance",
  "sourceCode" : "@Test\r\nvoid testHostOsInstance() {\r\n    final HostOs hostOs = new HostOs();\r\n    assertNotNull(hostOs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArTest.java",
  "methodName" : "testArArchiveCreation",
  "sourceCode" : "@Test\r\nvoid testArArchiveCreation() throws Exception {\r\n    final File output = newTempFile(\"bla.ar\");\r\n    final File file1 = getFile(\"test1.xml\");\r\n    final File file2 = getFile(\"test2.xml\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath());\r\n        ArArchiveOutputStream os = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"ar\", out)) {\r\n        // file 1\r\n        os.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\r\n        os.write(file1);\r\n        os.closeArchiveEntry();\r\n        // file 2\r\n        os.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\r\n        os.write(file2);\r\n        os.closeArchiveEntry();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArTest.java",
  "methodName" : "testArDelete",
  "sourceCode" : "@Test\r\nvoid testArDelete() throws Exception {\r\n    final File output = newTempFile(\"bla.ar\");\r\n    final File file1 = getFile(\"test1.xml\");\r\n    final File file2 = getFile(\"test2.xml\");\r\n    {\r\n        // create\r\n        try (OutputStream out = Files.newOutputStream(output.toPath());\r\n            ArchiveOutputStream<ArArchiveEntry> os = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"ar\", out)) {\r\n            // file 1\r\n            os.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\r\n            os.write(file1);\r\n            os.closeArchiveEntry();\r\n            // file 2\r\n            os.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\r\n            os.write(file2);\r\n            os.closeArchiveEntry();\r\n        }\r\n    }\r\n    assertEquals(8 + 60 + file1.length() + file1.length() % 2 + 60 + file2.length() + file2.length() % 2, output.length());\r\n    final File output2 = newTempFile(\"bla2.ar\");\r\n    int copied = 0;\r\n    int deleted = 0;\r\n    // remove all but one file\r\n    try (OutputStream os = Files.newOutputStream(output2.toPath());\r\n        InputStream is = Files.newInputStream(output.toPath());\r\n        ArchiveOutputStream<ArArchiveEntry> aos = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", os);\r\n        ArchiveInputStream<ArArchiveEntry> ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is))) {\r\n        while (true) {\r\n            final ArArchiveEntry entry = ais.getNextEntry();\r\n            if (entry == null) {\r\n                break;\r\n            }\r\n            if (\"test1.xml\".equals(entry.getName())) {\r\n                aos.putArchiveEntry(entry);\r\n                IOUtils.copy(ais, aos);\r\n                aos.closeArchiveEntry();\r\n                copied++;\r\n            } else {\r\n                IOUtils.copy(ais, new ByteArrayOutputStream());\r\n                deleted++;\r\n            }\r\n        }\r\n    }\r\n    assertEquals(1, copied);\r\n    assertEquals(1, deleted);\r\n    assertEquals(8 + 60 + file1.length() + file1.length() % 2, output2.length());\r\n    long files = 0;\r\n    long sum = 0;\r\n    {\r\n        try (InputStream is = Files.newInputStream(output2.toPath());\r\n            ArchiveInputStream<ArArchiveEntry> ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is))) {\r\n            while (true) {\r\n                final ArArchiveEntry entry = ais.getNextEntry();\r\n                if (entry == null) {\r\n                    break;\r\n                }\r\n                IOUtils.copy(ais, new ByteArrayOutputStream());\r\n                sum += entry.getLength();\r\n                files++;\r\n            }\r\n        }\r\n    }\r\n    assertEquals(1, files);\r\n    assertEquals(file1.length(), sum);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArTest.java",
  "methodName" : "testArUnarchive",
  "sourceCode" : "@Test\r\nvoid testArUnarchive() throws Exception {\r\n    final File output = newTempFile(\"bla.ar\");\r\n    {\r\n        final File file1 = getFile(\"test1.xml\");\r\n        final File file2 = getFile(\"test2.xml\");\r\n        try (OutputStream out = Files.newOutputStream(output.toPath());\r\n            ArchiveOutputStream<ArArchiveEntry> os = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"ar\", out)) {\r\n            // file 1\r\n            os.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\r\n            os.write(file1);\r\n            os.closeArchiveEntry();\r\n            // file 2\r\n            os.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\r\n            os.write(file2);\r\n            os.closeArchiveEntry();\r\n        }\r\n    }\r\n    // UnArArchive Operation\r\n    try (InputStream is = Files.newInputStream(output.toPath());\r\n        ArchiveInputStream<ArArchiveEntry> in = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is))) {\r\n        final ArArchiveEntry entry = in.getNextEntry();\r\n        final File target = newTempFile(entry.getName());\r\n        Files.copy(in, target.toPath());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArTest.java",
  "methodName" : "testExplicitFileEntry",
  "sourceCode" : "@Test\r\nvoid testExplicitFileEntry() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".ar\");\r\n    try (ArArchiveOutputStream aos = new ArArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final ArArchiveEntry in = new ArArchiveEntry(\"foo\", file.length(), 0, 0, 0, file.lastModified() / 1000);\r\n        aos.putArchiveEntry(in);\r\n        aos.write(file);\r\n        aos.closeArchiveEntry();\r\n    }\r\n    //\r\n    final ArArchiveEntry out;\r\n    try (ArArchiveInputStream ais = ArArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = ais.getNextEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo\", out.getName());\r\n    assertEquals(file.length(), out.getSize());\r\n    assertEquals(file.lastModified() / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertFalse(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArTest.java",
  "methodName" : "testFileEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testFileEntryFromFile() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".ar\");\r\n    try (ArArchiveOutputStream aos = new ArArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final ArArchiveEntry in = new ArArchiveEntry(file, \"foo\");\r\n        aos.putArchiveEntry(in);\r\n        aos.write(file);\r\n        aos.closeArchiveEntry();\r\n    }\r\n    final ArArchiveEntry out;\r\n    try (ArArchiveInputStream ais = ArArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = ais.getNextEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo\", out.getName());\r\n    assertEquals(file.length(), out.getSize());\r\n    // AR stores time with a granularity of 1 second\r\n    assertEquals(file.lastModified() / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertFalse(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArTest.java",
  "methodName" : "testFileEntryFromPath",
  "sourceCode" : "@Test\r\nvoid testFileEntryFromPath() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".ar\");\r\n    try (ArArchiveOutputStream aos = new ArArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final ArArchiveEntry in = new ArArchiveEntry(file.toPath(), \"foo\");\r\n        aos.putArchiveEntry(in);\r\n        aos.write(file);\r\n        aos.closeArchiveEntry();\r\n    }\r\n    final ArArchiveEntry out;\r\n    try (ArArchiveInputStream ais = ArArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = ais.getNextEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo\", out.getName());\r\n    assertEquals(file.length(), out.getSize());\r\n    // AR stores time with a granularity of 1 second\r\n    assertEquals(file.lastModified() / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertFalse(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArTest.java",
  "methodName" : "testXtestDirectoryEntryFromFile",
  "sourceCode" : "// TODO: revisit - does AR not support storing directories?\r\n@Disabled\r\n@Test\r\nvoid testXtestDirectoryEntryFromFile() throws Exception {\r\n    final File tmp = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".ar\");\r\n    final long beforeArchiveWrite;\r\n    try (ArArchiveOutputStream aos = new ArArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        beforeArchiveWrite = tmp.lastModified();\r\n        final ArArchiveEntry in = new ArArchiveEntry(tmp, \"foo\");\r\n        aos.putArchiveEntry(in);\r\n        aos.closeArchiveEntry();\r\n    }\r\n    final ArArchiveEntry out;\r\n    try (ArArchiveInputStream ais = ArArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = ais.getNextEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo/\", out.getName());\r\n    assertEquals(0, out.getSize());\r\n    // AR stores time with a granularity of 1 second\r\n    assertEquals(beforeArchiveWrite / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertTrue(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ArTest.java",
  "methodName" : "testXtestExplicitDirectoryEntry",
  "sourceCode" : "// TODO: revisit - does AR not support storing directories?\r\n@Disabled\r\n@Test\r\nvoid testXtestExplicitDirectoryEntry() throws Exception {\r\n    final File tmp = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".ar\");\r\n    final long beforeArchiveWrite;\r\n    try (ArArchiveOutputStream aos = new ArArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        beforeArchiveWrite = getTempDirFile().lastModified();\r\n        final ArArchiveEntry in = new ArArchiveEntry(\"foo\", 0, 0, 0, 0, tmp.lastModified() / 1000);\r\n        aos.putArchiveEntry(in);\r\n        aos.closeArchiveEntry();\r\n    }\r\n    final ArArchiveEntry out;\r\n    try (ArArchiveInputStream ais = ArArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = ais.getNextEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo/\", out.getName());\r\n    assertEquals(0, out.getSize());\r\n    assertEquals(beforeArchiveWrite / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertTrue(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveEntryTest.java",
  "methodName" : "testGetHeaderPadCountOverflow",
  "sourceCode" : "@Test\r\nvoid testGetHeaderPadCountOverflow() throws Exception {\r\n    final CpioArchiveEntry entry = new CpioArchiveEntry(CpioConstants.FORMAT_NEW);\r\n    entry.setName(\"test name\");\r\n    assertThrows(ArchiveException.class, () -> entry.getHeaderPadCount(Long.MAX_VALUE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testCpioUnarchive",
  "sourceCode" : "@Test\r\nvoid testCpioUnarchive() throws Exception {\r\n    final StringBuilder expected = new StringBuilder();\r\n    expected.append(\"./test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>./test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\r\n    expected.append(\"<empty/>\\n\");\r\n    final StringBuilder result = new StringBuilder();\r\n    try (CpioArchiveInputStream in = CpioArchiveInputStream.builder().setURI(getURI(\"bla.cpio\")).get()) {\r\n        CpioArchiveEntry entry;\r\n        while ((entry = in.getNextEntry()) != null) {\r\n            result.append(entry.getName());\r\n            int tmp;\r\n            while ((tmp = in.read()) != -1) {\r\n                result.append((char) tmp);\r\n            }\r\n        }\r\n    }\r\n    assertEquals(result.toString(), expected.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testCpioUnarchiveCreatedByRedlineRpm",
  "sourceCode" : "@Test\r\nvoid testCpioUnarchiveCreatedByRedlineRpm() throws Exception {\r\n    long count = 0;\r\n    try (CpioArchiveInputStream in = CpioArchiveInputStream.builder().setURI(getURI(\"redline.cpio\")).get()) {\r\n        count = consumeEntries(in);\r\n    }\r\n    assertEquals(count, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testCpioUnarchiveMultibyteCharName",
  "sourceCode" : "@Test\r\nvoid testCpioUnarchiveMultibyteCharName() throws Exception {\r\n    long count = 0;\r\n    try (CpioArchiveInputStream in = CpioArchiveInputStream.builder().setURI(getURI(\"COMPRESS-459.cpio\")).setCharset(StandardCharsets.UTF_8).get()) {\r\n        count = consumeEntries(in);\r\n    }\r\n    assertEquals(2, count);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testEndOfFileInEntry_c_namesize_0x7FFFFFFF",
  "sourceCode" : "@Test\r\nvoid testEndOfFileInEntry_c_namesize_0x7FFFFFFF() throws Exception {\r\n    // CPIO header with c_namesize = 0x7FFFFFFF\r\n    // @formatter:off\r\n    final String header = // c_magic\r\n    \"070701\" + // c_ino\r\n    \"00000000\" + // c_mode\r\n    \"000081A4\" + // c_uid\r\n    \"00000000\" + // c_gid\r\n    \"00000000\" + // c_nlink\r\n    \"00000001\" + // c_mtime\r\n    \"00000000\" + // c_filesize\r\n    \"00000000\" + // c_devmajor\r\n    \"00000000\" + // c_devminor\r\n    \"00000000\" + // c_rdevmajor\r\n    \"00000000\" + // c_rdevminor\r\n    \"00000000\" + // c_namesize\r\n    \"7FFFFFFF\" + // c_check\r\n    \"00000000\";\r\n    // @formatter:on\r\n    final byte[] data = new byte[header.getBytes(StandardCharsets.US_ASCII).length + 1];\r\n    System.arraycopy(header.getBytes(), 0, data, 0, header.getBytes().length);\r\n    try (CpioArchiveInputStream cpio = CpioArchiveInputStream.builder().setByteArray(data).get()) {\r\n        assertThrows(MemoryLimitException.class, () -> cpio.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testEndOfFileInEntry_c_namesize_0xFFFFFFFF",
  "sourceCode" : "@Test\r\nvoid testEndOfFileInEntry_c_namesize_0xFFFFFFFF() throws Exception {\r\n    // CPIO header with c_namesize = 0xFFFFFFFF\r\n    // @formatter:off\r\n    final String header = // c_magic\r\n    \"070701\" + // c_ino\r\n    \"00000000\" + // c_mode\r\n    \"000081A4\" + // c_uid\r\n    \"00000000\" + // c_gid\r\n    \"00000000\" + // c_nlink\r\n    \"00000001\" + // c_mtime\r\n    \"00000000\" + // c_filesize\r\n    \"00000000\" + // c_devmajor\r\n    \"00000000\" + // c_devminor\r\n    \"00000000\" + // c_rdevmajor\r\n    \"00000000\" + // c_rdevminor\r\n    \"00000000\" + // c_namesize\r\n    \"FFFFFFFF\" + // c_check\r\n    \"00000000\";\r\n    // @formatter:on\r\n    final byte[] data = new byte[header.getBytes(StandardCharsets.US_ASCII).length + 1];\r\n    System.arraycopy(header.getBytes(), 0, data, 0, header.getBytes().length);\r\n    try (CpioArchiveInputStream cpio = CpioArchiveInputStream.builder().setByteArray(data).get()) {\r\n        assertThrows(ArchiveException.class, () -> cpio.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testInvalidLongValueInMetadata",
  "sourceCode" : "@Test\r\nvoid testInvalidLongValueInMetadata() throws Exception {\r\n    try (CpioArchiveInputStream archive = CpioArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/cpio/bad_long_value.cpio\")).get()) {\r\n        assertThrows(IOException.class, archive::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    final byte[] buf = new byte[2];\r\n    try (CpioArchiveInputStream archive = CpioArchiveInputStream.builder().setURI(getURI(\"bla.cpio\")).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read(buf));\r\n        assertEquals(-1, archive.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testSingleArgumentConstructor",
  "sourceCode" : "@Test\r\nvoid testSingleArgumentConstructor() throws Exception {\r\n    final InputStream inputStream = mock(InputStream.class);\r\n    try (CpioArchiveInputStream archiveStream = new CpioArchiveInputStream(inputStream)) {\r\n        assertEquals(StandardCharsets.US_ASCII, archiveStream.getCharset());\r\n        assertEquals(512, readDeclaredField(archiveStream, \"blockSize\", true));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    try (CpioArchiveInputStream archive = CpioArchiveInputStream.builder().setURI(getURI(\"bla.cpio\")).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read());\r\n        assertEquals(-1, archive.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveOutputStreamTest.java",
  "methodName" : "testWriteOldBinary",
  "sourceCode" : "@Test\r\nvoid testWriteOldBinary() throws Exception {\r\n    final File file = getFile(\"test1.xml\");\r\n    final File output = newTempFile(\"test.cpio\");\r\n    final CpioArchiveOutputStream ref;\r\n    try (CpioArchiveOutputStream outputStream = new CpioArchiveOutputStream(Files.newOutputStream(output.toPath()), CpioConstants.FORMAT_OLD_BINARY)) {\r\n        ref = outputStream;\r\n        outputStream.putArchiveEntry(new CpioArchiveEntry(CpioConstants.FORMAT_OLD_BINARY, file, \"test1.xml\"));\r\n        outputStream.write(file);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    assertTrue(ref.isClosed());\r\n    try (CpioArchiveInputStream in = CpioArchiveInputStream.builder().setFile(output).get()) {\r\n        final CpioArchiveEntry e = in.getNextCPIOEntry();\r\n        assertEquals(\"test1.xml\", e.getName());\r\n        assertNull(in.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveTest.java",
  "methodName" : "utf18RoundtripTestCtor2",
  "sourceCode" : "@Test\r\nvoid utf18RoundtripTestCtor2() throws Exception {\r\n    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\r\n        try (CpioArchiveOutputStream os = new CpioArchiveOutputStream(baos, StandardCharsets.UTF_8.name())) {\r\n            final CpioArchiveEntry entry = new CpioArchiveEntry(\"Test.txt\", 4);\r\n            os.putArchiveEntry(entry);\r\n            os.write(new byte[] { 1, 2, 3, 4 });\r\n            os.closeArchiveEntry();\r\n        }\r\n        baos.close();\r\n        try (CpioArchiveInputStream in = CpioArchiveInputStream.builder().setByteArray(baos.toByteArray()).setCharset(StandardCharsets.UTF_8).get()) {\r\n            final CpioArchiveEntry entry = in.getNextEntry();\r\n            assertNotNull(entry);\r\n            assertEquals(\"Test.txt\", entry.getName());\r\n            assertArrayEquals(new byte[] { 1, 2, 3, 4 }, IOUtils.toByteArray(in));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveTest.java",
  "methodName" : "utf18RoundtripTestCtor3",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void utf18RoundtripTestCtor3(final short format) throws Exception {\r\n    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\r\n        try (CpioArchiveOutputStream os = new CpioArchiveOutputStream(baos, format, CpioConstants.BLOCK_SIZE)) {\r\n            final CpioArchiveEntry entry = new CpioArchiveEntry(format, \"T\\u00e4st.txt\", 4);\r\n            if (format == CpioConstants.FORMAT_NEW_CRC) {\r\n                entry.setChksum(10);\r\n            }\r\n            os.putArchiveEntry(entry);\r\n            os.write(new byte[] { 1, 2, 3, 4 });\r\n            os.closeArchiveEntry();\r\n        }\r\n        baos.close();\r\n        try (CpioArchiveInputStream in = CpioArchiveInputStream.builder().setByteArray(baos.toByteArray()).get()) {\r\n            final CpioArchiveEntry entry = in.getNextEntry();\r\n            assertNotNull(entry);\r\n            assertEquals(\"T%U00E4st.txt\", entry.getName());\r\n            assertArrayEquals(new byte[] { 1, 2, 3, 4 }, IOUtils.toByteArray(in));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioArchiveTest.java",
  "methodName" : "utf18RoundtripTestCtor4",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void utf18RoundtripTestCtor4(final short format) throws Exception {\r\n    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\r\n        try (CpioArchiveOutputStream os = new CpioArchiveOutputStream(baos, format, CpioConstants.BLOCK_SIZE, StandardCharsets.UTF_16LE.name())) {\r\n            final CpioArchiveEntry entry = new CpioArchiveEntry(format, \"T\\u00e4st.txt\", 4);\r\n            if (format == CpioConstants.FORMAT_NEW_CRC) {\r\n                entry.setChksum(10);\r\n            }\r\n            os.putArchiveEntry(entry);\r\n            os.write(new byte[] { 1, 2, 3, 4 });\r\n            os.closeArchiveEntry();\r\n        }\r\n        baos.close();\r\n        try (CpioArchiveInputStream in = CpioArchiveInputStream.builder().setByteArray(baos.toByteArray()).setCharset(StandardCharsets.UTF_16LE).get()) {\r\n            final CpioArchiveEntry entry = in.getNextEntry();\r\n            assertNotNull(entry);\r\n            assertEquals(\"T\\u00e4st.txt\", entry.getName());\r\n            assertArrayEquals(new byte[] { 1, 2, 3, 4 }, IOUtils.toByteArray(in));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioUtilTest.java",
  "methodName" : "testByteArray2longThrowsUnsupportedOperationException",
  "sourceCode" : "@Test\r\nvoid testByteArray2longThrowsUnsupportedOperationException() {\r\n    assertThrows(UnsupportedOperationException.class, () -> CpioUtil.byteArray2long(new byte[1], true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioUtilTest.java",
  "methodName" : "testLong2byteArrayWithPositiveThrowsUnsupportedOperationException",
  "sourceCode" : "@Test\r\nvoid testLong2byteArrayWithPositiveThrowsUnsupportedOperationException() {\r\n    assertThrows(UnsupportedOperationException.class, () -> CpioUtil.long2byteArray(0L, 1021, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioUtilTest.java",
  "methodName" : "testLong2byteArrayWithZeroThrowsUnsupportedOperationException",
  "sourceCode" : "@Test\r\nvoid testLong2byteArrayWithZeroThrowsUnsupportedOperationException() {\r\n    assertThrows(UnsupportedOperationException.class, () -> CpioUtil.long2byteArray(0L, 0, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioUtilTest.java",
  "methodName" : "testOldBinMagic2ByteArrayNotSwapped",
  "sourceCode" : "@Test\r\nvoid testOldBinMagic2ByteArrayNotSwapped() {\r\n    assertArrayEquals(new byte[] { (byte) 0xc7, 0x71 }, CpioUtil.long2byteArray(CpioConstants.MAGIC_OLD_BINARY, 2, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioUtilTest.java",
  "methodName" : "testOldBinMagic2ByteArraySwapped",
  "sourceCode" : "@Test\r\nvoid testOldBinMagic2ByteArraySwapped() {\r\n    assertArrayEquals(new byte[] { 0x71, (byte) 0xc7 }, CpioUtil.long2byteArray(CpioConstants.MAGIC_OLD_BINARY, 2, true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioUtilTest.java",
  "methodName" : "testOldBinMagicFromByteArrayNotSwapped",
  "sourceCode" : "@Test\r\nvoid testOldBinMagicFromByteArrayNotSwapped() {\r\n    assertEquals(CpioConstants.MAGIC_OLD_BINARY, CpioUtil.byteArray2long(new byte[] { (byte) 0xc7, 0x71 }, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\cpio\\CpioUtilTest.java",
  "methodName" : "testOldBinMagicFromByteArraySwapped",
  "sourceCode" : "@Test\r\nvoid testOldBinMagicFromByteArraySwapped() {\r\n    assertEquals(CpioConstants.MAGIC_OLD_BINARY, CpioUtil.byteArray2long(new byte[] { 0x71, (byte) 0xc7 }, true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\CpioTest.java",
  "methodName" : "testCpioArchiveCreation",
  "sourceCode" : "@Test\r\nvoid testCpioArchiveCreation() throws Exception {\r\n    final File output = newTempFile(\"bla.cpio\");\r\n    final File file1 = getFile(\"test1.xml\");\r\n    final File file2 = getFile(\"test2.xml\");\r\n    try (OutputStream outputStream = Files.newOutputStream(output.toPath());\r\n        ArchiveOutputStream<CpioArchiveEntry> archiveOutputStream = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"cpio\", outputStream)) {\r\n        // file 1\r\n        archiveOutputStream.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\r\n        archiveOutputStream.write(file1);\r\n        archiveOutputStream.closeArchiveEntry();\r\n        // file 2\r\n        archiveOutputStream.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\r\n        archiveOutputStream.write(file2);\r\n        archiveOutputStream.closeArchiveEntry();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\CpioTest.java",
  "methodName" : "testCpioUnarchive",
  "sourceCode" : "@Test\r\nvoid testCpioUnarchive() throws Exception {\r\n    final File output = newTempFile(\"bla.cpio\");\r\n    final File file1 = getFile(\"test1.xml\");\r\n    final File file2 = getFile(\"test2.xml\");\r\n    final long file1Length = file1.length();\r\n    final long file2Length = file2.length();\r\n    try (OutputStream outputStream = Files.newOutputStream(output.toPath());\r\n        ArchiveOutputStream<CpioArchiveEntry> archiveOutputStream = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"cpio\", outputStream)) {\r\n        // file 1\r\n        CpioArchiveEntry entry = new CpioArchiveEntry(\"test1.xml\", file1Length);\r\n        entry.setMode(CpioConstants.C_ISREG);\r\n        archiveOutputStream.putArchiveEntry(entry);\r\n        archiveOutputStream.write(file1);\r\n        archiveOutputStream.closeArchiveEntry();\r\n        // file 2\r\n        entry = new CpioArchiveEntry(\"test2.xml\", file2Length);\r\n        entry.setMode(CpioConstants.C_ISREG);\r\n        archiveOutputStream.putArchiveEntry(entry);\r\n        archiveOutputStream.write(file2);\r\n        archiveOutputStream.closeArchiveEntry();\r\n        archiveOutputStream.finish();\r\n        archiveOutputStream.close();\r\n        outputStream.close();\r\n    }\r\n    // Unarchive Operation\r\n    final Map<String, File> result = new HashMap<>();\r\n    try (InputStream inputStream = Files.newInputStream(output.toPath());\r\n        ArchiveInputStream<?> archiveInputStream = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"cpio\", inputStream)) {\r\n        archiveInputStream.forEach(entry -> {\r\n            final File cpioget = newTempFile(entry.getName());\r\n            Files.copy(archiveInputStream, cpioget.toPath());\r\n            result.put(entry.getName(), cpioget);\r\n        });\r\n    }\r\n    File testFile = result.get(\"test1.xml\");\r\n    assertTrue(testFile.exists(), \"Expected \" + testFile.getAbsolutePath() + \" to exist\");\r\n    assertEquals(file1Length, testFile.length(), \"length of \" + testFile.getAbsolutePath());\r\n    testFile = result.get(\"test2.xml\");\r\n    assertTrue(testFile.exists(), \"Expected \" + testFile.getAbsolutePath() + \" to exist\");\r\n    assertEquals(file2Length, testFile.length(), \"length of \" + testFile.getAbsolutePath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\CpioTest.java",
  "methodName" : "testDirectoryEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testDirectoryEntryFromFile() throws Exception {\r\n    final File archive = createTempFile(\"test.\", \".cpio\");\r\n    final File dir = getTempDirFile();\r\n    final long beforeArchiveWrite = dir.lastModified();\r\n    final CpioArchiveEntry entryIn = new CpioArchiveEntry(dir, \"foo\");\r\n    try (CpioArchiveOutputStream tos = new CpioArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        tos.putArchiveEntry(entryIn);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final CpioArchiveEntry entryOut;\r\n    try (CpioArchiveInputStream tis = CpioArchiveInputStream.builder().setFile(archive).get()) {\r\n        entryOut = tis.getNextCPIOEntry();\r\n    }\r\n    assertNotNull(entryOut);\r\n    assertEquals(\"foo\", entryOut.getName());\r\n    assertEquals(0, entryOut.getSize());\r\n    // CPIO stores time with a granularity of 1 second\r\n    assertEquals(beforeArchiveWrite / 1000, entryOut.getLastModifiedDate().getTime() / 1000);\r\n    assertTrue(entryOut.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\CpioTest.java",
  "methodName" : "testExplicitDirectoryEntry",
  "sourceCode" : "@Test\r\nvoid testExplicitDirectoryEntry() throws Exception {\r\n    final File archive = createTempFile(\"test.\", \".cpio\");\r\n    final long beforeArchiveWrite;\r\n    try (CpioArchiveOutputStream tos = new CpioArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        beforeArchiveWrite = getTempDirFile().lastModified();\r\n        final CpioArchiveEntry in = new CpioArchiveEntry(\"foo/\");\r\n        in.setTime(beforeArchiveWrite / 1000);\r\n        in.setMode(CpioConstants.C_ISDIR);\r\n        tos.putArchiveEntry(in);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final CpioArchiveEntry out;\r\n    try (CpioArchiveInputStream tis = CpioArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = tis.getNextCPIOEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo/\", out.getName());\r\n    assertEquals(0, out.getSize());\r\n    assertEquals(beforeArchiveWrite / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertTrue(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\CpioTest.java",
  "methodName" : "testExplicitFileEntry",
  "sourceCode" : "@Test\r\nvoid testExplicitFileEntry() throws Exception {\r\n    final File tmp = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".cpio\");\r\n    try (CpioArchiveOutputStream tos = new CpioArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final CpioArchiveEntry in = new CpioArchiveEntry(\"foo\");\r\n        in.setTime(tmp.lastModified() / 1000);\r\n        in.setSize(tmp.length());\r\n        in.setMode(CpioConstants.C_ISREG);\r\n        tos.putArchiveEntry(in);\r\n        tos.write(tmp);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final CpioArchiveEntry out;\r\n    try (CpioArchiveInputStream tis = CpioArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = tis.getNextCPIOEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo\", out.getName());\r\n    assertEquals(tmp.length(), out.getSize());\r\n    assertEquals(tmp.lastModified() / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertFalse(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\CpioTest.java",
  "methodName" : "testFileEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testFileEntryFromFile() throws Exception {\r\n    final File tmp = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".cpio\");\r\n    try (CpioArchiveOutputStream tos = new CpioArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final CpioArchiveEntry in = new CpioArchiveEntry(tmp, \"foo\");\r\n        tos.putArchiveEntry(in);\r\n        tos.write(tmp);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final CpioArchiveEntry out;\r\n    try (CpioArchiveInputStream tis = CpioArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = tis.getNextCPIOEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo\", out.getName());\r\n    assertEquals(tmp.length(), out.getSize());\r\n    assertEquals(tmp.lastModified() / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertFalse(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\CpioTest.java",
  "methodName" : "testSymbolicLinkFileEntry",
  "sourceCode" : "/**\r\n * Tests COMPRESS-690.\r\n */\r\n@Test\r\nvoid testSymbolicLinkFileEntry() throws Exception {\r\n    final File tmp = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".cpio\");\r\n    final String name = \"EntryName\";\r\n    final String nameLink = \"LinkName\";\r\n    final Charset charset = StandardCharsets.UTF_8;\r\n    try (CpioArchiveOutputStream tos = new CpioArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final CpioArchiveEntry entry = new CpioArchiveEntry(name);\r\n        entry.setTime(tmp.lastModified() / 1000);\r\n        entry.setSize(nameLink.length());\r\n        entry.setMode(CpioConstants.C_ISLNK);\r\n        assertTrue(entry.isSymbolicLink());\r\n        tos.putArchiveEntry(entry);\r\n        tos.write(nameLink.getBytes(charset));\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final CpioArchiveEntry entry;\r\n    try (CpioArchiveInputStream tis = CpioArchiveInputStream.builder().setFile(archive).get()) {\r\n        entry = tis.getNextEntry();\r\n        assertEquals(nameLink, IOUtils.toString(tis, charset));\r\n    }\r\n    assertNotNull(entry);\r\n    assertEquals(name, entry.getName());\r\n    assertTrue(entry.isSymbolicLink());\r\n    assertEquals(nameLink.length(), entry.getSize());\r\n    assertEquals(tmp.lastModified() / 1000, entry.getLastModifiedDate().getTime() / 1000);\r\n    assertFalse(entry.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveEntryTest.java",
  "methodName" : "testPublicNameAddsTrailingSlashForDirectories",
  "sourceCode" : "@Test\r\nvoid testPublicNameAddsTrailingSlashForDirectories() {\r\n    final DumpArchiveEntry ent = new DumpArchiveEntry(\"foo\", \"bar\", -1, DumpArchiveEntry.TYPE.DIRECTORY);\r\n    assertEquals(\"bar\", ent.getSimpleName());\r\n    assertEquals(\"foo\", ent.getOriginalName());\r\n    assertEquals(\"foo/\", ent.getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveEntryTest.java",
  "methodName" : "testPublicNameRemovesLeadingDotSlash",
  "sourceCode" : "@Test\r\nvoid testPublicNameRemovesLeadingDotSlash() {\r\n    final DumpArchiveEntry ent = new DumpArchiveEntry(\"./foo\", \"bar\");\r\n    assertEquals(\"bar\", ent.getSimpleName());\r\n    assertEquals(\"./foo\", ent.getOriginalName());\r\n    assertEquals(\"foo\", ent.getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "checkSupportedRecordSizes",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 1, 10, 32, 1024 })\r\nvoid checkSupportedRecordSizes(final int ntrec) throws Exception {\r\n    try (DumpArchiveInputStream dump = DumpArchiveInputStream.builder().setByteArray(createArchive(ntrec)).get()) {\r\n        final DumpArchiveSummary summary = dump.getSummary();\r\n        assertNotNull(summary);\r\n        assertEquals(ntrec, summary.getNTRec());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "checkUnsupportedRecordSizes",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { Integer.MIN_VALUE, -1, 0, 1025, Integer.MAX_VALUE })\r\nvoid checkUnsupportedRecordSizes(final int ntrec) throws Exception {\r\n    final ArchiveException ex = assertThrows(ArchiveException.class, () -> DumpArchiveInputStream.builder().setByteArray(createArchive(ntrec)).get());\r\n    assertInstanceOf(ArchiveException.class, ex.getCause());\r\n    assertTrue(ex.getMessage().contains(Integer.toString(ntrec)), \"message should contain the invalid ntrec value\");\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testConsumesArchiveCompletely",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testConsumesArchiveCompletely() throws Exception {\r\n    try (InputStream is = DumpArchiveInputStreamTest.class.getResourceAsStream(\"/archive_with_trailer.dump\");\r\n        DumpArchiveInputStream dump = DumpArchiveInputStream.builder().setInputStream(is).get()) {\r\n        while (dump.getNextDumpEntry() != null) {\r\n            // just consume the archive\r\n        }\r\n        final byte[] expected = { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n' };\r\n        final byte[] actual = new byte[expected.length];\r\n        is.read(actual);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testDirectoryNullBytes",
  "sourceCode" : "@Test\r\nvoid testDirectoryNullBytes() throws Exception {\r\n    try (DumpArchiveInputStream archive = DumpArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/dump/directory_null_bytes-fail.dump\")).get()) {\r\n        assertThrows(InvalidFormatException.class, archive::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testGetNextEntry",
  "sourceCode" : "@Test\r\nvoid testGetNextEntry() throws IOException {\r\n    try (DumpArchiveInputStream inputStream = DumpArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/dump/getNextEntry.bin\")).get()) {\r\n        assertThrows(ArchiveException.class, inputStream::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testInvalidCompressType",
  "sourceCode" : "@Test\r\nvoid testInvalidCompressType() {\r\n    final ArchiveException ex = assertThrows(ArchiveException.class, () -> DumpArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/dump/invalid_compression_type-fail.dump\")).get().close());\r\n    assertInstanceOf(UnsupportedCompressionAlgorithmException.class, ex.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testLoopingInodes",
  "sourceCode" : "@Test\r\n@Timeout(value = 15, unit = TimeUnit.SECONDS, threadMode = ThreadMode.SEPARATE_THREAD)\r\nvoid testLoopingInodes() throws Exception {\r\n    try (DumpArchiveInputStream archive = DumpArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/dump/looping_inodes-fail.dump\")).get()) {\r\n        archive.getNextEntry();\r\n        assertThrows(DumpArchiveException.class, archive::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    final byte[] buf = new byte[2];\r\n    try (DumpArchiveInputStream archive = DumpArchiveInputStream.builder().setURI(getURI(\"bla.dump\")).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read(buf));\r\n        assertEquals(-1, archive.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testNotADumpArchive",
  "sourceCode" : "@Test\r\nvoid testNotADumpArchive() {\r\n    final ArchiveException ex = assertThrows(ArchiveException.class, () -> DumpArchiveInputStream.builder().setURI(getURI(\"bla.zip\")).get().close(), \"expected an exception\");\r\n    assertTrue(ex.getCause() instanceof ShortFileException);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testNotADumpArchiveButBigEnough",
  "sourceCode" : "@Test\r\nvoid testNotADumpArchiveButBigEnough() throws Exception {\r\n    final ArchiveException ex = assertThrows(ArchiveException.class, () -> DumpArchiveInputStream.builder().setURI(getURI(\"zip64support.tar.bz2\")).get().close(), \"expected an exception\");\r\n    assertInstanceOf(UnrecognizedFormatException.class, ex.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testRecLenZeroLongExecution",
  "sourceCode" : "@Test\r\nvoid testRecLenZeroLongExecution() throws Exception {\r\n    try (DumpArchiveInputStream archive = DumpArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/dump/reclen_zero-fail.dump\")).get()) {\r\n        assertTimeoutPreemptively(Duration.ofSeconds(20), () -> {\r\n            assertThrows(DumpArchiveException.class, archive::getNextEntry);\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testSingleArgumentConstructor",
  "sourceCode" : "@Test\r\nvoid testSingleArgumentConstructor() throws Exception {\r\n    try (InputStream inputStream = Files.newInputStream(getPath(\"bla.dump\"));\r\n        DumpArchiveInputStream archiveStream = new DumpArchiveInputStream(inputStream)) {\r\n        assertEquals(Charset.defaultCharset(), archiveStream.getCharset());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    try (DumpArchiveInputStream archive = DumpArchiveInputStream.builder().setURI(getURI(\"bla.dump\")).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read());\r\n        assertEquals(-1, archive.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveUtilTest.java",
  "methodName" : "testConvert16",
  "sourceCode" : "@Test\r\nvoid testConvert16() {\r\n    assertEquals(0xABCD, DumpArchiveUtil.convert16(new byte[] { (byte) 0xCD, (byte) 0xAB }, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveUtilTest.java",
  "methodName" : "testConvert32",
  "sourceCode" : "@Test\r\nvoid testConvert32() {\r\n    assertEquals(0xABCDEF01, DumpArchiveUtil.convert32(new byte[] { 1, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB }, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveUtilTest.java",
  "methodName" : "testConvert64",
  "sourceCode" : "@Test\r\nvoid testConvert64() {\r\n    assertEquals(0xABCDEF0123456780L, DumpArchiveUtil.convert64(new byte[] { (byte) 0x80, 0x67, 0x45, 0x23, 1, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB }, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveUtilTest.java",
  "methodName" : "testDecodeInvalidArguments",
  "sourceCode" : "@Test\r\nvoid testDecodeInvalidArguments() {\r\n    assertThrows(ArchiveException.class, () -> DumpArchiveUtil.decode(null, new byte[10], 10, -1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveUtilTest.java",
  "methodName" : "testVerifyNoMagic",
  "sourceCode" : "@Test\r\nvoid testVerifyNoMagic() {\r\n    assertFalse(DumpArchiveUtil.verify(new byte[32]));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\DumpArchiveUtilTest.java",
  "methodName" : "testVerifyNullArgument",
  "sourceCode" : "@Test\r\nvoid testVerifyNullArgument() {\r\n    assertFalse(DumpArchiveUtil.verify(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\TapeInputStreamTest.java",
  "methodName" : "testResetBlockSizeArchiveException",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { -1, 0 })\r\nvoid testResetBlockSizeArchiveException(final int recsPerBlock) throws Exception {\r\n    try (TapeInputStream tapeInputStream = new TapeInputStream(new ByteArrayInputStream(new byte[1]))) {\r\n        assertThrows(ArchiveException.class, () -> tapeInputStream.resetBlockSize(recsPerBlock, true));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\TapeInputStreamTest.java",
  "methodName" : "testResetBlockSizeBadSignature",
  "sourceCode" : "@Test\r\nvoid testResetBlockSizeBadSignature() {\r\n    assertThrows(ArchiveException.class, () -> DumpArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/dump/resetBlockSize.bin\")).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\dump\\TapeInputStreamTest.java",
  "methodName" : "testResetBlockSizeMemoryLimit",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { Integer.MAX_VALUE / 1000, Integer.MAX_VALUE })\r\nvoid testResetBlockSizeMemoryLimit(final int recsPerBlock) throws Exception {\r\n    try (TapeInputStream tapeInputStream = new TapeInputStream(new ByteArrayInputStream(new byte[1]))) {\r\n        // CompressException works from both the Maven command line and within Eclipse\r\n        assertThrows(CompressException.class, () -> tapeInputStream.resetBlockSize(recsPerBlock, true));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\DumpTest.java",
  "methodName" : "testArchiveDetection",
  "sourceCode" : "@Test\r\nvoid testArchiveDetection() throws Exception {\r\n    archiveDetection(getFile(\"bla.dump\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\DumpTest.java",
  "methodName" : "testCheckArchive",
  "sourceCode" : "@Test\r\nvoid testCheckArchive() throws Exception {\r\n    checkDumpArchive(getFile(\"bla.dump\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\DumpTest.java",
  "methodName" : "testCheckCompressedArchive",
  "sourceCode" : "@Test\r\nvoid testCheckCompressedArchive() throws Exception {\r\n    checkDumpArchive(getFile(\"bla.z.dump\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\DumpTest.java",
  "methodName" : "testCompressedArchiveDetection",
  "sourceCode" : "@Test\r\nvoid testCompressedArchiveDetection() throws Exception {\r\n    archiveDetection(getFile(\"bla.z.dump\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\DumpTest.java",
  "methodName" : "testCompressedDumpUnarchiveAll",
  "sourceCode" : "@Test\r\nvoid testCompressedDumpUnarchiveAll() throws Exception {\r\n    unarchiveAll(getFile(\"bla.z.dump\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\DumpTest.java",
  "methodName" : "testDumpUnarchiveAll",
  "sourceCode" : "@Test\r\nvoid testDumpUnarchiveAll() throws Exception {\r\n    unarchiveAll(getFile(\"bla.dump\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testCompress603Tar",
  "sourceCode" : "@Test\r\nvoid testCompress603Tar() throws IOException, ArchiveException {\r\n    setupTarForCompress603();\r\n    try (TarFile f = new TarFile(archive)) {\r\n        new Expander().expand(f, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testFileCantEscapeDoubleDotPath",
  "sourceCode" : "@Test\r\nvoid testFileCantEscapeDoubleDotPath() throws IOException, ArchiveException {\r\n    setupZip(\"../foo\");\r\n    try (ZipFile f = ZipFile.builder().setFile(archive).get()) {\r\n        assertThrows(ArchiveException.class, () -> new Expander().expand(f, tempResultDir));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testFileCantEscapeDoubleDotPathWithSimilarSibling",
  "sourceCode" : "@Test\r\nvoid testFileCantEscapeDoubleDotPathWithSimilarSibling() throws IOException, ArchiveException {\r\n    final String sibling = tempResultDir.getName() + \"x\";\r\n    final File s = new File(tempResultDir.getParentFile(), sibling);\r\n    assumeFalse(s.exists());\r\n    s.mkdirs();\r\n    assumeTrue(s.exists());\r\n    setupZip(\"../\" + sibling + \"/a\");\r\n    try (ZipFile f = ZipFile.builder().setFile(archive).get()) {\r\n        assertThrows(ArchiveException.class, () -> new Expander().expand(f, tempResultDir));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testFileCantEscapeViaAbsolutePath",
  "sourceCode" : "@Test\r\nvoid testFileCantEscapeViaAbsolutePath() throws IOException, ArchiveException {\r\n    setupZip(\"/tmp/foo\");\r\n    try (ZipFile f = ZipFile.builder().setFile(archive).get()) {\r\n        assertThrows(ArchiveException.class, () -> new Expander().expand(f, tempResultDir));\r\n    }\r\n    assertFalse(new File(tempResultDir, \"tmp/foo\").isFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testSevenZChannelVersion",
  "sourceCode" : "@Test\r\nvoid testSevenZChannelVersion() throws IOException, ArchiveException {\r\n    setup7z();\r\n    try (SeekableByteChannel c = FileChannel.open(archive.toPath(), StandardOpenOption.READ)) {\r\n        new Expander().expand(\"7z\", c, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testSevenZFileVersion",
  "sourceCode" : "@Test\r\nvoid testSevenZFileVersion() throws IOException {\r\n    setup7z();\r\n    try (SevenZFile file = SevenZFile.builder().setFile(archive).get()) {\r\n        new Expander().expand(file, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testSevenZInputStreamVersion",
  "sourceCode" : "@Test\r\nvoid testSevenZInputStreamVersion() throws IOException {\r\n    setup7z();\r\n    try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\r\n        assertThrows(StreamingNotSupportedException.class, () -> new Expander().expand(\"7z\", i, tempResultDir));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testSevenZInputStreamVersionWithAutoDetection",
  "sourceCode" : "@Test\r\nvoid testSevenZInputStreamVersionWithAutoDetection() throws IOException {\r\n    setup7z();\r\n    try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\r\n        assertThrows(StreamingNotSupportedException.class, () -> new Expander().expand(i, tempResultDir));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testSevenZTwoFileVersion",
  "sourceCode" : "@Test\r\nvoid testSevenZTwoFileVersion() throws IOException, ArchiveException {\r\n    setup7z();\r\n    new Expander().expand(\"7z\", archive, tempResultDir);\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testSevenZTwoFileVersionWithAutoDetection",
  "sourceCode" : "@Test\r\nvoid testSevenZTwoFileVersionWithAutoDetection() throws IOException, ArchiveException {\r\n    setup7z();\r\n    new Expander().expand(archive, tempResultDir);\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testTarFileVersion",
  "sourceCode" : "@Test\r\nvoid testTarFileVersion() throws IOException, ArchiveException {\r\n    setupTar();\r\n    try (TarFile f = new TarFile(archive)) {\r\n        new Expander().expand(f, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ExpanderTest.java",
  "methodName" : "testZipFileVersion",
  "sourceCode" : "@Test\r\nvoid testZipFileVersion() throws IOException, ArchiveException {\r\n    setupZip();\r\n    try (ZipFile f = ZipFile.builder().setFile(archive).get()) {\r\n        new Expander().expand(f, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedArchiverTest.java",
  "methodName" : "archiveStreamVersion",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void archiveStreamVersion(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    try (OutputStream os = Files.newOutputStream(target.toPath());\r\n        ArchiveOutputStream<?> aos = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(format, os)) {\r\n        new Archiver().create(aos, getTempDirFile());\r\n    }\r\n    verifyContent(format);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedArchiverTest.java",
  "methodName" : "channelVersion",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void channelVersion(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    try (SeekableByteChannel c = FileChannel.open(target.toPath(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\r\n        new Archiver().create(format, c, getTempDirFile());\r\n    }\r\n    verifyContent(format);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedArchiverTest.java",
  "methodName" : "fileVersion",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void fileVersion(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    new Archiver().create(format, target, getTempDirFile());\r\n    verifyContent(format);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedArchiverTest.java",
  "methodName" : "outputStreamVersion",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void outputStreamVersion(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    try (OutputStream os = Files.newOutputStream(target.toPath())) {\r\n        new Archiver().create(format, os, getTempDirFile());\r\n    }\r\n    verifyContent(format);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedExpanderTest.java",
  "methodName" : "archiveInputStreamVersion",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void archiveInputStreamVersion(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()));\r\n        ArchiveInputStream<?> ais = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(format, i)) {\r\n        new Expander().expand(ais, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedExpanderTest.java",
  "methodName" : "channelVersion",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void channelVersion(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    try (SeekableByteChannel c = FileChannel.open(archive.toPath(), StandardOpenOption.READ)) {\r\n        new Expander().expand(format, c, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedExpanderTest.java",
  "methodName" : "fileVersion",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void fileVersion(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    new Expander().expand(format, archive, tempResultDir);\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedExpanderTest.java",
  "methodName" : "fileVersionWithAutoDetection",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void fileVersionWithAutoDetection(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    new Expander().expand(archive, tempResultDir);\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedExpanderTest.java",
  "methodName" : "inputStreamVersion",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void inputStreamVersion(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\r\n        new Expander().expand(format, i, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\ParameterizedExpanderTest.java",
  "methodName" : "inputStreamVersionWithAutoDetection",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\npublic void inputStreamVersionWithAutoDetection(final String format) throws Exception {\r\n    // TODO How to parameterize a BeforeEach method?\r\n    setUp(format);\r\n    try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\r\n        new Expander().expand(i, tempResultDir);\r\n    }\r\n    verifyTargetDir();\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\SevenZArchiverTest.java",
  "methodName" : "testChannelVersion",
  "sourceCode" : "@Test\r\nvoid testChannelVersion() throws IOException, ArchiveException {\r\n    try (SeekableByteChannel c = FileChannel.open(target.toPath(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\r\n        new Archiver().create(\"7z\", c, getTempDirFile());\r\n    }\r\n    verifyContent();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\SevenZArchiverTest.java",
  "methodName" : "testFileVersion",
  "sourceCode" : "@Test\r\nvoid testFileVersion() throws IOException, ArchiveException {\r\n    new Archiver().create(\"7z\", target, getTempDirFile());\r\n    verifyContent();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\SevenZArchiverTest.java",
  "methodName" : "testOutputStreamVersion",
  "sourceCode" : "@Test\r\nvoid testOutputStreamVersion() throws IOException {\r\n    try (OutputStream os = Files.newOutputStream(target.toPath())) {\r\n        assertThrows(StreamingNotSupportedException.class, () -> new Archiver().create(\"7z\", os, getTempDirFile()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\examples\\SevenZArchiverTest.java",
  "methodName" : "testUnknownFormat",
  "sourceCode" : "// not really a 7z test, but I didn't feel like adding a new test just for this\r\n@Test\r\nvoid testUnknownFormat() throws IOException {\r\n    try (SeekableByteChannel c = FileChannel.open(target.toPath(), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\r\n        assertThrows(ArchiveException.class, () -> new Archiver().create(\"unknown format\", c, getTempDirFile()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ExceptionMessageTest.java",
  "methodName" : "testMessageWhenArchiverNameIsNull_1",
  "sourceCode" : "@Test\r\nvoid testMessageWhenArchiverNameIsNull_1() {\r\n    final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(null, System.in), \"Should raise an IllegalArgumentException.\");\r\n    assertEquals(ARCHIVER_NULL_MESSAGE, e.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ExceptionMessageTest.java",
  "methodName" : "testMessageWhenArchiverNameIsNull_2",
  "sourceCode" : "@Test\r\nvoid testMessageWhenArchiverNameIsNull_2() {\r\n    final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(null, System.out), \"Should raise an IllegalArgumentException.\");\r\n    assertEquals(ARCHIVER_NULL_MESSAGE, e.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ExceptionMessageTest.java",
  "methodName" : "testMessageWhenInputStreamIsNull",
  "sourceCode" : "@Test\r\nvoid testMessageWhenInputStreamIsNull() {\r\n    final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"zip\", null), \"Should raise an IllegalArgumentException.\");\r\n    assertEquals(INPUTSTREAM_NULL_MESSAGE, e.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ExceptionMessageTest.java",
  "methodName" : "testMessageWhenOutputStreamIsNull",
  "sourceCode" : "@Test\r\nvoid testMessageWhenOutputStreamIsNull() {\r\n    final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"zip\", null), \"Should raise an IllegalArgumentException.\");\r\n    assertEquals(OUTPUTSTREAM_NULL_MESSAGE, e.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\jar\\ExpandApkTest.java",
  "methodName" : "test",
  "sourceCode" : "@Test\r\nvoid test() throws IOException {\r\n    Streams.failableStream(PathUtils.walk(Paths.get(\"src/test/resources/android\"), new SuffixFileFilter(\".\" + ArchiveStreamFactory.APK, IOCase.INSENSITIVE), 100, false)).forEach(path -> new Expander().expand(ArchiveStreamFactory.APK, println(path), null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\jar\\JarArchiveInputStreamTest.java",
  "methodName" : "testSingleArgumentConstructor",
  "sourceCode" : "@Test\r\nvoid testSingleArgumentConstructor() throws IOException {\r\n    final InputStream inputStream = mock(InputStream.class);\r\n    try (JarArchiveInputStream archiveInputStream = new JarArchiveInputStream(inputStream)) {\r\n        assertEquals(UTF_8, archiveInputStream.getCharset());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\jar\\JarArchiveOutputStreamTest.java",
  "methodName" : "testJarMarker",
  "sourceCode" : "@Test\r\nvoid testJarMarker() throws IOException {\r\n    final Path testArchive = createTempPath(\"jar-aostest\", \".jar\");\r\n    try (JarArchiveOutputStream out = new JarArchiveOutputStream(Files.newOutputStream(testArchive))) {\r\n        final ZipArchiveEntry ze1 = new ZipArchiveEntry(\"foo/\");\r\n        // Ensure we won't accidentally add an Extra field.\r\n        ze1.setTime(Instant.parse(\"2022-12-27T12:10:23Z\").toEpochMilli());\r\n        out.putArchiveEntry(ze1);\r\n        out.closeArchiveEntry();\r\n        final ZipArchiveEntry ze2 = new ZipArchiveEntry(\"bar/\");\r\n        // Ensure we won't accidentally add an Extra field.\r\n        ze2.setTime(Instant.parse(\"2022-12-28T02:56:01Z\").toEpochMilli());\r\n        out.putArchiveEntry(ze2);\r\n        out.closeArchiveEntry();\r\n        out.finish();\r\n    }\r\n    try (ZipFile zf = ZipFile.builder().setPath(testArchive).get()) {\r\n        ZipArchiveEntry ze = zf.getEntry(\"foo/\");\r\n        assertNotNull(ze);\r\n        ZipExtraField[] fes = ze.getExtraFields();\r\n        assertEquals(1, fes.length);\r\n        assertTrue(fes[0] instanceof JarMarker);\r\n        ze = zf.getEntry(\"bar/\");\r\n        assertNotNull(ze);\r\n        fes = ze.getExtraFields();\r\n        assertEquals(0, fes.length);\r\n    } finally {\r\n        AbstractTest.forceDelete(testArchive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\jar\\JarMarkerTest.java",
  "methodName" : "testJarMarkerLengthCheck",
  "sourceCode" : "@Test\r\nvoid testJarMarkerLengthCheck() {\r\n    assertThrows(ZipException.class, () -> JarMarker.getInstance().parseFromLocalFileData(null, 0, 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\JarTest.java",
  "methodName" : "testJarArchiveCreation",
  "sourceCode" : "@Test\r\nvoid testJarArchiveCreation() throws Exception {\r\n    final File output = newTempFile(\"bla.jar\");\r\n    final File file1 = getFile(\"test1.xml\");\r\n    final File file2 = getFile(\"test2.xml\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath());\r\n        ArchiveOutputStream<ZipArchiveEntry> os = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"jar\", out)) {\r\n        // file 1\r\n        os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\r\n        os.write(file1);\r\n        os.closeArchiveEntry();\r\n        // file 2\r\n        os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\r\n        os.write(file2);\r\n        os.closeArchiveEntry();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\JarTest.java",
  "methodName" : "testJarUnarchive",
  "sourceCode" : "@Test\r\nvoid testJarUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.jar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ZipArchiveInputStream in = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"jar\", is)) {\r\n        ZipArchiveEntry entry = in.getNextEntry();\r\n        File o = newTempFile(entry.getName());\r\n        o.getParentFile().mkdirs();\r\n        Files.copy(in, o.toPath());\r\n        entry = in.getNextEntry();\r\n        o = newTempFile(entry.getName());\r\n        o.getParentFile().mkdirs();\r\n        Files.copy(in, o.toPath());\r\n        entry = in.getNextEntry();\r\n        o = newTempFile(entry.getName());\r\n        o.getParentFile().mkdirs();\r\n        Files.copy(in, o.toPath());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\JarTest.java",
  "methodName" : "testJarUnarchiveAll",
  "sourceCode" : "@Test\r\nvoid testJarUnarchiveAll() throws Exception {\r\n    final File input = getFile(\"bla.jar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<?> in = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"jar\", is)) {\r\n        in.forEach(entry -> {\r\n            final File archiveEntry = newTempFile(entry.getName());\r\n            archiveEntry.getParentFile().mkdirs();\r\n            if (entry.isDirectory()) {\r\n                archiveEntry.mkdir();\r\n            } else {\r\n                Files.copy(in, archiveEntry.toPath());\r\n            }\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ListerTest.java",
  "methodName" : "testMain",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"getFixtures\")\r\nvoid testMain(final Path path) throws ArchiveException, IOException {\r\n    new Lister(true, path.toString()).go();\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\LongPathTest.java",
  "methodName" : "testArchive",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\nvoid testArchive(final File file) throws Exception {\r\n    // fileList is of correct type\r\n    @SuppressWarnings(\"unchecked\")\r\n    final ArrayList<String> expected = (ArrayList<String>) FILE_LIST.clone();\r\n    final String name = file.getName();\r\n    if (\"minotaur.jar\".equals(name) || \"minotaur-0.jar\".equals(name)) {\r\n        expected.add(\"META-INF/\");\r\n        expected.add(\"META-INF/MANIFEST.MF\");\r\n    }\r\n    try (ArchiveInputStream<?> ais = factory.createArchiveInputStream(new BufferedInputStream(Files.newInputStream(file.toPath())))) {\r\n        // check if expected type recognized\r\n        if (name.endsWith(\".tar\")) {\r\n            assertInstanceOf(TarArchiveInputStream.class, ais);\r\n        } else if (name.endsWith(\".jar\") || name.endsWith(\".zip\")) {\r\n            assertInstanceOf(ZipArchiveInputStream.class, ais);\r\n        } else if (name.endsWith(\".cpio\")) {\r\n            assertInstanceOf(CpioArchiveInputStream.class, ais);\r\n            // Hack: cpio does not add trailing \"/\" to directory names\r\n            for (int i = 0; i < expected.size(); i++) {\r\n                final String ent = expected.get(i);\r\n                if (ent.endsWith(\"/\")) {\r\n                    expected.set(i, ent.substring(0, ent.length() - 1));\r\n                }\r\n            }\r\n        } else if (name.endsWith(\".ar\")) {\r\n            assertInstanceOf(ArArchiveInputStream.class, ais);\r\n            // CPIO does not store directories or directory names\r\n            expected.clear();\r\n            for (final String ent : FILE_LIST) {\r\n                if (!ent.endsWith(\"/\")) {\r\n                    // not a directory\r\n                    final int lastSlash = ent.lastIndexOf('/');\r\n                    if (lastSlash >= 0) {\r\n                        // extract path name\r\n                        expected.add(ent.substring(lastSlash + 1));\r\n                    } else {\r\n                        expected.add(ent);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            fail(\"Unexpected file type: \" + name);\r\n        }\r\n        assertDoesNotThrow(() -> checkArchiveContent(ais, expected), \"Error processing \" + file.getName());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\LongSymLinkTest.java",
  "methodName" : "testArchive",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\nvoid testArchive(final File file) throws Exception {\r\n    // fileList is of correct type\r\n    @SuppressWarnings(\"unchecked\")\r\n    final ArrayList<String> expected = (ArrayList<String>) FILE_LIST.clone();\r\n    final String name = file.getName();\r\n    if (\"minotaur.jar\".equals(name) || \"minotaur-0.jar\".equals(name)) {\r\n        expected.add(\"META-INF/\");\r\n        expected.add(\"META-INF/MANIFEST.MF\");\r\n    }\r\n    try (ArchiveInputStream<?> ais = factory.createArchiveInputStream(new BufferedInputStream(Files.newInputStream(file.toPath())))) {\r\n        // check if expected type recognized\r\n        if (name.endsWith(\".tar\")) {\r\n            assertInstanceOf(TarArchiveInputStream.class, ais);\r\n        } else if (name.endsWith(\".jar\") || name.endsWith(\".zip\")) {\r\n            assertInstanceOf(ZipArchiveInputStream.class, ais);\r\n        } else if (name.endsWith(\".cpio\")) {\r\n            assertInstanceOf(CpioArchiveInputStream.class, ais);\r\n            // Hack: cpio does not add trailing \"/\" to directory names\r\n            for (int i = 0; i < expected.size(); i++) {\r\n                final String ent = expected.get(i);\r\n                if (ent.endsWith(\"/\")) {\r\n                    expected.set(i, ent.substring(0, ent.length() - 1));\r\n                }\r\n            }\r\n        } else if (name.endsWith(\".ar\")) {\r\n            assertInstanceOf(ArArchiveInputStream.class, ais);\r\n            // CPIO does not store directories or directory names\r\n            expected.clear();\r\n            for (final String ent : FILE_LIST) {\r\n                if (!ent.endsWith(\"/\")) {\r\n                    // not a directory\r\n                    final int lastSlash = ent.lastIndexOf('/');\r\n                    if (lastSlash >= 0) {\r\n                        // extract path name\r\n                        expected.add(ent.substring(lastSlash + 1));\r\n                    } else {\r\n                        expected.add(ent);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            fail(\"Unexpected file type: \" + name);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\memory\\MemoryArchiveTest.java",
  "methodName" : "testReading",
  "sourceCode" : "@Test\r\nvoid testReading() throws IOException {\r\n    try (MemoryArchiveInputStream is = new MemoryArchiveInputStream(new String[][] { { \"test1\", \"content1\" }, { \"test2\", \"content2\" } })) {\r\n        final ArchiveEntry entry1 = is.getNextEntry();\r\n        assertNotNull(entry1);\r\n        assertEquals(\"test1\", entry1.getName());\r\n        final String content1 = is.readString();\r\n        assertEquals(\"content1\", content1);\r\n        final ArchiveEntry entry2 = is.getNextEntry();\r\n        assertNotNull(entry2);\r\n        assertEquals(\"test2\", entry2.getName());\r\n        final String content2 = is.readString();\r\n        assertEquals(\"content2\", content2);\r\n        final ArchiveEntry entry3 = is.getNextEntry();\r\n        assertNull(entry3);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZAES256SHA256DecoderTest.java",
  "methodName" : "testDecodeWithNonEmptyString",
  "sourceCode" : "@Test\r\nvoid testDecodeWithNonEmptyString() throws IOException {\r\n    final AES256SHA256Decoder aES256SHA256Decoder = new AES256SHA256Decoder();\r\n    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(null, 3138)) {\r\n        final byte[] byteArray = new byte[8];\r\n        byteArray[1] = (byte) -72;\r\n        final Coder coder = new Coder(null, 0, 0, byteArray);\r\n        try (InputStream inputStream = aES256SHA256Decoder.decode(\"x\", bufferedInputStream, 3138, coder, coder.properties, Integer.MAX_VALUE)) {\r\n            final IOException e = assertThrows(ArchiveException.class, () -> new ObjectInputStream(inputStream), \"Expecting exception: IOException\");\r\n            assertEquals(\"Salt size + IV size too long in 'x'\", e.getMessage());\r\n            assertEquals(\"org.apache.commons.compress.archivers.sevenz.AES256SHA256Decoder$AES256SHA256DecoderInputStream\", e.getStackTrace()[0].getClassName());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testMethodConfigurationMattersInEquals",
  "sourceCode" : "@Test\r\nvoid testMethodConfigurationMattersInEquals() {\r\n    final SevenZArchiveEntry z1 = new SevenZArchiveEntry();\r\n    final SevenZArchiveEntry z2 = new SevenZArchiveEntry();\r\n    final SevenZArchiveEntry z3 = new SevenZArchiveEntry();\r\n    z1.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.LZMA2, 1));\r\n    z2.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.LZMA2, 2));\r\n    z3.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.LZMA2, 2));\r\n    assertNotEquals(z1, z2);\r\n    assertNotEquals(z2, z1);\r\n    assertEquals(z3, z2);\r\n    assertEquals(z2, z3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testMethodOrderMattersInEquals",
  "sourceCode" : "@Test\r\nvoid testMethodOrderMattersInEquals() {\r\n    final SevenZArchiveEntry z1 = new SevenZArchiveEntry();\r\n    final SevenZArchiveEntry z2 = new SevenZArchiveEntry();\r\n    z1.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.LZMA2), new SevenZMethodConfiguration(SevenZMethod.DELTA_FILTER));\r\n    z2.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.DELTA_FILTER), new SevenZMethodConfiguration(SevenZMethod.LZMA2));\r\n    assertNotEquals(z1, z2);\r\n    assertNotEquals(z2, z1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testNoMethodsIsDifferentFromSomeMethods",
  "sourceCode" : "@Test\r\nvoid testNoMethodsIsDifferentFromSomeMethods() {\r\n    final SevenZArchiveEntry z1 = new SevenZArchiveEntry();\r\n    final SevenZArchiveEntry z2 = new SevenZArchiveEntry();\r\n    z2.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.COPY));\r\n    assertNotEquals(z1, z2);\r\n    assertNotEquals(z2, z1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testOneMethodsIsDifferentFromTwoMethods",
  "sourceCode" : "@Test\r\nvoid testOneMethodsIsDifferentFromTwoMethods() {\r\n    final SevenZArchiveEntry z1 = new SevenZArchiveEntry();\r\n    final SevenZArchiveEntry z2 = new SevenZArchiveEntry();\r\n    z1.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.COPY));\r\n    z2.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.DELTA_FILTER), new SevenZMethodConfiguration(SevenZMethod.LZMA2));\r\n    assertNotEquals(z1, z2);\r\n    assertNotEquals(z2, z1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testSameMethodsYieldEqualEntries",
  "sourceCode" : "@Test\r\nvoid testSameMethodsYieldEqualEntries() {\r\n    final SevenZArchiveEntry z1 = new SevenZArchiveEntry();\r\n    final SevenZArchiveEntry z2 = new SevenZArchiveEntry();\r\n    z1.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.DELTA_FILTER), new SevenZMethodConfiguration(SevenZMethod.LZMA2));\r\n    z2.setContentMethods(new SevenZMethodConfiguration(SevenZMethod.DELTA_FILTER), new SevenZMethodConfiguration(SevenZMethod.LZMA2));\r\n    assertEquals(z1, z2);\r\n    assertEquals(z2, z1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testShouldThrowIfAccessDateIsSetToNull",
  "sourceCode" : "@Test\r\nvoid testShouldThrowIfAccessDateIsSetToNull() {\r\n    assertThrows(UnsupportedOperationException.class, () -> {\r\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\r\n        entry.setAccessDate(null);\r\n        entry.getAccessDate();\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testShouldThrowIfCreationDateIsSetToNull",
  "sourceCode" : "@Test\r\nvoid testShouldThrowIfCreationDateIsSetToNull() {\r\n    assertThrows(UnsupportedOperationException.class, () -> {\r\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\r\n        entry.setCreationDate(null);\r\n        entry.getCreationDate();\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testShouldThrowIfLastModifiedDateIsSetToNull",
  "sourceCode" : "@Test\r\nvoid testShouldThrowIfLastModifiedDateIsSetToNull() {\r\n    assertThrows(UnsupportedOperationException.class, () -> {\r\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\r\n        entry.setLastModifiedDate(null);\r\n        entry.getLastModifiedDate();\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testShouldThrowIfNoAccessDateIsSet",
  "sourceCode" : "@Test\r\nvoid testShouldThrowIfNoAccessDateIsSet() {\r\n    assertThrows(UnsupportedOperationException.class, () -> new SevenZArchiveEntry().getAccessDate());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testShouldThrowIfNoCreationDateIsSet",
  "sourceCode" : "@Test\r\nvoid testShouldThrowIfNoCreationDateIsSet() {\r\n    assertThrows(UnsupportedOperationException.class, () -> new SevenZArchiveEntry().getCreationDate());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZArchiveEntryTest.java",
  "methodName" : "testShouldThrowIfNoLastModifiedDateIsSet",
  "sourceCode" : "@Test\r\nvoid testShouldThrowIfNoLastModifiedDateIsSet() {\r\n    assertThrows(UnsupportedOperationException.class, () -> new SevenZArchiveEntry().getLastModifiedDate());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZCompress679Test.java",
  "methodName" : "testCompress679",
  "sourceCode" : "@Test\r\nvoid testCompress679() {\r\n    final Path origin = Paths.get(\"src/test/resources/org/apache/commons/compress/COMPRESS-679/file.7z\");\r\n    assertTrue(Files.exists(origin));\r\n    final Callable<Boolean> runnable = () -> {\r\n        try (SevenZFile sevenZFile = SevenZFile.builder().setPath(origin).get()) {\r\n            SevenZArchiveEntry sevenZArchiveEntry;\r\n            while ((sevenZArchiveEntry = sevenZFile.getNextEntry()) != null) {\r\n                if (\"file4.txt\".equals(sevenZArchiveEntry.getName())) {\r\n                    // The entry must not be the first of the ZIP archive to reproduce\r\n                    final InputStream inputStream = sevenZFile.getInputStream(sevenZArchiveEntry);\r\n                    // treatments...\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return Boolean.TRUE;\r\n    };\r\n    final ExecutorService threadPool = Executors.newFixedThreadPool(10);\r\n    try {\r\n        final List<Future<Boolean>> futures = IntStream.range(0, 30).mapToObj(i -> threadPool.submit(runnable)).collect(Collectors.toList());\r\n        futures.forEach(f -> assertDoesNotThrow(() -> f.get()));\r\n    } finally {\r\n        threadPool.shutdownNow();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZCoverageTest.java",
  "methodName" : "testCLIInstance",
  "sourceCode" : "@Test\r\nvoid testCLIInstance() {\r\n    final CLI foo = new CLI();\r\n    assertNotNull(foo);\r\n    assertThrows(Exception.class, () -> CLI.main(new String[] { \"/dev/null/not-there\" }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZCoverageTest.java",
  "methodName" : "testNidInstance",
  "sourceCode" : "@Test\r\nvoid testNidInstance() {\r\n    assertNotNull(new NID());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "test7zDecryptUnarchive",
  "sourceCode" : "@Test\r\nvoid test7zDecryptUnarchive() throws Exception {\r\n    if (isStrongCryptoAvailable()) {\r\n        // stack LZMA + AES\r\n        test7zUnarchive(// stack LZMA + AES\r\n        getFile(\"bla.encrypted.7z\"), // stack LZMA + AES\r\n        SevenZMethod.LZMA, \"foo\".getBytes(UTF_16LE));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "test7zDecryptUnarchiveUsingCharArrayPassword",
  "sourceCode" : "@Test\r\nvoid test7zDecryptUnarchiveUsingCharArrayPassword() throws Exception {\r\n    if (isStrongCryptoAvailable()) {\r\n        // stack LZMA + AES\r\n        test7zUnarchive(// stack LZMA + AES\r\n        getFile(\"bla.encrypted.7z\"), // stack LZMA + AES\r\n        SevenZMethod.LZMA, \"foo\".toCharArray());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "test7zDeflate64Unarchive",
  "sourceCode" : "@Test\r\nvoid test7zDeflate64Unarchive() throws Exception {\r\n    test7zUnarchive(getFile(\"bla.deflate64.7z\"), SevenZMethod.DEFLATE64);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "test7zDeflateUnarchive",
  "sourceCode" : "@Test\r\nvoid test7zDeflateUnarchive() throws Exception {\r\n    test7zUnarchive(getFile(\"bla.deflate.7z\"), SevenZMethod.DEFLATE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "test7zMultiVolumeUnarchive",
  "sourceCode" : "@Test\r\nvoid test7zMultiVolumeUnarchive() throws Exception {\r\n    try (@SuppressWarnings(\"deprecation\") SevenZFile sevenZFile = new SevenZFile(MultiReadOnlySeekableByteChannel.forFiles(getFile(\"bla-multi.7z.001\"), getFile(\"bla-multi.7z.002\")))) {\r\n        test7zUnarchive(sevenZFile, SevenZMethod.LZMA2);\r\n    }\r\n    try (SevenZFile sevenZFile = SevenZFile.builder().setSeekableByteChannel(MultiReadOnlySeekableByteChannel.forFiles(getFile(\"bla-multi.7z.001\"), getFile(\"bla-multi.7z.002\"))).get()) {\r\n        test7zUnarchive(sevenZFile, SevenZMethod.LZMA2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "test7zUnarchive",
  "sourceCode" : "@Test\r\nvoid test7zUnarchive() throws Exception {\r\n    test7zUnarchive(getFile(\"bla.7z\"), SevenZMethod.LZMA);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "test7zUnarchiveWithDefectHeader",
  "sourceCode" : "@Test\r\nvoid test7zUnarchiveWithDefectHeader() throws Exception {\r\n    test7zUnarchive(getFile(\"bla.noendheaderoffset.7z\"), SevenZMethod.LZMA, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "test7zUnarchiveWithDefectHeaderFailsByDefault",
  "sourceCode" : "@Test\r\nvoid test7zUnarchiveWithDefectHeaderFailsByDefault() throws Exception {\r\n    assertThrows(ArchiveException.class, () -> test7zUnarchive(getFile(\"bla.noendheaderoffset.7z\"), SevenZMethod.LZMA));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testAllEmptyFilesArchive",
  "sourceCode" : "@Test\r\nvoid testAllEmptyFilesArchive() throws Exception {\r\n    try (SevenZFile archive = getSevenZFile(\"7z-empty-mhc-off.7z\")) {\r\n        final SevenZArchiveEntry e = archive.getNextEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"empty\", e.getName());\r\n        assertDates(e, \"2013-05-14T17:50:19Z\", null, null);\r\n        assertNull(archive.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testAssertFitsIntoNonNegativeInt",
  "sourceCode" : "@Test\r\nvoid testAssertFitsIntoNonNegativeInt() throws IOException {\r\n    assertThrows(ArchiveException.class, () -> SevenZFile.builder().setPath(\"src/test/resources/org/apache/commons/compress/sevenz/assertFitsIntoNonNegativeInt.bin\").get().close());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testCompressedHeaderWithNonDefaultDictionarySize",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-256\"\r\n */\r\n@Test\r\nvoid testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-256.7z\")) {\r\n        int count = 0;\r\n        while (sevenZFile.getNextEntry() != null) {\r\n            count++;\r\n        }\r\n        assertEquals(446, count);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testEncryptedArchiveRequiresPassword",
  "sourceCode" : "@Test\r\nvoid testEncryptedArchiveRequiresPassword() throws Exception {\r\n    final PasswordRequiredException ex = assertThrows(PasswordRequiredException.class, () -> getSevenZFile(\"bla.encrypted.7z\").close(), \"shouldn't decrypt without a password\");\r\n    final String msg = ex.getMessage();\r\n    assertTrue(msg.startsWith(\"Cannot read encrypted content from \"), \"Should start with whining about being unable to decrypt\");\r\n    assertTrue(msg.endsWith(\" without a password.\"), \"Should finish the sentence properly\");\r\n    assertTrue(msg.contains(\"bla.encrypted.7z\"), \"Should contain archive's name\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testExtractNonExistSpecifiedFile",
  "sourceCode" : "@Test\r\nvoid testExtractNonExistSpecifiedFile() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-256.7z\");\r\n        SevenZFile anotherSevenZFile = getSevenZFile(\"bla.7z\")) {\r\n        for (final SevenZArchiveEntry nonExistEntry : anotherSevenZFile.getEntries()) {\r\n            assertThrows(IllegalArgumentException.class, () -> sevenZFile.getInputStream(nonExistEntry));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testExtractSpecifiedFile",
  "sourceCode" : "@Test\r\nvoid testExtractSpecifiedFile() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-256.7z\")) {\r\n        // @formatter:off\r\n        final String testTxtContents = \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\";\r\n        // @formatter:off\r\n        for (final SevenZArchiveEntry entry : sevenZFile.getEntries()) {\r\n            if (entry.getName().equals(\"commons-compress-1.7-src/src/test/resources/test.txt\")) {\r\n                final byte[] contents = new byte[(int) entry.getSize()];\r\n                int off = 0;\r\n                final InputStream inputStream = sevenZFile.getInputStream(entry);\r\n                while (off < contents.length) {\r\n                    final int bytesRead = inputStream.read(contents, off, contents.length - off);\r\n                    assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n                    off += bytesRead;\r\n                }\r\n                assertEquals(testTxtContents, new String(contents, UTF_8));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testExtractSpecifiedFileDeprecated",
  "sourceCode" : "@Test\r\nvoid testExtractSpecifiedFileDeprecated() throws Exception {\r\n    try (@SuppressWarnings(\"deprecation\") SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"))) {\r\n        // @formatter:off\r\n        final String testTxtContents = \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\";\r\n        // @formatter:on\r\n        for (final SevenZArchiveEntry entry : sevenZFile.getEntries()) {\r\n            if (entry.getName().equals(\"commons-compress-1.7-src/src/test/resources/test.txt\")) {\r\n                final byte[] contents = new byte[(int) entry.getSize()];\r\n                int off = 0;\r\n                final InputStream inputStream = sevenZFile.getInputStream(entry);\r\n                while (off < contents.length) {\r\n                    final int bytesRead = inputStream.read(contents, off, contents.length - off);\r\n                    assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n                    off += bytesRead;\r\n                }\r\n                assertEquals(testTxtContents, new String(contents, UTF_8));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testGetDefaultName",
  "sourceCode" : "@Test\r\nvoid testGetDefaultName() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"bla.deflate64.7z\")) {\r\n        assertEquals(\"bla.deflate64\", sevenZFile.getDefaultName());\r\n    }\r\n    try (SevenZFile sevenZFile = SevenZFile.builder().setSeekableByteChannel(Files.newByteChannel(getFile(\"bla.deflate64.7z\").toPath())).get()) {\r\n        assertNull(sevenZFile.getDefaultName());\r\n    }\r\n    try (@SuppressWarnings(\"deprecation\") SevenZFile sevenZFile = new SevenZFile(Files.newByteChannel(getFile(\"bla.deflate64.7z\").toPath()), \"foo\")) {\r\n        assertEquals(\"foo~\", sevenZFile.getDefaultName());\r\n    }\r\n    try (SevenZFile sevenZFile = SevenZFile.builder().setSeekableByteChannel(Files.newByteChannel(getFile(\"bla.deflate64.7z\").toPath())).setDefaultName(\"foo\").get()) {\r\n        assertEquals(\"foo~\", sevenZFile.getDefaultName());\r\n    }\r\n    try (SevenZFile sevenZFile = SevenZFile.builder().setSeekableByteChannel(Files.newByteChannel(getFile(\"bla.deflate64.7z\").toPath())).setDefaultName(\".foo\").get()) {\r\n        assertEquals(\".foo~\", sevenZFile.getDefaultName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testGetEntriesOfUnarchiveInMemoryTest",
  "sourceCode" : "@Test\r\nvoid testGetEntriesOfUnarchiveInMemoryTest() throws IOException {\r\n    final byte[] data = readAllBytes(\"bla.7z\");\r\n    try (SevenZFile sevenZFile = SevenZFile.builder().setSeekableByteChannel(new SeekableInMemoryByteChannel(data)).get()) {\r\n        final Iterable<SevenZArchiveEntry> entries = sevenZFile.getEntries();\r\n        final Iterator<SevenZArchiveEntry> iter = entries.iterator();\r\n        SevenZArchiveEntry entry = iter.next();\r\n        assertEquals(\"test1.xml\", entry.getName());\r\n        entry = iter.next();\r\n        assertEquals(\"test2.xml\", entry.getName());\r\n        assertFalse(iter.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testGetEntriesOfUnarchiveTest",
  "sourceCode" : "@Test\r\nvoid testGetEntriesOfUnarchiveTest() throws IOException {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"bla.7z\")) {\r\n        final Iterable<SevenZArchiveEntry> entries = sevenZFile.getEntries();\r\n        final Iterator<SevenZArchiveEntry> iter = entries.iterator();\r\n        SevenZArchiveEntry entry = iter.next();\r\n        assertEquals(\"test1.xml\", entry.getName());\r\n        entry = iter.next();\r\n        assertEquals(\"test2.xml\", entry.getName());\r\n        assertFalse(iter.hasNext());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testGivenNameWinsOverDefaultName",
  "sourceCode" : "@Test\r\nvoid testGivenNameWinsOverDefaultName() throws Exception {\r\n    try (@SuppressWarnings(\"deprecation\") SevenZFile sevenZFile = new SevenZFile(getFile(\"bla.7z\"), SevenZFileOptions.builder().withUseDefaultNameForUnnamedEntries(true).build())) {\r\n        SevenZArchiveEntry ae = sevenZFile.getNextEntry();\r\n        assertNotNull(ae);\r\n        assertEquals(\"test1.xml\", ae.getName());\r\n        ae = sevenZFile.getNextEntry();\r\n        assertNotNull(ae);\r\n        assertEquals(\"test2.xml\", ae.getName());\r\n        assertNull(sevenZFile.getNextEntry());\r\n    }\r\n    try (SevenZFile sevenZFile = SevenZFile.builder().setFile(getFile(\"bla.7z\")).setUseDefaultNameForUnnamedEntries(true).get()) {\r\n        SevenZArchiveEntry ae = sevenZFile.getNextEntry();\r\n        assertNotNull(ae);\r\n        assertEquals(\"test1.xml\", ae.getName());\r\n        ae = sevenZFile.getNextEntry();\r\n        assertNotNull(ae);\r\n        assertEquals(\"test2.xml\", ae.getName());\r\n        assertNull(sevenZFile.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testHandlesEmptyArchiveWithFilesInfo",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-492\">COMPRESS-492</a>\r\n */\r\n@Test\r\nvoid testHandlesEmptyArchiveWithFilesInfo() throws Exception {\r\n    final File file = newTempFile(\"empty.7z\");\r\n    try (SevenZOutputFile s = new SevenZOutputFile(file)) {\r\n        // do nothing\r\n    }\r\n    try (SevenZFile z = SevenZFile.builder().setFile(file).get()) {\r\n        assertFalse(z.getEntries().iterator().hasNext());\r\n        assertNull(z.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testHandlesEmptyArchiveWithoutFilesInfo",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-492\">COMPRESS-492</a>\r\n */\r\n@Test\r\nvoid testHandlesEmptyArchiveWithoutFilesInfo() throws Exception {\r\n    try (SevenZFile z = getSevenZFile(\"COMPRESS-492.7z\")) {\r\n        assertFalse(z.getEntries().iterator().hasNext());\r\n        assertNull(z.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testHelloWorldHeaderCompressionOffCopy",
  "sourceCode" : "@Test\r\nvoid testHelloWorldHeaderCompressionOffCopy() throws Exception {\r\n    checkHelloWorld(\"7z-hello-mhc-off-copy.7z\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testHelloWorldHeaderCompressionOffLZMA2",
  "sourceCode" : "@Test\r\nvoid testHelloWorldHeaderCompressionOffLZMA2() throws Exception {\r\n    checkHelloWorld(\"7z-hello-mhc-off-lzma2.7z\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testLimitExtractionMemory",
  "sourceCode" : "@Test\r\nvoid testLimitExtractionMemory() {\r\n    assertThrows(MemoryLimitException.class, () -> {\r\n        try (SevenZFile sevenZFile = SevenZFile.builder().setFile(getFile(\"bla.7z\")).setMaxMemoryLimitKb(1).get()) {\r\n            // Do nothing. Exception should be thrown\r\n        }\r\n    });\r\n    assertThrows(MemoryLimitException.class, () -> {\r\n        try (SevenZFile sevenZFile = SevenZFile.builder().setFile(getFile(\"bla.7z\")).setMaxMemoryLimitKiB(1).get()) {\r\n            // Do nothing. Exception should be thrown\r\n        }\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testNoNameCanBeReplacedByDefaultName",
  "sourceCode" : "@Test\r\nvoid testNoNameCanBeReplacedByDefaultName() throws Exception {\r\n    try (SevenZFile sevenZFile = SevenZFile.builder().setFile(getFile(\"bla-nonames.7z\")).setUseDefaultNameForUnnamedEntries(true).get()) {\r\n        SevenZArchiveEntry ae = sevenZFile.getNextEntry();\r\n        assertNotNull(ae);\r\n        assertEquals(\"bla-nonames\", ae.getName());\r\n        ae = sevenZFile.getNextEntry();\r\n        assertNotNull(ae);\r\n        assertEquals(\"bla-nonames\", ae.getName());\r\n        assertNull(sevenZFile.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testNoNameMeansNoNameByDefault",
  "sourceCode" : "@Test\r\nvoid testNoNameMeansNoNameByDefault() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"bla-nonames.7z\")) {\r\n        SevenZArchiveEntry ae = sevenZFile.getNextEntry();\r\n        assertNotNull(ae);\r\n        assertNull(ae.getName());\r\n        ae = sevenZFile.getNextEntry();\r\n        assertNotNull(ae);\r\n        assertNull(ae.getName());\r\n        assertNull(sevenZFile.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testNoOOMOnCorruptedHeader",
  "sourceCode" : "@Test\r\nvoid testNoOOMOnCorruptedHeader() throws IOException {\r\n    final List<Path> testFiles = new ArrayList<>();\r\n    testFiles.add(getPath(\"COMPRESS-542-1.7z\"));\r\n    testFiles.add(getPath(\"COMPRESS-542-2.7z\"));\r\n    testFiles.add(getPath(\"COMPRESS-542-endheadercorrupted.7z\"));\r\n    testFiles.add(getPath(\"COMPRESS-542-endheadercorrupted2.7z\"));\r\n    for (final Path file : testFiles) {\r\n        {\r\n            final IOException e = assertThrows(ArchiveException.class, () -> {\r\n                try (@SuppressWarnings(\"deprecation\") SevenZFile sevenZFile = new SevenZFile(Files.newByteChannel(file), SevenZFileOptions.builder().withTryToRecoverBrokenArchives(true).build())) {\r\n                    // do nothing\r\n                }\r\n            }, \"Expected IOException: start header corrupt and unable to guess end header\");\r\n            assertEquals(\"Start header corrupt and unable to guess end header\", e.getMessage());\r\n        }\r\n        {\r\n            final IOException e = assertThrows(ArchiveException.class, () -> {\r\n                try (SevenZFile sevenZFile = SevenZFile.builder().setSeekableByteChannel(Files.newByteChannel(file)).setTryToRecoverBrokenArchives(true).get()) {\r\n                    // do nothing\r\n                }\r\n            }, \"Expected IOException: start header corrupt and unable to guess end header\");\r\n            assertEquals(\"Start header corrupt and unable to guess end header\", e.getMessage());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testNumCyclesPower30",
  "sourceCode" : "@Test\r\nvoid testNumCyclesPower30() throws IOException {\r\n    final String fixture = \"src/test/resources/org/apache/commons/compress/sevenz/numCyclesPower30.bin\";\r\n    final char[] password = \"secret\".toCharArray();\r\n    // @formatter:off\r\n    assertThrows(ArchiveException.class, () -> SevenZFile.builder().setPath(fixture).get().close());\r\n    assertThrows(ArchiveException.class, () -> SevenZFile.builder().setPath(fixture).setPassword(password).get().close());\r\n    assertThrows(ArchiveException.class, () -> SevenZFile.builder().setPath(fixture).setPassword(password).setTryToRecoverBrokenArchives(true).get().close());\r\n    assertThrows(ArchiveException.class, () -> new SevenZFile(new File(fixture), password).close());\r\n    // @formatter:on\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRandomAccessMultipleReadSameFile",
  "sourceCode" : "@Test\r\nvoid testRandomAccessMultipleReadSameFile() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-256.7z\")) {\r\n        // @formatter:off\r\n        final String testTxtContents = \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\";\r\n        // @formatter:on\r\n        SevenZArchiveEntry entry;\r\n        SevenZArchiveEntry testTxtEntry = null;\r\n        while ((entry = sevenZFile.getNextEntry()) != null) {\r\n            if (entry.getName().equals(\"commons-compress-1.7-src/src/test/resources/test.txt\")) {\r\n                testTxtEntry = entry;\r\n                break;\r\n            }\r\n        }\r\n        assertNotNull(testTxtEntry, \"testTxtEntry\");\r\n        final byte[] contents = new byte[(int) testTxtEntry.getSize()];\r\n        int numberOfReads = 10;\r\n        while (numberOfReads-- > 0) {\r\n            try (InputStream inputStream = sevenZFile.getInputStream(testTxtEntry)) {\r\n                int off = 0;\r\n                while (off < contents.length) {\r\n                    final int bytesRead = inputStream.read(contents, off, contents.length - off);\r\n                    assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n                    off += bytesRead;\r\n                }\r\n                assertEquals(SevenZMethod.LZMA2, testTxtEntry.getContentMethods().iterator().next().getMethod());\r\n                assertEquals(testTxtContents, new String(contents, UTF_8));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRandomAccessTogetherWithSequentialAccess",
  "sourceCode" : "@Test\r\nvoid testRandomAccessTogetherWithSequentialAccess() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-256.7z\")) {\r\n        // @formatter:off\r\n        final String testTxtContents = \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\";\r\n        final String filesTxtContents = \"0xxxxxxxxx10xxxxxxxx20xxxxxxxx30xxxxxxxx40xxxxxxxx50xxxxxxxx60xxxxxxxx70xxxxxxxx80xxxxxxxx90xxxxxxxx100\" + \"xxxxxxx110xxxxxxx120xxxxxxx130xxxxxxx -> 0yyyyyyyyy10yyyyyyyy20yyyyyyyy30yyyyyyyy40yyyyyyyy50yyyyyyyy60yyyyyyyy70yyyyyyyy80\" + \"yyyyyyyy90yyyyyyyy100yyyyyyy110yyyyyyy120yyyyyyy130yyyyyyy\\n\";\r\n        // @formatter:on\r\n        int off;\r\n        byte[] contents;\r\n        // call getNextEntry and read before calling getInputStream\r\n        sevenZFile.getNextEntry();\r\n        SevenZArchiveEntry nextEntry = sevenZFile.getNextEntry();\r\n        contents = new byte[(int) nextEntry.getSize()];\r\n        off = 0;\r\n        assertEquals(SevenZMethod.LZMA2, nextEntry.getContentMethods().iterator().next().getMethod());\r\n        // just read them\r\n        while (off < contents.length) {\r\n            final int bytesRead = sevenZFile.read(contents, off, contents.length - off);\r\n            assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n            off += bytesRead;\r\n        }\r\n        sevenZFile.getNextEntry();\r\n        sevenZFile.getNextEntry();\r\n        for (final SevenZArchiveEntry entry : sevenZFile.getEntries()) {\r\n            // commons-compress-1.7-src/src/test/resources/test.txt\r\n            if (entry.getName().equals(\"commons-compress-1.7-src/src/test/resources/longsymlink/files.txt\")) {\r\n                contents = new byte[(int) entry.getSize()];\r\n                off = 0;\r\n                final InputStream inputStream = sevenZFile.getInputStream(entry);\r\n                while (off < contents.length) {\r\n                    final int bytesRead = inputStream.read(contents, off, contents.length - off);\r\n                    assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n                    off += bytesRead;\r\n                }\r\n                assertEquals(SevenZMethod.LZMA2, entry.getContentMethods().iterator().next().getMethod());\r\n                assertEquals(filesTxtContents, new String(contents, UTF_8));\r\n                break;\r\n            }\r\n        }\r\n        // call getNextEntry after getInputStream\r\n        nextEntry = sevenZFile.getNextEntry();\r\n        while (!nextEntry.getName().equals(\"commons-compress-1.7-src/src/test/resources/test.txt\")) {\r\n            nextEntry = sevenZFile.getNextEntry();\r\n        }\r\n        contents = new byte[(int) nextEntry.getSize()];\r\n        off = 0;\r\n        while (off < contents.length) {\r\n            final int bytesRead = sevenZFile.read(contents, off, contents.length - off);\r\n            assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n            off += bytesRead;\r\n        }\r\n        assertEquals(SevenZMethod.LZMA2, nextEntry.getContentMethods().iterator().next().getMethod());\r\n        assertEquals(testTxtContents, new String(contents, UTF_8));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRandomAccessWhenJumpingBackwards",
  "sourceCode" : "@Test\r\nvoid testRandomAccessWhenJumpingBackwards() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-256.7z\")) {\r\n        // @formatter:off\r\n        final String testTxtContents = \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\";\r\n        // @formatter:on\r\n        SevenZArchiveEntry entry;\r\n        SevenZArchiveEntry testTxtEntry = null;\r\n        while ((entry = sevenZFile.getNextEntry()) != null) {\r\n            if (entry.getName().equals(\"commons-compress-1.7-src/src/test/resources/test.txt\")) {\r\n                testTxtEntry = entry;\r\n                break;\r\n            }\r\n        }\r\n        // read the next entry and jump back using random access\r\n        final SevenZArchiveEntry entryAfterTestTxtEntry = sevenZFile.getNextEntry();\r\n        final byte[] entryAfterTestTxtEntryContents = new byte[(int) entryAfterTestTxtEntry.getSize()];\r\n        int off = 0;\r\n        while (off < entryAfterTestTxtEntryContents.length) {\r\n            final int bytesRead = sevenZFile.read(entryAfterTestTxtEntryContents, off, entryAfterTestTxtEntryContents.length - off);\r\n            assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n            off += bytesRead;\r\n        }\r\n        // jump backwards\r\n        assertNotNull(testTxtEntry, \"testTxtEntry\");\r\n        final byte[] contents = new byte[(int) testTxtEntry.getSize()];\r\n        try (InputStream inputStream = sevenZFile.getInputStream(testTxtEntry)) {\r\n            off = 0;\r\n            while (off < contents.length) {\r\n                final int bytesRead = inputStream.read(contents, off, contents.length - off);\r\n                assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n                off += bytesRead;\r\n            }\r\n            assertEquals(SevenZMethod.LZMA2, testTxtEntry.getContentMethods().iterator().next().getMethod());\r\n            assertEquals(testTxtContents, new String(contents, UTF_8));\r\n        }\r\n        // then read the next entry using getNextEntry\r\n        final SevenZArchiveEntry nextTestTxtEntry = sevenZFile.getNextEntry();\r\n        final byte[] nextTestContents = new byte[(int) nextTestTxtEntry.getSize()];\r\n        off = 0;\r\n        while (off < nextTestContents.length) {\r\n            final int bytesRead = sevenZFile.read(nextTestContents, off, nextTestContents.length - off);\r\n            assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n            off += bytesRead;\r\n        }\r\n        assertEquals(nextTestTxtEntry.getName(), entryAfterTestTxtEntry.getName());\r\n        assertEquals(nextTestTxtEntry.getSize(), entryAfterTestTxtEntry.getSize());\r\n        assertArrayEquals(nextTestContents, entryAfterTestTxtEntryContents);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRandomAccessWhenJumpingForwards",
  "sourceCode" : "@Test\r\nvoid testRandomAccessWhenJumpingForwards() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-256.7z\")) {\r\n        // @formatter:off\r\n        final String testTxtContents = \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\\n\" + \"111111111111111111111111111000101011\";\r\n        // @formatter:on\r\n        SevenZArchiveEntry testTxtEntry = null;\r\n        final Iterable<SevenZArchiveEntry> entries = sevenZFile.getEntries();\r\n        for (final SevenZArchiveEntry Entry : entries) {\r\n            testTxtEntry = Entry;\r\n            if (testTxtEntry.getName().equals(\"commons-compress-1.7-src/src/test/resources/test.txt\")) {\r\n                break;\r\n            }\r\n        }\r\n        final SevenZArchiveEntry firstEntry = sevenZFile.getNextEntry();\r\n        // only read some of the data of the first entry\r\n        byte[] contents = new byte[(int) firstEntry.getSize() / 2];\r\n        sevenZFile.read(contents);\r\n        // and the third entry\r\n        sevenZFile.getNextEntry();\r\n        final SevenZArchiveEntry thirdEntry = sevenZFile.getNextEntry();\r\n        contents = new byte[(int) thirdEntry.getSize() / 2];\r\n        sevenZFile.read(contents);\r\n        // and then read a file after the first entry using random access\r\n        assertNotNull(testTxtEntry, \"testTxtEntry\");\r\n        contents = new byte[(int) testTxtEntry.getSize()];\r\n        int numberOfReads = 10;\r\n        while (numberOfReads-- > 0) {\r\n            try (InputStream inputStream = sevenZFile.getInputStream(testTxtEntry)) {\r\n                int off = 0;\r\n                while (off < contents.length) {\r\n                    final int bytesRead = inputStream.read(contents, off, contents.length - off);\r\n                    assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n                    off += bytesRead;\r\n                }\r\n                assertEquals(SevenZMethod.LZMA2, testTxtEntry.getContentMethods().iterator().next().getMethod());\r\n                assertEquals(testTxtContents, new String(contents, UTF_8));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRandomlySkippingEntries",
  "sourceCode" : "// https://issues.apache.org/jira/browse/COMPRESS-320\r\n@Test\r\nvoid testRandomlySkippingEntries() throws Exception {\r\n    // Read sequential reference.\r\n    final Map<String, byte[]> entriesByName = new HashMap<>();\r\n    try (SevenZFile archive = getSevenZFile(\"COMPRESS-320/Copy.7z\")) {\r\n        SevenZArchiveEntry entry;\r\n        while ((entry = archive.getNextEntry()) != null) {\r\n            if (entry.hasStream()) {\r\n                entriesByName.put(entry.getName(), readFully(archive));\r\n            }\r\n        }\r\n    }\r\n    final String[] variants = { \"BZip2-solid.7z\", \"BZip2.7z\", \"Copy-solid.7z\", \"Copy.7z\", \"Deflate-solid.7z\", \"Deflate.7z\", \"LZMA-solid.7z\", \"LZMA.7z\", \"LZMA2-solid.7z\", \"LZMA2.7z\" // TODO: unsupported compression method.\r\n    // \"PPMd-solid.7z\",\r\n    // \"PPMd.7z\",\r\n    };\r\n    // TODO: use randomized testing for predictable, but different, randomness.\r\n    final Random rnd = new Random(0xdeadbeef);\r\n    for (final String fileName : variants) {\r\n        try (SevenZFile archive = getSevenZFile(\"COMPRESS-320/\" + fileName)) {\r\n            SevenZArchiveEntry entry;\r\n            while ((entry = archive.getNextEntry()) != null) {\r\n                // Sometimes skip reading entries.\r\n                if (rnd.nextBoolean()) {\r\n                    continue;\r\n                }\r\n                if (entry.hasStream()) {\r\n                    assertTrue(entriesByName.containsKey(entry.getName()));\r\n                    final byte[] content = readFully(archive);\r\n                    assertArrayEquals(content, entriesByName.get(entry.getName()), \"Content mismatch on: \" + fileName + \"!\" + entry.getName());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testReadBigSevenZipFile",
  "sourceCode" : "@Test\r\nvoid testReadBigSevenZipFile() throws IOException {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-592.7z\")) {\r\n        SevenZArchiveEntry entry = sevenZFile.getNextEntry();\r\n        while (entry != null) {\r\n            if (entry.hasStream()) {\r\n                final byte[] content = new byte[Math.toIntExact(entry.getSize())];\r\n                sevenZFile.read(content);\r\n            }\r\n            entry = sevenZFile.getNextEntry();\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testReadEntriesOfSize0",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-348\"\r\n */\r\n@Test\r\nvoid testReadEntriesOfSize0() throws IOException {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-348.7z\")) {\r\n        int entries = 0;\r\n        SevenZArchiveEntry entry = sevenZFile.getNextEntry();\r\n        while (entry != null) {\r\n            entries++;\r\n            final int b = sevenZFile.read();\r\n            if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) {\r\n                assertEquals(-1, b);\r\n            } else {\r\n                assertNotEquals(-1, b);\r\n            }\r\n            entry = sevenZFile.getNextEntry();\r\n        }\r\n        assertEquals(5, entries);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testReadingArchiveProperties",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-681\">COMPRESS-681</a>.\r\n */\r\n@Test\r\nvoid testReadingArchiveProperties() throws IOException {\r\n    final String entryName = \"COMPRESS-681.txt\";\r\n    final String entryContent = \"https://issues.apache.org/jira/browse/COMPRESS-681\";\r\n    try (SevenZFile archive = getSevenZFile(\"COMPRESS-681.7z\")) {\r\n        final SevenZArchiveEntry entry = archive.getNextEntry();\r\n        assertEquals(entryName, entry.getName());\r\n        final byte[] contents = new byte[(int) entry.getSize()];\r\n        int off = 0;\r\n        while (off < contents.length) {\r\n            final int bytesRead = archive.read(contents, off, contents.length - off);\r\n            assertTrue(bytesRead >= 0, \"bytesRead exp: >=0, act: \" + bytesRead);\r\n            off += bytesRead;\r\n        }\r\n        assertEquals(entryContent, new String(contents, UTF_8));\r\n        assertNull(archive.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testReadingBackDeltaDistance",
  "sourceCode" : "@Test\r\nvoid testReadingBackDeltaDistance() throws Exception {\r\n    final File output = newTempFile(\"delta-distance.7z\");\r\n    try (SevenZOutputFile outArchive = new SevenZOutputFile(output)) {\r\n        outArchive.setContentMethods(Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.DELTA_FILTER, 32), new SevenZMethodConfiguration(SevenZMethod.LZMA2)));\r\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\r\n        entry.setName(\"foo.txt\");\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(new byte[] { 'A' });\r\n        outArchive.closeArchiveEntry();\r\n    }\r\n    try (SevenZFile archive = SevenZFile.builder().setFile(output).get()) {\r\n        final SevenZArchiveEntry entry = archive.getNextEntry();\r\n        final SevenZMethodConfiguration m = entry.getContentMethods().iterator().next();\r\n        assertEquals(SevenZMethod.DELTA_FILTER, m.getMethod());\r\n        assertEquals(32, m.getOptions());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testReadingBackLZMA2DictSize",
  "sourceCode" : "@Test\r\nvoid testReadingBackLZMA2DictSize() throws Exception {\r\n    final File output = newTempFile(\"lzma2-dictsize.7z\");\r\n    try (SevenZOutputFile outArchive = new SevenZOutputFile(output)) {\r\n        outArchive.setContentMethods(Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.LZMA2, 1 << 20)));\r\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\r\n        entry.setName(\"foo.txt\");\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(new byte[] { 'A' });\r\n        outArchive.closeArchiveEntry();\r\n    }\r\n    try (SevenZFile archive = SevenZFile.builder().setFile(output).get()) {\r\n        final SevenZArchiveEntry entry = archive.getNextEntry();\r\n        final SevenZMethodConfiguration m = entry.getContentMethods().iterator().next();\r\n        assertEquals(SevenZMethod.LZMA2, m.getMethod());\r\n        assertEquals(1 << 20, m.getOptions());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testReadTimesFromFile",
  "sourceCode" : "@Test\r\nvoid testReadTimesFromFile() throws IOException {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"times.7z\")) {\r\n        SevenZArchiveEntry entry = sevenZFile.getNextEntry();\r\n        assertNotNull(entry);\r\n        assertEquals(\"test\", entry.getName());\r\n        assertTrue(entry.isDirectory());\r\n        assertDates(entry, \"2022-03-21T14:50:46.2099751Z\", \"2022-03-21T14:50:46.2099751Z\", \"2022-03-16T10:19:24.1051115Z\");\r\n        // next entry\r\n        entry = sevenZFile.getNextEntry();\r\n        assertNotNull(entry);\r\n        assertEquals(\"test/test-times.txt\", entry.getName());\r\n        assertFalse(entry.isDirectory());\r\n        assertDates(entry, \"2022-03-18T10:00:15Z\", \"2022-03-18T10:14:37.8130002Z\", \"2022-03-18T10:14:37.8110032Z\");\r\n        // next entry\r\n        entry = sevenZFile.getNextEntry();\r\n        assertNotNull(entry);\r\n        assertEquals(\"test/test-times2.txt\", entry.getName());\r\n        assertFalse(entry.isDirectory());\r\n        assertDates(entry, \"2022-03-18T10:00:19Z\", \"2022-03-18T10:14:37.8170038Z\", \"2022-03-18T10:14:37.8140004Z\");\r\n        // next entry\r\n        entry = sevenZFile.getNextEntry();\r\n        assertNull(entry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRemainingBytesUnchangedAfterRead",
  "sourceCode" : "@Test\r\nvoid testRemainingBytesUnchangedAfterRead() throws Exception {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-256.7z\")) {\r\n        for (final SevenZArchiveEntry entry : sevenZFile.getEntries()) {\r\n            final InputStream inputStream = sevenZFile.getInputStream(entry);\r\n            if (!(inputStream instanceof ChecksumInputStream)) {\r\n                continue;\r\n            }\r\n            assertEquals(entry.getSize(), ((ChecksumInputStream) inputStream).getRemaining());\r\n            // read 10 byte\r\n            final byte[] bytes = new byte[10];\r\n            inputStream.read(bytes);\r\n            assertNotEquals(entry.getSize(), ((ChecksumInputStream) inputStream).getRemaining());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRetrieveInputStreamForAllEntriesMultipleTimes",
  "sourceCode" : "@Test\r\nvoid testRetrieveInputStreamForAllEntriesMultipleTimes() throws IOException {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"bla.7z\")) {\r\n        for (final SevenZArchiveEntry entry : sevenZFile.getEntries()) {\r\n            final byte[] firstRead = read(sevenZFile, entry);\r\n            final byte[] secondRead = read(sevenZFile, entry);\r\n            assertArrayEquals(firstRead, secondRead);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRetrieveInputStreamForAllEntriesWithoutCRCMultipleTimes",
  "sourceCode" : "@Test\r\nvoid testRetrieveInputStreamForAllEntriesWithoutCRCMultipleTimes() throws IOException {\r\n    try (SevenZOutputFile out = new SevenZOutputFile(newTempFile(\"test.7z\"))) {\r\n        final Path inputFile = Files.createTempFile(\"SevenZTestTemp\", \"\");\r\n        final SevenZArchiveEntry entry = out.createArchiveEntry(inputFile.toFile(), \"test.txt\");\r\n        out.putArchiveEntry(entry);\r\n        out.write(\"Test\".getBytes(UTF_8));\r\n        out.closeArchiveEntry();\r\n        Files.deleteIfExists(inputFile);\r\n    }\r\n    try (SevenZFile sevenZFile = SevenZFile.builder().setFile(newTempFile(\"test.7z\")).get()) {\r\n        for (final SevenZArchiveEntry entry : sevenZFile.getEntries()) {\r\n            final byte[] firstRead = read(sevenZFile, entry);\r\n            final byte[] secondRead = read(sevenZFile, entry);\r\n            assertArrayEquals(firstRead, secondRead);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testRetrieveInputStreamForShuffledEntries",
  "sourceCode" : "@Test\r\nvoid testRetrieveInputStreamForShuffledEntries() throws IOException {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"COMPRESS-348.7z\")) {\r\n        final List<SevenZArchiveEntry> entries = (List<SevenZArchiveEntry>) sevenZFile.getEntries();\r\n        Collections.shuffle(entries);\r\n        for (final SevenZArchiveEntry entry : entries) {\r\n            read(sevenZFile, entry);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testSanityCheckUnpackInfo",
  "sourceCode" : "@Test\r\nvoid testSanityCheckUnpackInfo() throws IOException {\r\n    assertThrows(ArchiveException.class, () -> SevenZFile.builder().setPath(\"src/test/resources/org/apache/commons/compress/sevenz/sanityCheckUnpackInfo.bin\").get().close());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testSevenZWithEOS",
  "sourceCode" : "@Test\r\nvoid testSevenZWithEOS() throws IOException {\r\n    try (SevenZFile sevenZFile = getSevenZFile(\"lzma-with-eos.7z\")) {\r\n        final List<SevenZArchiveEntry> entries = (List<SevenZArchiveEntry>) sevenZFile.getEntries();\r\n        for (final SevenZArchiveEntry entry : entries) {\r\n            read(sevenZFile, entry);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFileTest.java",
  "methodName" : "testSignatureCheck",
  "sourceCode" : "@Test\r\nvoid testSignatureCheck() {\r\n    assertTrue(SevenZFile.matches(SevenZFile.SIGNATURE, SevenZFile.SIGNATURE.length));\r\n    assertTrue(SevenZFile.matches(SevenZFile.SIGNATURE, SevenZFile.SIGNATURE.length + 1));\r\n    final byte[] data0 = Arrays.copyOf(SevenZFile.SIGNATURE, SevenZFile.SIGNATURE.length - 1);\r\n    assertFalse(SevenZFile.matches(data0, data0.length));\r\n    final byte[] data1 = { 1, 2, 3, 4, 5, 6 };\r\n    assertFalse(SevenZFile.matches(data1, data1.length));\r\n    final byte[] data2 = { '7', 'z', (byte) 0xBC, (byte) 0xAF, 0x27, 0x1C };\r\n    assertTrue(SevenZFile.matches(data2, data2.length));\r\n    final byte[] data3 = { '7', 'z', (byte) 0xBC, (byte) 0xAF, 0x27, 0x1D };\r\n    assertFalse(SevenZFile.matches(data3, data3.length));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFolderTest.java",
  "methodName" : "testFindBindPairForInStream",
  "sourceCode" : "@Test\r\nvoid testFindBindPairForInStream() {\r\n    final Folder folder = new Folder();\r\n    final BindPair[] bindPairArray = new BindPair[1];\r\n    final BindPair bindPair = new BindPair(0, 0);\r\n    bindPairArray[0] = bindPair;\r\n    folder.bindPairs = bindPairArray;\r\n    assertEquals(0, folder.findBindPairForInStream(0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFolderTest.java",
  "methodName" : "testGetUnpackSizeForCoderOne",
  "sourceCode" : "@Test\r\nvoid testGetUnpackSizeForCoderOne() {\r\n    final Folder folder = new Folder();\r\n    final Coder[] coderArray = new Coder[5];\r\n    final Coder coder = new Coder(null, 0, 0, null);\r\n    folder.coders = coderArray;\r\n    assertEquals(0L, folder.getUnpackSizeForCoder(coder));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFolderTest.java",
  "methodName" : "testGetUnpackSizeOne",
  "sourceCode" : "@Test\r\nvoid testGetUnpackSizeOne() throws ArchiveException {\r\n    final Folder folder = new Folder();\r\n    folder.totalOutputStreams = 266L;\r\n    final BindPair[] bindPairArray = new BindPair[1];\r\n    final BindPair bindPair = new BindPair(0, 0);\r\n    bindPairArray[0] = bindPair;\r\n    folder.bindPairs = bindPairArray;\r\n    folder.totalOutputStreams = 1L;\r\n    assertEquals(0L, folder.getUnpackSize());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZFolderTest.java",
  "methodName" : "testGetUnpackSizeTwo",
  "sourceCode" : "@Test\r\nvoid testGetUnpackSizeTwo() throws ArchiveException {\r\n    final Folder folder = new Folder();\r\n    assertEquals(0L, folder.getUnpackSize());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZHugeNextHeaderTest.java",
  "methodName" : "test",
  "sourceCode" : "@Test\r\nvoid test() throws IOException {\r\n    generate();\r\n    try {\r\n        getEntries();\r\n    } catch (final MemoryLimitException ignore) {\r\n        // You may need a lower memory configuration to get here, depending on your OS, Java version, and/or container.\r\n        // For example: -Xmx128m\r\n        ignore.printStackTrace();\r\n    } catch (final ArchiveException ignore) {\r\n        // If a MemoryLimitException isn't thrown beause a lot of memory is available, then we get this failure:\r\n        // org.apache.commons.compress.archivers.ArchiveException: Broken or unsupported archive: no Header\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldAllowLZMA2OptionsForLZMA",
  "sourceCode" : "@Test\r\nvoid testShouldAllowLZMA2OptionsForLZMA() {\r\n    assertNotNull(new SevenZMethodConfiguration(SevenZMethod.LZMA, new LZMA2Options()).getOptions());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldAllowLZMA2OptionsForLZMA2",
  "sourceCode" : "@Test\r\nvoid testShouldAllowLZMA2OptionsForLZMA2() {\r\n    assertNotNull(new SevenZMethodConfiguration(SevenZMethod.LZMA2, new LZMA2Options()).getOptions());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldAllowNullOptions",
  "sourceCode" : "@Test\r\nvoid testShouldAllowNullOptions() {\r\n    assertNull(new SevenZMethodConfiguration(SevenZMethod.LZMA2, null).getOptions());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldAllowNumberForBzip2",
  "sourceCode" : "@Test\r\nvoid testShouldAllowNumberForBzip2() {\r\n    assertNotNull(new SevenZMethodConfiguration(SevenZMethod.BZIP2, 42).getOptions());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldAllowNumberForDeflate",
  "sourceCode" : "@Test\r\nvoid testShouldAllowNumberForDeflate() {\r\n    assertNotNull(new SevenZMethodConfiguration(SevenZMethod.DEFLATE, 42).getOptions());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldAllowNumberForLZMA",
  "sourceCode" : "@Test\r\nvoid testShouldAllowNumberForLZMA() {\r\n    assertNotNull(new SevenZMethodConfiguration(SevenZMethod.LZMA, 42).getOptions());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldAllowNumberForLZMA2",
  "sourceCode" : "@Test\r\nvoid testShouldAllowNumberForLZMA2() {\r\n    assertNotNull(new SevenZMethodConfiguration(SevenZMethod.LZMA2, 42).getOptions());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldNotAllowStringOptionsForLZMA",
  "sourceCode" : "@Test\r\nvoid testShouldNotAllowStringOptionsForLZMA() {\r\n    assertThrows(IllegalArgumentException.class, () -> new SevenZMethodConfiguration(SevenZMethod.LZMA, \"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZMethodConfigurationTest.java",
  "methodName" : "testShouldNotAllowStringOptionsForLZMA2",
  "sourceCode" : "@Test\r\nvoid testShouldNotAllowStringOptionsForLZMA2() {\r\n    assertThrows(IllegalArgumentException.class, () -> new SevenZMethodConfiguration(SevenZMethod.LZMA2, \"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZNativeHeapTest.java",
  "methodName" : "testEndDeflaterOnCloseStream",
  "sourceCode" : "@Test\r\nvoid testEndDeflaterOnCloseStream() throws Exception {\r\n    final Coders.DeflateDecoder deflateDecoder = new DeflateDecoder();\r\n    final DelegatingDeflater delegatingDeflater;\r\n    try (DeflateDecoderOutputStream outputStream = (DeflateDecoderOutputStream) deflateDecoder.encode(new ByteArrayOutputStream(), 9)) {\r\n        delegatingDeflater = new DelegatingDeflater(outputStream.deflater);\r\n        outputStream.deflater = delegatingDeflater;\r\n    }\r\n    assertTrue(delegatingDeflater.isEnded.get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZNativeHeapTest.java",
  "methodName" : "testEndInflaterOnCloseStream",
  "sourceCode" : "@Test\r\nvoid testEndInflaterOnCloseStream() throws Exception {\r\n    final Coders.DeflateDecoder deflateDecoder = new DeflateDecoder();\r\n    final DelegatingInflater delegatingInflater;\r\n    try (DeflateDecoderInputStream inputStream = (DeflateDecoderInputStream) deflateDecoder.decode(\"dummy\", new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY), 0, null, null, Integer.MAX_VALUE)) {\r\n        delegatingInflater = new DelegatingInflater(inputStream.inflater);\r\n        inputStream.inflater = delegatingInflater;\r\n    }\r\n    assertTrue(delegatingInflater.isEnded.get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testArchiveWithMixedMethods",
  "sourceCode" : "@Test\r\nvoid testArchiveWithMixedMethods() throws Exception {\r\n    final File output = newTempFile(\"mixed-methods.7z\");\r\n    try (SevenZOutputFile outArchive = new SevenZOutputFile(output)) {\r\n        addFile(outArchive, 0, true);\r\n        addFile(outArchive, 1, true, Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.BZIP2)));\r\n    }\r\n    try (SevenZFile archive = SevenZFile.builder().setFile(output).get()) {\r\n        assertEquals(Boolean.TRUE, verifyFile(archive, 0, Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.LZMA2))));\r\n        assertEquals(Boolean.TRUE, verifyFile(archive, 1, Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.BZIP2))));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testBCJARMRoundtrip",
  "sourceCode" : "@Test\r\nvoid testBCJARMRoundtrip() throws Exception {\r\n    if (XZ_BCJ_IS_BUGGY) {\r\n        return;\r\n    }\r\n    testFilterRoundTrip(new SevenZMethodConfiguration(SevenZMethod.BCJ_ARM_FILTER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testBCJARMThumbRoundtrip",
  "sourceCode" : "@Test\r\nvoid testBCJARMThumbRoundtrip() throws Exception {\r\n    if (XZ_BCJ_IS_BUGGY) {\r\n        return;\r\n    }\r\n    testFilterRoundTrip(new SevenZMethodConfiguration(SevenZMethod.BCJ_ARM_THUMB_FILTER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testBCJIA64Roundtrip",
  "sourceCode" : "@Test\r\nvoid testBCJIA64Roundtrip() throws Exception {\r\n    if (XZ_BCJ_IS_BUGGY) {\r\n        return;\r\n    }\r\n    testFilterRoundTrip(new SevenZMethodConfiguration(SevenZMethod.BCJ_IA64_FILTER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testBCJPPCRoundtrip",
  "sourceCode" : "@Test\r\nvoid testBCJPPCRoundtrip() throws Exception {\r\n    if (XZ_BCJ_IS_BUGGY) {\r\n        return;\r\n    }\r\n    testFilterRoundTrip(new SevenZMethodConfiguration(SevenZMethod.BCJ_PPC_FILTER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testBCJSparcRoundtrip",
  "sourceCode" : "@Test\r\nvoid testBCJSparcRoundtrip() throws Exception {\r\n    if (XZ_BCJ_IS_BUGGY) {\r\n        return;\r\n    }\r\n    testFilterRoundTrip(new SevenZMethodConfiguration(SevenZMethod.BCJ_SPARC_FILTER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testBCJX86Roundtrip",
  "sourceCode" : "@Test\r\nvoid testBCJX86Roundtrip() throws Exception {\r\n    if (XZ_BCJ_IS_BUGGY) {\r\n        return;\r\n    }\r\n    testFilterRoundTrip(new SevenZMethodConfiguration(SevenZMethod.BCJ_X86_FILTER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testBzip2Roundtrip",
  "sourceCode" : "@Test\r\nvoid testBzip2Roundtrip() throws Exception {\r\n    testRoundTrip(SevenZMethod.BZIP2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testBzip2WithConfiguration",
  "sourceCode" : "@Test\r\nvoid testBzip2WithConfiguration() throws Exception {\r\n    final File output = newTempFile(\"bzip2-options.7z\");\r\n    // 400k block size\r\n    createAndReadBack(output, Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.BZIP2, 4)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testCantFinishTwice",
  "sourceCode" : "@Test\r\nvoid testCantFinishTwice() throws IOException {\r\n    final File output = newTempFile(\"finish.7z\");\r\n    try (SevenZOutputFile outArchive = new SevenZOutputFile(output)) {\r\n        outArchive.finish();\r\n        final IOException ex = assertThrows(ArchiveException.class, outArchive::finish, \"shouldn't be able to call finish twice\");\r\n        assertEquals(\"This archive has already been finished\", ex.getMessage());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testCopyRoundtrip",
  "sourceCode" : "@Test\r\nvoid testCopyRoundtrip() throws Exception {\r\n    testRoundTrip(SevenZMethod.COPY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testDeflateRoundtrip",
  "sourceCode" : "@Test\r\nvoid testDeflateRoundtrip() throws Exception {\r\n    testRoundTrip(SevenZMethod.DEFLATE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testDeflateWithConfiguration",
  "sourceCode" : "@Test\r\nvoid testDeflateWithConfiguration() throws Exception {\r\n    final File output = newTempFile(\"deflate-options.7z\");\r\n    // Deflater.BEST_SPEED\r\n    createAndReadBack(output, Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.DEFLATE, 1)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testDeltaRoundtrip",
  "sourceCode" : "@Test\r\nvoid testDeltaRoundtrip() throws Exception {\r\n    testFilterRoundTrip(new SevenZMethodConfiguration(SevenZMethod.DELTA_FILTER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testDirectoriesAndEmptyFiles",
  "sourceCode" : "@Test\r\nvoid testDirectoriesAndEmptyFiles() throws Exception {\r\n    final File output = newTempFile(\"empties.7z\");\r\n    final FileTime accessTime = getHundredNanosFileTime();\r\n    final Date accessDate = new Date(accessTime.toMillis());\r\n    final Calendar cal = Calendar.getInstance();\r\n    cal.add(Calendar.HOUR, -1);\r\n    final Date creationDate = cal.getTime();\r\n    try (SevenZOutputFile outArchive = new SevenZOutputFile(output)) {\r\n        SevenZArchiveEntry entry = outArchive.createArchiveEntry(getTempDirFile(), \"foo/\");\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.closeArchiveEntry();\r\n        entry = new SevenZArchiveEntry();\r\n        entry.setName(\"foo/bar\");\r\n        entry.setCreationDate(creationDate);\r\n        entry.setAccessTime(accessTime);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(ArrayUtils.EMPTY_BYTE_ARRAY);\r\n        outArchive.closeArchiveEntry();\r\n        entry = new SevenZArchiveEntry();\r\n        entry.setName(\"foo/bar/boo0\");\r\n        entry.setCreationDate(creationDate);\r\n        entry.setAccessTime(accessTime);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY));\r\n        outArchive.closeArchiveEntry();\r\n        entry = new SevenZArchiveEntry();\r\n        entry.setName(\"foo/bar/boo1\");\r\n        entry.setCreationDate(creationDate);\r\n        entry.setAccessTime(accessTime);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(new ByteArrayInputStream(new byte[] { 'a' }));\r\n        outArchive.closeArchiveEntry();\r\n        entry = new SevenZArchiveEntry();\r\n        entry.setName(\"foo/bar/boo10000\");\r\n        entry.setCreationDate(creationDate);\r\n        entry.setAccessTime(accessTime);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(new ByteArrayInputStream(new byte[10000]));\r\n        outArchive.closeArchiveEntry();\r\n        entry = new SevenZArchiveEntry();\r\n        entry.setName(\"foo/bar/test.txt\");\r\n        entry.setCreationDate(creationDate);\r\n        entry.setAccessTime(accessTime);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(Paths.get(\"src/test/resources/test.txt\"));\r\n        outArchive.closeArchiveEntry();\r\n        entry = new SevenZArchiveEntry();\r\n        entry.setName(\"xyzzy\");\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(0);\r\n        outArchive.closeArchiveEntry();\r\n        entry = outArchive.createArchiveEntry(getTempDirFile(), \"baz/\");\r\n        entry.setAntiItem(true);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.closeArchiveEntry();\r\n        entry = outArchive.createArchiveEntry(getTempDirFile().toPath(), \"baz2/\");\r\n        entry.setAntiItem(true);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.closeArchiveEntry();\r\n        entry = new SevenZArchiveEntry();\r\n        entry.setName(\"dada\");\r\n        entry.setHasWindowsAttributes(true);\r\n        entry.setWindowsAttributes(17);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.write(5);\r\n        outArchive.write(42);\r\n        outArchive.closeArchiveEntry();\r\n        outArchive.finish();\r\n    }\r\n    try (SevenZFile archive = SevenZFile.builder().setFile(output).get()) {\r\n        SevenZArchiveEntry entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"foo/\", entry.getName());\r\n        assertTrue(entry.isDirectory());\r\n        assertFalse(entry.isAntiItem());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"foo/bar\", entry.getName());\r\n        assertFalse(entry.isDirectory());\r\n        assertFalse(entry.isAntiItem());\r\n        assertEquals(0, entry.getSize());\r\n        assertFalse(entry.getHasLastModifiedDate());\r\n        assertEquals(accessTime, entry.getAccessTime());\r\n        assertEquals(accessDate, entry.getAccessDate());\r\n        assertEquals(creationDate, entry.getCreationDate());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"foo/bar/boo0\", entry.getName());\r\n        assertFalse(entry.isDirectory());\r\n        assertFalse(entry.isAntiItem());\r\n        assertEquals(0, entry.getSize());\r\n        assertFalse(entry.getHasLastModifiedDate());\r\n        assertEquals(accessTime, entry.getAccessTime());\r\n        assertEquals(accessDate, entry.getAccessDate());\r\n        assertEquals(creationDate, entry.getCreationDate());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"foo/bar/boo1\", entry.getName());\r\n        assertFalse(entry.isDirectory());\r\n        assertFalse(entry.isAntiItem());\r\n        assertEquals(1, entry.getSize());\r\n        assertFalse(entry.getHasLastModifiedDate());\r\n        assertEquals(accessTime, entry.getAccessTime());\r\n        assertEquals(accessDate, entry.getAccessDate());\r\n        assertEquals(creationDate, entry.getCreationDate());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"foo/bar/boo10000\", entry.getName());\r\n        assertFalse(entry.isDirectory());\r\n        assertFalse(entry.isAntiItem());\r\n        assertEquals(10000, entry.getSize());\r\n        assertFalse(entry.getHasLastModifiedDate());\r\n        assertEquals(accessTime, entry.getAccessTime());\r\n        assertEquals(accessDate, entry.getAccessDate());\r\n        assertEquals(creationDate, entry.getCreationDate());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"foo/bar/test.txt\", entry.getName());\r\n        assertFalse(entry.isDirectory());\r\n        assertFalse(entry.isAntiItem());\r\n        assertEquals(Files.size(Paths.get(\"src/test/resources/test.txt\")), entry.getSize());\r\n        assertFalse(entry.getHasLastModifiedDate());\r\n        assertEquals(accessTime, entry.getAccessTime());\r\n        assertEquals(accessDate, entry.getAccessDate());\r\n        assertEquals(creationDate, entry.getCreationDate());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"xyzzy\", entry.getName());\r\n        assertEquals(1, entry.getSize());\r\n        assertFalse(entry.getHasAccessDate());\r\n        assertFalse(entry.getHasCreationDate());\r\n        assertEquals(0, archive.read());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"baz/\", entry.getName());\r\n        assertTrue(entry.isDirectory());\r\n        assertTrue(entry.isAntiItem());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"baz2/\", entry.getName());\r\n        assertTrue(entry.isDirectory());\r\n        assertTrue(entry.isAntiItem());\r\n        entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"Entry should not be null\");\r\n        assertEquals(\"dada\", entry.getName());\r\n        assertEquals(2, entry.getSize());\r\n        final byte[] content = new byte[2];\r\n        assertEquals(2, archive.read(content));\r\n        assertEquals(5, content[0]);\r\n        assertEquals(42, content[1]);\r\n        assertEquals(17, entry.getWindowsAttributes());\r\n        assertNull(archive.getNextEntry(), \"getNextEntry should return null\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testDirectoriesOnly",
  "sourceCode" : "@Test\r\nvoid testDirectoriesOnly() throws Exception {\r\n    final File output = newTempFile(\"dirs.7z\");\r\n    try (SevenZOutputFile outArchive = new SevenZOutputFile(output)) {\r\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\r\n        entry.setName(\"foo/\");\r\n        entry.setDirectory(true);\r\n        outArchive.putArchiveEntry(entry);\r\n        outArchive.closeArchiveEntry();\r\n    }\r\n    try (SevenZFile archive = SevenZFile.builder().setFile(output).get()) {\r\n        final SevenZArchiveEntry entry = archive.getNextEntry();\r\n        assertNotNull(entry, \"entry should not be null\");\r\n        assertEquals(\"foo/\", entry.getName());\r\n        assertTrue(entry.isDirectory());\r\n        assertFalse(entry.isAntiItem());\r\n        assertNull(archive.getNextEntry(), \"getnextEntry should return null\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testEightEmptyFiles",
  "sourceCode" : "@Test\r\nvoid testEightEmptyFiles() throws Exception {\r\n    testCompress252(8, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testEightFilesSomeNotEmpty",
  "sourceCode" : "@Test\r\nvoid testEightFilesSomeNotEmpty() throws Exception {\r\n    testCompress252(8, 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testEncrypt",
  "sourceCode" : "/**\r\n * Test password-based encryption\r\n *\r\n * <p>\r\n * As AES/CBC Cipher requires a minimum of 16 bytes file data to be encrypted, some padding logic has been implemented. This test checks different file\r\n * sizes (1, 16..) to ensure code coverage\r\n * </p>\r\n */\r\n@Test\r\nvoid testEncrypt() throws Exception {\r\n    final File output = newTempFile(\"encrypted.7z\");\r\n    try (SevenZOutputFile outArchive = new SevenZOutputFile(output, \"foo\".toCharArray())) {\r\n        addFile(outArchive, 0, 1, null);\r\n        addFile(outArchive, 1, 16, null);\r\n        addFile(outArchive, 2, 32, null);\r\n        addFile(outArchive, 3, 33, null);\r\n        addFile(outArchive, 4, 10000, null);\r\n    }\r\n    // Is archive really password-based encrypted ?\r\n    try (SevenZFile archive = SevenZFile.builder().setFile(output).get()) {\r\n        assertThrows(PasswordRequiredException.class, () -> verifyFile(archive, 0), \"A password should be needed\");\r\n    }\r\n    try (SevenZFile archive = SevenZFile.builder().setFile(output).setPassword(\"foo\").get()) {\r\n        assertEquals(Boolean.TRUE, verifyFile(archive, 0, 1, null));\r\n        assertEquals(Boolean.TRUE, verifyFile(archive, 1, 16, null));\r\n        assertEquals(Boolean.TRUE, verifyFile(archive, 2, 32, null));\r\n        assertEquals(Boolean.TRUE, verifyFile(archive, 3, 33, null));\r\n        assertEquals(Boolean.TRUE, verifyFile(archive, 4, 10000, null));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testLzma2Roundtrip",
  "sourceCode" : "@Test\r\nvoid testLzma2Roundtrip() throws Exception {\r\n    testRoundTrip(SevenZMethod.LZMA2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testLzma2WithIntConfiguration",
  "sourceCode" : "@Test\r\nvoid testLzma2WithIntConfiguration() throws Exception {\r\n    final File output = newTempFile(\"lzma2-options.7z\");\r\n    // 1 MB dictionary\r\n    createAndReadBack(output, Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA2, 1 << 20)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testLzma2WithOptionsConfiguration",
  "sourceCode" : "@Test\r\nvoid testLzma2WithOptionsConfiguration() throws Exception {\r\n    final File output = newTempFile(\"lzma2-options2.7z\");\r\n    final LZMA2Options opts = new LZMA2Options(1);\r\n    createAndReadBack(output, Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA2, opts)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testLzmaWithIntConfiguration",
  "sourceCode" : "@Test\r\nvoid testLzmaWithIntConfiguration() throws Exception {\r\n    final File output = newTempFile(\"lzma-options.7z\");\r\n    // 1 MB dictionary\r\n    createAndReadBack(output, Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA, 1 << 20)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testLzmaWithOptionsConfiguration",
  "sourceCode" : "@Test\r\nvoid testLzmaWithOptionsConfiguration() throws Exception {\r\n    final File output = newTempFile(\"lzma-options2.7z\");\r\n    final LZMA2Options opts = new LZMA2Options(1);\r\n    createAndReadBack(output, Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA, opts)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testNineEmptyFiles",
  "sourceCode" : "@Test\r\nvoid testNineEmptyFiles() throws Exception {\r\n    testCompress252(9, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testNineFilesSomeNotEmpty",
  "sourceCode" : "@Test\r\nvoid testNineFilesSomeNotEmpty() throws Exception {\r\n    testCompress252(9, 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testSevenEmptyFiles",
  "sourceCode" : "@Test\r\nvoid testSevenEmptyFiles() throws Exception {\r\n    testCompress252(7, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testSevenFilesSomeNotEmpty",
  "sourceCode" : "@Test\r\nvoid testSevenFilesSomeNotEmpty() throws Exception {\r\n    testCompress252(7, 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testSixEmptyFiles",
  "sourceCode" : "@Test\r\nvoid testSixEmptyFiles() throws Exception {\r\n    testCompress252(6, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testSixFilesSomeNotEmpty",
  "sourceCode" : "@Test\r\nvoid testSixFilesSomeNotEmpty() throws Exception {\r\n    testCompress252(6, 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testStackOfContentCompressions",
  "sourceCode" : "@Test\r\nvoid testStackOfContentCompressions() throws Exception {\r\n    final File output = newTempFile(\"multiple-methods.7z\");\r\n    final ArrayList<SevenZMethodConfiguration> methods = new ArrayList<>();\r\n    methods.add(new SevenZMethodConfiguration(SevenZMethod.LZMA2));\r\n    methods.add(new SevenZMethodConfiguration(SevenZMethod.COPY));\r\n    methods.add(new SevenZMethodConfiguration(SevenZMethod.DEFLATE));\r\n    methods.add(new SevenZMethodConfiguration(SevenZMethod.BZIP2));\r\n    createAndReadBack(output, methods);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testStackOfContentCompressionsInMemory",
  "sourceCode" : "@Test\r\nvoid testStackOfContentCompressionsInMemory() throws Exception {\r\n    final ArrayList<SevenZMethodConfiguration> methods = new ArrayList<>();\r\n    methods.add(new SevenZMethodConfiguration(SevenZMethod.LZMA2));\r\n    methods.add(new SevenZMethodConfiguration(SevenZMethod.COPY));\r\n    methods.add(new SevenZMethodConfiguration(SevenZMethod.DEFLATE));\r\n    methods.add(new SevenZMethodConfiguration(SevenZMethod.BZIP2));\r\n    try (SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel()) {\r\n        createAndReadBack(channel, methods);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testTwentyNineEmptyFiles",
  "sourceCode" : "@Test\r\nvoid testTwentyNineEmptyFiles() throws Exception {\r\n    testCompress252(29, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZOutputFileTest.java",
  "methodName" : "testTwentyNineFilesSomeNotEmpty",
  "sourceCode" : "@Test\r\nvoid testTwentyNineFilesSomeNotEmpty() throws Exception {\r\n    testCompress252(29, 7);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\sevenz\\SevenZReadSubStreamsInfoTest.java",
  "methodName" : "testReadSubStreamsInfo",
  "sourceCode" : "@Test\r\nvoid testReadSubStreamsInfo() throws IOException {\r\n    assertThrows(MemoryLimitException.class, () -> SevenZFile.builder().setPath(\"src/test/resources/org/apache/commons/compress/sevenz/readSubStreamsInfo.bin\").get().close());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingAES",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingAES() throws Exception {\r\n    assumeStrongCryptoIsAvailable();\r\n    try (SevenZFile archive = new SevenZFile(getFile(\"bla.encrypted.7z\"), \"foo\".toCharArray())) {\r\n        multiByteReadConsistentlyReturnsMinusOneAtEof(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingBZIP2",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingBZIP2() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.BZIP2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.DEFLATE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingLZMA",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingLZMA() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.LZMA);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingLZMA2",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingLZMA2() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.LZMA2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSevenZArchiveCreationUsingBZIP2",
  "sourceCode" : "@Test\r\nvoid testSevenZArchiveCreationUsingBZIP2() throws Exception {\r\n    testSevenZArchiveCreation(SevenZMethod.BZIP2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSevenZArchiveCreationUsingCopy",
  "sourceCode" : "@Test\r\nvoid testSevenZArchiveCreationUsingCopy() throws Exception {\r\n    testSevenZArchiveCreation(SevenZMethod.COPY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSevenZArchiveCreationUsingDeflate",
  "sourceCode" : "@Test\r\nvoid testSevenZArchiveCreationUsingDeflate() throws Exception {\r\n    testSevenZArchiveCreation(SevenZMethod.DEFLATE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSevenZArchiveCreationUsingLZMA",
  "sourceCode" : "@Test\r\nvoid testSevenZArchiveCreationUsingLZMA() throws Exception {\r\n    testSevenZArchiveCreation(SevenZMethod.LZMA);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSevenZArchiveCreationUsingLZMA2",
  "sourceCode" : "@Test\r\nvoid testSevenZArchiveCreationUsingLZMA2() throws Exception {\r\n    testSevenZArchiveCreation(SevenZMethod.LZMA2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingAES",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingAES() throws Exception {\r\n    assumeStrongCryptoIsAvailable();\r\n    try (SevenZFile archive = new SevenZFile(getFile(\"bla.encrypted.7z\"), \"foo\".toCharArray())) {\r\n        singleByteReadConsistentlyReturnsMinusOneAtEof(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingBZIP2",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingBZIP2() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.BZIP2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingCopy",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingCopy() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.COPY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.DEFLATE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingLZMA",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingLZMA() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.LZMA);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\SevenZTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingLZMA2",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingLZMA2() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(SevenZMethod.LZMA2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\BigFilesIT.java",
  "methodName" : "testReadFileBiggerThan8GBytePosix",
  "sourceCode" : "@Test\r\nvoid testReadFileBiggerThan8GBytePosix() throws Exception {\r\n    readFileBiggerThan8GByte(\"8.posix.tar.gz\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\BigFilesIT.java",
  "methodName" : "testReadFileBiggerThan8GByteStar",
  "sourceCode" : "@Test\r\nvoid testReadFileBiggerThan8GByteStar() throws Exception {\r\n    readFileBiggerThan8GByte(\"8.star.tar.gz\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\BigFilesIT.java",
  "methodName" : "testReadFileHeadersOfArchiveBiggerThan8GByte",
  "sourceCode" : "@Test\r\nvoid testReadFileHeadersOfArchiveBiggerThan8GByte() throws Exception {\r\n    try (InputStream in = new BufferedInputStream(Files.newInputStream(getPath(\"8.posix.tar.gz\")));\r\n        GzipCompressorInputStream gzin = new GzipCompressorInputStream(in);\r\n        TarArchiveInputStream tin = TarArchiveInputStream.builder().setInputStream(gzin).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\BigFilesIT.java",
  "methodName" : "testTarFileReadFileHeadersOfArchiveBiggerThan8GByte",
  "sourceCode" : "@Test\r\nvoid testTarFileReadFileHeadersOfArchiveBiggerThan8GByte() throws Exception {\r\n    final Path file = getPath(\"8.posix.tar.gz\");\r\n    final Path output = tempResultDir.toPath().resolve(\"8.posix.tar\");\r\n    try (InputStream in = new BufferedInputStream(Files.newInputStream(file));\r\n        GzipCompressorInputStream gzin = new GzipCompressorInputStream(in)) {\r\n        Files.copy(gzin, output, StandardCopyOption.REPLACE_EXISTING);\r\n    }\r\n    try (TarFile tarFile = new TarFile(output)) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(1, entries.size());\r\n        assertNotNull(entries.get(0));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\Compress699Test.java",
  "methodName" : "testTarArchive",
  "sourceCode" : "@Test\r\nvoid testTarArchive() throws Exception {\r\n    final Path fileToTest = Paths.get(\"src/test/resources/org/apache/commons/compress/COMPRESS-699/icure_medical_device_dart_sdk-1.2.10.tar\");\r\n    try (BufferedInputStream fileInputStream = new BufferedInputStream(Files.newInputStream(fileToTest))) {\r\n        assertEquals(ArchiveStreamFactory.TAR, ArchiveStreamFactory.detect(fileInputStream));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\Compress700Test.java",
  "methodName" : "testFirstTarArchiveEntry",
  "sourceCode" : "@Test\r\nvoid testFirstTarArchiveEntry() throws Exception {\r\n    try (TarArchiveInputStream inputStream = TarArchiveInputStream.builder().setURI(getURI(RESOURCE_NAME)).get()) {\r\n        final TarArchiveEntry entry = inputStream.getNextEntry();\r\n        assertNull(entry.getCreationTime());\r\n        assertEquals(-1, entry.getDataOffset());\r\n        assertEquals(0, entry.getDevMajor());\r\n        assertEquals(0, entry.getDevMinor());\r\n        assertEquals(Collections.emptyMap(), entry.getExtraPaxHeaders());\r\n        assertEquals(0, entry.getGroupId());\r\n        assertEquals(\"\", entry.getGroupName());\r\n        assertNull(entry.getLastAccessTime());\r\n        assertEquals(Date.parse(\"Tue Dec 03 05:08:42 EST 2019\"), entry.getLastModifiedDate().getTime());\r\n        assertEquals(FileTime.from(Instant.parse(\"2019-12-03T10:08:42Z\")), entry.getLastModifiedTime());\r\n        assertEquals(48, entry.getLinkFlag());\r\n        assertEquals(\"\", entry.getLinkName());\r\n        assertEquals(0, entry.getLongGroupId());\r\n        assertEquals(0, entry.getLongUserId());\r\n        assertEquals(33279, entry.getMode());\r\n        assertEquals(Date.parse(\"Tue Dec 03 05:08:42 EST 2019\"), entry.getModTime().getTime());\r\n        assertEquals(\"build/app.dill\", entry.getName());\r\n        assertNull(entry.getPath());\r\n        assertEquals(0, entry.getRealSize());\r\n        assertEquals(0, entry.getSize());\r\n        assertNull(entry.getStatusChangeTime());\r\n        assertEquals(0, entry.getUserId());\r\n        assertEquals(\"\", entry.getUserName());\r\n        assertTrue(entry.isFile());\r\n        assertFalse(entry.isBlockDevice());\r\n        assertFalse(entry.isCharacterDevice());\r\n        assertTrue(entry.isCheckSumOK());\r\n        assertFalse(entry.isDirectory());\r\n        assertFalse(entry.isExtended());\r\n        assertFalse(entry.isFIFO());\r\n        assertFalse(entry.isGlobalPaxHeader());\r\n        assertFalse(entry.isGNULongLinkEntry());\r\n        assertFalse(entry.isGNULongNameEntry());\r\n        assertFalse(entry.isGNUSparse());\r\n        assertFalse(entry.isLink());\r\n        assertFalse(entry.isOldGNUSparse());\r\n        assertFalse(entry.isPaxGNU1XSparse());\r\n        assertFalse(entry.isPaxGNUSparse());\r\n        assertFalse(entry.isPaxHeader());\r\n        assertFalse(entry.isSparse());\r\n        assertFalse(entry.isStarSparse());\r\n        assertTrue(entry.isStreamContiguous());\r\n        assertFalse(entry.isSymbolicLink());\r\n        assertTrue(entry.isTypeFlagUstar());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\Compress700Test.java",
  "methodName" : "testListEntries",
  "sourceCode" : "@Test\r\nvoid testListEntries() throws IOException {\r\n    final List<Object[]> list = Arrays.asList(// 0\r\n    new Object[] { 0, \"build/app.dill\" }, new Object[] { 105, \"CHANGELOG.md\" }, new Object[] { 2119, \"example/android/app/build.gradle\" }, new Object[] { 339, \"example/android/app/src/debug/AndroidManifest.xml\" }, new Object[] { 1745, \"example/android/app/src/main/AndroidManifest.xml\" }, new Object[] { 559, \"example/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java\" }, new Object[] { 353, \"example/android/app/src/main/kotlin/com/example/test_package/MainActivity.kt\" }, new Object[] { 446, \"example/android/app/src/main/res/drawable/launch_background.xml\" }, new Object[] { 544, \"example/android/app/src/main/res/mipmap-hdpi/ic_launcher.png\" }, new Object[] { 442, \"example/android/app/src/main/res/mipmap-mdpi/ic_launcher.png\" }, // 10\r\n    new Object[] { 721, \"example/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png\" }, new Object[] { 1031, \"example/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png\" }, new Object[] { 1443, \"example/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png\" }, new Object[] { 369, \"example/android/app/src/main/res/values/styles.xml\" }, new Object[] { 339, \"example/android/app/src/profile/AndroidManifest.xml\" }, new Object[] { 613, \"example/android/build.gradle\" }, new Object[] { 32, \"example/android/gradle.properties\" }, new Object[] { 4971, \"example/android/gradlew\" }, new Object[] { 2404, \"example/android/gradlew.bat\" }, new Object[] { 53636, \"example/android/gradle/wrapper/gradle-wrapper.jar\" }, // 20\r\n    new Object[] { 240, \"example/android/gradle/wrapper/gradle-wrapper.properties\" }, new Object[] { 150, \"example/android/local.properties\" }, new Object[] { 499, \"example/android/settings.gradle\" }, new Object[] { 1630, \"example/android/test_package_android.iml\" }, new Object[] { 820, \"example/ios/Flutter/AppFrameworkInfo.plist\" }, new Object[] { 31, \"example/ios/Flutter/Debug.xcconfig\" }, new Object[] { 461, \"example/ios/Flutter/flutter_export_environment.sh\" }, new Object[] { 380, \"example/ios/Flutter/Generated.xcconfig\" }, new Object[] { 31, \"example/ios/Flutter/Release.xcconfig\" }, new Object[] { 21606, \"example/ios/Runner.xcodeproj/project.pbxproj\" }, // 30\r\n    new Object[] { 159, \"example/ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata\" }, new Object[] { 3382, \"example/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme\" }, new Object[] { 159, \"example/ios/Runner.xcworkspace/contents.xcworkspacedata\" }, new Object[] { 417, \"example/ios/Runner/AppDelegate.swift\" }, new Object[] { 2641, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json\" }, new Object[] { 10932, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-1024x1024@1x.png\" }, new Object[] { 564, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@1x.png\" }, new Object[] { 1283, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@2x.png\" }, new Object[] { 1588, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@3x.png\" }, new Object[] { 1025, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@1x.png\" }, new Object[] { 1716, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@2x.png\" }, new Object[] { 1920, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@3x.png\" }, new Object[] { 1283, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@1x.png\" }, new Object[] { 1895, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@2x.png\" }, new Object[] { 2665, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@3x.png\" }, new Object[] { 2665, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@2x.png\" }, new Object[] { 3831, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@3x.png\" }, new Object[] { 1888, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@1x.png\" }, new Object[] { 3294, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@2x.png\" }, new Object[] { 3612, \"example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-83.5x83.5@2x.png\" }, new Object[] { 414, \"example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json\" }, new Object[] { 68, \"example/ios/Runner/Assets.xcassets/LaunchImage.imageset/LaunchImage.png\" }, new Object[] { 68, \"example/ios/Runner/Assets.xcassets/LaunchImage.imageset/LaunchImage@2x.png\" }, new Object[] { 68, \"example/ios/Runner/Assets.xcassets/LaunchImage.imageset/LaunchImage@3x.png\" }, new Object[] { 340, \"example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md\" }, new Object[] { 2414, \"example/ios/Runner/Base.lproj/LaunchScreen.storyboard\" }, new Object[] { 1631, \"example/ios/Runner/Base.lproj/Main.storyboard\" }, new Object[] { 310, \"example/ios/Runner/GeneratedPluginRegistrant.h\" }, new Object[] { 204, \"example/ios/Runner/GeneratedPluginRegistrant.m\" }, new Object[] { 1576, \"example/ios/Runner/Info.plist\" }, new Object[] { 37, \"example/ios/Runner/Runner-Bridging-Header.h\" }, new Object[] { 8996, \"example/lib/main.dart\" }, new Object[] { 2759, \"example/pubspec.yaml\" }, new Object[] { 9879, \"example/README.md\" }, new Object[] { 1081, \"example/test/widget_test.dart\" }, new Object[] { 913, \"example/test_package.iml\" }, new Object[] { 1000, \"flutter_buttons.iml\" }, new Object[] { 36861, \"lib/flutter_awesome_buttons.dart\" }, new Object[] { 30, \"LICENSE\" }, new Object[] { 1751, \"pubspec.yaml\" }, new Object[] { 9879, \"README.md\" }, new Object[] { 433, \"test/flutter_buttons_test.dart\" });\r\n    // @formatter:on\r\n    try (TarArchiveInputStream inputStream = TarArchiveInputStream.builder().setURI(getURI(RESOURCE_NAME)).get()) {\r\n        final AtomicInteger i = new AtomicInteger();\r\n        for (final Object[] pair : list) {\r\n            final TarArchiveEntry entry = inputStream.getNextEntry();\r\n            assertNotNull(entry, entry.getName());\r\n            // System.out.println(entry);\r\n            final String name = (String) pair[1];\r\n            assertEquals(name, entry.getName(), () -> String.format(\"[%d] %s\", i.get(), entry));\r\n            final int size = ((Integer) pair[0]).intValue();\r\n            assertEquals(size, entry.getSize(), () -> String.format(\"[%d] %s\", i.get(), entry));\r\n            assertEquals(size, entry.getRealSize(), () -> String.format(\"[%d] %s\", i.get(), entry));\r\n            i.incrementAndGet();\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\Compress700Test.java",
  "methodName" : "testTarArchive",
  "sourceCode" : "//@Disabled\r\n//@Ignore\r\n@Test\r\nvoid testTarArchive() throws Exception {\r\n    try (BufferedInputStream fileInputStream = new BufferedInputStream(newInputStream(RESOURCE_NAME))) {\r\n        assertEquals(ArchiveStreamFactory.TAR, ArchiveStreamFactory.detect(fileInputStream));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarEpax",
  "sourceCode" : "// Extended POSIX.1-2001 standard tar + x-header\r\n// Created using s-tar 1.6\r\n@Test\r\nvoid testReadTimeFromTarEpax() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-epax-folder.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/\", e.getName());\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory());\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44.147126600Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T01:02:11.910960100Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44.147126600Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/test-times.txt\", e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertTrue(e.isFile());\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.536752000Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarExustar",
  "sourceCode" : "// 'xustar' format - always x-header\r\n@Test\r\nvoid testReadTimeFromTarExustar() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-exustar-folder.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"test/\", e.getName());\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory());\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44.147126600Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:47:00.367783300Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44.147126600Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertGlobalHeaders(e);\r\n        e = tin.getNextTarEntry();\r\n        assertEquals(\"test/test-times.txt\", e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertTrue(e.isFile());\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.536752000Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertGlobalHeaders(e);\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarGnu",
  "sourceCode" : "// GNU tar format 1989 (violates POSIX)\r\n// Created using GNU tar\r\n@Test\r\nvoid testReadTimeFromTarGnu() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-gnu.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarGnuIncremental",
  "sourceCode" : "// GNU tar format 1989 (violates POSIX)\r\n// Created using GNU tar\r\n@Test\r\nvoid testReadTimeFromTarGnuIncremental() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-gnu-incremental.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test-times.txt\", e.getName());\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test-times.txt\", e.getName());\r\n        assertEquals(toFileTime(\"2022-03-14T03:17:05Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T03:17:10Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T03:17:10Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarGnuTar",
  "sourceCode" : "// GNU tar format 1989 (violates POSIX)\r\n// Created using s-tar 1.6, which somehow differs from GNU tar's.\r\n@Test\r\nvoid testReadTimeFromTarGnuTar() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-gnutar.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-17T01:52:25Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T01:52:25Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T01:52:25Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarOldBsdTar",
  "sourceCode" : "// Old BSD tar format\r\n@Test\r\nvoid testReadTimeFromTarOldBsdTar() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-oldbsdtar.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-17T01:52:25Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarOldGnu",
  "sourceCode" : "// Format used by GNU tar of versions prior to 1.12\r\n// Created using GNU tar\r\n@Test\r\nvoid testReadTimeFromTarOldGnu() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-oldgnu.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarOldGnuIncremental",
  "sourceCode" : "// Format used by GNU tar of versions prior to 1.12\r\n// Created using GNU tar\r\n@Test\r\nvoid testReadTimeFromTarOldGnuIncremental() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-oldgnu-incremental.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test-times.txt\", e.getName());\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test-times.txt\", e.getName());\r\n        assertEquals(toFileTime(\"2022-03-14T03:17:05Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T03:17:06Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T03:17:05Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarPax",
  "sourceCode" : "// Extended POSIX.1-2001 standard tar\r\n// Created using s-tar 1.6, which somehow differs from GNU tar's.\r\n@Test\r\nvoid testReadTimeFromTarPax() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-pax-folder.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/\", e.getName());\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory());\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44.147126600Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T01:01:53.369146300Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44.147126600Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/test-times.txt\", e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertTrue(e.isFile());\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.536752000Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarPosix",
  "sourceCode" : "// Extended POSIX.1-2001 standard tar\r\n// Created using GNU tar\r\n@Test\r\nvoid testReadTimeFromTarPosix() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-posix.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03.599853900Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:31:00.706927200Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:28:59.700505300Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarPosixLibArchive",
  "sourceCode" : "// Extended POSIX.1-2001 standard tar\r\n// Created using BSD tar on Windows\r\n@Test\r\nvoid testReadTimeFromTarPosixLibArchive() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-bsd-folder.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/\", e.getName());\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory());\r\n        assertEquals(toFileTime(\"2022-03-16T10:19:43.382883700Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-16T10:21:01.251181000Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-16T10:19:24.105111500Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertEquals(toFileTime(\"2022-03-16T10:19:24.105111500Z\"), e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/test-times.txt\", e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertTrue(e.isFile());\r\n        assertEquals(toFileTime(\"2022-03-16T10:21:00.249238500Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-16T10:21:01.251181000Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03.599853900Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03.599853900Z\"), e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarPosixLinux",
  "sourceCode" : "// Extended POSIX.1-2001 standard tar\r\n// Created using GNU tar on Linux\r\n@Test\r\nvoid testReadTimeFromTarPosixLinux() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-posix-linux.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03.599853900Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:32:13.837251500Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:31:00.706927200Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarStarFolder",
  "sourceCode" : "// Old star format from 1985\r\n@Test\r\nvoid testReadTimeFromTarStarFolder() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-star-folder.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/\", e.getName());\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory());\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/test-times.txt\", e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertTrue(e.isFile());\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarUstar",
  "sourceCode" : "// Standard POSIX.1-1988 tar format\r\n@Test\r\nvoid testReadTimeFromTarUstar() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-ustar.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarV7",
  "sourceCode" : "// Old Unix V7 tar format\r\n@Test\r\nvoid testReadTimeFromTarV7() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-v7.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertNull(e.getLastAccessTime(), \"atime\");\r\n        assertNull(e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarXstar",
  "sourceCode" : "// Extended standard tar (star 1994)\r\n@Test\r\nvoid testReadTimeFromTarXstar() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-xstar.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-14T04:11:22Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T04:12:48Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T04:12:47Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarXstarFolder",
  "sourceCode" : "// Extended standard tar (star 1994)\r\n@Test\r\nvoid testReadTimeFromTarXstarFolder() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-xstar-folder.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/\", e.getName());\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory());\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T01:01:34Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertEquals(\"test/test-times.txt\", e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertTrue(e.isFile());\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarXstarIncremental",
  "sourceCode" : "// Extended standard tar (star 1994)\r\n@Test\r\nvoid testReadTimeFromTarXstarIncremental() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-xstar-incremental.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test-times.txt\", e.getName());\r\n        assertEquals(toFileTime(\"2022-03-14T04:03:29Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T04:03:29Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T04:03:29Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test-times.txt\", e.getName(), \"name\");\r\n        assertEquals(toFileTime(\"2022-03-14T04:11:22Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T04:11:23Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T04:11:22Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarXustar",
  "sourceCode" : "// 'xstar' format without tar signature\r\n@Test\r\nvoid testReadTimeFromTarXustar() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-xustar.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.536752000Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarXustarFolder",
  "sourceCode" : "// 'xstar' format without tar signature\r\n@Test\r\nvoid testReadTimeFromTarXustarFolder() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-xustar-folder.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/\", e.getName());\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory());\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44.147126600Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T01:01:19.581236400Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:24:44.147126600Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test/test-times.txt\", e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertTrue(e.isFile());\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.536752000Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\FileTimesIT.java",
  "methodName" : "testReadTimeFromTarXustarIncremental",
  "sourceCode" : "// 'xstar' format without tar signature\r\n@Test\r\nvoid testReadTimeFromTarXustarIncremental() throws Exception {\r\n    final String file = \"COMPRESS-612/test-times-xustar-incremental.tar\";\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(file)).get()) {\r\n        TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test-times.txt\", e.getName(), \"name\");\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.536752000Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T00:38:20.470751500Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        e = tin.getNextTarEntry();\r\n        assertNotNull(e);\r\n        assertTrue(e.getExtraPaxHeaders().isEmpty());\r\n        assertEquals(\"test-times.txt\", e.getName(), \"name\");\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertEquals(toFileTime(\"2022-03-17T01:52:25.592262900Z\"), e.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-17T01:52:25.724278500Z\"), e.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-17T01:52:25.592262900Z\"), e.getStatusChangeTime(), \"ctime\");\r\n        assertNull(e.getCreationTime(), \"birthtime\");\r\n        assertNull(tin.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testCompareTarArchiveInputStreamWithTarFile",
  "sourceCode" : "@Test\r\nvoid testCompareTarArchiveInputStreamWithTarFile() throws IOException {\r\n    final Path file = getPath(\"oldgnu_sparse.tar\");\r\n    try (TarArchiveInputStream tarIn = TarArchiveInputStream.builder().setPath(file).get();\r\n        TarFile tarFile = new TarFile(file)) {\r\n        assertNotNull(tarIn.getNextTarEntry());\r\n        try (InputStream inputStream = tarFile.getInputStream(tarFile.getEntries().get(0))) {\r\n            assertArrayEquals(IOUtils.toByteArray(tarIn), IOUtils.toByteArray(inputStream));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testExtractExtendedOldGNU",
  "sourceCode" : "@Test\r\n@DisabledOnOs(OS.WINDOWS)\r\nvoid testExtractExtendedOldGNU() throws IOException, InterruptedException {\r\n    final File file = getFile(\"oldgnu_extended_sparse.tar\");\r\n    try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparse6\");\r\n        TarArchiveInputStream tin = TarArchiveInputStream.builder().setFile(file).get()) {\r\n        final TarArchiveEntry ae = tin.getNextTarEntry();\r\n        assertTrue(tin.canReadEntryData(ae));\r\n        assertArrayEquals(IOUtils.toByteArray(tin), IOUtils.toByteArray(sparseFileInputStream));\r\n        final List<TarArchiveStructSparse> sparseHeaders = ae.getOrderedSparseHeaders();\r\n        assertEquals(7, sparseHeaders.size());\r\n        assertEquals(0, sparseHeaders.get(0).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(0).getNumbytes());\r\n        assertEquals(10240, sparseHeaders.get(1).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(1).getNumbytes());\r\n        assertEquals(16384, sparseHeaders.get(2).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(2).getNumbytes());\r\n        assertEquals(24576, sparseHeaders.get(3).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(3).getNumbytes());\r\n        assertEquals(29696, sparseHeaders.get(4).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(4).getNumbytes());\r\n        assertEquals(36864, sparseHeaders.get(5).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(5).getNumbytes());\r\n        assertEquals(51200, sparseHeaders.get(6).getOffset());\r\n        assertEquals(0, sparseHeaders.get(6).getNumbytes());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testExtractOldGNU",
  "sourceCode" : "@Test\r\n@DisabledOnOs(OS.WINDOWS)\r\nvoid testExtractOldGNU() throws IOException, InterruptedException {\r\n    try {\r\n        final File file = getFile(\"oldgnu_sparse.tar\");\r\n        try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparsefile\");\r\n            TarArchiveInputStream tin = TarArchiveInputStream.builder().setFile(file).get()) {\r\n            final TarArchiveEntry entry = tin.getNextTarEntry();\r\n            assertTrue(tin.canReadEntryData(entry));\r\n            assertArrayEquals(IOUtils.toByteArray(tin), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n    } catch (RuntimeException | IOException ex) {\r\n        ex.printStackTrace();\r\n        throw ex;\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testExtractPaxGNU",
  "sourceCode" : "@Test\r\n@DisabledOnOs(OS.WINDOWS)\r\nvoid testExtractPaxGNU() throws IOException, InterruptedException {\r\n    // GNU tar with version 1.28 has some problems reading sparsefile-0.1,\r\n    // so the test should be skipped then\r\n    // TODO : what about the versions lower than 1.28?\r\n    assumeFalse(getTarBinaryHelp().startsWith(\"tar (GNU tar) 1.28\"), \"This test should be ignored if GNU tar is version 1.28\");\r\n    final File file = getFile(\"pax_gnu_sparse.tar\");\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setFile(file).get()) {\r\n        TarArchiveEntry paxGNUEntry = tin.getNextTarEntry();\r\n        assertTrue(tin.canReadEntryData(paxGNUEntry));\r\n        try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparsefile-0.0\")) {\r\n            assertArrayEquals(IOUtils.toByteArray(tin), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n        paxGNUEntry = tin.getNextTarEntry();\r\n        assertTrue(tin.canReadEntryData(paxGNUEntry));\r\n        try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparsefile-0.1\")) {\r\n            assertArrayEquals(IOUtils.toByteArray(tin), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n        paxGNUEntry = tin.getNextTarEntry();\r\n        assertTrue(tin.canReadEntryData(paxGNUEntry));\r\n        try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparsefile-1.0\")) {\r\n            assertArrayEquals(IOUtils.toByteArray(tin), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testExtractSparseTarsOnWindows",
  "sourceCode" : "@Test\r\n@EnabledOnOs(OS.WINDOWS)\r\nvoid testExtractSparseTarsOnWindows() throws IOException {\r\n    final File oldGNUSparseTar = getFile(\"oldgnu_sparse.tar\");\r\n    final File paxGNUSparseTar = getFile(\"pax_gnu_sparse.tar\");\r\n    try (TarArchiveInputStream paxGNUSparseInputStream = TarArchiveInputStream.builder().setFile(paxGNUSparseTar).get()) {\r\n        // compare between old GNU and PAX 0.0\r\n        TarArchiveEntry paxGNUEntry = paxGNUSparseInputStream.getNextTarEntry();\r\n        assertTrue(paxGNUSparseInputStream.canReadEntryData(paxGNUEntry));\r\n        try (TarArchiveInputStream oldGNUSparseInputStream = TarArchiveInputStream.builder().setFile(oldGNUSparseTar).get()) {\r\n            final TarArchiveEntry oldGNUEntry = oldGNUSparseInputStream.getNextTarEntry();\r\n            assertTrue(oldGNUSparseInputStream.canReadEntryData(oldGNUEntry));\r\n            assertArrayEquals(IOUtils.toByteArray(oldGNUSparseInputStream), IOUtils.toByteArray(paxGNUSparseInputStream));\r\n        }\r\n        // compare between old GNU and PAX 0.1\r\n        paxGNUEntry = paxGNUSparseInputStream.getNextTarEntry();\r\n        assertTrue(paxGNUSparseInputStream.canReadEntryData(paxGNUEntry));\r\n        try (TarArchiveInputStream oldGNUSparseInputStream = TarArchiveInputStream.builder().setFile(oldGNUSparseTar).get()) {\r\n            final TarArchiveEntry oldGNUEntry = oldGNUSparseInputStream.getNextTarEntry();\r\n            assertTrue(oldGNUSparseInputStream.canReadEntryData(oldGNUEntry));\r\n            assertArrayEquals(IOUtils.toByteArray(oldGNUSparseInputStream), IOUtils.toByteArray(paxGNUSparseInputStream));\r\n        }\r\n        // compare between old GNU and PAX 1.0\r\n        paxGNUEntry = paxGNUSparseInputStream.getNextTarEntry();\r\n        assertTrue(paxGNUSparseInputStream.canReadEntryData(paxGNUEntry));\r\n        try (TarArchiveInputStream oldGNUSparseInputStream = TarArchiveInputStream.builder().setFile(oldGNUSparseTar).get()) {\r\n            final TarArchiveEntry oldGNUEntry = oldGNUSparseInputStream.getNextTarEntry();\r\n            assertTrue(oldGNUSparseInputStream.canReadEntryData(oldGNUEntry));\r\n            assertArrayEquals(IOUtils.toByteArray(oldGNUSparseInputStream), IOUtils.toByteArray(paxGNUSparseInputStream));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testOldGNU",
  "sourceCode" : "@Test\r\nvoid testOldGNU() throws Throwable {\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(\"oldgnu_sparse.tar\")).get()) {\r\n        final TarArchiveEntry ae = tin.getNextTarEntry();\r\n        assertEquals(\"sparsefile\", ae.getName());\r\n        assertEquals(TarConstants.LF_GNUTYPE_SPARSE, ae.getLinkFlag());\r\n        assertTrue(ae.isOldGNUSparse());\r\n        assertTrue(ae.isGNUSparse());\r\n        assertFalse(ae.isPaxGNUSparse());\r\n        assertTrue(tin.canReadEntryData(ae));\r\n        final List<TarArchiveStructSparse> sparseHeaders = ae.getSparseHeaders();\r\n        assertEquals(4, sparseHeaders.size());\r\n        assertEquals(0, sparseHeaders.get(0).getOffset());\r\n        assertEquals(2048, sparseHeaders.get(0).getNumbytes());\r\n        assertEquals(1050624L, sparseHeaders.get(1).getOffset());\r\n        assertEquals(2560, sparseHeaders.get(1).getNumbytes());\r\n        assertEquals(3101184L, sparseHeaders.get(2).getOffset());\r\n        assertEquals(0, sparseHeaders.get(2).getNumbytes());\r\n        assertEquals(0, sparseHeaders.get(3).getOffset());\r\n        assertEquals(0, sparseHeaders.get(3).getNumbytes());\r\n        final List<TarArchiveStructSparse> sparseOrderedHeaders = ae.getOrderedSparseHeaders();\r\n        assertEquals(3, sparseOrderedHeaders.size());\r\n        assertEquals(0, sparseOrderedHeaders.get(0).getOffset());\r\n        assertEquals(2048, sparseOrderedHeaders.get(0).getNumbytes());\r\n        assertEquals(1050624L, sparseOrderedHeaders.get(1).getOffset());\r\n        assertEquals(2560, sparseOrderedHeaders.get(1).getNumbytes());\r\n        assertEquals(3101184L, sparseOrderedHeaders.get(2).getOffset());\r\n        assertEquals(0, sparseOrderedHeaders.get(2).getNumbytes());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testPaxGNU",
  "sourceCode" : "@Test\r\nvoid testPaxGNU() throws Throwable {\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setURI(getURI(\"pax_gnu_sparse.tar\")).get()) {\r\n        assertPaxGNUEntry(tin, \"0.0\");\r\n        assertPaxGNUEntry(tin, \"0.1\");\r\n        assertPaxGNUEntry(tin, \"1.0\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testTarFileExtractExtendedOldGNU",
  "sourceCode" : "@Test\r\n@DisabledOnOs(OS.WINDOWS)\r\nvoid testTarFileExtractExtendedOldGNU() throws IOException, InterruptedException {\r\n    final File file = getFile(\"oldgnu_extended_sparse.tar\");\r\n    try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparse6\");\r\n        TarFile tarFile = new TarFile(file)) {\r\n        final TarArchiveEntry ae = tarFile.getEntries().get(0);\r\n        try (InputStream tarInput = tarFile.getInputStream(ae)) {\r\n            assertArrayEquals(IOUtils.toByteArray(tarInput), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n        final List<TarArchiveStructSparse> sparseHeaders = ae.getOrderedSparseHeaders();\r\n        assertEquals(7, sparseHeaders.size());\r\n        assertEquals(0, sparseHeaders.get(0).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(0).getNumbytes());\r\n        assertEquals(10240, sparseHeaders.get(1).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(1).getNumbytes());\r\n        assertEquals(16384, sparseHeaders.get(2).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(2).getNumbytes());\r\n        assertEquals(24576, sparseHeaders.get(3).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(3).getNumbytes());\r\n        assertEquals(29696, sparseHeaders.get(4).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(4).getNumbytes());\r\n        assertEquals(36864, sparseHeaders.get(5).getOffset());\r\n        assertEquals(1024, sparseHeaders.get(5).getNumbytes());\r\n        assertEquals(51200, sparseHeaders.get(6).getOffset());\r\n        assertEquals(0, sparseHeaders.get(6).getNumbytes());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testTarFileExtractOldGNU",
  "sourceCode" : "@Test\r\n@DisabledOnOs(OS.WINDOWS)\r\nvoid testTarFileExtractOldGNU() throws IOException, InterruptedException {\r\n    final File file = getFile(\"oldgnu_sparse.tar\");\r\n    try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparsefile\");\r\n        TarFile tarFile = new TarFile(file)) {\r\n        final TarArchiveEntry entry = tarFile.getEntries().get(0);\r\n        try (InputStream tarInput = tarFile.getInputStream(entry)) {\r\n            assertArrayEquals(IOUtils.toByteArray(tarInput), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testTarFileExtractPaxGNU",
  "sourceCode" : "@Test\r\n@DisabledOnOs(OS.WINDOWS)\r\nvoid testTarFileExtractPaxGNU() throws IOException, InterruptedException {\r\n    // GNU tar with version 1.28 has some problems reading sparsefile-0.1,\r\n    // so the test should be skipped then\r\n    // TODO : what about the versions lower than 1.28?\r\n    assumeFalse(getTarBinaryHelp().startsWith(\"tar (GNU tar) 1.28\"), \"This test should be ignored if GNU tar is version 1.28\");\r\n    final File file = getFile(\"pax_gnu_sparse.tar\");\r\n    try (TarFile paxGnu = new TarFile(file)) {\r\n        final List<TarArchiveEntry> entries = paxGnu.getEntries();\r\n        TarArchiveEntry entry = entries.get(0);\r\n        try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparsefile-0.0\");\r\n            InputStream paxInput = paxGnu.getInputStream(entry)) {\r\n            assertArrayEquals(IOUtils.toByteArray(paxInput), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n        entry = entries.get(1);\r\n        try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparsefile-0.1\");\r\n            InputStream paxInput = paxGnu.getInputStream(entry)) {\r\n            assertArrayEquals(IOUtils.toByteArray(paxInput), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n        entry = entries.get(2);\r\n        try (InputStream sparseFileInputStream = extractTarAndGetInputStream(file, \"sparsefile-1.0\");\r\n            InputStream paxInput = paxGnu.getInputStream(entry)) {\r\n            assertArrayEquals(IOUtils.toByteArray(paxInput), IOUtils.toByteArray(sparseFileInputStream));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testTarFileExtractSparseTarsOnWindows",
  "sourceCode" : "@Test\r\n@EnabledOnOs(OS.WINDOWS)\r\nvoid testTarFileExtractSparseTarsOnWindows() throws IOException {\r\n    final File oldGNUSparseTar = getFile(\"oldgnu_sparse.tar\");\r\n    final File paxGNUSparseTar = getFile(\"pax_gnu_sparse.tar\");\r\n    try (TarFile paxGnu = new TarFile(paxGNUSparseTar)) {\r\n        final List<TarArchiveEntry> entries = paxGnu.getEntries();\r\n        // compare between old GNU and PAX 0.0\r\n        TarArchiveEntry paxGnuEntry = entries.get(0);\r\n        try (TarFile oldGnu = new TarFile(oldGNUSparseTar)) {\r\n            final TarArchiveEntry oldGnuEntry = oldGnu.getEntries().get(0);\r\n            try (InputStream old = oldGnu.getInputStream(oldGnuEntry);\r\n                InputStream pax = paxGnu.getInputStream(paxGnuEntry)) {\r\n                assertArrayEquals(IOUtils.toByteArray(old), IOUtils.toByteArray(pax));\r\n            }\r\n        }\r\n        // compare between old GNU and PAX 0.1\r\n        paxGnuEntry = entries.get(1);\r\n        try (TarFile oldGnu = new TarFile(oldGNUSparseTar)) {\r\n            final TarArchiveEntry oldGnuEntry = oldGnu.getEntries().get(0);\r\n            try (InputStream old = oldGnu.getInputStream(oldGnuEntry);\r\n                InputStream pax = paxGnu.getInputStream(paxGnuEntry)) {\r\n                assertArrayEquals(IOUtils.toByteArray(old), IOUtils.toByteArray(pax));\r\n            }\r\n        }\r\n        // compare between old GNU and PAX 1.0\r\n        paxGnuEntry = entries.get(2);\r\n        try (TarFile oldGnu = new TarFile(oldGNUSparseTar)) {\r\n            final TarArchiveEntry oldGnuEntry = oldGnu.getEntries().get(0);\r\n            try (InputStream old = oldGnu.getInputStream(oldGnuEntry);\r\n                InputStream pax = paxGnu.getInputStream(paxGnuEntry)) {\r\n                assertArrayEquals(IOUtils.toByteArray(old), IOUtils.toByteArray(pax));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testTarFileOldGNU",
  "sourceCode" : "@Test\r\nvoid testTarFileOldGNU() throws Throwable {\r\n    final File file = getFile(\"oldgnu_sparse.tar\");\r\n    try (TarFile tarFile = new TarFile(file)) {\r\n        final TarArchiveEntry ae = tarFile.getEntries().get(0);\r\n        assertEquals(\"sparsefile\", ae.getName());\r\n        assertEquals(TarConstants.LF_GNUTYPE_SPARSE, ae.getLinkFlag());\r\n        assertTrue(ae.isOldGNUSparse());\r\n        assertTrue(ae.isGNUSparse());\r\n        assertFalse(ae.isPaxGNUSparse());\r\n        final List<TarArchiveStructSparse> sparseHeaders = ae.getSparseHeaders();\r\n        assertEquals(4, sparseHeaders.size());\r\n        assertEquals(0, sparseHeaders.get(0).getOffset());\r\n        assertEquals(2048, sparseHeaders.get(0).getNumbytes());\r\n        assertEquals(1050624L, sparseHeaders.get(1).getOffset());\r\n        assertEquals(2560, sparseHeaders.get(1).getNumbytes());\r\n        assertEquals(3101184L, sparseHeaders.get(2).getOffset());\r\n        assertEquals(0, sparseHeaders.get(2).getNumbytes());\r\n        assertEquals(0, sparseHeaders.get(3).getOffset());\r\n        assertEquals(0, sparseHeaders.get(3).getNumbytes());\r\n        final List<TarArchiveStructSparse> sparseOrderedHeaders = ae.getOrderedSparseHeaders();\r\n        assertEquals(3, sparseOrderedHeaders.size());\r\n        assertEquals(0, sparseOrderedHeaders.get(0).getOffset());\r\n        assertEquals(2048, sparseOrderedHeaders.get(0).getNumbytes());\r\n        assertEquals(1050624L, sparseOrderedHeaders.get(1).getOffset());\r\n        assertEquals(2560, sparseOrderedHeaders.get(1).getNumbytes());\r\n        assertEquals(3101184L, sparseOrderedHeaders.get(2).getOffset());\r\n        assertEquals(0, sparseOrderedHeaders.get(2).getNumbytes());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\SparseFilesTest.java",
  "methodName" : "testTarFilePaxGNU",
  "sourceCode" : "@Test\r\nvoid testTarFilePaxGNU() throws IOException {\r\n    final File file = getFile(\"pax_gnu_sparse.tar\");\r\n    try (TarFile tarFile = new TarFile(file)) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertPaxGNUEntry(entries.get(0), \"0.0\");\r\n        assertPaxGNUEntry(entries.get(1), \"0.1\");\r\n        assertPaxGNUEntry(entries.get(2), \"1.0\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testExtraPaxHeaders",
  "sourceCode" : "@Test\r\nvoid testExtraPaxHeaders() throws IOException {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    TarArchiveEntry entry = new TarArchiveEntry(\"./weasels\");\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        entry.addPaxHeader(\"APACHE.mustelida\", \"true\");\r\n        entry.addPaxHeader(\"SCHILY.xattr.user.org.apache.weasels\", \"maximum weasels\");\r\n        entry.addPaxHeader(\"size\", \"1\");\r\n        assertEquals(2, entry.getExtraPaxHeaders().size(), \"extra header count\");\r\n        assertEquals(\"true\", entry.getExtraPaxHeader(\"APACHE.mustelida\"), \"APACHE.mustelida\");\r\n        assertEquals(\"maximum weasels\", entry.getExtraPaxHeader(\"SCHILY.xattr.user.org.apache.weasels\"), \"SCHILY.xattr.user.org.apache.weasels\");\r\n        assertEquals(entry.getSize(), 1, \"size\");\r\n        tos.putArchiveEntry(entry);\r\n        tos.write('W');\r\n        tos.closeArchiveEntry();\r\n    }\r\n    assertNotEquals(0, entry.getExtraPaxHeaders().size(), \"should have extra headers before clear\");\r\n    entry.clearExtraPaxHeaders();\r\n    assertEquals(0, entry.getExtraPaxHeaders().size(), \"extra headers should be empty after clear\");\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(bos.toByteArray()).get()) {\r\n        entry = tis.getNextTarEntry();\r\n        assertNotNull(entry, \"couldn't get entry\");\r\n        assertEquals(2, entry.getExtraPaxHeaders().size(), \"extra header count\");\r\n        assertEquals(\"true\", entry.getExtraPaxHeader(\"APACHE.mustelida\"), \"APACHE.mustelida\");\r\n        assertEquals(\"maximum weasels\", entry.getExtraPaxHeader(\"SCHILY.xattr.user.org.apache.weasels\"), \"user.org.apache.weasels\");\r\n        assertEquals('W', tis.read());\r\n        assertTrue(tis.read() < 0, \"should be at end of entry\");\r\n        assertNull(tis.getNextTarEntry(), \"should be at end of file\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testFileSystemRoot",
  "sourceCode" : "/**\r\n * JIRA issue SANDBOX-284\r\n *\r\n * @see \"https://issues.apache.org/jira/browse/SANDBOX-284\"\r\n */\r\n@Test\r\nvoid testFileSystemRoot() {\r\n    final TarArchiveEntry t = new TarArchiveEntry(new File(ROOT));\r\n    assertEquals(\"/\", t.getName());\r\n    assertEquals(TarConstants.LF_DIR, t.getLinkFlag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testGetFileFromNonFileEntry",
  "sourceCode" : "@Test\r\nvoid testGetFileFromNonFileEntry() {\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"test.txt\");\r\n    assertNull(entry.getFile());\r\n    assertNull(entry.getPath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testGetOrderedSparseHeadersRejectsOverlappingStructs",
  "sourceCode" : "@Test\r\nvoid testGetOrderedSparseHeadersRejectsOverlappingStructs() throws Exception {\r\n    final TarArchiveEntry te = new TarArchiveEntry(\"test\");\r\n    te.fillStarSparseData(Collections.singletonMap(\"SCHILY.realsize\", \"201\"));\r\n    te.setSparseHeaders(Arrays.asList(new TarArchiveStructSparse(10, 5), new TarArchiveStructSparse(12, 1)));\r\n    assertThrows(ArchiveException.class, () -> te.getOrderedSparseHeaders());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testGetOrderedSparseHeadersRejectsStructsPointingBeyondOutputEntry",
  "sourceCode" : "@Test\r\nvoid testGetOrderedSparseHeadersRejectsStructsPointingBeyondOutputEntry() throws Exception {\r\n    final TarArchiveEntry te = new TarArchiveEntry(\"test\");\r\n    te.setSparseHeaders(Arrays.asList(new TarArchiveStructSparse(200, 2)));\r\n    te.fillStarSparseData(Collections.singletonMap(\"SCHILY.realsize\", \"201\"));\r\n    assertThrows(ArchiveException.class, () -> te.getOrderedSparseHeaders());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testGetOrderedSparseHeadersRejectsStructsWithReallyBigNumbers",
  "sourceCode" : "@Test\r\nvoid testGetOrderedSparseHeadersRejectsStructsWithReallyBigNumbers() throws Exception {\r\n    final TarArchiveEntry te = new TarArchiveEntry(\"test\");\r\n    te.fillStarSparseData(Collections.singletonMap(\"SCHILY.realsize\", String.valueOf(Long.MAX_VALUE)));\r\n    te.setSparseHeaders(Arrays.asList(new TarArchiveStructSparse(Long.MAX_VALUE, 2)));\r\n    assertThrows(ArchiveException.class, () -> te.getOrderedSparseHeaders());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testGetOrderedSparseHeadersSortsAndFiltersSparseStructs",
  "sourceCode" : "@Test\r\nvoid testGetOrderedSparseHeadersSortsAndFiltersSparseStructs() throws Exception {\r\n    final TarArchiveEntry te = new TarArchiveEntry(\"test\");\r\n    // hacky way to set realSize\r\n    te.fillStarSparseData(Collections.singletonMap(\"SCHILY.realsize\", \"201\"));\r\n    te.setSparseHeaders(Arrays.asList(new TarArchiveStructSparse(10, 2), new TarArchiveStructSparse(20, 0), new TarArchiveStructSparse(15, 1), new TarArchiveStructSparse(0, 0)));\r\n    final List<TarArchiveStructSparse> strs = te.getOrderedSparseHeaders();\r\n    assertEquals(3, strs.size());\r\n    assertEquals(10, strs.get(0).getOffset());\r\n    assertEquals(15, strs.get(1).getOffset());\r\n    assertEquals(20, strs.get(2).getOffset());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testLinkFlagConstructor",
  "sourceCode" : "@Test\r\nvoid testLinkFlagConstructor() {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_GNUTYPE_LONGNAME);\r\n    assertGnuMagic(t);\r\n    assertEquals(\"foo\", t.getName());\r\n    assertEquals(TarConstants.LF_GNUTYPE_LONGNAME, t.getLinkFlag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testLinkFlagConstructorWithFileFlag",
  "sourceCode" : "@Test\r\nvoid testLinkFlagConstructorWithFileFlag() {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_NORMAL);\r\n    assertPosixMagic(t);\r\n    assertEquals(\"foo\", t.getName());\r\n    assertEquals(TarConstants.LF_NORMAL, t.getLinkFlag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testLinkFlagConstructorWithPreserve",
  "sourceCode" : "@Test\r\nvoid testLinkFlagConstructorWithPreserve() {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_GNUTYPE_LONGNAME, true);\r\n    assertGnuMagic(t);\r\n    assertEquals(\"/foo\", t.getName());\r\n    assertEquals(TarConstants.LF_GNUTYPE_LONGNAME, t.getLinkFlag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testLinuxFileInformationFromFile",
  "sourceCode" : "@Test\r\n@EnabledOnOs(org.junit.jupiter.api.condition.OS.LINUX)\r\nvoid testLinuxFileInformationFromFile() throws IOException {\r\n    final TarArchiveEntry entry = new TarArchiveEntry(getFile(\"test1.xml\"));\r\n    assertNotEquals(0, entry.getLongUserId());\r\n    assertNotEquals(0, entry.getLongGroupId());\r\n    assertNotEquals(\"\", entry.getUserName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testLinuxFileInformationFromPath",
  "sourceCode" : "@Test\r\n@EnabledOnOs(org.junit.jupiter.api.condition.OS.LINUX)\r\nvoid testLinuxFileInformationFromPath() throws IOException {\r\n    final TarArchiveEntry entry = new TarArchiveEntry(getPath(\"test1.xml\"));\r\n    assertNotEquals(0, entry.getLongUserId());\r\n    assertNotEquals(0, entry.getLongGroupId());\r\n    assertNotEquals(\"\", entry.getUserName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testMaxFileSize",
  "sourceCode" : "@Test\r\nvoid testMaxFileSize() {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"\");\r\n    t.setSize(0);\r\n    t.setSize(1);\r\n    assertThrows(IllegalArgumentException.class, () -> t.setSize(-1));\r\n    t.setSize(077777777777L);\r\n    t.setSize(0100000000000L);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testNegativeOffsetInConstructorNotAllowed",
  "sourceCode" : "@Test\r\nvoid testNegativeOffsetInConstructorNotAllowed() {\r\n    // @formatter:off\r\n    final byte[] entryContent = (\"test1.xml\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u00000000644\\u00000000765\\u00000000765\\u000000000001142\\u000010716545626\\u0000012260\\u0000 0\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000ustar  \\u0000tcurdt\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000tcurdt\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\" + \"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\").getBytes(UTF_8);\r\n    // @formatter:on\r\n    assertThrows(IllegalArgumentException.class, () -> new TarArchiveEntry(entryContent, ZipEncodingHelper.getZipEncoding(StandardCharsets.ISO_8859_1.name()), false, -1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testNegativeOffsetInSetterNotAllowed",
  "sourceCode" : "@Test\r\nvoid testNegativeOffsetInSetterNotAllowed() {\r\n    assertThrows(IllegalArgumentException.class, () -> new TarArchiveEntry(\"test\").setDataOffset(-1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testPaxTimeFieldsForInvalidValues",
  "sourceCode" : "@Test\r\nvoid testPaxTimeFieldsForInvalidValues() {\r\n    final String[] headerNames = { \"LIBARCHIVE.creationtime\", \"atime\", \"mtime\", \"ctime\" };\r\n    // @formatter:off\r\n    final String[] testValues = { // Generate a number with a very large integer or fractional component\r\n    new Random().nextLong() + \".\" + String.join(\"\", Collections.nCopies(15000, String.valueOf(Long.MAX_VALUE))), // These two examples use the exponent notation\r\n    \"9e9999999\", \"9E9999999\", // These examples are out of range for java.time.Instant\r\n    String.valueOf(Long.MAX_VALUE), String.valueOf(Long.MIN_VALUE) };\r\n    // @formatter:on\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"test.txt\");\r\n    for (final String name : headerNames) {\r\n        for (final String value : testValues) {\r\n            final Exception exp = assertThrows(IllegalArgumentException.class, () -> entry.addPaxHeader(name, value));\r\n            assertTrue(exp.getCause().getMessage().startsWith(\"Corrupted PAX header. Time field value is invalid\"));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testPreservesDriveSpecOnWindowsAndNetwareIfAskedTo",
  "sourceCode" : "@Test\r\nvoid testPreservesDriveSpecOnWindowsAndNetwareIfAskedTo() {\r\n    assumeTrue(\"C:\\\\\".equals(ROOT));\r\n    TarArchiveEntry t = new TarArchiveEntry(ROOT + \"foo.txt\", true);\r\n    assertEquals(\"C:/foo.txt\", t.getName());\r\n    assertEquals(TarConstants.LF_NORMAL, t.getLinkFlag());\r\n    t = new TarArchiveEntry(ROOT + \"foo.txt\", LF_GNUTYPE_LONGNAME, true);\r\n    assertEquals(\"C:/foo.txt\", t.getName());\r\n    assertEquals(TarConstants.LF_GNUTYPE_LONGNAME, t.getLinkFlag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testShouldNotWriteTimePaxHeadersByDefault",
  "sourceCode" : "@Test\r\nvoid testShouldNotWriteTimePaxHeadersByDefault() throws IOException {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        final TarArchiveEntry entry = createEntryForTimeTests();\r\n        tos.putArchiveEntry(entry);\r\n        tos.write('W');\r\n        tos.closeArchiveEntry();\r\n    }\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(bos.toByteArray()).get()) {\r\n        final TarArchiveEntry entry = tis.getNextTarEntry();\r\n        assertNotNull(entry, \"couldn't get entry\");\r\n        assertEquals(0, entry.getExtraPaxHeaders().size(), \"extra header count\");\r\n        assertNull(entry.getExtraPaxHeader(\"mtime\"), \"mtime\");\r\n        assertNull(entry.getExtraPaxHeader(\"atime\"), \"atime\");\r\n        assertNull(entry.getExtraPaxHeader(\"ctime\"), \"ctime\");\r\n        assertNull(entry.getExtraPaxHeader(\"LIBARCHIVE.creationtime\"), \"birthtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03Z\"), entry.getLastModifiedTime(), \"mtime\");\r\n        assertNull(entry.getLastAccessTime(), \"atime\");\r\n        assertNull(entry.getStatusChangeTime(), \"ctime\");\r\n        assertNull(entry.getCreationTime(), \"birthtime\");\r\n        assertEquals('W', tis.read());\r\n        assertTrue(tis.read() < 0, \"should be at end of entry\");\r\n        assertNull(tis.getNextTarEntry(), \"should be at end of file\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testShouldParseTimePaxHeadersAndNotCountAsExtraPaxHeaders",
  "sourceCode" : "@Test\r\nvoid testShouldParseTimePaxHeadersAndNotCountAsExtraPaxHeaders() {\r\n    final TarArchiveEntry entry = createEntryForTimeTests();\r\n    assertEquals(0, entry.getExtraPaxHeaders().size(), \"extra header count\");\r\n    assertNull(entry.getExtraPaxHeader(\"size\"), \"size\");\r\n    assertNull(entry.getExtraPaxHeader(\"mtime\"), \"mtime\");\r\n    assertNull(entry.getExtraPaxHeader(\"atime\"), \"atime\");\r\n    assertNull(entry.getExtraPaxHeader(\"ctime\"), \"ctime\");\r\n    assertNull(entry.getExtraPaxHeader(\"LIBARCHIVE.creationtime\"), \"birthtime\");\r\n    assertEquals(entry.getSize(), 1, \"size\");\r\n    assertEquals(toFileTime(\"2022-03-14T01:25:03.599853900Z\"), entry.getLastModifiedTime(), \"mtime\");\r\n    assertEquals(toFileTime(\"2022-03-14T01:31:00.706927200Z\"), entry.getLastAccessTime(), \"atime\");\r\n    assertEquals(toFileTime(\"2022-03-14T01:28:59.700505300Z\"), entry.getStatusChangeTime(), \"ctime\");\r\n    assertEquals(toFileTime(\"2022-03-14T01:29:00.723509000Z\"), entry.getCreationTime(), \"birthtime\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testShouldWriteTimesAsPaxHeadersForPosixMode",
  "sourceCode" : "@Test\r\nvoid testShouldWriteTimesAsPaxHeadersForPosixMode() throws IOException {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        final TarArchiveEntry entry = createEntryForTimeTests();\r\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\r\n        tos.putArchiveEntry(entry);\r\n        tos.write('W');\r\n        tos.closeArchiveEntry();\r\n    }\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(bos.toByteArray()).get()) {\r\n        final TarArchiveEntry entry = tis.getNextTarEntry();\r\n        assertNotNull(entry, \"couldn't get entry\");\r\n        assertEquals(0, entry.getExtraPaxHeaders().size(), \"extra header count\");\r\n        assertNull(entry.getExtraPaxHeader(\"mtime\"), \"mtime\");\r\n        assertNull(entry.getExtraPaxHeader(\"atime\"), \"atime\");\r\n        assertNull(entry.getExtraPaxHeader(\"ctime\"), \"ctime\");\r\n        assertNull(entry.getExtraPaxHeader(\"LIBARCHIVE.creationtime\"), \"birthtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03.599853900Z\"), entry.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:31:00.706927200Z\"), entry.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:28:59.700505300Z\"), entry.getStatusChangeTime(), \"ctime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:29:00.723509000Z\"), entry.getCreationTime(), \"birthtime\");\r\n        assertEquals('W', tis.read());\r\n        assertTrue(tis.read() < 0, \"should be at end of entry\");\r\n        assertNull(tis.getNextTarEntry(), \"should be at end of file\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testShouldWriteTimesAsPaxHeadersForPosixModeAndCreationTimeShouldBeUsedAsCtime",
  "sourceCode" : "@Test\r\nvoid testShouldWriteTimesAsPaxHeadersForPosixModeAndCreationTimeShouldBeUsedAsCtime() throws IOException {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        final TarArchiveEntry entry = createEntryForTimeTests();\r\n        entry.setStatusChangeTime(null);\r\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\r\n        tos.putArchiveEntry(entry);\r\n        tos.write('W');\r\n        tos.closeArchiveEntry();\r\n    }\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(bos.toByteArray()).get()) {\r\n        final TarArchiveEntry entry = tis.getNextTarEntry();\r\n        assertNotNull(entry, \"couldn't get entry\");\r\n        assertEquals(0, entry.getExtraPaxHeaders().size(), \"extra header count\");\r\n        assertNull(entry.getExtraPaxHeader(\"mtime\"), \"mtime\");\r\n        assertNull(entry.getExtraPaxHeader(\"atime\"), \"atime\");\r\n        assertNull(entry.getExtraPaxHeader(\"ctime\"), \"ctime\");\r\n        assertNull(entry.getExtraPaxHeader(\"LIBARCHIVE.creationtime\"), \"birthtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03.599853900Z\"), entry.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:31:00.706927200Z\"), entry.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:29:00.723509000Z\"), entry.getStatusChangeTime(), \"ctime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:29:00.723509000Z\"), entry.getCreationTime(), \"birthtime\");\r\n        assertEquals('W', tis.read());\r\n        assertTrue(tis.read() < 0, \"should be at end of entry\");\r\n        assertNull(tis.getNextTarEntry(), \"should be at end of file\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testShouldWriteTimesForStarMode",
  "sourceCode" : "@Test\r\nvoid testShouldWriteTimesForStarMode() throws IOException {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        final TarArchiveEntry entry = createEntryForTimeTests();\r\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\r\n        tos.putArchiveEntry(entry);\r\n        tos.write('W');\r\n        tos.closeArchiveEntry();\r\n    }\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(bos.toByteArray()).get()) {\r\n        final TarArchiveEntry entry = tis.getNextTarEntry();\r\n        assertNotNull(entry, \"couldn't get entry\");\r\n        assertEquals(0, entry.getExtraPaxHeaders().size(), \"extra header count\");\r\n        assertNull(entry.getExtraPaxHeader(\"mtime\"), \"mtime\");\r\n        assertNull(entry.getExtraPaxHeader(\"atime\"), \"atime\");\r\n        assertNull(entry.getExtraPaxHeader(\"ctime\"), \"ctime\");\r\n        assertNull(entry.getExtraPaxHeader(\"LIBARCHIVE.creationtime\"), \"birthtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:25:03Z\"), entry.getLastModifiedTime(), \"mtime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:31:00Z\"), entry.getLastAccessTime(), \"atime\");\r\n        assertEquals(toFileTime(\"2022-03-14T01:28:59Z\"), entry.getStatusChangeTime(), \"ctime\");\r\n        assertNull(entry.getCreationTime(), \"birthtime\");\r\n        assertEquals('W', tis.read());\r\n        assertTrue(tis.read() < 0, \"should be at end of entry\");\r\n        assertNull(tis.getNextTarEntry(), \"should be at end of file\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testTarFileWithFSRoot",
  "sourceCode" : "@Test\r\nvoid testTarFileWithFSRoot() throws IOException {\r\n    final File f = File.createTempFile(\"taetest\", \".tar\");\r\n    TarArchiveEntry entry = new TarArchiveEntry(new File(ROOT));\r\n    try {\r\n        try (TarArchiveOutputStream tout = new TarArchiveOutputStream(Files.newOutputStream(f.toPath()))) {\r\n            tout.putArchiveEntry(entry);\r\n            tout.closeArchiveEntry();\r\n            entry = new TarArchiveEntry(new File(new File(ROOT), \"foo.txt\"));\r\n            entry.setSize(6);\r\n            tout.putArchiveEntry(entry);\r\n            tout.write(new byte[] { 'h', 'e', 'l', 'l', 'o', ' ' });\r\n            tout.closeArchiveEntry();\r\n            entry = new TarArchiveEntry(new File(new File(ROOT), \"bar.txt\").getAbsolutePath());\r\n            entry.setSize(5);\r\n            tout.putArchiveEntry(entry);\r\n            tout.write(new byte[] { 'w', 'o', 'r', 'l', 'd' });\r\n            tout.closeArchiveEntry();\r\n            entry = new TarArchiveEntry(\"dummy\");\r\n            entry.setName(new File(new File(ROOT), \"baz.txt\").getAbsolutePath());\r\n            entry.setSize(1);\r\n            tout.putArchiveEntry(entry);\r\n            tout.write(new byte[] { '!' });\r\n            tout.closeArchiveEntry();\r\n        }\r\n        try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setFile(f).get()) {\r\n            // tin.setDebug(true);\r\n            entry = tin.getNextTarEntry();\r\n            assertNotNull(entry);\r\n            assertEquals(\"/\", entry.getName());\r\n            assertEquals(TarConstants.LF_DIR, entry.getLinkFlag());\r\n            assertTrue(entry.isCheckSumOK());\r\n            assertTrue(entry.isTypeFlagUstar());\r\n            entry = tin.getNextTarEntry();\r\n            assertNotNull(entry);\r\n            assertEquals(\"foo.txt\", entry.getName());\r\n            assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n            assertTrue(entry.isCheckSumOK());\r\n            assertTrue(entry.isTypeFlagUstar());\r\n            entry = tin.getNextTarEntry();\r\n            assertNotNull(entry);\r\n            assertEquals(\"bar.txt\", entry.getName());\r\n            assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n            assertTrue(entry.isCheckSumOK());\r\n            assertTrue(entry.isTypeFlagUstar());\r\n            entry = tin.getNextTarEntry();\r\n            assertNotNull(entry);\r\n            assertEquals(\"baz.txt\", entry.getName());\r\n            assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n            assertTrue(entry.isCheckSumOK());\r\n            assertTrue(entry.isTypeFlagUstar());\r\n        }\r\n    } finally {\r\n        AbstractTest.forceDelete(f);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testWindowsFileInformationFromFile",
  "sourceCode" : "@Test\r\n@EnabledOnOs(org.junit.jupiter.api.condition.OS.WINDOWS)\r\nvoid testWindowsFileInformationFromFile() throws IOException {\r\n    final TarArchiveEntry entry = new TarArchiveEntry(getFile(\"test1.xml\"));\r\n    assertNotEquals(\"\", entry.getUserName());\r\n    assertTrue(entry.isTypeFlagUstar());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveEntryTest.java",
  "methodName" : "testWindowsFileInformationFromPath",
  "sourceCode" : "@Test\r\n@EnabledOnOs(org.junit.jupiter.api.condition.OS.WINDOWS)\r\nvoid testWindowsFileInformationFromPath() throws IOException {\r\n    final TarArchiveEntry entry = new TarArchiveEntry(getPath(\"test1.xml\"));\r\n    assertNotEquals(\"\", entry.getUserName());\r\n    assertTrue(entry.isTypeFlagUstar());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testChecksumOnly4Byte",
  "sourceCode" : "@Test\r\nvoid testChecksumOnly4Byte() throws IOException {\r\n    try (TarArchiveInputStream archive = TarArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/COMPRESS-707/COMPRESS-707-lenient.tar\")).setLenient(true).get()) {\r\n        final TarArchiveEntry nextEntry = archive.getNextEntry();\r\n        assertNotNull(nextEntry);\r\n        assertEquals(\"hi-gary.txt\", nextEntry.getName());\r\n        assertTrue(nextEntry.isCheckSumOK());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testCompress197",
  "sourceCode" : "@Test\r\nvoid testCompress197() throws IOException {\r\n    try (TarArchiveInputStream tar = getTestStream(\"COMPRESS-197.tar\")) {\r\n        TarArchiveEntry entry = tar.getNextTarEntry();\r\n        assertNotNull(entry);\r\n        while (entry != null) {\r\n            assertTrue(entry.isTypeFlagUstar());\r\n            entry = tar.getNextTarEntry();\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testCompress197ForEach",
  "sourceCode" : "@Test\r\nvoid testCompress197ForEach() throws IOException {\r\n    try (TarArchiveInputStream tar = getTestStream(\"COMPRESS-197.tar\")) {\r\n        tar.forEach(IOConsumer.noop());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testCompress558",
  "sourceCode" : "@Test\r\nvoid testCompress558() throws IOException {\r\n    final String folderName = \"apache-activemq-5.16.0/examples/openwire/advanced-scenarios/jms-example-exclusive-consumer/src/main/\";\r\n    // @formatter:off\r\n    final String consumerJavaName = \"apache-activemq-5.16.0/examples/openwire/advanced-scenarios/jms-example-exclusive-consumer/src/main/java/example/queue/exclusive/Consumer.java\";\r\n    final String producerJavaName = \"apache-activemq-5.16.0/examples/openwire/advanced-scenarios/jms-example-exclusive-consumer/src/main/java/example/queue/exclusive/Producer.java\";\r\n    // @formatter:on\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\r\n        final TarArchiveEntry rootfolder = new TarArchiveEntry(folderName);\r\n        tos.putArchiveEntry(rootfolder);\r\n        final TarArchiveEntry consumerJava = new TarArchiveEntry(consumerJavaName);\r\n        tos.putArchiveEntry(consumerJava);\r\n        final TarArchiveEntry producerJava = new TarArchiveEntry(producerJavaName);\r\n        tos.putArchiveEntry(producerJava);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        assertEquals(folderName, tis.getNextTarEntry().getName());\r\n        assertEquals(TarConstants.LF_DIR, tis.getCurrentEntry().getLinkFlag());\r\n        assertEquals(consumerJavaName, tis.getNextTarEntry().getName());\r\n        assertEquals(TarConstants.LF_NORMAL, tis.getCurrentEntry().getLinkFlag());\r\n        assertEquals(producerJavaName, tis.getNextTarEntry().getName());\r\n        assertEquals(TarConstants.LF_NORMAL, tis.getCurrentEntry().getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testCompress666Buffered",
  "sourceCode" : "/**\r\n * Tests https://issues.apache.org/jira/browse/COMPRESS-666\r\n *\r\n * A factor of 20 is the default.\r\n */\r\n@ParameterizedTest\r\n@ValueSource(ints = { 1, 2, 4, 8, 16, 20, 32, 64, 128 })\r\nvoid testCompress666Buffered(final int factor) {\r\n    testCompress666(factor, true, \"/COMPRESS-666/compress-666.tar.gz\");\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testCompress666Unbuffered",
  "sourceCode" : "/**\r\n * Tests https://issues.apache.org/jira/browse/COMPRESS-666\r\n *\r\n * A factor of 20 is the default.\r\n */\r\n@ParameterizedTest\r\n@ValueSource(ints = { 1, 2, 4, 8, 16, 20, 32, 64, 128 })\r\nvoid testCompress666Unbuffered(final int factor) {\r\n    testCompress666(factor, false, \"/COMPRESS-666/compress-666.tar.gz\");\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testDatePriorToEpochInGNUFormat",
  "sourceCode" : "@Test\r\nvoid testDatePriorToEpochInGNUFormat() throws Exception {\r\n    datePriorToEpoch(\"preepoch-star.tar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testDatePriorToEpochInPAXFormat",
  "sourceCode" : "@Test\r\nvoid testDatePriorToEpochInPAXFormat() throws Exception {\r\n    datePriorToEpoch(\"preepoch-posix.tar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testDirectoryWithLongNameEndsWithSlash",
  "sourceCode" : "@Test\r\nvoid testDirectoryWithLongNameEndsWithSlash() throws IOException, ArchiveException {\r\n    final String rootPath = getTempDirFile().getAbsolutePath();\r\n    final String dirDirectory = \"COMPRESS-509\";\r\n    final int count = 100;\r\n    final File root = new File(rootPath + \"/\" + dirDirectory);\r\n    root.mkdirs();\r\n    for (int i = 1; i < count; i++) {\r\n        // create empty dirs with incremental length\r\n        String subDir = \"\";\r\n        for (int j = 0; j < i; j++) {\r\n            subDir += \"a\";\r\n        }\r\n        final File dir = new File(rootPath + \"/\" + dirDirectory, \"/\" + subDir);\r\n        dir.mkdir();\r\n        // tar these dirs\r\n        final String fileName = \"/\" + dirDirectory + \"/\" + subDir;\r\n        final File tarF = new File(rootPath + \"/tar\" + i + \".tar\");\r\n        try (OutputStream dest = Files.newOutputStream(tarF.toPath())) {\r\n            final TarArchiveOutputStream out = new TarArchiveOutputStream(new BufferedOutputStream(dest));\r\n            out.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\r\n            out.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\r\n            final File file = new File(rootPath, fileName);\r\n            final TarArchiveEntry entry = new TarArchiveEntry(file);\r\n            entry.setName(fileName);\r\n            out.putArchiveEntry(entry);\r\n            out.closeArchiveEntry();\r\n            out.flush();\r\n        }\r\n        // untar these tars\r\n        try (InputStream is = Files.newInputStream(tarF.toPath());\r\n            TarArchiveInputStream debInputStream = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"tar\", is)) {\r\n            TarArchiveEntry outEntry;\r\n            while ((outEntry = debInputStream.getNextEntry()) != null) {\r\n                assertTrue(outEntry.getName().endsWith(\"/\"), outEntry.getName());\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testGetAndSetOfPaxEntry",
  "sourceCode" : "@Test\r\nvoid testGetAndSetOfPaxEntry() throws Exception {\r\n    try (TarArchiveInputStream is = getTestStream(\"COMPRESS-356.tar\")) {\r\n        final TarArchiveEntry entry = is.getNextTarEntry();\r\n        assertEquals(\"package/package.json\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n        assertEquals(is.getCurrentEntry(), entry);\r\n        final TarArchiveEntry weaselEntry = new TarArchiveEntry(entry.getName());\r\n        weaselEntry.setSize(entry.getSize());\r\n        is.setCurrentEntry(weaselEntry);\r\n        assertEquals(entry, is.getCurrentEntry());\r\n        assertNotSame(entry, is.getCurrentEntry());\r\n        assertSame(weaselEntry, is.getCurrentEntry());\r\n        assertThrows(IllegalStateException.class, () -> {\r\n            is.setCurrentEntry(null);\r\n            is.read();\r\n        }, \"should abort because current entry is nulled\");\r\n        is.setCurrentEntry(entry);\r\n        is.read();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testGetNextEntry",
  "sourceCode" : "/**\r\n * Depending on your setup, this test may need a small stack size {@code -Xss256k}.\r\n */\r\n@Test\r\nvoid testGetNextEntry() throws IOException {\r\n    try (TarArchiveInputStream inputStream = getTestStream(\"org/apache/commons/compress/tar/getNextTarEntry.bin\")) {\r\n        final AtomicLong count = new AtomicLong();\r\n        final TarArchiveEntry entry = inputStream.getNextEntry();\r\n        assertNull(entry.getCreationTime());\r\n        assertNull(entry.getLastAccessTime());\r\n        assertEquals(new Date(0), entry.getLastModifiedDate());\r\n        assertEquals(FileTime.fromMillis(0), entry.getLastModifiedTime());\r\n        assertNull(entry.getStatusChangeTime());\r\n        assertEquals(-1, entry.getDataOffset());\r\n        assertEquals(0, entry.getDevMajor());\r\n        assertEquals(0, entry.getDevMinor());\r\n        assertEquals(0, entry.getDirectoryEntries().length);\r\n        assertEquals(0, entry.getExtraPaxHeaders().size());\r\n        assertEquals(0, entry.getOrderedSparseHeaders().size());\r\n        assertEquals(0, entry.getSparseHeaders().size());\r\n        assertNull(entry.getFile());\r\n        assertNull(entry.getPath());\r\n        assertEquals(\"\", entry.getGroupName());\r\n        assertEquals(0x1ff, entry.getMode());\r\n        assertEquals(\"\", entry.getName());\r\n        assertEquals(0, entry.getRealSize());\r\n        assertEquals(0, entry.getSize());\r\n        assertEquals(\"\", entry.getUserName());\r\n        assertEquals(\"\", entry.getLinkName());\r\n        assertEquals(0x30, entry.getLinkFlag());\r\n        assertEquals(0, entry.getLongGroupId());\r\n        assertEquals(0, entry.getLongUserId());\r\n        inputStream.forEach(e -> count.incrementAndGet());\r\n        assertEquals(0, count.get());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testGetNextTarEntryDeprecated",
  "sourceCode" : "/**\r\n * Depending on your setup, this test may need a small stack size {@code -Xss256k}.\r\n */\r\n@Test\r\nvoid testGetNextTarEntryDeprecated() throws IOException {\r\n    try (TarArchiveInputStream inputStream = getTestStream(\"org/apache/commons/compress/tar/getNextTarEntry.bin\")) {\r\n        final AtomicLong count = new AtomicLong();\r\n        final TarArchiveEntry entry = inputStream.getNextTarEntry();\r\n        assertNull(entry.getCreationTime());\r\n        assertNull(entry.getLastAccessTime());\r\n        assertEquals(new Date(0), entry.getLastModifiedDate());\r\n        assertEquals(FileTime.fromMillis(0), entry.getLastModifiedTime());\r\n        assertNull(entry.getStatusChangeTime());\r\n        assertEquals(-1, entry.getDataOffset());\r\n        assertEquals(0, entry.getDevMajor());\r\n        assertEquals(0, entry.getDevMinor());\r\n        assertEquals(0, entry.getDirectoryEntries().length);\r\n        assertEquals(0, entry.getExtraPaxHeaders().size());\r\n        assertEquals(0, entry.getOrderedSparseHeaders().size());\r\n        assertEquals(0, entry.getSparseHeaders().size());\r\n        assertNull(entry.getFile());\r\n        assertNull(entry.getPath());\r\n        assertEquals(\"\", entry.getGroupName());\r\n        assertEquals(0x1ff, entry.getMode());\r\n        assertEquals(\"\", entry.getName());\r\n        assertEquals(0, entry.getRealSize());\r\n        assertEquals(0, entry.getSize());\r\n        assertEquals(\"\", entry.getUserName());\r\n        assertEquals(\"\", entry.getLinkName());\r\n        assertEquals(0x30, entry.getLinkFlag());\r\n        assertEquals(0, entry.getLongGroupId());\r\n        assertEquals(0, entry.getLongUserId());\r\n        inputStream.forEach(e -> count.incrementAndGet());\r\n        assertEquals(0, count.get());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    final byte[] buf = new byte[2];\r\n    try (TarArchiveInputStream archive = getTestStream(\"bla.tar\")) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read(buf));\r\n        assertEquals(-1, archive.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testParseTarTruncatedInContent",
  "sourceCode" : "@Test\r\nvoid testParseTarTruncatedInContent() throws IOException {\r\n    try (TarArchiveInputStream archive = getTestStream(\"COMPRESS-544_truncated_in_content-fail.tar\")) {\r\n        getNextEntryUntilIOException(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testParseTarTruncatedInPadding",
  "sourceCode" : "@Test\r\nvoid testParseTarTruncatedInPadding() throws IOException {\r\n    try (TarArchiveInputStream archive = getTestStream(\"COMPRESS-544_truncated_in_padding-fail.tar\")) {\r\n        getNextEntryUntilIOException(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testParseTarWithNonNumberPaxHeaders",
  "sourceCode" : "@Test\r\nvoid testParseTarWithNonNumberPaxHeaders() throws IOException {\r\n    try (TarArchiveInputStream archive = getTestStream(\"COMPRESS-529-fail.tar\")) {\r\n        assertThrows(ArchiveException.class, () -> archive.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testParseTarWithSpecialPaxHeaders",
  "sourceCode" : "@Test\r\nvoid testParseTarWithSpecialPaxHeaders() throws IOException {\r\n    try (TarArchiveInputStream archive = getTestStream(\"COMPRESS-530-fail.tar\")) {\r\n        assertThrows(ArchiveException.class, () -> archive.getNextEntry());\r\n        assertThrows(ArchiveException.class, () -> IOUtils.toByteArray(archive));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testPaxHeaders",
  "sourceCode" : "/**\r\n * Depending on your setup, this test may need a small stack size {@code -Xss1m}.\r\n */\r\n@Test\r\nvoid testPaxHeaders() throws IOException {\r\n    try (TarArchiveInputStream inputStream = getTestStream(\"org/apache/commons/compress/tar/paxHeaders.bin\")) {\r\n        assertThrows(ArchiveException.class, inputStream::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testReadsArchiveCompletely_COMPRESS245",
  "sourceCode" : "@Test\r\nvoid testReadsArchiveCompletely_COMPRESS245() {\r\n    try (InputStream is = TarArchiveInputStreamTest.class.getResourceAsStream(\"/COMPRESS-245.tar.gz\")) {\r\n        final InputStream gin = new GZIPInputStream(is);\r\n        try (TarArchiveInputStream tar = TarArchiveInputStream.builder().setInputStream(gin).get()) {\r\n            int count = 0;\r\n            TarArchiveEntry entry = tar.getNextTarEntry();\r\n            while (entry != null) {\r\n                count++;\r\n                entry = tar.getNextTarEntry();\r\n            }\r\n            assertEquals(31, count);\r\n        }\r\n    } catch (final IOException e) {\r\n        fail(\"COMPRESS-245: \" + e.getMessage());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testRejectsArchivesWithNegativeSizes",
  "sourceCode" : "@Test\r\nvoid testRejectsArchivesWithNegativeSizes() throws Exception {\r\n    try (TarArchiveInputStream archive = getTestStream(\"COMPRESS-569-fail.tar\")) {\r\n        getNextEntryUntilIOException(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testShouldConsumeArchiveCompletely",
  "sourceCode" : "/**\r\n * This test ensures the implementation is reading the padded last block if a tool has added one to an archive\r\n */\r\n@Test\r\nvoid testShouldConsumeArchiveCompletely() throws Exception {\r\n    try (InputStream is = TarArchiveInputStreamTest.class.getResourceAsStream(\"/archive_with_trailer.tar\");\r\n        TarArchiveInputStream tar = TarArchiveInputStream.builder().setInputStream(is).get()) {\r\n        while (tar.getNextTarEntry() != null) {\r\n            // just consume the archive\r\n        }\r\n        final byte[] expected = { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n' };\r\n        final byte[] actual = new byte[expected.length];\r\n        is.read(actual);\r\n        assertArrayEquals(expected, actual, () -> Arrays.toString(actual));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testShouldReadBigGid",
  "sourceCode" : "@Test\r\nvoid testShouldReadBigGid() throws Exception {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\r\n        final TarArchiveEntry t = new TarArchiveEntry(\"name\");\r\n        t.setGroupId(4294967294L);\r\n        t.setSize(1);\r\n        tos.putArchiveEntry(t);\r\n        tos.write(30);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry t = tis.getNextTarEntry();\r\n        assertEquals(4294967294L, t.getLongGroupId());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testShouldReadGNULongNameEntryWithWrongName",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-324\">COMPRESS-324</a>\r\n */\r\n@Test\r\nvoid testShouldReadGNULongNameEntryWithWrongName() throws Exception {\r\n    try (TarArchiveInputStream is = getTestStream(\"COMPRESS-324.tar\")) {\r\n        final TarArchiveEntry entry = is.getNextTarEntry();\r\n        assertEquals(\"1234567890123456789012345678901234567890123456789012345678901234567890\" + \"1234567890123456789012345678901234567890123456789012345678901234567890\" + \"1234567890123456789012345678901234567890123456789012345678901234567890\" + \"1234567890123456789012345678901234567890.txt\", entry.getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testShouldThrowAnExceptionOnTruncatedEntries",
  "sourceCode" : "@Test\r\nvoid testShouldThrowAnExceptionOnTruncatedEntries() throws Exception {\r\n    final Path dir = createTempDirectory(\"COMPRESS-279\");\r\n    try (TarArchiveInputStream is = getTestStream(\"COMPRESS-279-fail.tar\")) {\r\n        assertThrows(ArchiveException.class, () -> {\r\n            TarArchiveEntry entry = is.getNextTarEntry();\r\n            int count = 0;\r\n            while (entry != null) {\r\n                Files.copy(is, dir.resolve(String.valueOf(count)));\r\n                count++;\r\n                entry = is.getNextTarEntry();\r\n            }\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testShouldThrowAnExceptionOnTruncatedStream",
  "sourceCode" : "@Test\r\nvoid testShouldThrowAnExceptionOnTruncatedStream() throws Exception {\r\n    final Path dir = createTempDirectory(\"COMPRESS-279\");\r\n    try (TarArchiveInputStream is = getTestStream(\"COMPRESS-279-fail.tar\")) {\r\n        final AtomicInteger count = new AtomicInteger();\r\n        assertThrows(ArchiveException.class, () -> is.forEach(entry -> Files.copy(is, dir.resolve(String.valueOf(count.getAndIncrement())))));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testShouldUseSpecifiedEncodingWhenReadingGNULongNames",
  "sourceCode" : "@Test\r\nvoid testShouldUseSpecifiedEncodingWhenReadingGNULongNames() throws Exception {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    final String encoding = StandardCharsets.UTF_16.name();\r\n    final String name = \"1234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"01234567890\\u00e4\";\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, encoding)) {\r\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\r\n        final TarArchiveEntry t = new TarArchiveEntry(name);\r\n        t.setSize(1);\r\n        tos.putArchiveEntry(t);\r\n        tos.write(30);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    final ByteArrayInputStream bis = new ByteArrayInputStream(data);\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(data).setCharset(encoding).get()) {\r\n        final TarArchiveEntry t = tis.getNextTarEntry();\r\n        assertEquals(name, t.getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testSingleArgumentConstructor",
  "sourceCode" : "@Test\r\nvoid testSingleArgumentConstructor() throws Exception {\r\n    final InputStream inputStream = mock(InputStream.class);\r\n    try (TarArchiveInputStream archiveStream = new TarArchiveInputStream(inputStream)) {\r\n        assertEquals(10240, readDeclaredField(archiveStream, \"blockSize\", true));\r\n        final byte[] recordBuffer = (byte[]) readField(archiveStream, \"recordBuffer\", true);\r\n        assertEquals(512, recordBuffer.length);\r\n        assertEquals(Charset.defaultCharset(), archiveStream.getCharset());\r\n        assertEquals(false, readField(archiveStream, \"lenient\", true));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    try (TarArchiveInputStream archive = getTestStream(\"bla.tar\")) {\r\n        assertNotNull(archive.getNextEntry());\r\n        IOUtils.toByteArray(archive);\r\n        assertEquals(-1, archive.read());\r\n        assertEquals(-1, archive.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testSkipsDevNumbersWhenEntryIsNoDevice",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-417\">COMPRESS-417</a>\r\n */\r\n@Test\r\nvoid testSkipsDevNumbersWhenEntryIsNoDevice() throws Exception {\r\n    try (TarArchiveInputStream is = getTestStream(\"COMPRESS-417.tar\")) {\r\n        assertEquals(\"test1.xml\", is.getNextTarEntry().getName());\r\n        assertEquals(TarConstants.LF_NORMAL, is.getCurrentEntry().getLinkFlag());\r\n        assertEquals(\"test2.xml\", is.getNextTarEntry().getName());\r\n        assertEquals(TarConstants.LF_NORMAL, is.getCurrentEntry().getLinkFlag());\r\n        assertNull(is.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testSurvivesBlankLinesInPaxHeader",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-355\">COMPRESS-355</a>\r\n */\r\n@Test\r\nvoid testSurvivesBlankLinesInPaxHeader() throws Exception {\r\n    try (TarArchiveInputStream is = getTestStream(\"COMPRESS-355.tar\")) {\r\n        final TarArchiveEntry entry = is.getNextTarEntry();\r\n        assertEquals(\"package/package.json\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n        assertNull(is.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testSurvivesPaxHeaderWithNameEndingInSlash",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-356\">COMPRESS-356</a>\r\n */\r\n@Test\r\nvoid testSurvivesPaxHeaderWithNameEndingInSlash() throws Exception {\r\n    try (TarArchiveInputStream is = getTestStream(\"COMPRESS-356.tar\")) {\r\n        final TarArchiveEntry entry = is.getNextTarEntry();\r\n        assertEquals(\"package/package.json\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n        assertNull(is.getNextTarEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testThrowException",
  "sourceCode" : "@Test\r\nvoid testThrowException() throws IOException {\r\n    try (TarArchiveInputStream archive = getTestStream(\"COMPRESS-553-fail.tar\")) {\r\n        getNextEntryUntilIOException(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testThrowExceptionWithNullEntry",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionWithNullEntry() throws IOException {\r\n    try (TarArchiveInputStream archive = getTestStream(\"COMPRESS-554-fail.tar\")) {\r\n        getNextEntryUntilIOException(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveInputStreamTest.java",
  "methodName" : "testWorkaroundForBrokenTimeHeader",
  "sourceCode" : "@Test\r\nvoid testWorkaroundForBrokenTimeHeader() throws Exception {\r\n    try (TarArchiveInputStream in = getTestStream(\"simple-aix-native-tar.tar\")) {\r\n        TarArchiveEntry tae = in.getNextTarEntry();\r\n        tae = in.getNextTarEntry();\r\n        assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName());\r\n        assertEquals(TarConstants.LF_SYMLINK, tae.getLinkFlag());\r\n        assertEquals(new Date(0), tae.getLastModifiedDate());\r\n        assertTrue(tae.isSymbolicLink());\r\n        assertTrue(tae.isCheckSumOK());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamLongFileModeTest.java",
  "methodName" : "test",
  "sourceCode" : "/**\r\n * Run with a non-default low memory configuration {@code -Xmx256m} if you want to see the test fail without the change to main.\r\n */\r\n@Test\r\nvoid test() throws Exception {\r\n    // 100m characters, adjust as needed\r\n    final String longName = StringUtils.repeat('a', 100_000_000);\r\n    try (TarArchiveOutputStream taos = new TarArchiveOutputStream(new ByteArrayOutputStream())) {\r\n        final TarArchiveEntry entry = new TarArchiveEntry(longName);\r\n        entry.setSize(0);\r\n        assertThrows(IllegalArgumentException.class, () -> taos.putArchiveEntry(entry));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testBigNumberErrorMode",
  "sourceCode" : "@Test\r\nvoid testBigNumberErrorMode() throws Exception {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\r\n    t.setSize(0100000000000L);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        assertThrows(IllegalArgumentException.class, () -> tos.putArchiveEntry(t));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testBigNumberPosixMode",
  "sourceCode" : "@Test\r\nvoid testBigNumberPosixMode() throws Exception {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\r\n    t.setSize(0100000000000L);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\r\n    tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\r\n    tos.putArchiveEntry(t);\r\n    // make sure header is written to byte array\r\n    tos.write(new byte[10 * 1024]);\r\n    final byte[] data = bos.toByteArray();\r\n    assertEquals(\"00000000000 \", new String(data, 1024 + TarConstants.NAMELEN + TarConstants.MODELEN + TarConstants.UIDLEN + TarConstants.GIDLEN, 12, UTF_8));\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertEquals(0100000000000L, e.getSize());\r\n    }\r\n    // generates IOE because of unclosed entries.\r\n    // However, we don't really want to create such large entries.\r\n    closeQuietly(tos);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testBigNumberStarMode",
  "sourceCode" : "@Test\r\nvoid testBigNumberStarMode() throws Exception {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\r\n    t.setSize(0100000000000L);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\r\n    tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\r\n    tos.putArchiveEntry(t);\r\n    // make sure header is written to byte array\r\n    tos.write(new byte[10 * 1024]);\r\n    final byte[] data = bos.toByteArray();\r\n    assertEquals(0x80, data[TarConstants.NAMELEN + TarConstants.MODELEN + TarConstants.UIDLEN + TarConstants.GIDLEN] & 0x80);\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertEquals(0100000000000L, e.getSize());\r\n    }\r\n    // generates IOE because of unclosed entries.\r\n    // However, we don't really want to create such large entries.\r\n    closeQuietly(tos);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testBlockSizes",
  "sourceCode" : "@Test\r\nvoid testBlockSizes() throws Exception {\r\n    final String fileName = \"/test1.xml\";\r\n    final byte[] contents = getResourceContents(fileName);\r\n    // USTAR / pre-pax\r\n    testPadding(TarConstants.DEFAULT_BLKSIZE, fileName, contents);\r\n    // PAX default\r\n    testPadding(5120, fileName, contents);\r\n    // PAX max\r\n    testPadding(1 << 15, fileName, contents);\r\n    // don't specify a block size -> use minimum length\r\n    testPadding(-2, fileName, contents);\r\n    // don't specify a block size -> use minimum length\r\n    assertThrows(IllegalArgumentException.class, () -> testPadding(511, fileName, contents));\r\n    // don't specify a block size -> use minimum length\r\n    assertThrows(IllegalArgumentException.class, () -> testPadding(0, fileName, contents));\r\n    // test with \"content\" that is an exact multiple of record length\r\n    final byte[] contents2 = ArrayFill.fill(new byte[2048], (byte) 42);\r\n    testPadding(TarConstants.DEFAULT_BLKSIZE, fileName, contents2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testCount",
  "sourceCode" : "@Test\r\nvoid testCount() throws Exception {\r\n    final File f = createTempFile(\"commons-compress-tarcount\", \".tar\");\r\n    try (OutputStream fos = Files.newOutputStream(f.toPath());\r\n        ArchiveOutputStream<ArchiveEntry> tarOut = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(ArchiveStreamFactory.TAR, fos)) {\r\n        final File file1 = getFile(\"test1.xml\");\r\n        final TarArchiveEntry sEntry = new TarArchiveEntry(file1, file1.getName());\r\n        tarOut.putArchiveEntry(sEntry);\r\n        try (InputStream in = Files.newInputStream(file1.toPath())) {\r\n            final byte[] buf = new byte[8192];\r\n            int read = 0;\r\n            while ((read = in.read(buf)) > 0) {\r\n                tarOut.write(buf, 0, read);\r\n            }\r\n        }\r\n        tarOut.closeArchiveEntry();\r\n        // Close, then measure, and test.\r\n        tarOut.close();\r\n        assertEquals(f.length(), tarOut.getBytesWritten());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testLongNameMd5Hash",
  "sourceCode" : "/**\r\n * When using long file names the longLinkEntry included the current timestamp as the Entry modification date. This was never exposed to the client, but it\r\n * caused identical archives to have different MD5 hashes.\r\n */\r\n@Test\r\nvoid testLongNameMd5Hash() throws Exception {\r\n    // @formatter:off\r\n    final String longFileName = \"a/considerably/longer/file/name/which/forces/use/of/the/long/link/header/which/appears/to/always/use/the/current/time/as/modification/date\";\r\n    // @formatter:on\r\n    final Date modificationDate = new Date();\r\n    final byte[] archive1 = createTarArchiveContainingOneDirectory(longFileName, modificationDate);\r\n    final byte[] digest1 = MessageDigest.getInstance(\"MD5\").digest(archive1);\r\n    // let a second elapse otherwise the modification dates will be equal\r\n    Thread.sleep(1000L);\r\n    // now recreate exactly the same tar file\r\n    final byte[] archive2 = createTarArchiveContainingOneDirectory(longFileName, modificationDate);\r\n    // and I would expect the MD5 hash to be the same, but for long names it isn't\r\n    final byte[] digest2 = MessageDigest.getInstance(\"MD5\").digest(archive2);\r\n    assertArrayEquals(digest1, digest2);\r\n    // do I still have the correct modification date?\r\n    // let a second elapse, so we don't get the current time\r\n    Thread.sleep(1000);\r\n    try (TarArchiveInputStream tarIn = TarArchiveInputStream.builder().setByteArray(archive2).get()) {\r\n        final ArchiveEntry nextEntry = tarIn.getNextEntry();\r\n        assertEquals(longFileName, nextEntry.getName());\r\n        // tar archive stores modification time to second granularity only (floored)\r\n        assertEquals(modificationDate.getTime() / 1000, nextEntry.getLastModifiedDate().getTime() / 1000);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testMaxFileSizeError",
  "sourceCode" : "@Test\r\nvoid testMaxFileSizeError() throws Exception {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\r\n    t.setSize(077777777777L);\r\n    final TarArchiveOutputStream tos1 = new TarArchiveOutputStream(new ByteArrayOutputStream());\r\n    tos1.putArchiveEntry(t);\r\n    t.setSize(0100000000000L);\r\n    final TarArchiveOutputStream tos2 = new TarArchiveOutputStream(new ByteArrayOutputStream());\r\n    assertThrows(RuntimeException.class, () -> tos2.putArchiveEntry(t), \"Should have generated RuntimeException\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testOldEntryError",
  "sourceCode" : "@Test\r\nvoid testOldEntryError() throws Exception {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\r\n    t.setSize(Integer.MAX_VALUE);\r\n    t.setModTime(-1000);\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(new ByteArrayOutputStream())) {\r\n        assertThrows(RuntimeException.class, () -> tos.putArchiveEntry(t));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testOldEntryPosixMode",
  "sourceCode" : "@Test\r\nvoid testOldEntryPosixMode() throws Exception {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\r\n    t.setSize(Integer.MAX_VALUE);\r\n    t.setModTime(-1000);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\r\n    tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\r\n    tos.putArchiveEntry(t);\r\n    // make sure header is written to byte array\r\n    tos.write(new byte[10 * 1024]);\r\n    final byte[] data = bos.toByteArray();\r\n    assertEquals(\"00000000000 \", new String(data, 1024 + TarConstants.NAMELEN + TarConstants.MODELEN + TarConstants.UIDLEN + TarConstants.GIDLEN + TarConstants.SIZELEN, 12, UTF_8));\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        final Calendar cal = Calendar.getInstance(TimeZones.GMT);\r\n        cal.set(1969, 11, 31, 23, 59, 59);\r\n        cal.set(Calendar.MILLISECOND, 0);\r\n        assertEquals(cal.getTime(), e.getLastModifiedDate());\r\n    }\r\n    // generates IOE because of unclosed entries.\r\n    // However, we don't really want to create such large entries.\r\n    closeQuietly(tos);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testOldEntryStarMode",
  "sourceCode" : "@Test\r\nvoid testOldEntryStarMode() throws Exception {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\r\n    t.setSize(Integer.MAX_VALUE);\r\n    t.setModTime(-1000);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\r\n    tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\r\n    tos.putArchiveEntry(t);\r\n    // make sure header is written to byte array\r\n    tos.write(new byte[10 * 1024]);\r\n    final byte[] data = bos.toByteArray();\r\n    assertEquals((byte) 0xff, data[TarConstants.NAMELEN + TarConstants.MODELEN + TarConstants.UIDLEN + TarConstants.GIDLEN + TarConstants.SIZELEN]);\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        final Calendar cal = Calendar.getInstance(TimeZones.GMT);\r\n        cal.set(1969, 11, 31, 23, 59, 59);\r\n        cal.set(Calendar.MILLISECOND, 0);\r\n        assertEquals(cal.getTime(), e.getLastModifiedDate());\r\n    }\r\n    // generates IOE because of unclosed entries.\r\n    // However, we don't really want to create such large entries.\r\n    closeQuietly(tos);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testPaxHeadersWithLength101",
  "sourceCode" : "@Test\r\nvoid testPaxHeadersWithLength101() throws Exception {\r\n    final Map<String, String> m = new HashMap<>();\r\n    m.put(\"a\", \"0123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"0123\");\r\n    final byte[] data = writePaxHeader(m);\r\n    assertEquals(\"00000000145 \", new String(data, TarConstants.NAMELEN + TarConstants.MODELEN + TarConstants.UIDLEN + TarConstants.GIDLEN, 12, UTF_8));\r\n    assertEquals(\"101 a=0123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"0123\\n\", new String(data, 512, 101, UTF_8));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testPaxHeadersWithLength99",
  "sourceCode" : "@Test\r\nvoid testPaxHeadersWithLength99() throws Exception {\r\n    final Map<String, String> m = new HashMap<>();\r\n    m.put(\"a\", \"0123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"012\");\r\n    final byte[] data = writePaxHeader(m);\r\n    assertEquals(\"00000000143 \", new String(data, TarConstants.NAMELEN + TarConstants.MODELEN + TarConstants.UIDLEN + TarConstants.GIDLEN, 12, UTF_8));\r\n    assertEquals(\"99 a=0123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"012\\n\", new String(data, 512, 99, UTF_8));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testPutGlobalPaxHeaderEntry",
  "sourceCode" : "@Test\r\nvoid testPutGlobalPaxHeaderEntry() throws IOException {\r\n    final String x = \"If at first you don't succeed, give up\";\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        final int pid = 73;\r\n        final int globCount = 1;\r\n        final byte lfPaxGlobalExtendedHeader = TarConstants.LF_PAX_GLOBAL_EXTENDED_HEADER;\r\n        final TarArchiveEntry globalHeader = new TarArchiveEntry(\"/tmp/GlobalHead.\" + pid + \".\" + globCount, lfPaxGlobalExtendedHeader);\r\n        globalHeader.addPaxHeader(\"SCHILLY.xattr.user.org.apache.weasels\", \"global-weasels\");\r\n        tos.putArchiveEntry(globalHeader);\r\n        TarArchiveEntry entry = new TarArchiveEntry(\"message\");\r\n        entry.setSize(x.length());\r\n        tos.putArchiveEntry(entry);\r\n        tos.write(x.getBytes());\r\n        tos.closeArchiveEntry();\r\n        entry = new TarArchiveEntry(\"counter-message\");\r\n        final String y = \"Nothing succeeds like excess\";\r\n        entry.setSize(y.length());\r\n        entry.addPaxHeader(\"SCHILLY.xattr.user.org.apache.weasels.species\", \"unknown\");\r\n        tos.putArchiveEntry(entry);\r\n        tos.write(y.getBytes());\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final TarArchiveInputStream in = TarArchiveInputStream.builder().setByteArray(bos.toByteArray()).get();\r\n    TarArchiveEntry entryIn = in.getNextTarEntry();\r\n    assertNotNull(entryIn);\r\n    assertEquals(\"message\", entryIn.getName());\r\n    assertEquals(TarConstants.LF_NORMAL, entryIn.getLinkFlag());\r\n    assertEquals(\"global-weasels\", entryIn.getExtraPaxHeader(\"SCHILLY.xattr.user.org.apache.weasels\"));\r\n    final Reader reader = new InputStreamReader(in);\r\n    for (int i = 0; i < x.length(); i++) {\r\n        assertEquals(x.charAt(i), reader.read());\r\n    }\r\n    assertEquals(-1, reader.read());\r\n    entryIn = in.getNextTarEntry();\r\n    assertEquals(\"counter-message\", entryIn.getName());\r\n    assertEquals(\"global-weasels\", entryIn.getExtraPaxHeader(\"SCHILLY.xattr.user.org.apache.weasels\"));\r\n    assertEquals(\"unknown\", entryIn.getExtraPaxHeader(\"SCHILLY.xattr.user.org.apache.weasels.species\"));\r\n    assertNull(in.getNextTarEntry());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testRecordSize",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testRecordSize() throws IOException {\r\n    assertThrows(IllegalArgumentException.class, () -> new TarArchiveOutputStream(new ByteArrayOutputStream(), 512, 511), \"should have rejected recordSize of 511\");\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(new ByteArrayOutputStream(), 512, 512)) {\r\n        assertEquals(512, tos.getRecordSize(), \"recordSize\");\r\n    }\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(new ByteArrayOutputStream(), 512, 512, null)) {\r\n        assertEquals(512, tos.getRecordSize(), \"recordSize\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testRoundtripWith67CharFileNameGnu",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-200\"\r\n */\r\n@Test\r\nvoid testRoundtripWith67CharFileNameGnu() throws Exception {\r\n    testRoundtripWith67CharFileName(TarArchiveOutputStream.LONGFILE_GNU);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testRoundtripWith67CharFileNamePosix",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-200\"\r\n */\r\n@Test\r\nvoid testRoundtripWith67CharFileNamePosix() throws Exception {\r\n    testRoundtripWith67CharFileName(TarArchiveOutputStream.LONGFILE_POSIX);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongDirectoryNameErrorMode",
  "sourceCode" : "@Test\r\nvoid testWriteLongDirectoryNameErrorMode() throws Exception {\r\n    // @formatter:off\r\n    final String n = \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789/\";\r\n    // @formatter:on\r\n    assertThrows(IllegalArgumentException.class, () -> {\r\n        final TarArchiveEntry t = new TarArchiveEntry(n);\r\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\")) {\r\n            tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_ERROR);\r\n            tos.putArchiveEntry(t);\r\n            tos.closeArchiveEntry();\r\n        }\r\n    }, \"Truncated name didn't throw an exception\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongDirectoryNameGnuMode",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-203\"\r\n */\r\n@Test\r\nvoid testWriteLongDirectoryNameGnuMode() throws Exception {\r\n    testWriteLongDirectoryName(TarArchiveOutputStream.LONGFILE_GNU);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongDirectoryNamePosixMode",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-203\"\r\n */\r\n@Test\r\nvoid testWriteLongDirectoryNamePosixMode() throws Exception {\r\n    testWriteLongDirectoryName(TarArchiveOutputStream.LONGFILE_POSIX);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongDirectoryNameTruncateMode",
  "sourceCode" : "@Test\r\nvoid testWriteLongDirectoryNameTruncateMode() throws Exception {\r\n    // @formatter:off\r\n    final String n = \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789/\";\r\n    // @formatter:on\r\n    final TarArchiveEntry t = new TarArchiveEntry(n);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\")) {\r\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_TRUNCATE);\r\n        tos.putArchiveEntry(t);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertEquals(n.substring(0, TarConstants.NAMELEN) + \"/\", e.getName(), \"Entry name\");\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory(), \"The entry is not a directory\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongFileNamePosixMode",
  "sourceCode" : "@Test\r\nvoid testWriteLongFileNamePosixMode() throws Exception {\r\n    // @formatter:off\r\n    final String n = \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\";\r\n    // @formatter:on\r\n    final TarArchiveEntry t = new TarArchiveEntry(n);\r\n    t.setSize(10 * 1024);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\")) {\r\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\r\n        tos.putArchiveEntry(t);\r\n        tos.write(new byte[10 * 1024]);\r\n        tos.closeArchiveEntry();\r\n        final byte[] data = bos.toByteArray();\r\n        assertEquals(\"160 path=\" + n + \"\\n\", new String(data, 512, 160, UTF_8));\r\n        try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n            assertEquals(n, tin.getNextTarEntry().getName());\r\n            assertEquals(TarConstants.LF_NORMAL, tin.getCurrentEntry().getLinkFlag());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongFileNameThrowsException",
  "sourceCode" : "@Test\r\nvoid testWriteLongFileNameThrowsException() throws Exception {\r\n    final String n = \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\";\r\n    final TarArchiveEntry t = new TarArchiveEntry(n);\r\n    final TarArchiveOutputStream tos = new TarArchiveOutputStream(new ByteArrayOutputStream(), \"ASCII\");\r\n    assertThrows(IllegalArgumentException.class, () -> tos.putArchiveEntry(t));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongLinkNameErrorMode",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-237\"\r\n */\r\n@Test\r\nvoid testWriteLongLinkNameErrorMode() throws Exception {\r\n    final String linkName = \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789/test\";\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"test\", TarConstants.LF_SYMLINK);\r\n    entry.setLinkName(linkName);\r\n    assertThrows(RuntimeException.class, () -> {\r\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\")) {\r\n            tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_ERROR);\r\n            tos.putArchiveEntry(entry);\r\n            tos.closeArchiveEntry();\r\n        }\r\n    }, \"Truncated link name didn't throw an exception\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongLinkNameGnuMode",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-237\"\r\n */\r\n@Test\r\nvoid testWriteLongLinkNameGnuMode() throws Exception {\r\n    testWriteLongLinkName(TarArchiveOutputStream.LONGFILE_GNU);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongLinkNamePosixMode",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-237\"\r\n */\r\n@Test\r\nvoid testWriteLongLinkNamePosixMode() throws Exception {\r\n    testWriteLongLinkName(TarArchiveOutputStream.LONGFILE_POSIX);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteLongLinkNameTruncateMode",
  "sourceCode" : "@Test\r\nvoid testWriteLongLinkNameTruncateMode() throws Exception {\r\n    final String linkName = \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789/\";\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"test\", TarConstants.LF_SYMLINK);\r\n    entry.setLinkName(linkName);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\")) {\r\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_TRUNCATE);\r\n        tos.putArchiveEntry(entry);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertEquals(linkName.substring(0, TarConstants.NAMELEN), e.getLinkName(), \"Link name\");\r\n        assertEquals(TarConstants.LF_SYMLINK, e.getLinkFlag(), \"Link flag\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteNonAsciiDirectoryNamePosixMode",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-203\"\r\n */\r\n@Test\r\nvoid testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\r\n    final String n = \"f\\u00f6\\u00f6/\";\r\n    final TarArchiveEntry t = new TarArchiveEntry(n);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        tos.setAddPaxHeadersForNonAsciiNames(true);\r\n        tos.putArchiveEntry(t);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertEquals(n, e.getName());\r\n        assertEquals(TarConstants.LF_DIR, e.getLinkFlag());\r\n        assertTrue(e.isDirectory());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteNonAsciiLinkPathNamePaxHeader",
  "sourceCode" : "@Test\r\nvoid testWriteNonAsciiLinkPathNamePaxHeader() throws Exception {\r\n    final String n = \"\\u00e4\";\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"a\", TarConstants.LF_LINK);\r\n    t.setSize(10 * 1024);\r\n    t.setLinkName(n);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        tos.setAddPaxHeadersForNonAsciiNames(true);\r\n        tos.putArchiveEntry(t);\r\n        tos.write(new byte[10 * 1024]);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    assertEquals(\"15 linkpath=\" + n + \"\\n\", new String(data, 512, 15, UTF_8));\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertEquals(n, e.getLinkName());\r\n        assertEquals(TarConstants.LF_LINK, e.getLinkFlag(), \"Link flag\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteNonAsciiNameWithUnfortunateNamePosixMode",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-265\"\r\n */\r\n@Test\r\nvoid testWriteNonAsciiNameWithUnfortunateNamePosixMode() throws Exception {\r\n    final String n = \"f\\u00f6\\u00f6\\u00dc\";\r\n    final TarArchiveEntry t = new TarArchiveEntry(n);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        tos.setAddPaxHeadersForNonAsciiNames(true);\r\n        tos.putArchiveEntry(t);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertEquals(n, e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n        assertFalse(e.isDirectory());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteNonAsciiPathNamePaxHeader",
  "sourceCode" : "@Test\r\nvoid testWriteNonAsciiPathNamePaxHeader() throws Exception {\r\n    final String n = \"\\u00e4\";\r\n    final TarArchiveEntry t = new TarArchiveEntry(n);\r\n    t.setSize(10 * 1024);\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        tos.setAddPaxHeadersForNonAsciiNames(true);\r\n        tos.putArchiveEntry(t);\r\n        tos.write(new byte[10 * 1024]);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    assertEquals(\"11 path=\" + n + \"\\n\", new String(data, 512, 11, UTF_8));\r\n    try (TarArchiveInputStream tin = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n        final TarArchiveEntry e = tin.getNextTarEntry();\r\n        assertEquals(n, e.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, e.getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWriteSimplePaxHeaders",
  "sourceCode" : "@Test\r\nvoid testWriteSimplePaxHeaders() throws Exception {\r\n    final Map<String, String> m = new HashMap<>();\r\n    m.put(\"a\", \"b\");\r\n    final byte[] data = writePaxHeader(m);\r\n    assertEquals(\"00000000006 \", new String(data, TarConstants.NAMELEN + TarConstants.MODELEN + TarConstants.UIDLEN + TarConstants.GIDLEN, 12, UTF_8));\r\n    assertEquals(\"6 a=b\\n\", new String(data, 512, 6, UTF_8));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarArchiveOutputStreamTest.java",
  "methodName" : "testWritingBigFile",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-642\"\r\n */\r\n@Disabled(\"The test needs to write 1.1 TB in chunks of 512 bytes which takes a long time. So it's disabled by default\")\r\n@Test\r\nvoid testWritingBigFile() throws Exception {\r\n    final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\r\n    t.setSize((Integer.MAX_VALUE + 1L) * TarConstants.DEFAULT_RCDSIZE);\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(NullOutputStream.INSTANCE)) {\r\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\r\n        tos.putArchiveEntry(t);\r\n        final byte[] bytes = new byte[TarConstants.DEFAULT_RCDSIZE];\r\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\r\n            tos.write(bytes);\r\n        }\r\n        tos.write(bytes);\r\n        tos.closeArchiveEntry();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testArchiveWithTrailer",
  "sourceCode" : "/**\r\n * This test ensures the implementation is reading the padded last block if a tool has added one to an archive\r\n */\r\n@Test\r\nvoid testArchiveWithTrailer() throws IOException {\r\n    try (SeekableByteChannel channel = Files.newByteChannel(getPath(\"archive_with_trailer.tar\"));\r\n        TarFile tarfile = new TarFile(channel, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, false)) {\r\n        final String tarAppendix = \"Hello, world!\\n\";\r\n        final ByteBuffer buffer = ByteBuffer.allocate(tarAppendix.length());\r\n        channel.read(buffer);\r\n        assertEquals(tarAppendix, new String(buffer.array()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testBuilderSeekableByteChannel",
  "sourceCode" : "@Test\r\nvoid testBuilderSeekableByteChannel() throws IOException {\r\n    try (SeekableByteChannel channel = Files.newByteChannel(getPath(\"archive_with_trailer.tar\"));\r\n        TarFile tarfile = TarFile.builder().setSeekableByteChannel(channel).setBlockSize(TarConstants.DEFAULT_BLKSIZE).setRecordSize(TarConstants.DEFAULT_RCDSIZE).setLenient(false).get()) {\r\n        final String tarAppendix = \"Hello, world!\\n\";\r\n        final ByteBuffer buffer = ByteBuffer.allocate(tarAppendix.length());\r\n        channel.read(buffer);\r\n        assertEquals(tarAppendix, new String(buffer.array()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testCompress197",
  "sourceCode" : "@Test\r\nvoid testCompress197() throws IOException {\r\n    try (TarFile tarFile = new TarFile(getPath(\"COMPRESS-197.tar\"))) {\r\n        // noop\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testCompress558",
  "sourceCode" : "@Test\r\nvoid testCompress558() throws IOException {\r\n    final String folderName = \"apache-activemq-5.16.0/examples/openwire/advanced-scenarios/jms-example-exclusive-consumer/src/main/\";\r\n    // @formatter:off\r\n    final String consumerJavaName = \"apache-activemq-5.16.0/examples/openwire/advanced-scenarios/jms-example-exclusive-consumer/src/main/java/example/queue/exclusive/Consumer.java\";\r\n    final String producerJavaName = \"apache-activemq-5.16.0/examples/openwire/advanced-scenarios/jms-example-exclusive-consumer/src/main/java/example/queue/exclusive/Producer.java\";\r\n    // @formatter:on\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\r\n        final TarArchiveEntry rootfolder = new TarArchiveEntry(folderName);\r\n        tos.putArchiveEntry(rootfolder);\r\n        final TarArchiveEntry consumerJava = new TarArchiveEntry(consumerJavaName);\r\n        tos.putArchiveEntry(consumerJava);\r\n        final TarArchiveEntry producerJava = new TarArchiveEntry(producerJavaName);\r\n        tos.putArchiveEntry(producerJava);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarFile tarFile = new TarFile(data)) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(folderName, entries.get(0).getName());\r\n        assertEquals(TarConstants.LF_DIR, entries.get(0).getLinkFlag());\r\n        assertEquals(consumerJavaName, entries.get(1).getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entries.get(1).getLinkFlag());\r\n        assertEquals(producerJavaName, entries.get(2).getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entries.get(2).getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testCompress657",
  "sourceCode" : "@Test\r\nvoid testCompress657() throws IOException {\r\n    try (TarFile tarFile = new TarFile(getPath(\"COMPRESS-657/orjson-3.7.8.tar\"))) {\r\n        for (final TarArchiveEntry entry : tarFile.getEntries()) {\r\n            if (entry.isDirectory()) {\r\n                // An entry cannot be a directory and a \"normal file\" at the same time.\r\n                assertFalse(entry.isFile(), \"Entry '\" + entry.getName() + \"' is both a directory and a file\");\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testDatePriorToEpochInGNUFormat",
  "sourceCode" : "@Test\r\nvoid testDatePriorToEpochInGNUFormat() throws Exception {\r\n    datePriorToEpoch(\"preepoch-star.tar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testDatePriorToEpochInPAXFormat",
  "sourceCode" : "@Test\r\nvoid testDatePriorToEpochInPAXFormat() throws Exception {\r\n    datePriorToEpoch(\"preepoch-posix.tar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testDirectoryWithLongNameEndsWithSlash",
  "sourceCode" : "@Test\r\nvoid testDirectoryWithLongNameEndsWithSlash() throws IOException {\r\n    final String rootPath = getTempDirFile().getAbsolutePath();\r\n    final String dirDirectory = \"COMPRESS-509\";\r\n    final int count = 100;\r\n    final File root = new File(rootPath + \"/\" + dirDirectory);\r\n    root.mkdirs();\r\n    for (int i = 1; i < count; i++) {\r\n        // create empty dirs with incremental length\r\n        final String subDir = StringUtils.repeat('a', i);\r\n        final File dir = new File(rootPath + \"/\" + dirDirectory, \"/\" + subDir);\r\n        dir.mkdir();\r\n        // tar these dirs\r\n        final String fileName = \"/\" + dirDirectory + \"/\" + subDir;\r\n        final File tarF = new File(rootPath + \"/tar\" + i + \".tar\");\r\n        try (OutputStream dest = Files.newOutputStream(tarF.toPath());\r\n            TarArchiveOutputStream out = new TarArchiveOutputStream(new BufferedOutputStream(dest))) {\r\n            out.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\r\n            out.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\r\n            final File file = new File(rootPath, fileName);\r\n            final TarArchiveEntry entry = new TarArchiveEntry(file);\r\n            entry.setName(fileName);\r\n            out.putArchiveEntry(entry);\r\n            out.closeArchiveEntry();\r\n            out.flush();\r\n        }\r\n        // untar these tars\r\n        try (TarFile tarFile = new TarFile(tarF)) {\r\n            for (final TarArchiveEntry entry : tarFile.getEntries()) {\r\n                assertTrue(entry.getName().endsWith(\"/\"), \"Entry name: \" + entry.getName());\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    final byte[] buf = new byte[2];\r\n    try (TarFile tarFile = new TarFile(getPath(\"bla.tar\"));\r\n        InputStream input = tarFile.getInputStream(tarFile.getEntries().get(0))) {\r\n        IOUtils.toByteArray(input);\r\n        assertEquals(-1, input.read(buf));\r\n        assertEquals(-1, input.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testParseTarTruncatedInContent",
  "sourceCode" : "@Test\r\nvoid testParseTarTruncatedInContent() {\r\n    assertThrows(IOException.class, () -> new TarFile(getPath(\"COMPRESS-544_truncated_in_content.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testParseTarTruncatedInPadding",
  "sourceCode" : "@Test\r\nvoid testParseTarTruncatedInPadding() {\r\n    assertThrows(IOException.class, () -> new TarFile(getPath(\"COMPRESS-544_truncated_in_padding.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testParseTarWithNonNumberPaxHeaders",
  "sourceCode" : "@Test\r\nvoid testParseTarWithNonNumberPaxHeaders() {\r\n    assertThrows(ArchiveException.class, () -> new TarFile(getPath(\"COMPRESS-529-fail.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testParseTarWithSpecialPaxHeaders",
  "sourceCode" : "@Test\r\nvoid testParseTarWithSpecialPaxHeaders() {\r\n    assertThrows(ArchiveException.class, () -> new TarFile(getPath(\"COMPRESS-530-fail.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testReadsArchiveCompletely_COMPRESS245",
  "sourceCode" : "@Test\r\nvoid testReadsArchiveCompletely_COMPRESS245() {\r\n    try {\r\n        final Path tempTar = tempResultDir.toPath().resolve(\"COMPRESS-245.tar\");\r\n        try (GZIPInputStream gin = new GZIPInputStream(Files.newInputStream(getPath(\"COMPRESS-245.tar.gz\")))) {\r\n            Files.copy(gin, tempTar);\r\n        }\r\n        try (TarFile tarFile = new TarFile(tempTar)) {\r\n            assertEquals(31, tarFile.getEntries().size());\r\n        }\r\n    } catch (final IOException e) {\r\n        fail(\"COMPRESS-245: \" + e.getMessage());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testRejectsArchivesWithNegativeSizes",
  "sourceCode" : "@Test\r\nvoid testRejectsArchivesWithNegativeSizes() throws Exception {\r\n    assertThrows(ArchiveException.class, () -> new TarFile(getFile(\"COMPRESS-569-fail.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testShouldReadBigGid",
  "sourceCode" : "@Test\r\nvoid testShouldReadBigGid() throws Exception {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos)) {\r\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\r\n        final TarArchiveEntry t = new TarArchiveEntry(\"name\");\r\n        t.setGroupId(4294967294L);\r\n        t.setSize(1);\r\n        tos.putArchiveEntry(t);\r\n        tos.write(30);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarFile tarFile = new TarFile(data)) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(4294967294L, entries.get(0).getLongGroupId());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testShouldReadGNULongNameEntryWithWrongName",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-324\">COMPRESS-324</a>\r\n */\r\n@Test\r\nvoid testShouldReadGNULongNameEntryWithWrongName() throws Exception {\r\n    try (TarFile tarFile = new TarFile(getPath(\"COMPRESS-324.tar\"))) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(\"1234567890123456789012345678901234567890123456789012345678901234567890\" + \"1234567890123456789012345678901234567890123456789012345678901234567890\" + \"1234567890123456789012345678901234567890123456789012345678901234567890\" + \"1234567890123456789012345678901234567890.txt\", entries.get(0).getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testShouldThrowAnExceptionOnTruncatedEntries",
  "sourceCode" : "@Test\r\nvoid testShouldThrowAnExceptionOnTruncatedEntries() throws Exception {\r\n    createTempDirectory(\"COMPRESS-279\");\r\n    assertThrows(IOException.class, () -> new TarFile(getPath(\"COMPRESS-279.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testShouldUseSpecifiedEncodingWhenReadingGNULongNames",
  "sourceCode" : "@Test\r\nvoid testShouldUseSpecifiedEncodingWhenReadingGNULongNames() throws Exception {\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    final String encoding = StandardCharsets.UTF_16.name();\r\n    final String name = \"1234567890123456789012345678901234567890123456789\" + \"01234567890123456789012345678901234567890123456789\" + \"01234567890\\u00e4\";\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, encoding)) {\r\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\r\n        final TarArchiveEntry t = new TarArchiveEntry(name);\r\n        t.setSize(1);\r\n        tos.putArchiveEntry(t);\r\n        tos.write(30);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = bos.toByteArray();\r\n    try (TarFile tarFile = new TarFile(data, encoding)) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(1, entries.size());\r\n        assertEquals(name, entries.get(0).getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    try (TarFile tarFile = new TarFile(getPath(\"bla.tar\"));\r\n        InputStream input = tarFile.getInputStream(tarFile.getEntries().get(0))) {\r\n        IOUtils.toByteArray(input);\r\n        assertEquals(-1, input.read());\r\n        assertEquals(-1, input.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testSkipsDevNumbersWhenEntryIsNoDevice",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-417\">COMPRESS-417</a>\r\n */\r\n@Test\r\nvoid testSkipsDevNumbersWhenEntryIsNoDevice() throws Exception {\r\n    try (TarFile tarFile = new TarFile(getPath(\"COMPRESS-417.tar\"))) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(2, entries.size());\r\n        assertEquals(\"test1.xml\", entries.get(0).getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entries.get(0).getLinkFlag());\r\n        assertEquals(\"test2.xml\", entries.get(1).getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entries.get(1).getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testSurvivesBlankLinesInPaxHeader",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-355\">COMPRESS-355</a>\r\n */\r\n@Test\r\nvoid testSurvivesBlankLinesInPaxHeader() throws Exception {\r\n    try (TarFile tarFile = new TarFile(getPath(\"COMPRESS-355.tar\"))) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(1, entries.size());\r\n        assertEquals(\"package/package.json\", entries.get(0).getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entries.get(0).getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testSurvivesPaxHeaderWithNameEndingInSlash",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-356\">COMPRESS-356</a>\r\n */\r\n@Test\r\nvoid testSurvivesPaxHeaderWithNameEndingInSlash() throws Exception {\r\n    try (TarFile tarFile = new TarFile(getPath(\"COMPRESS-356.tar\"))) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(1, entries.size());\r\n        assertEquals(\"package/package.json\", entries.get(0).getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entries.get(0).getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testThrowException",
  "sourceCode" : "@Test\r\nvoid testThrowException() {\r\n    assertThrows(ArchiveException.class, () -> new TarFile(getPath(\"COMPRESS-553-fail.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testThrowExceptionWithNullEntry",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionWithNullEntry() {\r\n    // Only on Windows: throws a UnmappableCharacterException\r\n    assertThrows(IOException.class, () -> new TarFile(getPath(\"COMPRESS-554-fail.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarFileTest.java",
  "methodName" : "testWorkaroundForBrokenTimeHeader",
  "sourceCode" : "@Test\r\nvoid testWorkaroundForBrokenTimeHeader() throws IOException {\r\n    try (TarFile tarFile = new TarFile(getPath(\"simple-aix-native-tar.tar\"))) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        assertEquals(3, entries.size());\r\n        final TarArchiveEntry entry = entries.get(1);\r\n        assertEquals(\"sample/link-to-txt-file.lnk\", entry.getName());\r\n        assertEquals(TarConstants.LF_SYMLINK, entry.getLinkFlag());\r\n        assertEquals(new Date(0), entry.getLastModifiedDate());\r\n        assertTrue(entry.isSymbolicLink());\r\n        assertTrue(entry.isCheckSumOK());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarMemoryFileSystemTest.java",
  "methodName" : "testCheckUserInformationInTarEntry",
  "sourceCode" : "@Test\r\nvoid testCheckUserInformationInTarEntry() throws IOException, ArchiveException {\r\n    final String user = \"commons\";\r\n    final String group = \"compress\";\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().addUser(user).addGroup(group).build()) {\r\n        final Path pathSource = fileSystem.getPath(\"original-file.txt\");\r\n        Files.write(pathSource, \"Test\".getBytes(UTF_8));\r\n        Files.setAttribute(pathSource, \"posix:owner\", (UserPrincipal) () -> user);\r\n        Files.setAttribute(pathSource, \"posix:group\", (GroupPrincipal) () -> group);\r\n        final Path target = fileSystem.getPath(\"original-file.tar\");\r\n        try (OutputStream out = Files.newOutputStream(target);\r\n            ArchiveOutputStream<ArchiveEntry> tarOut = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(ArchiveStreamFactory.TAR, out)) {\r\n            final TarArchiveEntry entry = new TarArchiveEntry(pathSource);\r\n            tarOut.putArchiveEntry(entry);\r\n            tarOut.write(pathSource);\r\n            tarOut.closeArchiveEntry();\r\n        }\r\n        try (TarArchiveInputStream tarIn = TarArchiveInputStream.builder().setPath(target).get()) {\r\n            final TarArchiveEntry nextTarEntry = tarIn.getNextTarEntry();\r\n            assertEquals(user, nextTarEntry.getUserName());\r\n            assertEquals(group, nextTarEntry.getGroupName());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarMemoryFileSystemTest.java",
  "methodName" : "testTarFromMemoryFileSystem",
  "sourceCode" : "@Test\r\nvoid testTarFromMemoryFileSystem() throws IOException, ArchiveException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path p = fileSystem.getPath(\"test.txt\");\r\n        Files.write(p, \"Test\".getBytes(UTF_8));\r\n        final File f = File.createTempFile(\"commons-compress-memoryfs\", \".tar\");\r\n        try (OutputStream out = Files.newOutputStream(f.toPath());\r\n            ArchiveOutputStream<ArchiveEntry> tarOut = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(ArchiveStreamFactory.TAR, out)) {\r\n            final TarArchiveEntry entry = new TarArchiveEntry(p);\r\n            tarOut.putArchiveEntry(entry);\r\n            tarOut.write(p);\r\n            tarOut.closeArchiveEntry();\r\n            assertEquals(f.length(), tarOut.getBytesWritten());\r\n        } finally {\r\n            AbstractTest.forceDelete(f);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarMemoryFileSystemTest.java",
  "methodName" : "testTarToMemoryFileSystem",
  "sourceCode" : "@Test\r\nvoid testTarToMemoryFileSystem() throws IOException, ArchiveException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path p = fileSystem.getPath(\"target.tar\");\r\n        try (OutputStream out = Files.newOutputStream(p);\r\n            ArchiveOutputStream<ArchiveEntry> tarOut = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(ArchiveStreamFactory.TAR, out)) {\r\n            final String content = \"Test\";\r\n            final TarArchiveEntry entry = new TarArchiveEntry(\"test.txt\");\r\n            entry.setSize(content.length());\r\n            tarOut.putArchiveEntry(entry);\r\n            tarOut.writeUtf8(\"Test\");\r\n            tarOut.closeArchiveEntry();\r\n            assertTrue(Files.exists(p));\r\n            assertEquals(Files.size(p), tarOut.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testName",
  "sourceCode" : "@Test\r\nvoid testName() {\r\n    byte[] buff = new byte[20];\r\n    final String sb1 = \"abcdefghijklmnopqrstuvwxyz\";\r\n    int off = TarUtils.formatNameBytes(sb1, buff, 1, buff.length - 1);\r\n    assertEquals(off, 20);\r\n    String sb2 = TarUtils.parseName(buff, 1, 10);\r\n    assertEquals(sb2, sb1.substring(0, 10));\r\n    sb2 = TarUtils.parseName(buff, 1, 19);\r\n    assertEquals(sb2, sb1.substring(0, 19));\r\n    buff = new byte[30];\r\n    off = TarUtils.formatNameBytes(sb1, buff, 1, buff.length - 1);\r\n    assertEquals(off, 30);\r\n    sb2 = TarUtils.parseName(buff, 1, buff.length - 1);\r\n    assertEquals(sb1, sb2);\r\n    buff = new byte[] { 0, 1, 0 };\r\n    sb2 = TarUtils.parseName(buff, 0, 3);\r\n    assertEquals(\"\", sb2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testNegative",
  "sourceCode" : "@Test\r\nvoid testNegative() {\r\n    final byte[] buffer = new byte[22];\r\n    TarUtils.formatUnsignedOctalString(-1, buffer, 0, buffer.length);\r\n    assertEquals(\"1777777777777777777777\", new String(buffer, UTF_8));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testOverflow",
  "sourceCode" : "@Test\r\nvoid testOverflow() {\r\n    // a lot of the numbers have 8-byte buffers (nul term)\r\n    final byte[] buffer = new byte[8 - 1];\r\n    TarUtils.formatUnsignedOctalString(07777777L, buffer, 0, buffer.length);\r\n    assertEquals(\"7777777\", new String(buffer, UTF_8));\r\n    assertThrows(IllegalArgumentException.class, () -> TarUtils.formatUnsignedOctalString(017777777L, buffer, 0, buffer.length), \"Should have cause IllegalArgumentException\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseFromPAX01SparseHeaders",
  "sourceCode" : "@Test\r\nvoid testParseFromPAX01SparseHeaders() throws Exception {\r\n    final String map = \"0,10,20,0,20,5\";\r\n    final List<TarArchiveStructSparse> sparse = TarUtils.parseFromPAX01SparseHeaders(map);\r\n    assertEquals(3, sparse.size());\r\n    assertEquals(0, sparse.get(0).getOffset());\r\n    assertEquals(10, sparse.get(0).getNumbytes());\r\n    assertEquals(20, sparse.get(1).getOffset());\r\n    assertEquals(0, sparse.get(1).getNumbytes());\r\n    assertEquals(20, sparse.get(2).getOffset());\r\n    assertEquals(5, sparse.get(2).getNumbytes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseFromPAX01SparseHeadersRejectsNegativeNumbytes",
  "sourceCode" : "@Test\r\nvoid testParseFromPAX01SparseHeadersRejectsNegativeNumbytes() throws Exception {\r\n    assertThrows(ArchiveException.class, () -> TarUtils.parseFromPAX01SparseHeaders(\"0,10,20,0,20,-5\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseFromPAX01SparseHeadersRejectsNegativeOffset",
  "sourceCode" : "@Test\r\nvoid testParseFromPAX01SparseHeadersRejectsNegativeOffset() throws Exception {\r\n    assertThrows(ArchiveException.class, () -> TarUtils.parseFromPAX01SparseHeaders(\"0,10,20,0,-2,5\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseFromPAX01SparseHeadersRejectsNonNumericNumbytes",
  "sourceCode" : "@Test\r\nvoid testParseFromPAX01SparseHeadersRejectsNonNumericNumbytes() throws Exception {\r\n    assertThrows(IOException.class, () -> TarUtils.parseFromPAX01SparseHeaders(\"0,10,20,0,20,b\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseFromPAX01SparseHeadersRejectsNonNumericOffset",
  "sourceCode" : "@Test\r\nvoid testParseFromPAX01SparseHeadersRejectsNonNumericOffset() throws Exception {\r\n    assertThrows(IOException.class, () -> TarUtils.parseFromPAX01SparseHeaders(\"0,10,20,0,2a,5\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseFromPAX01SparseHeadersRejectsOddNumberOfEntries",
  "sourceCode" : "@Test\r\nvoid testParseFromPAX01SparseHeadersRejectsOddNumberOfEntries() throws Exception {\r\n    final String map = \"0,10,20,0,20\";\r\n    assertThrows(ArchiveException.class, () -> TarUtils.parseFromPAX01SparseHeaders(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseOctal",
  "sourceCode" : "@Test\r\nvoid testParseOctal() {\r\n    long value;\r\n    byte[] buffer;\r\n    // Allowed 11 digits\r\n    final long MAX_OCTAL = 077777777777L;\r\n    // in fact 12 for some implementations\r\n    final long MAX_OCTAL_OVERFLOW = 0777777777777L;\r\n    // Maximum valid octal\r\n    final String maxOctal = \"777777777777\";\r\n    buffer = maxOctal.getBytes(UTF_8);\r\n    value = TarUtils.parseOctal(buffer, 0, buffer.length);\r\n    assertEquals(MAX_OCTAL_OVERFLOW, value);\r\n    buffer[buffer.length - 1] = ' ';\r\n    value = TarUtils.parseOctal(buffer, 0, buffer.length);\r\n    assertEquals(MAX_OCTAL, value);\r\n    buffer[buffer.length - 1] = 0;\r\n    value = TarUtils.parseOctal(buffer, 0, buffer.length);\r\n    assertEquals(MAX_OCTAL, value);\r\n    buffer = new byte[] { 0, 0 };\r\n    value = TarUtils.parseOctal(buffer, 0, buffer.length);\r\n    assertEquals(0, value);\r\n    buffer = new byte[] { 0, ' ' };\r\n    value = TarUtils.parseOctal(buffer, 0, buffer.length);\r\n    assertEquals(0, value);\r\n    buffer = new byte[] { ' ', 0 };\r\n    value = TarUtils.parseOctal(buffer, 0, buffer.length);\r\n    assertEquals(0, value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseOctalCompress330",
  "sourceCode" : "@Test\r\nvoid testParseOctalCompress330() {\r\n    final long expected = 0100000;\r\n    final byte[] buffer = { 32, 32, 32, 32, 32, 49, 48, 48, 48, 48, 48, 32 };\r\n    assertEquals(expected, TarUtils.parseOctalOrBinary(buffer, 0, buffer.length));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseOctalEmbeddedSpace",
  "sourceCode" : "@Test\r\nvoid testParseOctalEmbeddedSpace() {\r\n    // Invalid - embedded space\r\n    final byte[] buffer4 = \" 0 07 \".getBytes(UTF_8);\r\n    assertThrows(IllegalArgumentException.class, () -> TarUtils.parseOctal(buffer4, 0, buffer4.length), \"Expected IllegalArgumentException - embedded space\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseOctalInvalid",
  "sourceCode" : "@Test\r\nvoid testParseOctalInvalid() {\r\n    final byte[] buffer1 = ArrayUtils.EMPTY_BYTE_ARRAY;\r\n    assertThrows(IllegalArgumentException.class, () -> TarUtils.parseOctal(buffer1, 0, buffer1.length), \"Expected IllegalArgumentException - should be at least 2 bytes long\");\r\n    // 1-byte array\r\n    final byte[] buffer2 = { 0 };\r\n    assertThrows(IllegalArgumentException.class, () -> TarUtils.parseOctal(buffer2, 0, buffer2.length), \"Expected IllegalArgumentException - should be at least 2 bytes long\");\r\n    // Invalid input\r\n    final byte[] buffer3 = \"abcdef \".getBytes(UTF_8);\r\n    assertThrows(IllegalArgumentException.class, () -> TarUtils.parseOctal(buffer3, 0, buffer3.length), \"Expected IllegalArgumentException\");\r\n    // Invalid - embedded NUL\r\n    final byte[] buffer5 = \" 0\\00007 \".getBytes(UTF_8);\r\n    assertThrows(IllegalArgumentException.class, () -> TarUtils.parseOctal(buffer5, 0, buffer5.length), \"Expected IllegalArgumentException - embedded NUL\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX01SparseHeadersRejectsOddNumberOfEntries",
  "sourceCode" : "@Test\r\nvoid testParsePAX01SparseHeadersRejectsOddNumberOfEntries() {\r\n    final String map = \"0,10,20,0,20\";\r\n    assertThrows(UncheckedIOException.class, () -> TarUtils.parsePAX01SparseHeaders(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX1XSparseHeaders",
  "sourceCode" : "@Test\r\nvoid testParsePAX1XSparseHeaders() throws Exception {\r\n    final byte[] header = (\"1\\n\" + \"0\\n\" + \"20\\n\").getBytes();\r\n    final byte[] block = new byte[512];\r\n    System.arraycopy(header, 0, block, 0, header.length);\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(block)) {\r\n        final List<TarArchiveStructSparse> sparse = TarUtils.parsePAX1XSparseHeaders(in, 512);\r\n        assertEquals(1, sparse.size());\r\n        assertEquals(0, sparse.get(0).getOffset());\r\n        assertEquals(20, sparse.get(0).getNumbytes());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX1XSparseHeadersRejectsIncompleteLastLine",
  "sourceCode" : "@Test\r\nvoid testParsePAX1XSparseHeadersRejectsIncompleteLastLine() throws Exception {\r\n    final byte[] header = (\"1\\n\" + \"0\\n\" + \"20\").getBytes();\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(header)) {\r\n        assertThrows(ArchiveException.class, () -> TarUtils.parsePAX1XSparseHeaders(in, 512));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX1XSparseHeadersRejectsNegativeNumberOfEntries",
  "sourceCode" : "@Test\r\nvoid testParsePAX1XSparseHeadersRejectsNegativeNumberOfEntries() throws Exception {\r\n    final byte[] header = (\"111111111111111111111111111111111111111111111111111111111111111\\n\" + \"0\\n\" + \"20\\n\").getBytes();\r\n    final byte[] block = new byte[512];\r\n    System.arraycopy(header, 0, block, 0, header.length);\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(block)) {\r\n        assertThrows(ArchiveException.class, () -> TarUtils.parsePAX1XSparseHeaders(in, 512));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX1XSparseHeadersRejectsNegativeNumbytes",
  "sourceCode" : "@Test\r\nvoid testParsePAX1XSparseHeadersRejectsNegativeNumbytes() throws Exception {\r\n    final byte[] header = (\"1\\n\" + \"0\\n\" + \"111111111111111111111111111111111111111111111111111111111111111\\n\").getBytes();\r\n    final byte[] block = new byte[512];\r\n    System.arraycopy(header, 0, block, 0, header.length);\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(block)) {\r\n        assertThrows(ArchiveException.class, () -> TarUtils.parsePAX1XSparseHeaders(in, 512));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX1XSparseHeadersRejectsNegativeOffset",
  "sourceCode" : "@Test\r\nvoid testParsePAX1XSparseHeadersRejectsNegativeOffset() throws Exception {\r\n    final byte[] header = (\"1\\n\" + \"111111111111111111111111111111111111111111111111111111111111111\\n\" + \"20\\n\").getBytes();\r\n    final byte[] block = new byte[512];\r\n    System.arraycopy(header, 0, block, 0, header.length);\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(block)) {\r\n        assertThrows(ArchiveException.class, () -> TarUtils.parsePAX1XSparseHeaders(in, 512));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX1XSparseHeadersRejectsNonNumericNumberOfEntries",
  "sourceCode" : "@Test\r\nvoid testParsePAX1XSparseHeadersRejectsNonNumericNumberOfEntries() throws Exception {\r\n    final byte[] header = (\"x\\n\" + \"0\\n\" + \"20\\n\").getBytes();\r\n    final byte[] block = new byte[512];\r\n    System.arraycopy(header, 0, block, 0, header.length);\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(block)) {\r\n        assertThrows(ArchiveException.class, () -> TarUtils.parsePAX1XSparseHeaders(in, 512));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX1XSparseHeadersRejectsNonNumericNumbytes",
  "sourceCode" : "@Test\r\nvoid testParsePAX1XSparseHeadersRejectsNonNumericNumbytes() throws Exception {\r\n    final byte[] header = (\"1\\n\" + \"0\\n\" + \"2x\\n\").getBytes();\r\n    final byte[] block = new byte[512];\r\n    System.arraycopy(header, 0, block, 0, header.length);\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(block)) {\r\n        assertThrows(ArchiveException.class, () -> TarUtils.parsePAX1XSparseHeaders(in, 512));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParsePAX1XSparseHeadersRejectsNonNumericOffset",
  "sourceCode" : "@Test\r\nvoid testParsePAX1XSparseHeadersRejectsNonNumericOffset() throws Exception {\r\n    final byte[] header = (\"1\\n\" + \"x\\n\" + \"20\\n\").getBytes();\r\n    final byte[] block = new byte[512];\r\n    System.arraycopy(header, 0, block, 0, header.length);\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(block)) {\r\n        assertThrows(ArchiveException.class, () -> TarUtils.parsePAX1XSparseHeaders(in, 512));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseSparse",
  "sourceCode" : "@Test\r\nvoid testParseSparse() {\r\n    final long expectedOffset = 0100000;\r\n    final long expectedNumbytes = 0111000;\r\n    final byte[] buffer = { // sparseOffset\r\n    ' ', // sparseOffset\r\n    ' ', // sparseOffset\r\n    ' ', // sparseOffset\r\n    ' ', // sparseOffset\r\n    ' ', // sparseOffset\r\n    '0', // sparseOffset\r\n    '1', // sparseOffset\r\n    '0', // sparseOffset\r\n    '0', // sparseOffset\r\n    '0', // sparseOffset\r\n    '0', // sparseOffset\r\n    '0', ' ', ' ', ' ', ' ', ' ', '0', '1', '1', '1', '0', '0', '0' };\r\n    final TarArchiveStructSparse sparse = TarUtils.parseSparse(buffer, 0);\r\n    assertEquals(sparse.getOffset(), expectedOffset);\r\n    assertEquals(sparse.getNumbytes(), expectedNumbytes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testParseTarWithSpecialPaxHeaders",
  "sourceCode" : "@Test\r\nvoid testParseTarWithSpecialPaxHeaders() throws IOException {\r\n    try (TarArchiveInputStream archive = TarArchiveInputStream.builder().setURI(getURI(\"COMPRESS-530-fail.tar\")).get()) {\r\n        assertThrows(ArchiveException.class, () -> archive.getNextEntry());\r\n        // IOUtils.toByteArray(archive);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testPaxHeaderEntryWithEmptyValueRemovesKey",
  "sourceCode" : "@Test\r\nvoid testPaxHeaderEntryWithEmptyValueRemovesKey() throws Exception {\r\n    final Map<String, String> headers = TarUtils.parsePaxHeaders(new ByteArrayInputStream(\"11 foo=bar\\n7 foo=\\n\".getBytes(UTF_8)), null, new HashMap<>());\r\n    assertEquals(0, headers.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadLongNameHandlesLimits",
  "sourceCode" : "@ParameterizedTest(name = \"{0} long name is read correctly\")\r\n@MethodSource\r\nvoid testReadLongNameHandlesLimits(final String kind, final String expectedName, final byte[] data) throws IOException {\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"test\");\r\n    entry.setSize(data.length);\r\n    // Lets add a trailing \"garbage\" to ensure we only read what we should\r\n    final byte[] dataWithGarbage = Arrays.copyOf(data, data.length + 1024);\r\n    Arrays.fill(dataWithGarbage, data.length, dataWithGarbage.length, (byte) 0xFF);\r\n    try (InputStream in = new ByteArrayInputStream(dataWithGarbage)) {\r\n        final String actualName = TarUtils.readLongName(in, ZipEncodingHelper.getZipEncoding(UTF_8), entry);\r\n        assertEquals(expectedName, actualName, () -> String.format(\"[%s] The long name read does not match the expected value.\", kind));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadLongNameThrowsOnTruncation",
  "sourceCode" : "@ParameterizedTest(name = \"readLongName of {0} bytes throws ArchiveException\")\r\n@MethodSource\r\nvoid testReadLongNameThrowsOnTruncation(final long size, final CharSequence expectedMessage) throws IOException {\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"test\");\r\n    // absurdly large so any finite stream truncates\r\n    entry.setSize(size);\r\n    try (InputStream in = new NullInputStream()) {\r\n        final ArchiveException ex = assertThrows(ArchiveException.class, () -> TarUtils.readLongName(in, TarUtils.DEFAULT_ENCODING, entry), \"Expected ArchiveException due to truncated long name, but no exception was thrown\");\r\n        final String actualMessage = StringUtils.toRootLowerCase(ex.getMessage());\r\n        assertNotNull(actualMessage, \"Exception message should not be null\");\r\n        assertTrue(actualMessage.contains(expectedMessage), () -> \"Expected exception message to contain '\" + expectedMessage + \"', but got: \" + actualMessage);\r\n        assertTrue(actualMessage.contains(String.format(\"%,d\", size)), () -> \"Expected exception message to mention '\" + size + \"', but got: \" + actualMessage);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadNegativeBinary12Byte",
  "sourceCode" : "@Test\r\nvoid testReadNegativeBinary12Byte() {\r\n    final byte[] b = { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef };\r\n    assertEquals(-3601L, TarUtils.parseOctalOrBinary(b, 0, 12));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadNegativeBinary8Byte",
  "sourceCode" : "@Test\r\nvoid testReadNegativeBinary8Byte() {\r\n    final byte[] b = { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef };\r\n    assertEquals(-3601L, TarUtils.parseOctalOrBinary(b, 0, 8));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadNonAsciiPaxHeader",
  "sourceCode" : "@Test\r\nvoid testReadNonAsciiPaxHeader() throws Exception {\r\n    final String ae = \"\\u00e4\";\r\n    final String line = \"11 path=\" + ae + \"\\n\";\r\n    assertEquals(11, line.getBytes(UTF_8).length);\r\n    final Map<String, String> headers = TarUtils.parsePaxHeaders(new ByteArrayInputStream(line.getBytes(UTF_8)), null, new HashMap<>());\r\n    assertEquals(1, headers.size());\r\n    assertEquals(ae, headers.get(\"path\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadPax00SparseHeader",
  "sourceCode" : "@Test\r\nvoid testReadPax00SparseHeader() throws Exception {\r\n    final String header = \"23 GNU.sparse.offset=0\\n26 GNU.sparse.numbytes=10\\n\";\r\n    final List<TarArchiveStructSparse> sparseHeaders = new ArrayList<>();\r\n    TarUtils.parsePaxHeaders(new ByteArrayInputStream(header.getBytes(UTF_8)), sparseHeaders, Collections.emptyMap());\r\n    assertEquals(1, sparseHeaders.size());\r\n    assertEquals(0, sparseHeaders.get(0).getOffset());\r\n    assertEquals(10, sparseHeaders.get(0).getNumbytes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadPax00SparseHeaderMakesNumbytesOptional",
  "sourceCode" : "@Test\r\nvoid testReadPax00SparseHeaderMakesNumbytesOptional() throws Exception {\r\n    final String header = \"23 GNU.sparse.offset=0\\n24 GNU.sparse.offset=10\\n\";\r\n    final List<TarArchiveStructSparse> sparseHeaders = new ArrayList<>();\r\n    TarUtils.parsePaxHeaders(new ByteArrayInputStream(header.getBytes(UTF_8)), sparseHeaders, Collections.emptyMap());\r\n    assertEquals(2, sparseHeaders.size());\r\n    assertEquals(0, sparseHeaders.get(0).getOffset());\r\n    assertEquals(0, sparseHeaders.get(0).getNumbytes());\r\n    assertEquals(10, sparseHeaders.get(1).getOffset());\r\n    assertEquals(0, sparseHeaders.get(1).getNumbytes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadPax00SparseHeaderRejectsNegativeNumbytes",
  "sourceCode" : "@Test\r\nvoid testReadPax00SparseHeaderRejectsNegativeNumbytes() throws Exception {\r\n    final String header = \"23 GNU.sparse.offset=0\\n26 GNU.sparse.numbytes=-1\\n\";\r\n    assertThrows(ArchiveException.class, () -> TarUtils.parsePaxHeaders(new ByteArrayInputStream(header.getBytes(UTF_8)), null, Collections.emptyMap()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadPax00SparseHeaderRejectsNegativeOffset",
  "sourceCode" : "@Test\r\nvoid testReadPax00SparseHeaderRejectsNegativeOffset() throws Exception {\r\n    final String header = \"24 GNU.sparse.offset=-1\\n26 GNU.sparse.numbytes=10\\n\";\r\n    assertThrows(ArchiveException.class, () -> TarUtils.parsePaxHeaders(new ByteArrayInputStream(header.getBytes(UTF_8)), null, Collections.emptyMap()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadPax00SparseHeaderRejectsNonNumericNumbytes",
  "sourceCode" : "@Test\r\nvoid testReadPax00SparseHeaderRejectsNonNumericNumbytes() throws Exception {\r\n    final String header = \"23 GNU.sparse.offset=0\\n26 GNU.sparse.numbytes=1a\\n\";\r\n    assertThrows(IOException.class, () -> TarUtils.parsePaxHeaders(new ByteArrayInputStream(header.getBytes(UTF_8)), null, Collections.emptyMap()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadPax00SparseHeaderRejectsNonNumericOffset",
  "sourceCode" : "@Test\r\nvoid testReadPax00SparseHeaderRejectsNonNumericOffset() throws Exception {\r\n    final String header = \"23 GNU.sparse.offset=a\\n26 GNU.sparse.numbytes=10\\n\";\r\n    assertThrows(ArchiveException.class, () -> TarUtils.parsePaxHeaders(new ByteArrayInputStream(header.getBytes(UTF_8)), null, Collections.emptyMap()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadPaxHeaderWithEmbeddedNewline",
  "sourceCode" : "@Test\r\nvoid testReadPaxHeaderWithEmbeddedNewline() throws Exception {\r\n    final Map<String, String> headers = TarUtils.parsePaxHeaders(new ByteArrayInputStream(\"28 comment=line1\\nline2\\nand3\\n\".getBytes(UTF_8)), null, new HashMap<>());\r\n    assertEquals(1, headers.size());\r\n    assertEquals(\"line1\\nline2\\nand3\", headers.get(\"comment\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadPaxHeaderWithoutTrailingNewline",
  "sourceCode" : "@Test\r\nvoid testReadPaxHeaderWithoutTrailingNewline() throws Exception {\r\n    assertThrows(ArchiveException.class, () -> TarUtils.parsePaxHeaders(new ByteArrayInputStream(\"30 atime=1321711775.9720594634\".getBytes(UTF_8)), null, Collections.emptyMap()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadSimplePaxHeader",
  "sourceCode" : "@Test\r\nvoid testReadSimplePaxHeader() throws Exception {\r\n    final Map<String, String> headers = TarUtils.parsePaxHeaders(new ByteArrayInputStream(\"30 atime=1321711775.972059463\\n\".getBytes(UTF_8)), null, new HashMap<>());\r\n    assertEquals(1, headers.size());\r\n    assertEquals(\"1321711775.972059463\", headers.get(\"atime\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadSparseStructsBinary",
  "sourceCode" : "@Test\r\nvoid testReadSparseStructsBinary() throws Exception {\r\n    final byte[] header = { (byte) 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7 };\r\n    assertEquals(24, header.length);\r\n    final List<TarArchiveStructSparse> sparse = TarUtils.readSparseStructs(header, 0, 1);\r\n    assertEquals(1, sparse.size());\r\n    assertEquals(0, sparse.get(0).getOffset());\r\n    assertEquals(7, sparse.get(0).getNumbytes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadSparseStructsOctal",
  "sourceCode" : "@Test\r\nvoid testReadSparseStructsOctal() throws Exception {\r\n    final byte[] header = \"00000000000 00000000007 \".getBytes();\r\n    assertEquals(24, header.length);\r\n    final List<TarArchiveStructSparse> sparse = TarUtils.readSparseStructs(header, 0, 1);\r\n    assertEquals(1, sparse.size());\r\n    assertEquals(0, sparse.get(0).getOffset());\r\n    assertEquals(7, sparse.get(0).getNumbytes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadSparseStructsRejectsNegativeNumbytes",
  "sourceCode" : "@Test\r\nvoid testReadSparseStructsRejectsNegativeNumbytes() throws Exception {\r\n    final byte[] header = { (byte) 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff };\r\n    assertThrows(ArchiveException.class, () -> TarUtils.readSparseStructs(header, 0, 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadSparseStructsRejectsNegativeOffset",
  "sourceCode" : "@Test\r\nvoid testReadSparseStructsRejectsNegativeOffset() throws Exception {\r\n    final byte[] header = { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7 };\r\n    assertThrows(ArchiveException.class, () -> TarUtils.readSparseStructs(header, 0, 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadSparseStructsRejectsNonNumericNumbytes",
  "sourceCode" : "@Test\r\nvoid testReadSparseStructsRejectsNonNumericNumbytes() throws Exception {\r\n    final byte[] header = \"00000000000 0000000000x \".getBytes();\r\n    assertThrows(ArchiveException.class, () -> TarUtils.readSparseStructs(header, 0, 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testReadSparseStructsRejectsNonNumericOffset",
  "sourceCode" : "@Test\r\nvoid testReadSparseStructsRejectsNonNumericOffset() throws Exception {\r\n    final byte[] header = \"0000000000x 00000000007 \".getBytes();\r\n    assertThrows(ArchiveException.class, () -> TarUtils.readSparseStructs(header, 0, 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testRoundEncoding",
  "sourceCode" : "@Test\r\nvoid testRoundEncoding() throws Exception {\r\n    // COMPRESS-114\r\n    final ZipEncoding enc = ZipEncodingHelper.getZipEncoding(StandardCharsets.ISO_8859_1.name());\r\n    // @formatter:off\r\n    final String s = \"0302-0601-3\\u00b1\\u00b1\\u00b1F06\\u00b1W220\\u00b1ZB\\u00b1LALALA\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1CAN\" + \"\\u00b1\\u00b1DC\\u00b1\\u00b1\\u00b104\\u00b1060302\\u00b1MOE.model\";\r\n    // @formatter:on\r\n    final byte[] buff = new byte[100];\r\n    final int len = TarUtils.formatNameBytes(s, buff, 0, buff.length, enc);\r\n    assertEquals(s, TarUtils.parseName(buff, 0, len, enc));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testRoundTripNames",
  "sourceCode" : "@Test\r\nvoid testRoundTripNames() {\r\n    checkName(\"\");\r\n    checkName(\"The quick brown fox\\n\");\r\n    checkName(\"\\177\");\r\n    // checkName(\"\\0\"); // does not work, because NUL is ignored\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testRoundTripOctal",
  "sourceCode" : "@Test\r\nvoid testRoundTripOctal() {\r\n    checkRoundTripOctal(0);\r\n    checkRoundTripOctal(1);\r\n    //        checkRoundTripOctal(-1); // TODO What should this do?\r\n    checkRoundTripOctal(TarConstants.MAXSIZE);\r\n    //        checkRoundTripOctal(0100000000000L); // TODO What should this do?\r\n    checkRoundTripOctal(0, TarConstants.UIDLEN);\r\n    checkRoundTripOctal(1, TarConstants.UIDLEN);\r\n    checkRoundTripOctal(TarConstants.MAXID, 8);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testRoundTripOctalOrBinary12",
  "sourceCode" : "@Test\r\nvoid testRoundTripOctalOrBinary12() {\r\n    testRoundTripOctalOrBinary(12);\r\n    checkRoundTripOctalOrBinary(Long.MAX_VALUE, 12);\r\n    checkRoundTripOctalOrBinary(Long.MIN_VALUE + 1, 12);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testRoundTripOctalOrBinary8",
  "sourceCode" : "@Test\r\nvoid testRoundTripOctalOrBinary8() {\r\n    testRoundTripOctalOrBinary(8);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testRoundTripOctalOrBinary8_ValueTooBigForBinary",
  "sourceCode" : "@Test\r\nvoid testRoundTripOctalOrBinary8_ValueTooBigForBinary() {\r\n    final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> checkRoundTripOctalOrBinary(Long.MAX_VALUE, 8), \"Should throw exception - value is too long to fit buffer of this len\");\r\n    assertEquals(\"Value 9223372036854775807 is too large for 8 byte field.\", e.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testSecondEntryWinsWhenPaxHeaderContainsDuplicateKey",
  "sourceCode" : "@Test\r\nvoid testSecondEntryWinsWhenPaxHeaderContainsDuplicateKey() throws Exception {\r\n    final Map<String, String> headers = TarUtils.parsePaxHeaders(new ByteArrayInputStream(\"11 foo=bar\\n11 foo=baz\\n\".getBytes(UTF_8)), null, new HashMap<>());\r\n    assertEquals(1, headers.size());\r\n    assertEquals(\"baz\", headers.get(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testTrailers",
  "sourceCode" : "// Check correct trailing bytes are generated\r\n@Test\r\nvoid testTrailers() {\r\n    final byte[] buffer = new byte[12];\r\n    TarUtils.formatLongOctalBytes(123, buffer, 0, buffer.length);\r\n    assertEquals(' ', buffer[buffer.length - 1]);\r\n    // end of number\r\n    assertEquals('3', buffer[buffer.length - 2]);\r\n    TarUtils.formatOctalBytes(123, buffer, 0, buffer.length);\r\n    assertEquals(0, buffer[buffer.length - 1]);\r\n    assertEquals(' ', buffer[buffer.length - 2]);\r\n    // end of number\r\n    assertEquals('3', buffer[buffer.length - 3]);\r\n    TarUtils.formatCheckSumOctalBytes(123, buffer, 0, buffer.length);\r\n    assertEquals(' ', buffer[buffer.length - 1]);\r\n    assertEquals(0, buffer[buffer.length - 2]);\r\n    // end of number\r\n    assertEquals('3', buffer[buffer.length - 3]);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testVerifyHeaderCheckSum",
  "sourceCode" : "// https://issues.apache.org/jira/browse/COMPRESS-191\r\n@Test\r\nvoid testVerifyHeaderCheckSum() {\r\n    final byte[] valid = { // from bla.tar\r\n    116, 101, 115, 116, 49, 46, 120, 109, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 48, 54, 52, 52, 0, 48, 48, 48, 48, 55, 54, 53, 0, 48, 48, 48, 48, 55, 54, 53, 0, 48, 48, 48, 48, 48, 48, 48, 49, 49, 52, 50, 0, 49, 48, 55, 49, 54, 53, 52, 53, 54, 50, 54, 0, 48, 49, 50, 50, 54, 48, 0, 32, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 117, 115, 116, 97, 114, 32, 32, 0, 116, 99, 117, 114, 100, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 99, 117, 114, 100, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\n    assertTrue(TarUtils.verifyCheckSum(valid, false));\r\n    final byte[] compress117 = { // from COMPRESS-117\r\n    (byte) 0x37, (byte) 0x7a, (byte) 0x43, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x31, (byte) 0x30, (byte) 0x30, (byte) 0x37, (byte) 0x37, (byte) 0x37, (byte) 0x20, (byte) 0x00, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x30, (byte) 0x20, (byte) 0x00, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x30, (byte) 0x20, (byte) 0x00, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x31, (byte) 0x33, (byte) 0x30, (byte) 0x33, (byte) 0x33, (byte) 0x20, (byte) 0x31, (byte) 0x31, (byte) 0x31, (byte) 0x31, (byte) 0x35, (byte) 0x31, (byte) 0x36, (byte) 0x36, (byte) 0x30, (byte) 0x31, (byte) 0x36, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x35, (byte) 0x34, (byte) 0x31, (byte) 0x37, (byte) 0x20, (byte) 0x00, (byte) 0x30, (byte) 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\n    assertTrue(TarUtils.verifyCheckSum(compress117, false));\r\n    final byte[] invalid = { // from the testAIFF.aif file in Tika\r\n    70, 79, 82, 77, 0, 0, 15, 46, 65, 73, 70, 70, 67, 79, 77, 77, 0, 0, 0, 18, 0, 2, 0, 0, 3, -64, 0, 16, 64, 14, -84, 68, 0, 0, 0, 0, 0, 0, 83, 83, 78, 68, 0, 0, 15, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 0, 1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 0, 0, 0, 0, 0, 0, -1, -1, 0, 2, -1, -2, 0, 2, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 0, 0, -1, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 0, 1, -1, -2, 0, 1, -1, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, 0, 2, -1, -2, 0, 2, -1, -1, 0, 0, 0, 1, -1, -1, 0, 1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -2, 0, 2, -1, -2, 0, 1, 0, 0, 0, 1, -1, -1, 0, 0, 0, 1, -1, -1, 0, 0, 0, 1, -1, -2, 0, 2, -1, -1, 0, 0, 0, 0, 0, 0, -1, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, 0, 1, -1, -1, 0, 2, -1, -2, 0, 2, -1, -2, 0, 2, -1, -2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, -1, -2, 0, 2, -1, -2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, 0, 1, 0, 0, -1, -1, 0, 2, -1, -2, 0, 2, -1, -1, 0, 0, 0, 0, 0, 0, -1, -1, 0, 1, -1, -1, 0, 1, -1, -1, 0, 2, -1, -2, 0, 1, 0, 0, -1, -1, 0, 2, -1, -2, 0, 2, -1, -2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 0, 0, 0, 0, -1, -1, 0, 1, 0, 0, 0, 0, 0, 1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -2, 0, 2, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 0, 0, 0, 0, -1, -1, 0, 2, -1, -2, 0, 2, -1, -2, 0, 2, -1, -1, 0, 0, 0, 0, -1, -1, 0, 1, -1, -1, 0, 1, -1, -1, 0, 1, -1, -1, 0, 1, -1, -1, 0, 1, 0, 0, 0, 0, -1, -1, 0, 2, -1, -2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 0, 0, 0, 0, -1, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };\r\n    assertFalse(TarUtils.verifyCheckSum(invalid, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\tar\\TarUtilsTest.java",
  "methodName" : "testWriteNegativeBinary8Byte",
  "sourceCode" : "@Test\r\nvoid testWriteNegativeBinary8Byte() {\r\n    final byte[] b = { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef };\r\n    assertEquals(-3601L, TarUtils.parseOctalOrBinary(b, 0, 8));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testCOMPRESS114",
  "sourceCode" : "@Test\r\nvoid testCOMPRESS114() throws Exception {\r\n    try (TarArchiveInputStream in = TarArchiveInputStream.builder().setURI(getURI(\"COMPRESS-114.tar\")).setCharset(StandardCharsets.ISO_8859_1).get()) {\r\n        TarArchiveEntry entry = in.getNextEntry();\r\n        assertEquals(\"3\\u00b1\\u00b1\\u00b1F06\\u00b1W2345\\u00b1ZB\\u00b1la\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1BLA\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n        entry = in.getNextEntry();\r\n        assertEquals(\"0302-0601-3\\u00b1\\u00b1\\u00b1F06\\u00b1W2345\\u00b1ZB\\u00b1la\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1BLA\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testCOMPRESS178",
  "sourceCode" : "@Test\r\nvoid testCOMPRESS178() throws Exception {\r\n    final File input = getFile(\"COMPRESS-178-fail.tar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<?> in = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"tar\", is)) {\r\n        final IOException e = assertThrows(ArchiveException.class, in::getNextEntry, \"Expected IOException\");\r\n        final Throwable t = e.getCause();\r\n        assertInstanceOf(IllegalArgumentException.class, t, \"Expected cause = IllegalArgumentException\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testCOMPRESS178Lenient",
  "sourceCode" : "@Test\r\nvoid testCOMPRESS178Lenient() throws Exception {\r\n    try (ArchiveInputStream<?> in = TarArchiveInputStream.builder().setURI(getURI(\"COMPRESS-178-fail.tar\")).setLenient(true).get()) {\r\n        in.getNextEntry();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testDirectoryEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testDirectoryEntryFromFile() throws Exception {\r\n    final File archive = createTempFile(\"test.\", \".tar\");\r\n    final long beforeArchiveWrite;\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final File dir = getTempDirFile();\r\n        beforeArchiveWrite = dir.lastModified();\r\n        final TarArchiveEntry in = new TarArchiveEntry(dir, \"foo\");\r\n        tos.putArchiveEntry(in);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final TarArchiveEntry out;\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = tis.getNextTarEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo/\", out.getName());\r\n    assertEquals(TarConstants.LF_DIR, out.getLinkFlag());\r\n    assertEquals(0, out.getSize());\r\n    // TAR stores time with a granularity of 1 second\r\n    assertEquals(beforeArchiveWrite / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertTrue(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testDirectoryRead",
  "sourceCode" : "@Test\r\nvoid testDirectoryRead() throws IOException {\r\n    try (TarArchiveInputStream in = TarArchiveInputStream.builder().setURI(getURI(\"directory.tar\")).get()) {\r\n        final TarArchiveEntry directoryEntry = in.getNextTarEntry();\r\n        assertEquals(\"directory/\", directoryEntry.getName());\r\n        assertEquals(TarConstants.LF_DIR, directoryEntry.getLinkFlag());\r\n        assertTrue(directoryEntry.isDirectory());\r\n        final byte[] directoryRead = IOUtils.toByteArray(in);\r\n        assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, directoryRead);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testExplicitDirectoryEntry",
  "sourceCode" : "@Test\r\nvoid testExplicitDirectoryEntry() throws Exception {\r\n    final File archive = createTempFile(\"test.\", \".tar\");\r\n    final long beforeArchiveWrite;\r\n    final TarArchiveEntry in = new TarArchiveEntry(\"foo/\");\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        beforeArchiveWrite = getTempDirFile().lastModified();\r\n        in.setModTime(beforeArchiveWrite);\r\n        tos.putArchiveEntry(in);\r\n        tos.closeArchiveEntry();\r\n    }\r\n    final TarArchiveEntry out;\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = tis.getNextTarEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo/\", out.getName());\r\n    assertEquals(TarConstants.LF_DIR, in.getLinkFlag());\r\n    assertEquals(0, out.getSize());\r\n    assertEquals(beforeArchiveWrite / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertTrue(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testExplicitFileEntry",
  "sourceCode" : "@Test\r\nvoid testExplicitFileEntry() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".tar\");\r\n    try (TarArchiveOutputStream outputStream = new TarArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final TarArchiveEntry entryIn = new TarArchiveEntry(\"foo\");\r\n        entryIn.setModTime(file.lastModified());\r\n        entryIn.setSize(file.length());\r\n        outputStream.putArchiveEntry(entryIn);\r\n        outputStream.write(file);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    final TarArchiveEntry entryOut;\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setFile(archive).get()) {\r\n        entryOut = tis.getNextTarEntry();\r\n    }\r\n    assertNotNull(entryOut);\r\n    assertEquals(\"foo\", entryOut.getName());\r\n    assertEquals(TarConstants.LF_NORMAL, entryOut.getLinkFlag());\r\n    assertEquals(file.length(), entryOut.getSize());\r\n    assertEquals(file.lastModified() / 1000, entryOut.getLastModifiedDate().getTime() / 1000);\r\n    assertFalse(entryOut.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testFileEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testFileEntryFromFile() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".tar\");\r\n    final TarArchiveEntry in = new TarArchiveEntry(file, \"foo\");\r\n    try (TarArchiveOutputStream outputStream = new TarArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        outputStream.putArchiveEntry(in);\r\n        outputStream.write(file);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    final TarArchiveEntry out;\r\n    try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setFile(archive).get()) {\r\n        out = tis.getNextTarEntry();\r\n    }\r\n    assertNotNull(out);\r\n    assertEquals(\"foo\", out.getName());\r\n    assertEquals(TarConstants.LF_NORMAL, out.getLinkFlag());\r\n    assertEquals(file.length(), out.getSize());\r\n    assertEquals(file.lastModified() / 1000, out.getLastModifiedDate().getTime() / 1000);\r\n    assertFalse(out.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testLongNameLargerThanBuffer",
  "sourceCode" : "@Test\r\nvoid testLongNameLargerThanBuffer() throws IOException {\r\n    final List<Integer> nameLength = Arrays.asList(300, 4096);\r\n    for (final Integer length : nameLength) {\r\n        final String fileName = createLongName(length);\r\n        assertEquals(length.intValue(), fileName.length());\r\n        final byte[] data = createTarWithOneLongNameEntry(fileName);\r\n        try (TarArchiveInputStream tis = TarArchiveInputStream.builder().setByteArray(data).get()) {\r\n            assertEquals(fileName, tis.getNextTarEntry().getName());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarArchiveCreation",
  "sourceCode" : "@Test\r\nvoid testTarArchiveCreation() throws Exception {\r\n    final File output = newTempFile(\"bla.tar\");\r\n    final File file1 = getFile(\"test1.xml\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath());\r\n        TarArchiveOutputStream os = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"tar\", out)) {\r\n        final TarArchiveEntry entry = new TarArchiveEntry(\"testdata/test1.xml\");\r\n        entry.setModTime(0);\r\n        entry.setSize(file1.length());\r\n        entry.setUserId(0);\r\n        entry.setGroupId(0);\r\n        entry.setUserName(\"avalon\");\r\n        entry.setGroupName(\"excalibur\");\r\n        entry.setMode(0100000);\r\n        os.putArchiveEntry(entry);\r\n        os.write(file1);\r\n        os.closeArchiveEntry();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarArchiveLongNameCreation",
  "sourceCode" : "@Test\r\nvoid testTarArchiveLongNameCreation() throws Exception {\r\n    final String name = \"testdata/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456.xml\";\r\n    final byte[] bytes = name.getBytes(UTF_8);\r\n    assertEquals(bytes.length, 99);\r\n    final File output = newTempFile(\"bla.tar\");\r\n    final File file1 = getFile(\"test1.xml\");\r\n    final TarArchiveEntry entry = new TarArchiveEntry(name);\r\n    try (OutputStream out = Files.newOutputStream(output.toPath());\r\n        TarArchiveOutputStream os = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"tar\", out)) {\r\n        entry.setModTime(0);\r\n        entry.setSize(file1.length());\r\n        entry.setUserId(0);\r\n        entry.setGroupId(0);\r\n        entry.setUserName(\"avalon\");\r\n        entry.setGroupName(\"excalibur\");\r\n        entry.setMode(0100000);\r\n        os.putArchiveEntry(entry);\r\n        os.write(file1);\r\n        os.closeArchiveEntry();\r\n    }\r\n    final String toLongName = \"testdata/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567.xml\";\r\n    final File output2 = newTempFile(\"bla.tar\");\r\n    try (OutputStream out2 = Files.newOutputStream(output2.toPath());\r\n        TarArchiveOutputStream os2 = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"tar\", out2)) {\r\n        final TarArchiveEntry entry2 = new TarArchiveEntry(toLongName);\r\n        entry2.setModTime(0);\r\n        entry2.setSize(file1.length());\r\n        entry2.setUserId(0);\r\n        entry2.setGroupId(0);\r\n        entry2.setUserName(\"avalon\");\r\n        entry2.setGroupName(\"excalibur\");\r\n        entry2.setMode(0100000);\r\n        os2.putArchiveEntry(entry);\r\n        os2.write(file1);\r\n        os2.closeArchiveEntry();\r\n    } catch (final IOException e) {\r\n        assertTrue(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileCOMPRESS114",
  "sourceCode" : "@Test\r\nvoid testTarFileCOMPRESS114() throws Exception {\r\n    final File input = getFile(\"COMPRESS-114.tar\");\r\n    try (TarFile tarFile = new TarFile(input, StandardCharsets.ISO_8859_1.name())) {\r\n        final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n        TarArchiveEntry entry = entries.get(0);\r\n        assertEquals(\"3\\u00b1\\u00b1\\u00b1F06\\u00b1W2345\\u00b1ZB\\u00b1la\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1BLA\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n        entry = entries.get(1);\r\n        assertEquals(\"0302-0601-3\\u00b1\\u00b1\\u00b1F06\\u00b1W2345\\u00b1ZB\\u00b1la\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1BLA\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileCOMPRESS178",
  "sourceCode" : "@Test\r\nvoid testTarFileCOMPRESS178() throws Exception {\r\n    final File input = getFile(\"COMPRESS-178-fail.tar\");\r\n    final IOException e = assertThrows(ArchiveException.class, () -> {\r\n        try (TarFile tarFile = new TarFile(input)) {\r\n            // Compared to the TarArchiveInputStream all entries are read when instantiating the tar file\r\n        }\r\n    }, \"Expected IOException\");\r\n    final Throwable t = e.getCause();\r\n    assertInstanceOf(IllegalArgumentException.class, t, \"Expected cause = IllegalArgumentException\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileCOMPRESS178Lenient",
  "sourceCode" : "@Test\r\nvoid testTarFileCOMPRESS178Lenient() throws Exception {\r\n    final File input = getFile(\"COMPRESS-178-fail.tar\");\r\n    try (TarFile tarFile = new TarFile(input, true)) {\r\n        // Compared to the TarArchiveInputStream all entries are read when instantiating the tar file\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileDirectoryEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testTarFileDirectoryEntryFromFile() throws Exception {\r\n    final File archive = createTempFile(\"test.\", \".tar\");\r\n    final File dir = getTempDirFile();\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final long beforeArchiveWrite = dir.lastModified();\r\n        final TarArchiveEntry in = new TarArchiveEntry(dir, \"foo\");\r\n        tos.putArchiveEntry(in);\r\n        tos.closeArchiveEntry();\r\n        tos.close();\r\n        try (TarFile tarFile = new TarFile(archive)) {\r\n            final TarArchiveEntry entry = tarFile.getEntries().get(0);\r\n            assertNotNull(entry);\r\n            assertEquals(\"foo/\", entry.getName());\r\n            assertEquals(TarConstants.LF_DIR, entry.getLinkFlag());\r\n            assertEquals(0, entry.getSize());\r\n            // TAR stores time with a granularity of 1 second\r\n            assertEquals(beforeArchiveWrite / 1000, entry.getLastModifiedDate().getTime() / 1000);\r\n            assertTrue(entry.isDirectory());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileDirectoryRead",
  "sourceCode" : "@Test\r\nvoid testTarFileDirectoryRead() throws IOException {\r\n    final File input = getFile(\"directory.tar\");\r\n    try (TarFile tarFile = new TarFile(input)) {\r\n        final TarArchiveEntry directoryEntry = tarFile.getEntries().get(0);\r\n        assertEquals(\"directory/\", directoryEntry.getName());\r\n        assertEquals(TarConstants.LF_DIR, directoryEntry.getLinkFlag());\r\n        assertTrue(directoryEntry.isDirectory());\r\n        try (InputStream directoryStream = tarFile.getInputStream(directoryEntry)) {\r\n            final byte[] directoryRead = IOUtils.toByteArray(directoryStream);\r\n            assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, directoryRead);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testTarFileEntryFromFile() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".tar\");\r\n    try (TarArchiveOutputStream outputStream = new TarArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final TarArchiveEntry in = new TarArchiveEntry(file, \"foo\");\r\n        outputStream.putArchiveEntry(in);\r\n        outputStream.write(file);\r\n        outputStream.closeArchiveEntry();\r\n        outputStream.close();\r\n        try (TarFile tarFile = new TarFile(archive)) {\r\n            final TarArchiveEntry entry = tarFile.getEntries().get(0);\r\n            assertNotNull(entry);\r\n            assertEquals(\"foo\", entry.getName());\r\n            assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n            assertEquals(file.length(), entry.getSize());\r\n            assertEquals(file.lastModified() / 1000, entry.getLastModifiedDate().getTime() / 1000);\r\n            assertFalse(entry.isDirectory());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileExplicitDirectoryEntry",
  "sourceCode" : "@Test\r\nvoid testTarFileExplicitDirectoryEntry() throws Exception {\r\n    final File archive = createTempFile(\"test.\", \".tar\");\r\n    try (TarArchiveOutputStream tos = new TarArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final long beforeArchiveWrite = getTempDirFile().lastModified();\r\n        final TarArchiveEntry in = new TarArchiveEntry(\"foo/\");\r\n        in.setModTime(beforeArchiveWrite);\r\n        tos.putArchiveEntry(in);\r\n        tos.closeArchiveEntry();\r\n        tos.close();\r\n        try (TarFile tarFile = new TarFile(archive)) {\r\n            final TarArchiveEntry entry = tarFile.getEntries().get(0);\r\n            assertNotNull(entry);\r\n            assertEquals(\"foo/\", entry.getName());\r\n            assertEquals(TarConstants.LF_DIR, entry.getLinkFlag());\r\n            assertEquals(0, entry.getSize());\r\n            assertEquals(beforeArchiveWrite / 1000, entry.getLastModifiedDate().getTime() / 1000);\r\n            assertTrue(entry.isDirectory());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileExplicitFileEntry",
  "sourceCode" : "@Test\r\nvoid testTarFileExplicitFileEntry() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".tar\");\r\n    try (TarArchiveOutputStream outputStream = new TarArchiveOutputStream(Files.newOutputStream(archive.toPath()))) {\r\n        final TarArchiveEntry in = new TarArchiveEntry(\"foo\");\r\n        in.setModTime(file.lastModified());\r\n        in.setSize(file.length());\r\n        outputStream.putArchiveEntry(in);\r\n        outputStream.write(file);\r\n        outputStream.closeArchiveEntry();\r\n        try (TarFile tarFile = new TarFile(archive)) {\r\n            final TarArchiveEntry entry = tarFile.getEntries().get(0);\r\n            assertNotNull(entry);\r\n            assertEquals(\"foo\", entry.getName());\r\n            assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n            assertEquals(file.length(), entry.getSize());\r\n            assertEquals(file.lastModified() / 1000, entry.getLastModifiedDate().getTime() / 1000);\r\n            assertFalse(entry.isDirectory());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileLongNameLargerThanBuffer",
  "sourceCode" : "@Test\r\nvoid testTarFileLongNameLargerThanBuffer() throws IOException {\r\n    final List<Integer> nameLength = Arrays.asList(300, 4096);\r\n    for (final Integer length : nameLength) {\r\n        final String fileName = createLongName(length);\r\n        assertEquals(length.intValue(), fileName.length());\r\n        final byte[] data = createTarWithOneLongNameEntry(fileName);\r\n        try (TarFile tarFile = new TarFile(data)) {\r\n            final List<TarArchiveEntry> entries = tarFile.getEntries();\r\n            assertEquals(fileName, entries.get(0).getName());\r\n            assertEquals(TarConstants.LF_NORMAL, entries.get(0).getLinkFlag());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarFileUnarchive",
  "sourceCode" : "@Test\r\nvoid testTarFileUnarchive() throws Exception {\r\n    final File file = getFile(\"bla.tar\");\r\n    try (TarFile tarFile = new TarFile(file)) {\r\n        final TarArchiveEntry entry = tarFile.getEntries().get(0);\r\n        try (InputStream inputStream = tarFile.getInputStream(entry)) {\r\n            Files.copy(inputStream, newTempFile(entry.getName()).toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\TarTest.java",
  "methodName" : "testTarUnarchive",
  "sourceCode" : "@Test\r\nvoid testTarUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.tar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        TarArchiveInputStream in = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"tar\", is)) {\r\n        final TarArchiveEntry entry = in.getNextEntry();\r\n        Files.copy(in, newTempFile(entry.getName()).toPath());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\AsiExtraFieldTest.java",
  "methodName" : "testClone",
  "sourceCode" : "@Test\r\nvoid testClone() {\r\n    final AsiExtraField s1 = new AsiExtraField();\r\n    s1.setUserId(42);\r\n    s1.setGroupId(12);\r\n    s1.setLinkedFile(\"foo\");\r\n    s1.setMode(0644);\r\n    s1.setDirectory(true);\r\n    final AsiExtraField s2 = (AsiExtraField) s1.clone();\r\n    assertNotSame(s1, s2);\r\n    assertEquals(s1.getUserId(), s2.getUserId());\r\n    assertEquals(s1.getGroupId(), s2.getGroupId());\r\n    assertEquals(s1.getLinkedFile(), s2.getLinkedFile());\r\n    assertEquals(s1.getMode(), s2.getMode());\r\n    assertEquals(s1.isDirectory(), s2.isDirectory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\AsiExtraFieldTest.java",
  "methodName" : "testContent",
  "sourceCode" : "/**\r\n * Test content.\r\n */\r\n@Test\r\nvoid testContent() {\r\n    final AsiExtraField a = new AsiExtraField();\r\n    a.setMode(0123);\r\n    a.setUserId(5);\r\n    a.setGroupId(6);\r\n    byte[] b = a.getLocalFileDataData();\r\n    // CRC manually calculated, sorry\r\n    byte[] expect = { // CRC\r\n    (byte) 0xC6, // CRC\r\n    0x02, // CRC\r\n    0x78, // CRC\r\n    (byte) 0xB6, // mode\r\n    0123, // mode\r\n    (byte) 0x80, // link length\r\n    0, // link length\r\n    0, // link length\r\n    0, // link length\r\n    0, 5, 0, 6, // uid, gid\r\n    0 };\r\n    assertEquals(expect.length, b.length, \"no link\");\r\n    for (int i = 0; i < expect.length; i++) {\r\n        assertEquals(expect[i], b[i], \"no link, byte \" + i);\r\n    }\r\n    a.setLinkedFile(\"test\");\r\n    expect = new byte[] { // CRC\r\n    0x75, // CRC\r\n    (byte) 0x8E, // CRC\r\n    0x41, // CRC\r\n    (byte) 0xFD, // mode\r\n    0123, // mode\r\n    (byte) 0xA0, // link length\r\n    4, // link length\r\n    0, // link length\r\n    0, // link length\r\n    0, // uid, gid\r\n    5, // uid, gid\r\n    0, // uid, gid\r\n    6, // uid, gid\r\n    0, (byte) 't', (byte) 'e', (byte) 's', (byte) 't' };\r\n    b = a.getLocalFileDataData();\r\n    assertEquals(expect.length, b.length, \"no link\");\r\n    for (int i = 0; i < expect.length; i++) {\r\n        assertEquals(expect[i], b[i], \"no link, byte \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\AsiExtraFieldTest.java",
  "methodName" : "testModes",
  "sourceCode" : "/**\r\n * Test file mode magic.\r\n */\r\n@Test\r\nvoid testModes() {\r\n    final AsiExtraField a = new AsiExtraField();\r\n    a.setMode(0123);\r\n    assertEquals(0100123, a.getMode(), \"plain file\");\r\n    a.setDirectory(true);\r\n    assertEquals(040123, a.getMode(), \"directory\");\r\n    a.setLinkedFile(\"test\");\r\n    assertEquals(0120123, a.getMode(), \"symbolic link\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\AsiExtraFieldTest.java",
  "methodName" : "testReparse",
  "sourceCode" : "/**\r\n * Test reparse\r\n */\r\n@Test\r\nvoid testReparse() throws Exception {\r\n    // CRC manually calculated, sorry\r\n    final byte[] data1 = { // CRC\r\n    (byte) 0xC6, // CRC\r\n    0x02, // CRC\r\n    0x78, // CRC\r\n    (byte) 0xB6, // mode\r\n    0123, // mode\r\n    (byte) 0x80, // link length\r\n    0, // link length\r\n    0, // link length\r\n    0, // link length\r\n    0, 5, 0, 6, // uid, gid\r\n    0 };\r\n    final AsiExtraField a1 = new AsiExtraField();\r\n    a1.parseFromLocalFileData(data1, 0, data1.length);\r\n    assertEquals(data1.length, a1.getLocalFileDataLength().getValue(), \"length plain file\");\r\n    assertFalse(a1.isLink(), \"plain file, no link\");\r\n    assertFalse(a1.isDirectory(), \"plain file, no dir\");\r\n    assertEquals(FILE_FLAG | 0123, a1.getMode(), \"mode plain file\");\r\n    assertEquals(5, a1.getUserId(), \"uid plain file\");\r\n    assertEquals(6, a1.getGroupId(), \"gid plain file\");\r\n    final byte[] data2 = { // CRC\r\n    0x75, // CRC\r\n    (byte) 0x8E, // CRC\r\n    0x41, // CRC\r\n    (byte) 0xFD, // mode\r\n    0123, // mode\r\n    (byte) 0xA0, // link length\r\n    4, // link length\r\n    0, // link length\r\n    0, // link length\r\n    0, // uid, gid\r\n    5, // uid, gid\r\n    0, // uid, gid\r\n    6, // uid, gid\r\n    0, (byte) 't', (byte) 'e', (byte) 's', (byte) 't' };\r\n    final AsiExtraField a2 = new AsiExtraField();\r\n    a2.parseFromLocalFileData(data2, 0, data2.length);\r\n    assertEquals(data2.length, a2.getLocalFileDataLength().getValue(), \"length link\");\r\n    assertTrue(a2.isLink(), \"link, is link\");\r\n    assertFalse(a2.isDirectory(), \"link, no dir\");\r\n    assertEquals(LINK_FLAG | 0123, a2.getMode(), \"mode link\");\r\n    assertEquals(5, a2.getUserId(), \"uid link\");\r\n    assertEquals(6, a2.getGroupId(), \"gid link\");\r\n    assertEquals(\"test\", a2.getLinkedFile());\r\n    final byte[] data3 = { // CRC\r\n    (byte) 0x8E, // CRC\r\n    0x01, // CRC\r\n    (byte) 0xBF, // CRC\r\n    (byte) 0x0E, // mode\r\n    0123, // mode\r\n    (byte) 0x40, // link\r\n    0, // link\r\n    0, // link\r\n    0, // link\r\n    0, 5, 0, 6, // uid, gid\r\n    0 };\r\n    final AsiExtraField a3 = new AsiExtraField();\r\n    a3.parseFromLocalFileData(data3, 0, data3.length);\r\n    assertEquals(data3.length, a3.getLocalFileDataLength().getValue(), \"length dir\");\r\n    assertFalse(a3.isLink(), \"dir, no link\");\r\n    assertTrue(a3.isDirectory(), \"dir, is dir\");\r\n    assertEquals(DIR_FLAG | 0123, a3.getMode(), \"mode dir\");\r\n    assertEquals(5, a3.getUserId(), \"uid dir\");\r\n    assertEquals(6, a3.getGroupId(), \"gid dir\");\r\n    final byte[] data4 = { // bad CRC\r\n    0, // bad CRC\r\n    0, // bad CRC\r\n    0, // bad CRC\r\n    0, // mode\r\n    0123, // mode\r\n    (byte) 0x40, // link\r\n    0, // link\r\n    0, // link\r\n    0, // link\r\n    0, 5, 0, 6, // uid, gid\r\n    0 };\r\n    final AsiExtraField a4 = new AsiExtraField();\r\n    final Exception e = assertThrows(Exception.class, () -> a4.parseFromLocalFileData(data4, 0, data4.length), \"should raise bad CRC exception\");\r\n    assertEquals(\"Bad CRC checksum, expected 0 instead of ebf018e\", e.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\BinaryTreeTest.java",
  "methodName" : "testDecode",
  "sourceCode" : "@Test\r\nvoid testDecode() throws IOException {\r\n    final InputStream in = new ByteArrayInputStream(new byte[] { 0x02, 0x42, 0x01, 0x13 });\r\n    final BinaryTree tree = BinaryTree.decode(in, 8);\r\n    assertNotNull(tree);\r\n    try (BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0x8D, (byte) 0xC5, (byte) 0x11, 0x00 }))) {\r\n        assertEquals(0, tree.read(stream));\r\n        assertEquals(1, tree.read(stream));\r\n        assertEquals(2, tree.read(stream));\r\n        assertEquals(3, tree.read(stream));\r\n        assertEquals(4, tree.read(stream));\r\n        assertEquals(5, tree.read(stream));\r\n        assertEquals(6, tree.read(stream));\r\n        assertEquals(7, tree.read(stream));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\BinaryTreeTest.java",
  "methodName" : "testExceptions",
  "sourceCode" : "@Test\r\nvoid testExceptions() {\r\n    final BinaryTree binaryFinary = new BinaryTree(4);\r\n    binaryFinary.addLeaf(0, 0, 0, 1);\r\n    assertThrows(IllegalArgumentException.class, () -> binaryFinary.addLeaf(0, 0, 0, 1));\r\n    final InputStream is = new ByteArrayInputStream(new byte[] {});\r\n    assertThrows(ArchiveException.class, () -> BinaryTree.decode(is, 0));\r\n    assertThrows(ArchiveException.class, () -> new BinaryTree(4).read(new BitStream(new ByteArrayInputStream(new byte[] { 0 }))));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\BitStreamTest.java",
  "methodName" : "testNextByte",
  "sourceCode" : "@Test\r\nvoid testNextByte() throws Exception {\r\n    try (BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x35 }))) {\r\n        assertEquals(0, stream.readBit(), \"bit 0\");\r\n        assertEquals(1, stream.readBit(), \"bit 1\");\r\n        assertEquals(0, stream.readBit(), \"bit 2\");\r\n        assertEquals(1, stream.readBit(), \"bit 3\");\r\n        assertEquals(0x5E, stream.nextByte(), \"next byte\");\r\n        // not enough bits left to read a byte\r\n        assertEquals(-1, stream.nextByte(), \"next byte\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\BitStreamTest.java",
  "methodName" : "testNextByteFromEmptyStream",
  "sourceCode" : "@Test\r\nvoid testNextByteFromEmptyStream() throws Exception {\r\n    try (BitStream stream = new BitStream(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY))) {\r\n        assertEquals(-1, stream.nextByte(), \"next byte\");\r\n        assertEquals(-1, stream.nextByte(), \"next byte\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\BitStreamTest.java",
  "methodName" : "testReadAlignedBytes",
  "sourceCode" : "@Test\r\nvoid testReadAlignedBytes() throws Exception {\r\n    try (BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x35 }))) {\r\n        assertEquals(0xEA, stream.nextByte(), \"next byte\");\r\n        assertEquals(0x35, stream.nextByte(), \"next byte\");\r\n        assertEquals(-1, stream.nextByte(), \"next byte\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\CircularBufferTest.java",
  "methodName" : "testCopy",
  "sourceCode" : "@Test\r\nvoid testCopy() {\r\n    final CircularBuffer buffer = new CircularBuffer(16);\r\n    buffer.put(1);\r\n    buffer.put(2);\r\n    buffer.get();\r\n    buffer.get();\r\n    // copy uninitialized data\r\n    buffer.copy(6, 8);\r\n    for (int i = 2; i < 6; i++) {\r\n        assertEquals(0, buffer.get(), \"buffer[\" + i + \"]\");\r\n    }\r\n    assertEquals(1, buffer.get(), \"buffer[\" + 6 + \"]\");\r\n    assertEquals(2, buffer.get(), \"buffer[\" + 7 + \"]\");\r\n    assertEquals(0, buffer.get(), \"buffer[\" + 8 + \"]\");\r\n    assertEquals(0, buffer.get(), \"buffer[\" + 9 + \"]\");\r\n    for (int i = 10; i < 14; i++) {\r\n        buffer.put(i);\r\n        buffer.get();\r\n    }\r\n    assertFalse(buffer.available(), \"available\");\r\n    // copy data and wrap\r\n    buffer.copy(2, 8);\r\n    for (int i = 14; i < 18; i++) {\r\n        assertEquals(i % 2 == 0 ? 12 : 13, buffer.get(), \"buffer[\" + i + \"]\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\CircularBufferTest.java",
  "methodName" : "testPutAndGet",
  "sourceCode" : "@Test\r\nvoid testPutAndGet() {\r\n    final int size = 16;\r\n    final CircularBuffer buffer = new CircularBuffer(size);\r\n    for (int i = 0; i < size / 2; i++) {\r\n        buffer.put(i);\r\n    }\r\n    assertTrue(buffer.available(), \"available\");\r\n    for (int i = 0; i < size / 2; i++) {\r\n        assertEquals(i, buffer.get(), \"buffer[\" + i + \"]\");\r\n    }\r\n    assertEquals(-1, buffer.get());\r\n    assertFalse(buffer.available(), \"available\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Crash_f2efd9eaeb86cda597d07b5e3c3d81363633c2da_Test.java",
  "methodName" : "test",
  "sourceCode" : "@Test\r\nvoid test() throws IOException {\r\n    try (ZipArchiveInputStream zis = ZipArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/fuzz/crash-f2efd9eaeb86cda597d07b5e3c3d81363633c2da\")).get()) {\r\n        assertThrows(IOException.class, () -> {\r\n            for (; ; ) {\r\n                final ArchiveEntry zipEntry = zis.getNextEntry();\r\n                if (zipEntry == null) {\r\n                    break;\r\n                }\r\n                final long entrySize = zipEntry.getSize();\r\n                if (entrySize == -1) {\r\n                    IOUtils.toByteArray(zis);\r\n                } else {\r\n                    IOUtils.toByteArray(zis, entrySize);\r\n                }\r\n                // Eventually throws a NullPointerException\r\n                zis.getCompressedCount();\r\n            }\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\DataDescriptorTest.java",
  "methodName" : "testDoesntWriteDataDescriptorForDeflatedEntryOnSeekableOutput",
  "sourceCode" : "@Test\r\nvoid testDoesntWriteDataDescriptorForDeflatedEntryOnSeekableOutput() throws IOException {\r\n    final File file = new File(dir, \"test.zip\");\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(file)) {\r\n        zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\r\n        zos.writeUtf8(\"foo\");\r\n        zos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = Files.readAllBytes(file.toPath());\r\n    final byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\r\n    // still 2.0 because of Deflate\r\n    assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\r\n    final byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\r\n    // no DD but EFS flag\r\n    assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\r\n    final int cdhStart = findCentralDirectory(data);\r\n    final byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\r\n    assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\r\n    final byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\r\n    assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\r\n    final int ddStart = cdhStart - 16;\r\n    assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\r\n    final long crcFromLFH = ZipLong.getValue(data, 14);\r\n    final long cSizeFromLFH = ZipLong.getValue(data, 18);\r\n    final long sizeFromLFH = ZipLong.getValue(data, 22);\r\n    assertEquals(3, sizeFromLFH);\r\n    final long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\r\n    assertEquals(crcFromLFH, crcFromCDH);\r\n    final long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\r\n    assertEquals(cSizeFromLFH, cSizeFromCDH);\r\n    final long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\r\n    assertEquals(sizeFromLFH, sizeFromCDH);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\DataDescriptorTest.java",
  "methodName" : "testDoesntWriteDataDescriptorWhenAddingRawEntries",
  "sourceCode" : "@Test\r\nvoid testDoesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\r\n    final ByteArrayOutputStream init = new ByteArrayOutputStream();\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\r\n        zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\r\n        zos.writeUtf8(\"foo\");\r\n        zos.closeArchiveEntry();\r\n    }\r\n    final File f = new File(dir, \"test.zip\");\r\n    try (OutputStream fos = Files.newOutputStream(f.toPath())) {\r\n        fos.write(init.toByteArray());\r\n    }\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (ZipFile zf = ZipFile.builder().setFile(f).get();\r\n        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(baos)) {\r\n        final ZipArchiveEntry zae = zf.getEntry(\"test1.txt\");\r\n        try (InputStream rawInputStream = zf.getRawInputStream(zae)) {\r\n            zos.addRawArchiveEntry(zae, rawInputStream);\r\n        }\r\n    }\r\n    final byte[] data = baos.toByteArray();\r\n    final byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\r\n    // still 2.0 because of Deflate\r\n    assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\r\n    final byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\r\n    // no DD but EFS flag\r\n    assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\r\n    final int cdhStart = findCentralDirectory(data);\r\n    final byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\r\n    assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\r\n    final byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\r\n    assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\r\n    final int ddStart = cdhStart - 16;\r\n    assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\r\n    final long crcFromLFH = ZipLong.getValue(data, 14);\r\n    final long cSizeFromLFH = ZipLong.getValue(data, 18);\r\n    final long sizeFromLFH = ZipLong.getValue(data, 22);\r\n    assertEquals(3, sizeFromLFH);\r\n    final long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\r\n    assertEquals(crcFromLFH, crcFromCDH);\r\n    final long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\r\n    assertEquals(cSizeFromLFH, cSizeFromCDH);\r\n    final long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\r\n    assertEquals(sizeFromLFH, sizeFromCDH);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\DataDescriptorTest.java",
  "methodName" : "testWritesDataDescriptorForDeflatedEntryOnUnseekableOutput",
  "sourceCode" : "@Test\r\nvoid testWritesDataDescriptorForDeflatedEntryOnUnseekableOutput() throws IOException {\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(baos)) {\r\n        zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\r\n        zos.writeUtf8(\"foo\");\r\n        zos.closeArchiveEntry();\r\n    }\r\n    final byte[] data = baos.toByteArray();\r\n    final byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\r\n    // 2.0 because of DD\r\n    assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\r\n    final byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\r\n    // DD and EFS flags\r\n    assertArrayEquals(new byte[] { 8, 8 }, gpbInLFH);\r\n    final byte[] crcAndSizedInLFH = Arrays.copyOfRange(data, 14, 26);\r\n    assertArrayEquals(new byte[12], crcAndSizedInLFH);\r\n    final int cdhStart = findCentralDirectory(data);\r\n    final byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\r\n    assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\r\n    final byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\r\n    assertArrayEquals(new byte[] { 8, 8 }, gpbInCDH);\r\n    final int ddStart = cdhStart - 16;\r\n    assertEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\r\n    final long crcFromDD = ZipLong.getValue(data, ddStart + 4);\r\n    final long cSizeFromDD = ZipLong.getValue(data, ddStart + 8);\r\n    final long sizeFromDD = ZipLong.getValue(data, ddStart + 12);\r\n    assertEquals(3, sizeFromDD);\r\n    final long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\r\n    assertEquals(crcFromDD, crcFromCDH);\r\n    final long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\r\n    assertEquals(cSizeFromDD, cSizeFromCDH);\r\n    final long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\r\n    assertEquals(sizeFromDD, sizeFromCDH);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\EncryptedArchiveTest.java",
  "methodName" : "testReadPasswordEncryptedEntryViaStream",
  "sourceCode" : "@Test\r\nvoid testReadPasswordEncryptedEntryViaStream() throws IOException {\r\n    try (ZipArchiveInputStream zin = ZipArchiveInputStream.builder().setURI(getURI(\"password-encrypted.zip\")).get()) {\r\n        final ZipArchiveEntry zae = zin.getNextZipEntry();\r\n        assertEquals(\"LICENSE.txt\", zae.getName());\r\n        assertTrue(zae.getGeneralPurposeBit().usesEncryption());\r\n        assertFalse(zae.getGeneralPurposeBit().usesStrongEncryption());\r\n        assertFalse(zin.canReadEntryData(zae));\r\n        final UnsupportedZipFeatureException ex = assertThrows(UnsupportedZipFeatureException.class, () -> {\r\n            final byte[] buf = new byte[1024];\r\n            zin.read(buf, 0, buf.length);\r\n        }, \"expected an exception\");\r\n        assertSame(UnsupportedZipFeatureException.Feature.ENCRYPTION, ex.getFeature());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\EncryptedArchiveTest.java",
  "methodName" : "testReadPasswordEncryptedEntryViaZipFile",
  "sourceCode" : "@Test\r\nvoid testReadPasswordEncryptedEntryViaZipFile() throws IOException {\r\n    try (ZipFile zf = ZipFile.builder().setURI(getURI(\"password-encrypted.zip\")).get()) {\r\n        final ZipArchiveEntry zae = zf.getEntry(\"LICENSE.txt\");\r\n        assertTrue(zae.getGeneralPurposeBit().usesEncryption());\r\n        assertFalse(zae.getGeneralPurposeBit().usesStrongEncryption());\r\n        assertFalse(zf.canReadEntryData(zae));\r\n        final UnsupportedZipFeatureException ex = assertThrows(UnsupportedZipFeatureException.class, () -> zf.getInputStream(zae), \"expected an exception\");\r\n        assertSame(UnsupportedZipFeatureException.Feature.ENCRYPTION, ex.getFeature());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExplodeSupportTest.java",
  "methodName" : "testArchiveWithImplodeCompression4K2Trees",
  "sourceCode" : "@Test\r\nvoid testArchiveWithImplodeCompression4K2Trees() throws IOException {\r\n    testArchiveWithImplodeCompression(\"target/test-classes/imploding-4Kdict-2trees.zip\", \"HEADER.TXT\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExplodeSupportTest.java",
  "methodName" : "testArchiveWithImplodeCompression8K3Trees",
  "sourceCode" : "@Test\r\nvoid testArchiveWithImplodeCompression8K3Trees() throws IOException {\r\n    testArchiveWithImplodeCompression(\"target/test-classes/imploding-8Kdict-3trees.zip\", \"LICENSE.TXT\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExplodeSupportTest.java",
  "methodName" : "testConstructorThrowsExceptions",
  "sourceCode" : "@Test\r\nvoid testConstructorThrowsExceptions() {\r\n    assertThrows(IllegalArgumentException.class, () -> new ExplodingInputStream(4095, 2, new ByteArrayInputStream(new byte[] {})), \"should have failed with illegal argument exception\");\r\n    assertThrows(IllegalArgumentException.class, () -> new ExplodingInputStream(4096, 4, new ByteArrayInputStream(new byte[] {})), \"should have failed with illegal argument exception\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExplodeSupportTest.java",
  "methodName" : "testTikaTestArchive",
  "sourceCode" : "@Test\r\nvoid testTikaTestArchive() throws IOException {\r\n    testArchiveWithImplodeCompression(\"target/test-classes/moby-imploded.zip\", \"README\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExplodeSupportTest.java",
  "methodName" : "testTikaTestStream",
  "sourceCode" : "@Test\r\nvoid testTikaTestStream() throws IOException {\r\n    testZipStreamWithImplodeCompression(\"target/test-classes/moby-imploded.zip\", \"README\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExplodeSupportTest.java",
  "methodName" : "testZipStreamWithImplodeCompression4K2Trees",
  "sourceCode" : "@Test\r\nvoid testZipStreamWithImplodeCompression4K2Trees() throws IOException {\r\n    testZipStreamWithImplodeCompression(\"target/test-classes/imploding-4Kdict-2trees.zip\", \"HEADER.TXT\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExplodeSupportTest.java",
  "methodName" : "testZipStreamWithImplodeCompression8K3Trees",
  "sourceCode" : "@Test\r\nvoid testZipStreamWithImplodeCompression8K3Trees() throws IOException {\r\n    testZipStreamWithImplodeCompression(\"target/test-classes/imploding-8Kdict-3trees.zip\", \"LICENSE.TXT\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExtraFieldUtilsTest.java",
  "methodName" : "testMerge",
  "sourceCode" : "/**\r\n * Test merge methods\r\n */\r\n@Test\r\nvoid testMerge() {\r\n    final byte[] local = ExtraFieldUtils.mergeLocalFileDataData(new ZipExtraField[] { a, dummy });\r\n    assertEquals(data.length, local.length, \"local length\");\r\n    for (int i = 0; i < local.length; i++) {\r\n        assertEquals(data[i], local[i], \"local byte \" + i);\r\n    }\r\n    final byte[] dummyCentral = dummy.getCentralDirectoryData();\r\n    final byte[] data2 = new byte[4 + aLocal.length + 4 + dummyCentral.length];\r\n    System.arraycopy(data, 0, data2, 0, 4 + aLocal.length + 2);\r\n    System.arraycopy(dummy.getCentralDirectoryLength().getBytes(), 0, data2, 4 + aLocal.length + 2, 2);\r\n    System.arraycopy(dummyCentral, 0, data2, 4 + aLocal.length + 4, dummyCentral.length);\r\n    final byte[] central = ExtraFieldUtils.mergeCentralDirectoryData(new ZipExtraField[] { a, dummy });\r\n    assertEquals(data2.length, central.length, \"central length\");\r\n    for (int i = 0; i < central.length; i++) {\r\n        assertEquals(data2[i], central[i], \"central byte \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExtraFieldUtilsTest.java",
  "methodName" : "testMergeWithUnparseableData",
  "sourceCode" : "@Test\r\nvoid testMergeWithUnparseableData() throws Exception {\r\n    final ZipExtraField d = new UnparseableExtraFieldData();\r\n    final byte[] b = UNRECOGNIZED_HEADER.getBytes();\r\n    d.parseFromLocalFileData(new byte[] { b[0], b[1], 1, 0 }, 0, 4);\r\n    final byte[] local = ExtraFieldUtils.mergeLocalFileDataData(new ZipExtraField[] { a, d });\r\n    assertEquals(data.length - 1, local.length, \"local length\");\r\n    for (int i = 0; i < local.length; i++) {\r\n        assertEquals(data[i], local[i], \"local byte \" + i);\r\n    }\r\n    final byte[] dCentral = d.getCentralDirectoryData();\r\n    final byte[] data2 = new byte[4 + aLocal.length + dCentral.length];\r\n    System.arraycopy(data, 0, data2, 0, 4 + aLocal.length + 2);\r\n    System.arraycopy(dCentral, 0, data2, 4 + aLocal.length, dCentral.length);\r\n    final byte[] central = ExtraFieldUtils.mergeCentralDirectoryData(new ZipExtraField[] { a, d });\r\n    assertEquals(data2.length, central.length, \"central length\");\r\n    for (int i = 0; i < central.length; i++) {\r\n        assertEquals(data2[i], central[i], \"central byte \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExtraFieldUtilsTest.java",
  "methodName" : "testParse",
  "sourceCode" : "/**\r\n * test parser.\r\n */\r\n@Test\r\nvoid testParse() throws Exception {\r\n    final ZipExtraField[] ze = ExtraFieldUtils.parse(data);\r\n    assertEquals(2, ze.length, \"number of fields\");\r\n    assertTrue(ze[0] instanceof AsiExtraField, \"type field 1\");\r\n    assertEquals(040755, ((AsiExtraField) ze[0]).getMode(), \"mode field 1\");\r\n    assertTrue(ze[1] instanceof UnrecognizedExtraField, \"type field 2\");\r\n    assertEquals(1, ze[1].getLocalFileDataLength().getValue(), \"data length field 2\");\r\n    final byte[] data2 = new byte[data.length - 1];\r\n    System.arraycopy(data, 0, data2, 0, data2.length);\r\n    final Exception e = assertThrows(Exception.class, () -> ExtraFieldUtils.parse(data2), \"data should be invalid\");\r\n    assertEquals(\"Bad extra field starting at \" + (4 + aLocal.length) + \".  Block length of 1 bytes exceeds remaining data of 0 bytes.\", e.getMessage(), \"message\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExtraFieldUtilsTest.java",
  "methodName" : "testParseCentral",
  "sourceCode" : "@Test\r\nvoid testParseCentral() throws Exception {\r\n    final ZipExtraField[] ze = ExtraFieldUtils.parse(data, false);\r\n    assertEquals(2, ze.length, \"number of fields\");\r\n    assertTrue(ze[0] instanceof AsiExtraField, \"type field 1\");\r\n    assertEquals(040755, ((AsiExtraField) ze[0]).getMode(), \"mode field 1\");\r\n    assertTrue(ze[1] instanceof UnrecognizedExtraField, \"type field 2\");\r\n    assertEquals(1, ze[1].getCentralDirectoryLength().getValue(), \"data length field 2\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExtraFieldUtilsTest.java",
  "methodName" : "testParseTurnsArrayIndexOutOfBoundsIntoZipException",
  "sourceCode" : "@Test\r\nvoid testParseTurnsArrayIndexOutOfBoundsIntoZipException() {\r\n    ExtraFieldUtils.register(AiobThrowingExtraField.class);\r\n    final AiobThrowingExtraField f = new AiobThrowingExtraField();\r\n    final byte[] d = new byte[4 + AiobThrowingExtraField.LENGTH];\r\n    System.arraycopy(f.getHeaderId().getBytes(), 0, d, 0, 2);\r\n    System.arraycopy(f.getLocalFileDataLength().getBytes(), 0, d, 2, 2);\r\n    System.arraycopy(f.getLocalFileDataData(), 0, d, 4, AiobThrowingExtraField.LENGTH);\r\n    final ZipException e = assertThrows(ZipException.class, () -> ExtraFieldUtils.parse(d), \"data should be invalid\");\r\n    assertEquals(\"Failed to parse corrupt ZIP extra field of type 1000\", e.getMessage(), \"message\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExtraFieldUtilsTest.java",
  "methodName" : "testParseWithRead",
  "sourceCode" : "@Test\r\nvoid testParseWithRead() throws Exception {\r\n    ZipExtraField[] ze = ExtraFieldUtils.parse(data, true, ExtraFieldUtils.UnparseableExtraField.READ);\r\n    assertEquals(2, ze.length, \"number of fields\");\r\n    assertTrue(ze[0] instanceof AsiExtraField, \"type field 1\");\r\n    assertEquals(040755, ((AsiExtraField) ze[0]).getMode(), \"mode field 1\");\r\n    assertTrue(ze[1] instanceof UnrecognizedExtraField, \"type field 2\");\r\n    assertEquals(1, ze[1].getLocalFileDataLength().getValue(), \"data length field 2\");\r\n    final byte[] data2 = new byte[data.length - 1];\r\n    System.arraycopy(data, 0, data2, 0, data2.length);\r\n    ze = ExtraFieldUtils.parse(data2, true, ExtraFieldUtils.UnparseableExtraField.READ);\r\n    assertEquals(2, ze.length, \"number of fields\");\r\n    assertTrue(ze[0] instanceof AsiExtraField, \"type field 1\");\r\n    assertEquals(040755, ((AsiExtraField) ze[0]).getMode(), \"mode field 1\");\r\n    assertTrue(ze[1] instanceof UnparseableExtraFieldData, \"type field 2\");\r\n    assertEquals(4, ze[1].getLocalFileDataLength().getValue(), \"data length field 2\");\r\n    for (int i = 0; i < 4; i++) {\r\n        assertEquals(data2[data.length - 5 + i], ze[1].getLocalFileDataData()[i], \"byte number \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ExtraFieldUtilsTest.java",
  "methodName" : "testParseWithSkip",
  "sourceCode" : "@Test\r\nvoid testParseWithSkip() throws Exception {\r\n    ZipExtraField[] ze = ExtraFieldUtils.parse(data, true, ExtraFieldUtils.UnparseableExtraField.SKIP);\r\n    assertEquals(2, ze.length, \"number of fields\");\r\n    assertTrue(ze[0] instanceof AsiExtraField, \"type field 1\");\r\n    assertEquals(040755, ((AsiExtraField) ze[0]).getMode(), \"mode field 1\");\r\n    assertTrue(ze[1] instanceof UnrecognizedExtraField, \"type field 2\");\r\n    assertEquals(1, ze[1].getLocalFileDataLength().getValue(), \"data length field 2\");\r\n    final byte[] data2 = new byte[data.length - 1];\r\n    System.arraycopy(data, 0, data2, 0, data2.length);\r\n    ze = ExtraFieldUtils.parse(data2, true, ExtraFieldUtils.UnparseableExtraField.SKIP);\r\n    assertEquals(1, ze.length, \"number of fields\");\r\n    assertTrue(ze[0] instanceof AsiExtraField, \"type field 1\");\r\n    assertEquals(040755, ((AsiExtraField) ze[0]).getMode(), \"mode field 1\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\FileRandomAccessOutputStreamTest.java",
  "methodName" : "testChannelReturn",
  "sourceCode" : "@Test\r\nvoid testChannelReturn() throws IOException {\r\n    final Path file = newTempPath(\"testChannel\");\r\n    try (FileRandomAccessOutputStream stream = new FileRandomAccessOutputStream(file)) {\r\n        assertNotNull(stream.channel());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\FileRandomAccessOutputStreamTest.java",
  "methodName" : "testClose",
  "sourceCode" : "@Test\r\nvoid testClose() throws IOException {\r\n    final Path file = newTempPath(\"testChannel\");\r\n    try (FileRandomAccessOutputStream stream = new FileRandomAccessOutputStream(file)) {\r\n        assertNotNull(stream.channel());\r\n        stream.close();\r\n        stream.close();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\FileRandomAccessOutputStreamTest.java",
  "methodName" : "testWrite",
  "sourceCode" : "@Test\r\nvoid testWrite() throws IOException {\r\n    final FileChannel channel = mock(FileChannel.class);\r\n    final FileRandomAccessOutputStream stream = new FileRandomAccessOutputStream(channel);\r\n    when(channel.write((ByteBuffer) any())).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(5);\r\n        return 5;\r\n    }).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(6);\r\n        return 6;\r\n    });\r\n    stream.write(\"hello\".getBytes(StandardCharsets.UTF_8));\r\n    stream.write(\"world\\n\".getBytes(StandardCharsets.UTF_8));\r\n    verify(channel, times(2)).write((ByteBuffer) any());\r\n    assertEquals(11, stream.position());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\FileRandomAccessOutputStreamTest.java",
  "methodName" : "testWriteFullyAt_whenFullAtOnce_thenSucceed",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenFullAtOnce_thenSucceed() throws IOException {\r\n    final FileChannel channel = mock(FileChannel.class);\r\n    final FileRandomAccessOutputStream stream = new FileRandomAccessOutputStream(channel);\r\n    when(channel.write((ByteBuffer) any(), eq(20L))).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(5);\r\n        return 5;\r\n    });\r\n    when(channel.write((ByteBuffer) any(), eq(30L))).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(6);\r\n        return 6;\r\n    });\r\n    stream.writeAll(\"hello\".getBytes(StandardCharsets.UTF_8), 20);\r\n    stream.writeAll(\"world\\n\".getBytes(StandardCharsets.UTF_8), 30);\r\n    verify(channel, times(1)).write((ByteBuffer) any(), eq(20L));\r\n    verify(channel, times(1)).write((ByteBuffer) any(), eq(30L));\r\n    assertEquals(11, stream.position());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\FileRandomAccessOutputStreamTest.java",
  "methodName" : "testWriteFullyAt_whenFullButPartial_thenSucceed",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenFullButPartial_thenSucceed() throws IOException {\r\n    final FileChannel channel = mock(FileChannel.class);\r\n    final FileRandomAccessOutputStream stream = new FileRandomAccessOutputStream(channel);\r\n    when(channel.write((ByteBuffer) any(), eq(20L))).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(3);\r\n        return 3;\r\n    });\r\n    when(channel.write((ByteBuffer) any(), eq(23L))).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(5);\r\n        return 2;\r\n    });\r\n    when(channel.write((ByteBuffer) any(), eq(30L))).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(6);\r\n        return 6;\r\n    });\r\n    stream.writeAll(\"hello\".getBytes(StandardCharsets.UTF_8), 20);\r\n    stream.writeAll(\"world\\n\".getBytes(StandardCharsets.UTF_8), 30);\r\n    verify(channel, times(1)).write((ByteBuffer) any(), eq(20L));\r\n    verify(channel, times(1)).write((ByteBuffer) any(), eq(23L));\r\n    verify(channel, times(1)).write((ByteBuffer) any(), eq(30L));\r\n    assertEquals(11, stream.position());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\FileRandomAccessOutputStreamTest.java",
  "methodName" : "testWriteFullyAt_whenPartial_thenFail",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenPartial_thenFail() throws IOException {\r\n    final FileChannel channel = mock(FileChannel.class);\r\n    final FileRandomAccessOutputStream stream = new FileRandomAccessOutputStream(channel);\r\n    when(channel.write((ByteBuffer) any(), eq(20L))).thenAnswer(answer -> 0).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(3);\r\n        return 3;\r\n    });\r\n    when(channel.write((ByteBuffer) any(), eq(23L))).thenAnswer(answer -> -1);\r\n    assertThrows(ArchiveException.class, () -> stream.writeAll(\"hello\".getBytes(StandardCharsets.UTF_8), 20));\r\n    verify(channel, times(2)).write((ByteBuffer) any(), eq(20L));\r\n    verify(channel, times(1)).write((ByteBuffer) any(), eq(23L));\r\n    verify(channel, times(0)).write((ByteBuffer) any(), eq(25L));\r\n    assertEquals(0, stream.position());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\GeneralPurposeBitTest.java",
  "methodName" : "testClone",
  "sourceCode" : "@Test\r\nvoid testClone() {\r\n    final GeneralPurposeBit b = new GeneralPurposeBit();\r\n    b.useStrongEncryption(true);\r\n    b.useUTF8ForNames(true);\r\n    assertEquals(b, b.clone());\r\n    assertNotSame(b, b.clone());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\GeneralPurposeBitTest.java",
  "methodName" : "testDataDescriptor",
  "sourceCode" : "@Test\r\nvoid testDataDescriptor() {\r\n    final byte[] flags = { (byte) 8, (byte) 0 };\r\n    assertTrue(GeneralPurposeBit.parse(flags, 0).usesDataDescriptor());\r\n    final GeneralPurposeBit b = new GeneralPurposeBit();\r\n    b.useDataDescriptor(true);\r\n    assertArrayEquals(flags, b.encode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\GeneralPurposeBitTest.java",
  "methodName" : "testDefaults",
  "sourceCode" : "@Test\r\nvoid testDefaults() {\r\n    assertFalse(new GeneralPurposeBit().usesDataDescriptor());\r\n    assertFalse(new GeneralPurposeBit().usesUTF8ForNames());\r\n    assertFalse(new GeneralPurposeBit().usesEncryption());\r\n    assertFalse(new GeneralPurposeBit().usesStrongEncryption());\r\n    final byte[] b = new byte[2];\r\n    assertArrayEquals(b, new GeneralPurposeBit().encode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\GeneralPurposeBitTest.java",
  "methodName" : "testEncryption",
  "sourceCode" : "@Test\r\nvoid testEncryption() {\r\n    final byte[] flags = { (byte) 1, (byte) 0 };\r\n    assertTrue(GeneralPurposeBit.parse(flags, 0).usesEncryption());\r\n    final GeneralPurposeBit b = new GeneralPurposeBit();\r\n    b.useEncryption(true);\r\n    assertArrayEquals(flags, b.encode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\GeneralPurposeBitTest.java",
  "methodName" : "testLanguageEncodingFlag",
  "sourceCode" : "@Test\r\nvoid testLanguageEncodingFlag() {\r\n    final byte[] flags = { (byte) 0, (byte) 8 };\r\n    assertTrue(GeneralPurposeBit.parse(flags, 0).usesUTF8ForNames());\r\n    final GeneralPurposeBit b = new GeneralPurposeBit();\r\n    b.useUTF8ForNames(true);\r\n    assertArrayEquals(flags, b.encode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\GeneralPurposeBitTest.java",
  "methodName" : "testParseEdgeCases",
  "sourceCode" : "@Test\r\nvoid testParseEdgeCases() {\r\n    assertFalse(GeneralPurposeBit.parse(new byte[2], 0).usesDataDescriptor());\r\n    assertFalse(GeneralPurposeBit.parse(new byte[2], 0).usesUTF8ForNames());\r\n    assertFalse(GeneralPurposeBit.parse(new byte[2], 0).usesEncryption());\r\n    assertFalse(GeneralPurposeBit.parse(new byte[2], 0).usesStrongEncryption());\r\n    assertTrue(GeneralPurposeBit.parse(new byte[] { (byte) 255, (byte) 255 }, 0).usesDataDescriptor());\r\n    assertTrue(GeneralPurposeBit.parse(new byte[] { (byte) 255, (byte) 255 }, 0).usesUTF8ForNames());\r\n    assertTrue(GeneralPurposeBit.parse(new byte[] { (byte) 255, (byte) 255 }, 0).usesEncryption());\r\n    assertTrue(GeneralPurposeBit.parse(new byte[] { (byte) 255, (byte) 255 }, 0).usesStrongEncryption());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\GeneralPurposeBitTest.java",
  "methodName" : "testStrongEncryption",
  "sourceCode" : "@Test\r\nvoid testStrongEncryption() {\r\n    byte[] flags = { (byte) 65, (byte) 0 };\r\n    assertTrue(GeneralPurposeBit.parse(flags, 0).usesStrongEncryption());\r\n    final GeneralPurposeBit b = new GeneralPurposeBit();\r\n    b.useStrongEncryption(true);\r\n    assertTrue(b.usesEncryption());\r\n    assertArrayEquals(flags, b.encode());\r\n    flags = new byte[] { (byte) 64, (byte) 0 };\r\n    assertFalse(GeneralPurposeBit.parse(flags, 0).usesStrongEncryption());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Maven221MultiVolumeTest.java",
  "methodName" : "testRead7ZipMultiVolumeArchiveForFile",
  "sourceCode" : "@Test\r\nvoid testRead7ZipMultiVolumeArchiveForFile() {\r\n    assertThrows(IOException.class, () -> ZipFile.builder().setFile(getFile(\"apache-maven-2.2.1.zip.001\")).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Maven221MultiVolumeTest.java",
  "methodName" : "testRead7ZipMultiVolumeArchiveForStream",
  "sourceCode" : "@Test\r\nvoid testRead7ZipMultiVolumeArchiveForStream() throws IOException {\r\n    try (ZipArchiveInputStream zi = ZipArchiveInputStream.builder().setURI(getURI(\"apache-maven-2.2.1.zip.001\")).setUseUnicodeExtraFields(false).get()) {\r\n        // these are the entries that are supposed to be processed correctly without any problems.\r\n        for (final String element : ENTRIES) {\r\n            assertEquals(element, zi.getNextEntry().getName());\r\n        }\r\n        // this is the last entry that is truncated\r\n        final ArchiveEntry lastEntry = zi.getNextEntry();\r\n        assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\r\n        final byte[] buffer = new byte[4096];\r\n        // before the fix, we'd get 0 bytes on this read and all\r\n        // subsequent reads thus a client application might enter\r\n        // an infinite loop after the fix, we should get an exception.\r\n        final IOException e1 = assertThrows(ArchiveException.class, () -> {\r\n            while (zi.read(buffer) > 0) {\r\n                // empty\r\n            }\r\n        }, \"shouldn't be able to read from truncated entry\");\r\n        assertEquals(\"Truncated ZIP file\", e1.getMessage());\r\n        final IOException e2 = assertThrows(ArchiveException.class, () -> zi.read(buffer), \"shouldn't be able to read from truncated entry after exception\");\r\n        assertEquals(\"Truncated ZIP file\", e2.getMessage());\r\n        // and now we get another entry, which should also yield an exception.\r\n        assertThrows(IOException.class, zi::getNextEntry, \"shouldn't be able to read another entry from truncated file\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\NioZipEncodingTest.java",
  "methodName" : "testPartialSurrogatePair",
  "sourceCode" : "@Test\r\nvoid testPartialSurrogatePair() {\r\n    final NioZipEncoding e = new NioZipEncoding(US_ASCII);\r\n    final ByteBuffer bb = e.encode(\"\\ud83c\");\r\n    final int off = bb.arrayOffset();\r\n    final byte[] result = Arrays.copyOfRange(bb.array(), off, off + bb.limit() - bb.position());\r\n    assertEquals(0, result.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\NioZipEncodingTest.java",
  "methodName" : "testRainbowEmojiToSurrogatePairUTF16",
  "sourceCode" : "@Test\r\nvoid testRainbowEmojiToSurrogatePairUTF16() {\r\n    final NioZipEncoding e = new NioZipEncoding(UTF_16BE);\r\n    final ByteBuffer bb = e.encode(RAINBOW_EMOJI);\r\n    final int off = bb.arrayOffset();\r\n    final byte[] result = Arrays.copyOfRange(bb.array(), off, off + bb.limit() - bb.position());\r\n    assertArrayEquals(RAINBOW_EMOJI.getBytes(UTF_16BE), result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\NioZipEncodingTest.java",
  "methodName" : "testUmlautToISO88591",
  "sourceCode" : "@Test\r\nvoid testUmlautToISO88591() {\r\n    final NioZipEncoding e = new NioZipEncoding(ISO_8859_1);\r\n    final ByteBuffer bb = e.encode(\"\\u00e4\\u00f6\\u00fc\");\r\n    final int off = bb.arrayOffset();\r\n    final byte[] result = Arrays.copyOfRange(bb.array(), off, off + bb.limit() - bb.position());\r\n    assertArrayEquals(UMLAUTS.getBytes(ISO_8859_1), result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\NioZipEncodingTest.java",
  "methodName" : "testUmlautToUTF16BE",
  "sourceCode" : "@Test\r\nvoid testUmlautToUTF16BE() {\r\n    final NioZipEncoding e = new NioZipEncoding(UTF_16BE);\r\n    final ByteBuffer bb = e.encode(UMLAUTS);\r\n    final int off = bb.arrayOffset();\r\n    final byte[] result = Arrays.copyOfRange(bb.array(), off, off + bb.limit() - bb.position());\r\n    assertArrayEquals(UMLAUTS.getBytes(UTF_16BE), result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\NioZipEncodingTest.java",
  "methodName" : "testUmlautToUTF8",
  "sourceCode" : "@Test\r\nvoid testUmlautToUTF8() {\r\n    final NioZipEncoding e = new NioZipEncoding(UTF_8);\r\n    final ByteBuffer bb = e.encode(\"\\u00e4\\u00f6\\u00fc\");\r\n    final int off = bb.arrayOffset();\r\n    final byte[] result = Arrays.copyOfRange(bb.array(), off, off + bb.limit() - bb.position());\r\n    assertArrayEquals(UMLAUTS.getBytes(UTF_8), result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\NioZipEncodingTest.java",
  "methodName" : "testUnmappableRainbowEmoji",
  "sourceCode" : "@Test\r\nvoid testUnmappableRainbowEmoji() {\r\n    final NioZipEncoding e = new NioZipEncoding(US_ASCII);\r\n    final ByteBuffer bb = e.encode(RAINBOW_EMOJI);\r\n    final int off = bb.arrayOffset();\r\n    final byte[] result = Arrays.copyOfRange(bb.array(), off, off + bb.limit() - bb.position());\r\n    assertEquals(\"%UD83C%UDF08\", new String(result, US_ASCII));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\NioZipEncodingTest.java",
  "methodName" : "testUnmappableUmlauts",
  "sourceCode" : "@Test\r\nvoid testUnmappableUmlauts() {\r\n    final NioZipEncoding e = new NioZipEncoding(US_ASCII);\r\n    final ByteBuffer bb = e.encode(\"\\u00e4\\u00f6\\u00fc\");\r\n    final int off = bb.arrayOffset();\r\n    final byte[] result = Arrays.copyOfRange(bb.array(), off, off + bb.limit() - bb.position());\r\n    assertEquals(\"%U00E4%U00F6%U00FC\", new String(result, US_ASCII));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "sameZipArchiveEntryNullPointerException",
  "sourceCode" : "@Test\r\n@Disabled(\"[COMPRESS-639]\")\r\npublic void sameZipArchiveEntryNullPointerException() throws IOException, ExecutionException, InterruptedException {\r\n    final ByteArrayOutputStream testOutputStream = new ByteArrayOutputStream();\r\n    final String fileContent = \"A\";\r\n    final int NUM_OF_FILES = 100;\r\n    final LinkedList<InputStream> inputStreams = new LinkedList<>();\r\n    for (int i = 0; i < NUM_OF_FILES; i++) {\r\n        inputStreams.add(new ByteArrayInputStream(fileContent.getBytes(StandardCharsets.UTF_8)));\r\n    }\r\n    final ParallelScatterZipCreator zipCreator = new ParallelScatterZipCreator();\r\n    try (ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(testOutputStream)) {\r\n        zipArchiveOutputStream.setUseZip64(Zip64Mode.Always);\r\n        for (final InputStream inputStream : inputStreams) {\r\n            final ZipArchiveEntry zipArchiveEntry = new ZipArchiveEntry(\"./dir/myfile.txt\");\r\n            zipArchiveEntry.setMethod(ZipEntry.DEFLATED);\r\n            zipCreator.addArchiveEntry(zipArchiveEntry, () -> inputStream);\r\n        }\r\n        zipCreator.writeTo(zipArchiveOutputStream);\r\n    }\r\n    // Throws NullPointerException on close()\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "testCallableApiUsingSubmit",
  "sourceCode" : "@Test\r\nvoid testCallableApiUsingSubmit() throws Exception {\r\n    final File result = createTempFile(\"parallelScatterGather2\", \"\");\r\n    callableApi(zipCreator -> zipCreator::submit, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "testCallableApiUsingSubmitStreamAwareCallable",
  "sourceCode" : "@Test\r\nvoid testCallableApiUsingSubmitStreamAwareCallable() throws Exception {\r\n    final File result = createTempFile(\"parallelScatterGather3\", \"\");\r\n    callableApi(zipCreator -> zipCreator::submitStreamAwareCallable, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "testCallableApiWithHighestLevelUsingSubmitStreamAwareCallable",
  "sourceCode" : "@Test\r\nvoid testCallableApiWithHighestLevelUsingSubmitStreamAwareCallable() throws Exception {\r\n    final File result = createTempFile(\"parallelScatterGather5\", \"\");\r\n    callableApiWithTestFiles(zipCreator -> zipCreator::submitStreamAwareCallable, Deflater.BEST_COMPRESSION, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "testCallableWithLowestLevelApiUsingSubmit",
  "sourceCode" : "@Test\r\nvoid testCallableWithLowestLevelApiUsingSubmit() throws Exception {\r\n    final File result = createTempFile(\"parallelScatterGather4\", \"\");\r\n    callableApiWithTestFiles(zipCreator -> zipCreator::submit, Deflater.NO_COMPRESSION, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "testConcurrentCustomTempFolder",
  "sourceCode" : "@Test\r\nvoid testConcurrentCustomTempFolder() throws Exception {\r\n    final File result = createTempFile(\"parallelScatterGather1\", \"\");\r\n    final ParallelScatterZipCreator zipCreator;\r\n    final Map<String, byte[]> entries;\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(result)) {\r\n        zos.setEncoding(StandardCharsets.UTF_8.name());\r\n        // Formatter:off\r\n        final Path dir = Paths.get(\"target/custom-temp-dir\");\r\n        Files.createDirectories(dir);\r\n        zipCreator = new ParallelScatterZipCreator(Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()), new DefaultBackingStoreSupplier(dir));\r\n        // Formatter:on\r\n        entries = writeEntries(zipCreator);\r\n        zipCreator.writeTo(zos);\r\n    }\r\n    removeEntriesFoundInZipFile(result, entries);\r\n    assertTrue(entries.isEmpty());\r\n    assertNotNull(zipCreator.getStatisticsMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "testConcurrentDefaultTempFolder",
  "sourceCode" : "@Test\r\nvoid testConcurrentDefaultTempFolder() throws Exception {\r\n    final File result = createTempFile(\"parallelScatterGather1\", \"\");\r\n    final ParallelScatterZipCreator zipCreator;\r\n    final Map<String, byte[]> entries;\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(result)) {\r\n        zos.setEncoding(StandardCharsets.UTF_8.name());\r\n        zipCreator = new ParallelScatterZipCreator();\r\n        entries = writeEntries(zipCreator);\r\n        zipCreator.writeTo(zos);\r\n    }\r\n    removeEntriesFoundInZipFile(result, entries);\r\n    assertTrue(entries.isEmpty());\r\n    assertNotNull(zipCreator.getStatisticsMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "testThrowsExceptionWithCompressionLevelTooBig",
  "sourceCode" : "@Test\r\nvoid testThrowsExceptionWithCompressionLevelTooBig() {\r\n    final int compressLevelTooBig = Deflater.BEST_COMPRESSION + 1;\r\n    final ExecutorService es = Executors.newFixedThreadPool(1);\r\n    assertThrows(IllegalArgumentException.class, () -> new ParallelScatterZipCreator(es, () -> new FileBasedScatterGatherBackingStore(createTempFile(\"parallelscatter\", \"n1\")), compressLevelTooBig));\r\n    es.shutdownNow();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ParallelScatterZipCreatorTest.java",
  "methodName" : "testThrowsExceptionWithCompressionLevelTooSmall",
  "sourceCode" : "@Test\r\nvoid testThrowsExceptionWithCompressionLevelTooSmall() {\r\n    final int compressLevelTooSmall = Deflater.DEFAULT_COMPRESSION - 1;\r\n    final ExecutorService es = Executors.newFixedThreadPool(1);\r\n    assertThrows(IllegalArgumentException.class, () -> new ParallelScatterZipCreator(es, () -> new FileBasedScatterGatherBackingStore(createTempFile(\"parallelscatter\", \"n1\")), compressLevelTooSmall));\r\n    es.shutdownNow();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\PkWareExtraHeaderTest.java",
  "methodName" : "testEncryptionAlgorithm",
  "sourceCode" : "@Test\r\nvoid testEncryptionAlgorithm() {\r\n    final String name = \"AES256\";\r\n    final int code = EncryptionAlgorithm.AES256.getCode();\r\n    final EncryptionAlgorithm e = EncryptionAlgorithm.valueOf(name);\r\n    assertEquals(code, e.getCode());\r\n    assertNotNull(e);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\PkWareExtraHeaderTest.java",
  "methodName" : "testHashAlgorithm",
  "sourceCode" : "@Test\r\nvoid testHashAlgorithm() {\r\n    final String name = \"SHA256\";\r\n    final int code = HashAlgorithm.SHA256.getCode();\r\n    final HashAlgorithm e = HashAlgorithm.valueOf(name);\r\n    assertEquals(code, e.getCode());\r\n    assertNotNull(e);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\RandomAccessOutputStreamTest.java",
  "methodName" : "testWrite",
  "sourceCode" : "@Test\r\nvoid testWrite() throws IOException {\r\n    final RandomAccessOutputStream delegate = mock(RandomAccessOutputStream.class);\r\n    final RandomAccessOutputStream stream = new RandomAccessOutputStream() {\r\n\r\n        @Override\r\n        public long position() throws IOException {\r\n            return delegate.position();\r\n        }\r\n\r\n        @Override\r\n        public void write(final byte[] b, final int off, final int len) throws IOException {\r\n            delegate.write(b, off, len);\r\n        }\r\n\r\n        @Override\r\n        void writeAll(final byte[] b, final int off, final int len, final long position) throws IOException {\r\n            delegate.writeAll(b, off, len, position);\r\n        }\r\n    };\r\n    stream.write('\\n');\r\n    verify(delegate, times(1)).write(any(), eq(0), eq(1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ScatterSampleTest.java",
  "methodName" : "testSample",
  "sourceCode" : "@Test\r\nvoid testSample() throws Exception {\r\n    final File result = createTempFile(\"testSample\", \"fe\");\r\n    createFile(result);\r\n    checkFile(result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ScatterZipOutputStreamTest.java",
  "methodName" : "testPutArchiveEntry",
  "sourceCode" : "@Test\r\nvoid testPutArchiveEntry() throws Exception {\r\n    final File scatterFile = createTempFile(\"scattertest\", \".notzip\");\r\n    final File target = createTempFile(\"scattertest\", \".zip\");\r\n    final byte[] B_PAYLOAD = \"RBBBBBBS\".getBytes();\r\n    final byte[] A_PAYLOAD = \"XAAY\".getBytes();\r\n    try (ScatterZipOutputStream scatterZipOutputStream = ScatterZipOutputStream.fileBased(scatterFile)) {\r\n        final ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\r\n        zab.setMethod(ZipEntry.DEFLATED);\r\n        final ByteArrayInputStream payload = new ByteArrayInputStream(B_PAYLOAD);\r\n        scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zab, createPayloadSupplier(payload)));\r\n        final ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\r\n        zae.setMethod(ZipEntry.DEFLATED);\r\n        final ByteArrayInputStream payload1 = new ByteArrayInputStream(A_PAYLOAD);\r\n        scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zae, createPayloadSupplier(payload1)));\r\n        try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target)) {\r\n            scatterZipOutputStream.writeTo(outputStream);\r\n        }\r\n    }\r\n    try (ZipFile zf = ZipFile.builder().setFile(target).get()) {\r\n        final ZipArchiveEntry bEntry = zf.getEntries(\"b.txt\").iterator().next();\r\n        assertEquals(8, bEntry.getSize());\r\n        try (InputStream inputStream = zf.getInputStream(bEntry)) {\r\n            assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n        }\r\n        final ZipArchiveEntry aEntry = zf.getEntries(\"a.txt\").iterator().next();\r\n        assertEquals(4, aEntry.getSize());\r\n        try (InputStream inputStream = zf.getInputStream(aEntry)) {\r\n            assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\SeekableChannelRandomAccessOutputStreamTest.java",
  "methodName" : "testInitialization",
  "sourceCode" : "@Test\r\nvoid testInitialization() throws IOException {\r\n    final Path file = newTempPath(\"testChannel\");\r\n    try (SeekableChannelRandomAccessOutputStream stream = new SeekableChannelRandomAccessOutputStream(Files.newByteChannel(file, StandardOpenOption.CREATE, StandardOpenOption.WRITE))) {\r\n        assertEquals(0, stream.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\SeekableChannelRandomAccessOutputStreamTest.java",
  "methodName" : "testWrite",
  "sourceCode" : "@Test\r\nvoid testWrite() throws IOException {\r\n    final FileChannel channel = mock(FileChannel.class);\r\n    final SeekableChannelRandomAccessOutputStream stream = new SeekableChannelRandomAccessOutputStream(channel);\r\n    when(channel.position()).thenReturn(11L);\r\n    when(channel.write((ByteBuffer) any())).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(5);\r\n        return 5;\r\n    }).thenAnswer(answer -> {\r\n        ((ByteBuffer) answer.getArgument(0)).position(6);\r\n        return 6;\r\n    });\r\n    stream.write(\"hello\".getBytes(StandardCharsets.UTF_8));\r\n    stream.write(\"world\\n\".getBytes(StandardCharsets.UTF_8));\r\n    verify(channel, times(2)).write((ByteBuffer) any());\r\n    assertEquals(11, stream.position());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\SeekableChannelRandomAccessOutputStreamTest.java",
  "methodName" : "testWriteFullyAt_whenFullAtOnce_thenSucceed",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenFullAtOnce_thenSucceed() throws IOException {\r\n    try (SeekableByteChannel channel = mock(SeekableByteChannel.class);\r\n        SeekableChannelRandomAccessOutputStream stream = new SeekableChannelRandomAccessOutputStream(channel)) {\r\n        when(channel.position()).thenReturn(50L).thenReturn(60L);\r\n        when(channel.write((ByteBuffer) any())).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(5);\r\n            return 5;\r\n        }).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(6);\r\n            return 6;\r\n        });\r\n        stream.writeAll(\"hello\".getBytes(StandardCharsets.UTF_8), 20);\r\n        stream.writeAll(\"world\\n\".getBytes(StandardCharsets.UTF_8), 30);\r\n        verify(channel, times(2)).write((ByteBuffer) any());\r\n        verify(channel, times(1)).position(eq(50L));\r\n        verify(channel, times(1)).position(eq(60L));\r\n        assertEquals(60L, stream.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\SeekableChannelRandomAccessOutputStreamTest.java",
  "methodName" : "testWriteFullyAt_whenFullButPartial_thenSucceed",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenFullButPartial_thenSucceed() throws IOException {\r\n    try (SeekableByteChannel channel = mock(SeekableByteChannel.class);\r\n        SeekableChannelRandomAccessOutputStream stream = new SeekableChannelRandomAccessOutputStream(channel)) {\r\n        when(channel.position()).thenReturn(50L).thenReturn(60L);\r\n        when(channel.write((ByteBuffer) any())).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(3);\r\n            return 3;\r\n        }).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(5);\r\n            return 2;\r\n        }).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(6);\r\n            return 6;\r\n        });\r\n        stream.writeAll(\"hello\".getBytes(StandardCharsets.UTF_8), 20);\r\n        stream.writeAll(\"world\\n\".getBytes(StandardCharsets.UTF_8), 30);\r\n        verify(channel, times(3)).write((ByteBuffer) any());\r\n        verify(channel, times(1)).position(eq(50L));\r\n        verify(channel, times(1)).position(eq(60L));\r\n        assertEquals(60L, stream.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\SeekableChannelRandomAccessOutputStreamTest.java",
  "methodName" : "testWriteFullyAt_whenPartial_thenFail",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenPartial_thenFail() throws IOException {\r\n    try (SeekableByteChannel channel = mock(SeekableByteChannel.class);\r\n        SeekableChannelRandomAccessOutputStream stream = new SeekableChannelRandomAccessOutputStream(channel)) {\r\n        when(channel.position()).thenReturn(50L);\r\n        when(channel.write((ByteBuffer) any())).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(3);\r\n            return 3;\r\n        }).thenAnswer(answer -> 0).thenAnswer(answer -> -1);\r\n        assertThrows(ArchiveException.class, () -> stream.writeAll(\"hello\".getBytes(StandardCharsets.UTF_8), 20));\r\n        verify(channel, times(3)).write((ByteBuffer) any());\r\n        assertEquals(50L, stream.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\StreamCompressorTest.java",
  "methodName" : "testCreateDataOutputCompressor",
  "sourceCode" : "@Test\r\nvoid testCreateDataOutputCompressor() throws IOException {\r\n    final DataOutput dataOutputStream = new DataOutputStream(new ByteArrayOutputStream());\r\n    try (StreamCompressor streamCompressor = StreamCompressor.create(dataOutputStream, new Deflater(9))) {\r\n        assertNotNull(streamCompressor);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\StreamCompressorTest.java",
  "methodName" : "testDeflatedEntries",
  "sourceCode" : "@Test\r\nvoid testDeflatedEntries() throws Exception {\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (StreamCompressor sc = StreamCompressor.create(baos)) {\r\n        sc.deflate(new ByteArrayInputStream(\"AAAAAABBBBBB\".getBytes()), ZipEntry.DEFLATED);\r\n        assertEquals(12, sc.getBytesRead());\r\n        assertEquals(8, sc.getBytesWrittenForLastEntry());\r\n        assertEquals(3299542, sc.getCrc32());\r\n        final byte[] actuals = baos.toByteArray();\r\n        final byte[] expected = { 115, 116, 4, 1, 39, 48, 0, 0 };\r\n        // Note that this test really asserts stuff about the java Deflater, which might be a little bit brittle\r\n        assertArrayEquals(expected, actuals);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\StreamCompressorTest.java",
  "methodName" : "testStoredEntries",
  "sourceCode" : "@Test\r\nvoid testStoredEntries() throws Exception {\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (StreamCompressor sc = StreamCompressor.create(baos)) {\r\n        sc.deflate(new ByteArrayInputStream(\"A\".getBytes()), ZipEntry.STORED);\r\n        sc.deflate(new ByteArrayInputStream(\"BAD\".getBytes()), ZipEntry.STORED);\r\n        assertEquals(3, sc.getBytesRead());\r\n        assertEquals(3, sc.getBytesWrittenForLastEntry());\r\n        assertEquals(344750961, sc.getCrc32());\r\n        sc.deflate(new ByteArrayInputStream(\"CAFE\".getBytes()), ZipEntry.STORED);\r\n        assertEquals(\"ABADCAFE\", baos.toString());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testASCIIFileRoundtripExplicitUnicodeExtra",
  "sourceCode" : "@Test\r\nvoid testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException {\r\n    testFileRoundtrip(StandardCharsets.US_ASCII.name(), false, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testASCIIFileRoundtripImplicitUnicodeExtra",
  "sourceCode" : "@Test\r\nvoid testASCIIFileRoundtripImplicitUnicodeExtra() throws IOException {\r\n    testFileRoundtrip(StandardCharsets.US_ASCII.name(), false, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testCP437FileRoundtripExplicitUnicodeExtra",
  "sourceCode" : "@Test\r\nvoid testCP437FileRoundtripExplicitUnicodeExtra() throws IOException {\r\n    testFileRoundtrip(CP437, false, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testCP437FileRoundtripImplicitUnicodeExtra",
  "sourceCode" : "@Test\r\nvoid testCP437FileRoundtripImplicitUnicodeExtra() throws IOException {\r\n    testFileRoundtrip(CP437, false, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testRawNameReadFromStream",
  "sourceCode" : "@Test\r\nvoid testRawNameReadFromStream() throws IOException {\r\n    try (ZipArchiveInputStream zi = ZipArchiveInputStream.builder().setURI(getURI(\"utf8-7zip-test.zip\")).setCharset(CP437).setUseUnicodeExtraFields(false).get()) {\r\n        assertRawNameOfAcsiiTxt(zi.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testRawNameReadFromZipFile",
  "sourceCode" : "@Test\r\nvoid testRawNameReadFromZipFile() throws IOException {\r\n    final File archive = getFile(\"utf8-7zip-test.zip\");\r\n    try (ZipFile zf = ZipFile.builder().setFile(archive).setCharset(CP437).setUseUnicodeExtraFields(false).get()) {\r\n        assertRawNameOfAcsiiTxt(zf.getEntry(ASCII_TXT));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testRead7ZipArchive",
  "sourceCode" : "/*\r\n     * 7-ZIP created archive, uses EFS to signal UTF-8 file names.\r\n     *\r\n     * 7-ZIP doesn't use EFS for strings that can be encoded in CP437 - which is true for OIL_BARREL_TXT.\r\n     */\r\n@Test\r\nvoid testRead7ZipArchive() throws IOException {\r\n    final File archive = getFile(\"utf8-7zip-test.zip\");\r\n    try (ZipFile zf = new ZipFile(archive, CP437, false)) {\r\n        assertNotNull(zf.getEntry(ASCII_TXT));\r\n        assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\r\n        assertNotNull(zf.getEntry(OIL_BARREL_TXT));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testRead7ZipArchiveForStream",
  "sourceCode" : "@Test\r\nvoid testRead7ZipArchiveForStream() throws IOException {\r\n    try (ZipArchiveInputStream zi = ZipArchiveInputStream.builder().setURI(getURI(\"utf8-7zip-test.zip\")).setCharset(CP437).setUseUnicodeExtraFields(false).get()) {\r\n        assertEquals(ASCII_TXT, zi.getNextEntry().getName());\r\n        assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\r\n        assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testReadWinZipArchive",
  "sourceCode" : "/*\r\n     * WinZIP created archive, uses Unicode Extra Fields but only in the central directory.\r\n     */\r\n@Test\r\nvoid testReadWinZipArchive() throws IOException {\r\n    final File archive = getFile(\"utf8-winzip-test.zip\");\r\n    // fix for test fails on Windows with default charset that is not UTF-8\r\n    String encoding = null;\r\n    if (Charset.defaultCharset() != UTF_8) {\r\n        encoding = UTF_8.name();\r\n    }\r\n    try (ZipFile zf = ZipFile.builder().setFile(archive).setCharset(encoding).setUseUnicodeExtraFields(true).get()) {\r\n        assertCanRead(zf, ASCII_TXT);\r\n        assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\r\n        assertCanRead(zf, OIL_BARREL_TXT);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testReadWinZipArchiveForStream",
  "sourceCode" : "@Test\r\nvoid testReadWinZipArchiveForStream() throws IOException {\r\n    try (ZipArchiveInputStream zi = ZipArchiveInputStream.builder().setURI(getURI(\"utf8-winzip-test.zip\")).setCharset(UTF_8).get()) {\r\n        assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());\r\n        assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\r\n        assertEquals(ASCII_TXT, zi.getNextEntry().getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testStreamSkipsOverUnicodeExtraFieldWithUnsupportedVersion",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-479\">COMPRESS-479</a>\r\n */\r\n@Test\r\nvoid testStreamSkipsOverUnicodeExtraFieldWithUnsupportedVersion() throws IOException {\r\n    try (ZipArchiveInputStream zi = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-479.zip\")).get()) {\r\n        assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\r\n        assertEquals(\"%U20AC_for_Dollar.txt\", zi.getNextEntry().getName());\r\n        assertEquals(ASCII_TXT, zi.getNextEntry().getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testUtf8FileRoundtripExplicitUnicodeExtra",
  "sourceCode" : "@Test\r\nvoid testUtf8FileRoundtripExplicitUnicodeExtra() throws IOException {\r\n    testFileRoundtrip(StandardCharsets.UTF_8.name(), true, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testUtf8FileRoundtripImplicitUnicodeExtra",
  "sourceCode" : "@Test\r\nvoid testUtf8FileRoundtripImplicitUnicodeExtra() throws IOException {\r\n    testFileRoundtrip(StandardCharsets.UTF_8.name(), true, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testUtf8FileRoundtripNoEFSExplicitUnicodeExtra",
  "sourceCode" : "@Test\r\nvoid testUtf8FileRoundtripNoEFSExplicitUnicodeExtra() throws IOException {\r\n    testFileRoundtrip(StandardCharsets.UTF_8.name(), false, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testUtf8FileRoundtripNoEFSImplicitUnicodeExtra",
  "sourceCode" : "@Test\r\nvoid testUtf8FileRoundtripNoEFSImplicitUnicodeExtra() throws IOException {\r\n    testFileRoundtrip(StandardCharsets.UTF_8.name(), false, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testUtf8Interoperability",
  "sourceCode" : "@Test\r\nvoid testUtf8Interoperability() throws IOException {\r\n    final File file1 = getFile(\"utf8-7zip-test.zip\");\r\n    final File file2 = getFile(\"utf8-winzip-test.zip\");\r\n    testFile(file1, CP437);\r\n    testFile(file2, CP437);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testZipArchiveInputStreamReadsUnicodeFields",
  "sourceCode" : "@Test\r\nvoid testZipArchiveInputStreamReadsUnicodeFields() throws IOException {\r\n    final File file = createTempFile(\"unicode-test\", \".zip\");\r\n    createTestFile(file, StandardCharsets.US_ASCII.name(), false, true);\r\n    try (ZipFile zf = ZipFile.builder().setFile(file).setCharset(StandardCharsets.US_ASCII).setUseUnicodeExtraFields(true).get()) {\r\n        assertNotNull(zf.getEntry(ASCII_TXT));\r\n        assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\r\n        assertNotNull(zf.getEntry(OIL_BARREL_TXT));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testZipFileReadsUnicodeFields",
  "sourceCode" : "@Test\r\nvoid testZipFileReadsUnicodeFields() throws IOException {\r\n    final File file = createTempFile(\"unicode-test\", \".zip\");\r\n    createTestFile(file, StandardCharsets.US_ASCII.name(), false, true);\r\n    try (ZipArchiveInputStream zi = ZipArchiveInputStream.builder().setFile(file).setCharset(StandardCharsets.US_ASCII).get()) {\r\n        assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\r\n        assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());\r\n        assertEquals(ASCII_TXT, zi.getNextEntry().getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\UTF8ZipFilesTest.java",
  "methodName" : "testZipFileSkipsOverUnicodeExtraFieldWithUnsupportedVersion",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-479\">COMPRESS-479</a>\r\n */\r\n@Test\r\nvoid testZipFileSkipsOverUnicodeExtraFieldWithUnsupportedVersion() throws IOException {\r\n    try (ZipFile zf = ZipFile.builder().setFile(getFile(\"COMPRESS-479.zip\")).get()) {\r\n        assertNotNull(zf.getEntry(ASCII_TXT));\r\n        assertNotNull(zf.getEntry(\"%U20AC_for_Dollar.txt\"));\r\n        assertNotNull(zf.getEntry(OIL_BARREL_TXT));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X000A_NTFSTest.java",
  "methodName" : "testSimpleRoundtrip",
  "sourceCode" : "@Test\r\nvoid testSimpleRoundtrip() throws Exception {\r\n    final X000A_NTFS xf = new X000A_NTFS();\r\n    xf.setModifyJavaTime(new Date(0));\r\n    // one second past midnight\r\n    xf.setAccessJavaTime(new Date(-11644473601000L));\r\n    xf.setCreateJavaTime(null);\r\n    final byte[] b = xf.getLocalFileDataData();\r\n    final X000A_NTFS xf2 = new X000A_NTFS();\r\n    xf2.parseFromLocalFileData(b, 0, b.length);\r\n    assertEquals(new Date(0), xf2.getModifyJavaTime());\r\n    assertEquals(new Date(-11644473601000L), xf2.getAccessJavaTime());\r\n    assertNull(xf2.getCreateJavaTime());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X000A_NTFSTest.java",
  "methodName" : "testSimpleRoundtripWithHighPrecisionDatesWithBigValues",
  "sourceCode" : "@Test\r\nvoid testSimpleRoundtripWithHighPrecisionDatesWithBigValues() throws Exception {\r\n    final X000A_NTFS xf = new X000A_NTFS();\r\n    xf.setModifyFileTime(FileTime.from(Instant.ofEpochSecond(123456789101L, 123456700)));\r\n    // one second past midnight\r\n    xf.setAccessFileTime(FileTime.from(Instant.ofEpochSecond(-11644473601L)));\r\n    // 765432100ns past midnight\r\n    xf.setCreateFileTime(FileTime.from(Instant.ofEpochSecond(-11644473600L, 765432100)));\r\n    final byte[] b = xf.getLocalFileDataData();\r\n    final X000A_NTFS xf2 = new X000A_NTFS();\r\n    xf2.parseFromLocalFileData(b, 0, b.length);\r\n    assertEquals(FileTime.from(Instant.ofEpochSecond(123456789101L, 123456700)), xf2.getModifyFileTime());\r\n    assertEquals(new Date(123456789101123L), xf2.getModifyJavaTime());\r\n    assertEquals(FileTime.from(Instant.ofEpochSecond(-11644473601L)), xf2.getAccessFileTime());\r\n    assertEquals(new Date(-11644473601000L), xf2.getAccessJavaTime());\r\n    assertEquals(FileTime.from(Instant.ofEpochSecond(-11644473600L, 765432100)), xf2.getCreateFileTime());\r\n    assertEquals(new Date(-11644473599235L).toInstant(), xf2.getCreateJavaTime().toInstant());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X000A_NTFSTest.java",
  "methodName" : "testSimpleRoundtripWithHighPrecisionDatesWithSmallValues",
  "sourceCode" : "@Test\r\nvoid testSimpleRoundtripWithHighPrecisionDatesWithSmallValues() throws Exception {\r\n    final X000A_NTFS xf = new X000A_NTFS();\r\n    // The last 2 digits should not be written due to the 100ns precision\r\n    xf.setModifyFileTime(FileTime.from(Instant.ofEpochSecond(0, 1234)));\r\n    // one second past midnight\r\n    xf.setAccessFileTime(FileTime.from(Instant.ofEpochSecond(-11644473601L)));\r\n    xf.setCreateFileTime(null);\r\n    final byte[] b = xf.getLocalFileDataData();\r\n    final X000A_NTFS xf2 = new X000A_NTFS();\r\n    xf2.parseFromLocalFileData(b, 0, b.length);\r\n    assertEquals(FileTime.from(Instant.ofEpochSecond(0, 1200)), xf2.getModifyFileTime());\r\n    assertEquals(new Date(0), xf2.getModifyJavaTime());\r\n    assertEquals(FileTime.from(Instant.ofEpochSecond(-11644473601L)), xf2.getAccessFileTime());\r\n    assertEquals(new Date(-11644473601000L), xf2.getAccessJavaTime());\r\n    assertNull(xf2.getCreateFileTime());\r\n    assertNull(xf2.getCreateJavaTime());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X5455_ExtendedTimestampTest.java",
  "methodName" : "testBitsAreSetWithTime",
  "sourceCode" : "@Test\r\nvoid testBitsAreSetWithTime() {\r\n    xf.setModifyJavaTime(new Date(1111));\r\n    assertTrue(xf.isBit0_modifyTimePresent());\r\n    assertEquals(1, xf.getFlags());\r\n    xf.setAccessJavaTime(new Date(2222));\r\n    assertTrue(xf.isBit1_accessTimePresent());\r\n    assertEquals(3, xf.getFlags());\r\n    xf.setCreateJavaTime(new Date(3333));\r\n    assertTrue(xf.isBit2_createTimePresent());\r\n    assertEquals(7, xf.getFlags());\r\n    xf.setModifyJavaTime(null);\r\n    assertFalse(xf.isBit0_modifyTimePresent());\r\n    assertEquals(6, xf.getFlags());\r\n    xf.setAccessJavaTime(null);\r\n    assertFalse(xf.isBit1_accessTimePresent());\r\n    assertEquals(4, xf.getFlags());\r\n    xf.setCreateJavaTime(null);\r\n    assertFalse(xf.isBit2_createTimePresent());\r\n    assertEquals(0, xf.getFlags());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X5455_ExtendedTimestampTest.java",
  "methodName" : "testGetHeaderId",
  "sourceCode" : "@Test\r\nvoid testGetHeaderId() {\r\n    assertEquals(X5455, xf.getHeaderId());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X5455_ExtendedTimestampTest.java",
  "methodName" : "testGettersSetters",
  "sourceCode" : "@Test\r\nvoid testGettersSetters() {\r\n    // X5455 is concerned with time, so let's\r\n    // get a timestamp to play with (Jan 1st, 2000).\r\n    final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\r\n    cal.set(Calendar.YEAR, 2000);\r\n    cal.set(Calendar.MONTH, Calendar.JANUARY);\r\n    cal.set(Calendar.DATE, 1);\r\n    cal.set(Calendar.HOUR_OF_DAY, 0);\r\n    cal.set(Calendar.MINUTE, 0);\r\n    cal.set(Calendar.SECOND, 0);\r\n    cal.set(Calendar.MILLISECOND, 0);\r\n    final long timeMillis = cal.getTimeInMillis();\r\n    final ZipLong time = new ZipLong(timeMillis / 1000);\r\n    // set too big\r\n    // Java time is 1000 x larger (milliseconds).\r\n    assertThrows(IllegalArgumentException.class, () -> xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L))), \"Time too big for 32 bits!\");\r\n    // get/set modify time\r\n    xf.setModifyTime(time);\r\n    assertEquals(time, xf.getModifyTime());\r\n    assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getModifyFileTime().toMillis());\r\n    assertTrue(xf.isBit0_modifyTimePresent());\r\n    xf.setModifyJavaTime(new Date(timeMillis));\r\n    assertEquals(time, xf.getModifyTime());\r\n    assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getModifyFileTime().toMillis());\r\n    assertTrue(xf.isBit0_modifyTimePresent());\r\n    // Make sure milliseconds get zeroed out:\r\n    xf.setModifyJavaTime(new Date(timeMillis + 123));\r\n    assertEquals(time, xf.getModifyTime());\r\n    assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getModifyFileTime().toMillis());\r\n    assertTrue(xf.isBit0_modifyTimePresent());\r\n    // Make sure it works correctly for FileTime\r\n    xf.setModifyFileTime(FileTime.fromMillis(timeMillis + 123));\r\n    assertEquals(time, xf.getModifyTime());\r\n    assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getModifyFileTime().toMillis());\r\n    assertTrue(xf.isBit0_modifyTimePresent());\r\n    // Null\r\n    xf.setModifyTime(null);\r\n    assertNull(xf.getModifyJavaTime());\r\n    assertNull(xf.getModifyFileTime());\r\n    assertFalse(xf.isBit0_modifyTimePresent());\r\n    xf.setModifyJavaTime(null);\r\n    assertNull(xf.getModifyTime());\r\n    assertNull(xf.getModifyFileTime());\r\n    assertFalse(xf.isBit0_modifyTimePresent());\r\n    xf.setModifyFileTime(null);\r\n    assertNull(xf.getModifyJavaTime());\r\n    assertNull(xf.getModifyTime());\r\n    assertFalse(xf.isBit0_modifyTimePresent());\r\n    // get/set access time\r\n    xf.setAccessTime(time);\r\n    assertEquals(time, xf.getAccessTime());\r\n    assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getAccessFileTime().toMillis());\r\n    assertTrue(xf.isBit1_accessTimePresent());\r\n    xf.setAccessJavaTime(new Date(timeMillis));\r\n    assertEquals(time, xf.getAccessTime());\r\n    assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getAccessFileTime().toMillis());\r\n    assertTrue(xf.isBit1_accessTimePresent());\r\n    // Make sure milliseconds get zeroed out:\r\n    xf.setAccessJavaTime(new Date(timeMillis + 123));\r\n    assertEquals(time, xf.getAccessTime());\r\n    assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getAccessFileTime().toMillis());\r\n    assertTrue(xf.isBit1_accessTimePresent());\r\n    // Make sure it works correctly for FileTime\r\n    xf.setAccessFileTime(FileTime.fromMillis(timeMillis + 123));\r\n    assertEquals(time, xf.getAccessTime());\r\n    assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getAccessFileTime().toMillis());\r\n    assertTrue(xf.isBit1_accessTimePresent());\r\n    // Null\r\n    xf.setAccessTime(null);\r\n    assertNull(xf.getAccessJavaTime());\r\n    assertNull(xf.getAccessFileTime());\r\n    assertFalse(xf.isBit1_accessTimePresent());\r\n    xf.setAccessJavaTime(null);\r\n    assertNull(xf.getAccessTime());\r\n    assertNull(xf.getAccessFileTime());\r\n    assertFalse(xf.isBit1_accessTimePresent());\r\n    xf.setAccessFileTime(null);\r\n    assertNull(xf.getAccessJavaTime());\r\n    assertNull(xf.getAccessTime());\r\n    assertFalse(xf.isBit1_accessTimePresent());\r\n    // get/set create time\r\n    xf.setCreateTime(time);\r\n    assertEquals(time, xf.getCreateTime());\r\n    assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getCreateFileTime().toMillis());\r\n    assertTrue(xf.isBit2_createTimePresent());\r\n    xf.setCreateJavaTime(new Date(timeMillis));\r\n    assertEquals(time, xf.getCreateTime());\r\n    assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getCreateFileTime().toMillis());\r\n    assertTrue(xf.isBit2_createTimePresent());\r\n    // Make sure milliseconds get zeroed out:\r\n    xf.setCreateJavaTime(new Date(timeMillis + 123));\r\n    assertEquals(time, xf.getCreateTime());\r\n    assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getCreateFileTime().toMillis());\r\n    assertTrue(xf.isBit2_createTimePresent());\r\n    // Make sure it works correctly for FileTime\r\n    xf.setCreateFileTime(FileTime.fromMillis(timeMillis + 123));\r\n    assertEquals(time, xf.getCreateTime());\r\n    assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\r\n    assertEquals(timeMillis, xf.getCreateFileTime().toMillis());\r\n    assertTrue(xf.isBit2_createTimePresent());\r\n    // Null\r\n    xf.setCreateTime(null);\r\n    assertNull(xf.getCreateJavaTime());\r\n    assertNull(xf.getCreateFileTime());\r\n    assertFalse(xf.isBit2_createTimePresent());\r\n    xf.setCreateJavaTime(null);\r\n    assertNull(xf.getCreateTime());\r\n    assertNull(xf.getCreateFileTime());\r\n    assertFalse(xf.isBit2_createTimePresent());\r\n    xf.setCreateFileTime(null);\r\n    assertNull(xf.getCreateJavaTime());\r\n    assertNull(xf.getCreateTime());\r\n    assertFalse(xf.isBit2_createTimePresent());\r\n    // initialize for flags\r\n    xf.setModifyTime(time);\r\n    xf.setAccessTime(time);\r\n    xf.setCreateTime(time);\r\n    // get/set flags: 000\r\n    xf.setFlags((byte) 0);\r\n    assertEquals(0, xf.getFlags());\r\n    assertFalse(xf.isBit0_modifyTimePresent());\r\n    assertFalse(xf.isBit1_accessTimePresent());\r\n    assertFalse(xf.isBit2_createTimePresent());\r\n    // Local length=1, Central length=1 (flags only!)\r\n    assertEquals(1, xf.getLocalFileDataLength().getValue());\r\n    assertEquals(1, xf.getCentralDirectoryLength().getValue());\r\n    // get/set flags: 001\r\n    xf.setFlags((byte) 1);\r\n    assertEquals(1, xf.getFlags());\r\n    assertTrue(xf.isBit0_modifyTimePresent());\r\n    assertFalse(xf.isBit1_accessTimePresent());\r\n    assertFalse(xf.isBit2_createTimePresent());\r\n    // Local length=5, Central length=5 (flags + mod)\r\n    assertEquals(5, xf.getLocalFileDataLength().getValue());\r\n    assertEquals(5, xf.getCentralDirectoryLength().getValue());\r\n    // get/set flags: 010\r\n    xf.setFlags((byte) 2);\r\n    assertEquals(2, xf.getFlags());\r\n    assertFalse(xf.isBit0_modifyTimePresent());\r\n    assertTrue(xf.isBit1_accessTimePresent());\r\n    assertFalse(xf.isBit2_createTimePresent());\r\n    // Local length=5, Central length=1\r\n    assertEquals(5, xf.getLocalFileDataLength().getValue());\r\n    assertEquals(1, xf.getCentralDirectoryLength().getValue());\r\n    // get/set flags: 100\r\n    xf.setFlags((byte) 4);\r\n    assertEquals(4, xf.getFlags());\r\n    assertFalse(xf.isBit0_modifyTimePresent());\r\n    assertFalse(xf.isBit1_accessTimePresent());\r\n    assertTrue(xf.isBit2_createTimePresent());\r\n    // Local length=5, Central length=1\r\n    assertEquals(5, xf.getLocalFileDataLength().getValue());\r\n    assertEquals(1, xf.getCentralDirectoryLength().getValue());\r\n    // get/set flags: 111\r\n    xf.setFlags((byte) 7);\r\n    assertEquals(7, xf.getFlags());\r\n    assertTrue(xf.isBit0_modifyTimePresent());\r\n    assertTrue(xf.isBit1_accessTimePresent());\r\n    assertTrue(xf.isBit2_createTimePresent());\r\n    // Local length=13, Central length=5\r\n    assertEquals(13, xf.getLocalFileDataLength().getValue());\r\n    assertEquals(5, xf.getCentralDirectoryLength().getValue());\r\n    // get/set flags: 11111111\r\n    xf.setFlags((byte) -1);\r\n    assertEquals(-1, xf.getFlags());\r\n    assertTrue(xf.isBit0_modifyTimePresent());\r\n    assertTrue(xf.isBit1_accessTimePresent());\r\n    assertTrue(xf.isBit2_createTimePresent());\r\n    // Local length=13, Central length=5\r\n    assertEquals(13, xf.getLocalFileDataLength().getValue());\r\n    assertEquals(5, xf.getCentralDirectoryLength().getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X5455_ExtendedTimestampTest.java",
  "methodName" : "testMisc",
  "sourceCode" : "@Test\r\nvoid testMisc() throws Exception {\r\n    assertNotEquals(xf, new Object());\r\n    assertTrue(xf.toString().startsWith(\"0x5455 Zip Extra Field\"));\r\n    assertFalse(xf.toString().contains(\" Modify:\"));\r\n    assertFalse(xf.toString().contains(\" Access:\"));\r\n    assertFalse(xf.toString().contains(\" Create:\"));\r\n    Object o = xf.clone();\r\n    assertEquals(o.hashCode(), xf.hashCode());\r\n    assertEquals(xf, o);\r\n    xf.setModifyJavaTime(new Date(1111));\r\n    xf.setAccessJavaTime(new Date(2222));\r\n    xf.setCreateJavaTime(new Date(3333));\r\n    xf.setFlags((byte) 7);\r\n    assertNotEquals(xf, o);\r\n    assertTrue(xf.toString().startsWith(\"0x5455 Zip Extra Field\"));\r\n    assertTrue(xf.toString().contains(\" Modify:\"));\r\n    assertTrue(xf.toString().contains(\" Access:\"));\r\n    assertTrue(xf.toString().contains(\" Create:\"));\r\n    o = xf.clone();\r\n    assertEquals(o.hashCode(), xf.hashCode());\r\n    assertEquals(xf, o);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X5455_ExtendedTimestampTest.java",
  "methodName" : "testParseReparse",
  "sourceCode" : "@Test\r\nvoid testParseReparse() throws ZipException {\r\n    /*\r\n         * Recall the spec:\r\n         *\r\n         * 0x5455 Short tag for this extra block type (\"UT\") TSize Short total data size for this block Flags Byte info bits (ModTime) Long time of last\r\n         * modification (UTC/GMT) (AcTime) Long time of last access (UTC/GMT) (CrTime) Long time of original creation (UTC/GMT)\r\n         */\r\n    final byte[] NULL_FLAGS = { 0 };\r\n    // central data only contains the AC flag and no actual data\r\n    final byte[] AC_CENTRAL = { 2 };\r\n    // central data only contains the CR flag and no actual data\r\n    final byte[] CR_CENTRAL = { 4 };\r\n    final byte[] MOD_ZERO = { 1, 0, 0, 0, 0 };\r\n    final byte[] MOD_MAX = { 1, -1, -1, -1, 0x7f };\r\n    final byte[] AC_ZERO = { 2, 0, 0, 0, 0 };\r\n    final byte[] AC_MAX = { 2, -1, -1, -1, 0x7f };\r\n    final byte[] CR_ZERO = { 4, 0, 0, 0, 0 };\r\n    final byte[] CR_MAX = { 4, -1, -1, -1, 0x7f };\r\n    final byte[] MOD_AC_ZERO = { 3, 0, 0, 0, 0, 0, 0, 0, 0 };\r\n    final byte[] MOD_AC_MAX = { 3, -1, -1, -1, 0x7f, -1, -1, -1, 0x7f };\r\n    final byte[] MOD_AC_CR_ZERO = { 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\n    final byte[] MOD_AC_CR_MAX = { 7, -1, -1, -1, 0x7f, -1, -1, -1, 0x7f, -1, -1, -1, 0x7f };\r\n    parseReparse(null, NULL_FLAGS, NULL_FLAGS);\r\n    parseReparse(ZERO_TIME, MOD_ZERO, MOD_ZERO);\r\n    parseReparse(MAX_TIME_SECONDS, MOD_MAX, MOD_MAX);\r\n    parseReparse(ZERO_TIME, AC_ZERO, AC_CENTRAL);\r\n    parseReparse(MAX_TIME_SECONDS, AC_MAX, AC_CENTRAL);\r\n    parseReparse(ZERO_TIME, CR_ZERO, CR_CENTRAL);\r\n    parseReparse(MAX_TIME_SECONDS, CR_MAX, CR_CENTRAL);\r\n    parseReparse(ZERO_TIME, MOD_AC_ZERO, MOD_ZERO);\r\n    parseReparse(MAX_TIME_SECONDS, MOD_AC_MAX, MOD_MAX);\r\n    parseReparse(ZERO_TIME, MOD_AC_CR_ZERO, MOD_ZERO);\r\n    parseReparse(MAX_TIME_SECONDS, MOD_AC_CR_MAX, MOD_MAX);\r\n    // As far as the spec is concerned (December 2012) all of these flags\r\n    // are spurious versions of 7 (a.k.a. binary 00000111).\r\n    parseReparse((byte) 15, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\r\n    parseReparse((byte) 31, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\r\n    parseReparse((byte) 63, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\r\n    parseReparse((byte) 71, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\r\n    parseReparse((byte) 127, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\r\n    parseReparse((byte) -1, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X5455_ExtendedTimestampTest.java",
  "methodName" : "testResetsFlagsWhenLocalFileArrayIsTooShort",
  "sourceCode" : "@Test\r\nvoid testResetsFlagsWhenLocalFileArrayIsTooShort() throws Exception {\r\n    // claims all three time values would be present, but they are not\r\n    final byte[] local = { 7 };\r\n    xf.parseFromLocalFileData(local, 0, 1);\r\n    assertArrayEquals(new byte[1], xf.getLocalFileDataData());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X5455_ExtendedTimestampTest.java",
  "methodName" : "testSampleFile",
  "sourceCode" : "@Test\r\nvoid testSampleFile() throws Exception {\r\n    /*\r\n         * Contains entries with zipTime, accessTime, and modifyTime. The file name tells you the year we tried to set the time to (Jan 1st, Midnight, UTC).\r\n         *\r\n         * For example:\r\n         *\r\n         * COMPRESS-210_unix_time_zip_test/1999 COMPRESS-210_unix_time_zip_test/2000 COMPRESS-210_unix_time_zip_test/2108\r\n         *\r\n         * File's last-modified is 1st second after midnight. Zip-time's 2-second granularity rounds that up to 2nd second. File's last-access is 3rd second\r\n         * after midnight.\r\n         *\r\n         * So, from example above:\r\n         *\r\n         * 1999's zip time: Jan 1st, 1999-01-01/00:00:02 1999's mod time: Jan 1st, 1999-01-01/00:00:01 1999's acc time: Jan 1st, 1999-01-01/00:00:03\r\n         *\r\n         * Starting with a patch release of Java8, \"zip time\" actually uses the extended time stamp field itself and should be the same as \"mod time\".\r\n         * https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/90df6756406f\r\n         *\r\n         * Starting with Java9 the parser for extended time stamps has been fixed to use signed integers which was detected during the triage of COMPRESS-416.\r\n         * Signed integers is the correct format and Compress 1.15 has started to use signed integers as well.\r\n         */\r\n    final File archive = AbstractTest.getFile(\"COMPRESS-210_unix_time_zip_test.zip\");\r\n    try (ZipFile zipFile = ZipFile.builder().setFile(archive).get()) {\r\n        final Enumeration<ZipArchiveEntry> en = zipFile.getEntries();\r\n        // We expect EVERY entry of this ZIP file\r\n        // to contain extra field 0x5455.\r\n        while (en.hasMoreElements()) {\r\n            final ZipArchiveEntry zae = en.nextElement();\r\n            if (zae.isDirectory()) {\r\n                continue;\r\n            }\r\n            final String name = zae.getName();\r\n            final int x = name.lastIndexOf('/');\r\n            final String yearString = name.substring(x + 1);\r\n            final int year;\r\n            try {\r\n                year = Integer.parseInt(yearString);\r\n            } catch (final NumberFormatException nfe) {\r\n                // setTime.sh, skip\r\n                continue;\r\n            }\r\n            final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) zae.getExtraField(X5455);\r\n            final Date rawZ = zae.getLastModifiedDate();\r\n            final Date m = xf.getModifyJavaTime();\r\n            /*\r\n                 * We must distinguish three cases: - Java has read the extended time field itself and agrees with us (Java9 or Java8 and years prior to 2038) -\r\n                 * Java has read the extended time field but found a year >= 2038 (Java8) - Java hasn't read the extended time field at all (Java7- or early\r\n                 * Java8)\r\n                 */\r\n            final boolean zipTimeUsesExtendedTimestampCorrectly = rawZ.equals(m);\r\n            final boolean zipTimeUsesExtendedTimestampButUnsigned = year > 2037 && rawZ.getSeconds() == 1;\r\n            final boolean zipTimeUsesExtendedTimestamp = zipTimeUsesExtendedTimestampCorrectly || zipTimeUsesExtendedTimestampButUnsigned;\r\n            final Date z = zipTimeUsesExtendedTimestamp ? rawZ : adjustFromGMTToExpectedOffset(rawZ);\r\n            final Date a = xf.getAccessJavaTime();\r\n            final String zipTime = DATE_FORMAT.format(z);\r\n            final String modTime = DATE_FORMAT.format(m);\r\n            final String accTime = DATE_FORMAT.format(a);\r\n            switch(year) {\r\n                case 2109:\r\n                    // All three timestamps have overflowed by 2109.\r\n                    if (!zipTimeUsesExtendedTimestamp) {\r\n                        assertEquals(\"1981-01-01/00:00:02 +0000\", zipTime);\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (!zipTimeUsesExtendedTimestamp) {\r\n                        // X5455 time is good from epoch (1970) to 2037.\r\n                        // Zip time is good from 1980 to 2107.\r\n                        if (year < 1980) {\r\n                            assertEquals(\"1980-01-01/08:00:00 +0000\", zipTime);\r\n                        } else {\r\n                            assertEquals(year + \"-01-01/00:00:02 +0000\", zipTime);\r\n                        }\r\n                    }\r\n                    if (year < 2038) {\r\n                        assertEquals(year + \"-01-01/00:00:01 +0000\", modTime);\r\n                        assertEquals(year + \"-01-01/00:00:03 +0000\", accTime);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X5455_ExtendedTimestampTest.java",
  "methodName" : "testWriteReadRoundtrip",
  "sourceCode" : "@Test\r\nvoid testWriteReadRoundtrip() throws IOException {\r\n    final File output = new File(tmpDir, \"write_rewrite.zip\");\r\n    final Calendar instance = Calendar.getInstance();\r\n    instance.clear();\r\n    instance.set(1997, 8, 24, 15, 10, 2);\r\n    final Date date = instance.getTime();\r\n    try (OutputStream out = Files.newOutputStream(output.toPath());\r\n        ZipArchiveOutputStream os = new ZipArchiveOutputStream(out)) {\r\n        final ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\r\n        xf.setModifyJavaTime(date);\r\n        xf.setFlags((byte) 1);\r\n        ze.addExtraField(xf);\r\n        os.putArchiveEntry(ze);\r\n        os.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zf = ZipFile.builder().setFile(output).get()) {\r\n        final ZipArchiveEntry ze = zf.getEntry(\"foo\");\r\n        final X5455_ExtendedTimestamp ext = (X5455_ExtendedTimestamp) ze.getExtraField(X5455);\r\n        assertNotNull(ext);\r\n        assertTrue(ext.isBit0_modifyTimePresent());\r\n        assertEquals(date, ext.getModifyJavaTime());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X7875_NewUnixTest.java",
  "methodName" : "testGetHeaderId",
  "sourceCode" : "@Test\r\nvoid testGetHeaderId() {\r\n    assertEquals(X7875, xf.getHeaderId());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X7875_NewUnixTest.java",
  "methodName" : "testMisc",
  "sourceCode" : "@Test\r\nvoid testMisc() throws Exception {\r\n    assertNotEquals(xf, new Object());\r\n    assertTrue(xf.toString().startsWith(\"0x7875 Zip Extra Field\"));\r\n    final Object o = xf.clone();\r\n    assertEquals(o.hashCode(), xf.hashCode());\r\n    assertEquals(xf, o);\r\n    xf.setUID(12345);\r\n    assertNotEquals(xf, o);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X7875_NewUnixTest.java",
  "methodName" : "testParseReparse",
  "sourceCode" : "@Test\r\nvoid testParseReparse() throws ZipException {\r\n    // Version=1, Len=0, Len=0.\r\n    final byte[] ZERO_LEN = { 1, 0, 0 };\r\n    // Version=1, Len=1, zero, Len=1, zero.\r\n    final byte[] ZERO_UID_GID = { 1, 1, 0, 1, 0 };\r\n    // Version=1, Len=1, one, Len=1, one\r\n    final byte[] ONE_UID_GID = { 1, 1, 1, 1, 1 };\r\n    // Version=1, Len=2, one thousand, Len=2, one thousand\r\n    final byte[] ONE_THOUSAND_UID_GID = { 1, 2, -24, 3, 2, -24, 3 };\r\n    // (2^32 - 2). I guess they avoid (2^32 - 1) since it's identical to -1 in\r\n    // two's complement, and -1 often has a special meaning.\r\n    final byte[] UNIX_MAX_UID_GID = { 1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1 };\r\n    // Version=1, Len=5, 2^32, Len=5, 2^32 + 1\r\n    // Esoteric test: can we handle 40 bit numbers?\r\n    final byte[] LENGTH_5 = { 1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1 };\r\n    // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1\r\n    // Esoteric test: can we handle 64-bit numbers?\r\n    final byte[] LENGTH_8 = { 1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127 };\r\n    final long TWO_TO_32 = 0x100000000L;\r\n    final long MAX = TWO_TO_32 - 2;\r\n    parseReparse(0, 0, ZERO_LEN, 0, 0);\r\n    parseReparse(0, 0, ZERO_UID_GID, 0, 0);\r\n    parseReparse(1, 1, ONE_UID_GID, 1, 1);\r\n    parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);\r\n    parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);\r\n    parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);\r\n    parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);\r\n    parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);\r\n    // We never emit this, but we should be able to parse it:\r\n    final byte[] SPURIOUS_ZEROES_1 = { 1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0 };\r\n    final byte[] EXPECTED_1 = { 1, 1, -1, 1, -128 };\r\n    xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);\r\n    assertEquals(255, xf.getUID());\r\n    assertEquals(128, xf.getGID());\r\n    assertArrayEquals(EXPECTED_1, xf.getLocalFileDataData());\r\n    final byte[] SPURIOUS_ZEROES_2 = { 1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0 };\r\n    final byte[] EXPECTED_2 = { 1, 2, -1, -1, 2, 1, 2 };\r\n    xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);\r\n    assertEquals(65535, xf.getUID());\r\n    assertEquals(513, xf.getGID());\r\n    assertArrayEquals(EXPECTED_2, xf.getLocalFileDataData());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X7875_NewUnixTest.java",
  "methodName" : "testSampleFile",
  "sourceCode" : "@Test\r\nvoid testSampleFile() throws Exception {\r\n    try (ZipFile zipFile = ZipFile.builder().setFile(getFile(\"COMPRESS-211_uid_gid_zip_test.zip\")).get()) {\r\n        // We expect EVERY entry of this ZIP file (dir & file) to\r\n        // contain extra field 0x7875.\r\n        zipFile.stream().forEach(zae -> {\r\n            final String name = zae.getName();\r\n            final X7875_NewUnix xf = (X7875_NewUnix) zae.getExtraField(X7875);\r\n            // The directory entry in the test ZIP file is uid/gid 1000.\r\n            long expected = 1000;\r\n            if (name.contains(\"uid555_gid555\")) {\r\n                expected = 555;\r\n            } else if (name.contains(\"uid5555_gid5555\")) {\r\n                expected = 5555;\r\n            } else if (name.contains(\"uid55555_gid55555\")) {\r\n                expected = 55555;\r\n            } else if (name.contains(\"uid555555_gid555555\")) {\r\n                expected = 555555;\r\n            } else if (name.contains(\"min_unix\")) {\r\n                expected = 0;\r\n            } else if (name.contains(\"max_unix\")) {\r\n                // 2^32-2 was the biggest UID/GID I could create on my Linux!\r\n                // (December 2012, Linux kernel 3.4)\r\n                expected = 0x100000000L - 2;\r\n            }\r\n            assertEquals(expected, xf.getUID());\r\n            assertEquals(expected, xf.getGID());\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\X7875_NewUnixTest.java",
  "methodName" : "testTrimLeadingZeroesForceMinLength4",
  "sourceCode" : "@Test\r\nvoid testTrimLeadingZeroesForceMinLength4() {\r\n    final byte[] NULL = null;\r\n    final byte[] EMPTY = ArrayUtils.EMPTY_BYTE_ARRAY;\r\n    final byte[] ONE_ZERO = { 0 };\r\n    final byte[] TWO_ZEROES = { 0, 0 };\r\n    final byte[] FOUR_ZEROES = { 0, 0, 0, 0 };\r\n    final byte[] SEQUENCE = { 1, 2, 3 };\r\n    final byte[] SEQUENCE_LEADING_ZERO = { 0, 1, 2, 3 };\r\n    final byte[] SEQUENCE_LEADING_ZEROES = { 0, 0, 0, 0, 0, 0, 0, 1, 2, 3 };\r\n    final byte[] TRAILING_ZERO = { 1, 2, 3, 0 };\r\n    final byte[] PADDING_ZERO = { 0, 1, 2, 3, 0 };\r\n    final byte[] SEQUENCE6 = { 1, 2, 3, 4, 5, 6 };\r\n    final byte[] SEQUENCE6_LEADING_ZERO = { 0, 1, 2, 3, 4, 5, 6 };\r\n    assertSame(NULL, trimTest(NULL));\r\n    assertArrayEquals(ONE_ZERO, trimTest(EMPTY));\r\n    assertArrayEquals(ONE_ZERO, trimTest(ONE_ZERO));\r\n    assertArrayEquals(ONE_ZERO, trimTest(TWO_ZEROES));\r\n    assertArrayEquals(ONE_ZERO, trimTest(FOUR_ZEROES));\r\n    assertArrayEquals(SEQUENCE, trimTest(SEQUENCE));\r\n    assertArrayEquals(SEQUENCE, trimTest(SEQUENCE_LEADING_ZERO));\r\n    assertArrayEquals(SEQUENCE, trimTest(SEQUENCE_LEADING_ZEROES));\r\n    assertArrayEquals(TRAILING_ZERO, trimTest(TRAILING_ZERO));\r\n    assertArrayEquals(TRAILING_ZERO, trimTest(PADDING_ZERO));\r\n    assertArrayEquals(SEQUENCE6, trimTest(SEQUENCE6));\r\n    assertArrayEquals(SEQUENCE6, trimTest(SEQUENCE6_LEADING_ZERO));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testReadCDSizesAndOffset",
  "sourceCode" : "@Test\r\nvoid testReadCDSizesAndOffset() throws ZipException {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField();\r\n    final byte[] b = new byte[24];\r\n    System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\r\n    System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\r\n    System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\r\n    f.parseFromCentralDirectoryData(b, 0, b.length);\r\n    assertEquals(SIZE, f.getSize());\r\n    assertEquals(CSIZE, f.getCompressedSize());\r\n    assertEquals(OFF, f.getRelativeHeaderOffset());\r\n    assertNull(f.getDiskStartNumber());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testReadCDSizesOffsetAndDisk",
  "sourceCode" : "@Test\r\nvoid testReadCDSizesOffsetAndDisk() throws ZipException {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField();\r\n    final byte[] b = new byte[28];\r\n    System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\r\n    System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\r\n    System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\r\n    System.arraycopy(DISK.getBytes(), 0, b, 24, 4);\r\n    f.parseFromCentralDirectoryData(b, 0, b.length);\r\n    assertEquals(SIZE, f.getSize());\r\n    assertEquals(CSIZE, f.getCompressedSize());\r\n    assertEquals(OFF, f.getRelativeHeaderOffset());\r\n    assertEquals(DISK, f.getDiskStartNumber());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testReadCDSomethingAndDisk",
  "sourceCode" : "@Test\r\nvoid testReadCDSomethingAndDisk() throws ZipException {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField();\r\n    final byte[] b = new byte[12];\r\n    System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\r\n    System.arraycopy(DISK.getBytes(), 0, b, 8, 4);\r\n    f.parseFromCentralDirectoryData(b, 0, b.length);\r\n    assertNull(f.getSize());\r\n    assertNull(f.getCompressedSize());\r\n    assertNull(f.getRelativeHeaderOffset());\r\n    assertEquals(DISK, f.getDiskStartNumber());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testReadLFHSizesAndDisk",
  "sourceCode" : "@Test\r\nvoid testReadLFHSizesAndDisk() throws ZipException {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField();\r\n    final byte[] b = new byte[20];\r\n    System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\r\n    System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\r\n    System.arraycopy(DISK.getBytes(), 0, b, 16, 4);\r\n    f.parseFromLocalFileData(b, 0, b.length);\r\n    assertEquals(SIZE, f.getSize());\r\n    assertEquals(CSIZE, f.getCompressedSize());\r\n    assertNull(f.getRelativeHeaderOffset());\r\n    assertEquals(DISK, f.getDiskStartNumber());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testReadLFHSizesAndOffset",
  "sourceCode" : "@Test\r\nvoid testReadLFHSizesAndOffset() throws ZipException {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField();\r\n    final byte[] b = new byte[24];\r\n    System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\r\n    System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\r\n    System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\r\n    f.parseFromLocalFileData(b, 0, b.length);\r\n    assertEquals(SIZE, f.getSize());\r\n    assertEquals(CSIZE, f.getCompressedSize());\r\n    assertEquals(OFF, f.getRelativeHeaderOffset());\r\n    assertNull(f.getDiskStartNumber());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testReadLFHSizesOffsetAndDisk",
  "sourceCode" : "@Test\r\nvoid testReadLFHSizesOffsetAndDisk() throws ZipException {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField();\r\n    final byte[] b = new byte[28];\r\n    System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\r\n    System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\r\n    System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\r\n    System.arraycopy(DISK.getBytes(), 0, b, 24, 4);\r\n    f.parseFromLocalFileData(b, 0, b.length);\r\n    assertEquals(SIZE, f.getSize());\r\n    assertEquals(CSIZE, f.getCompressedSize());\r\n    assertEquals(OFF, f.getRelativeHeaderOffset());\r\n    assertEquals(DISK, f.getDiskStartNumber());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testReadLFHSizesOnly",
  "sourceCode" : "@Test\r\nvoid testReadLFHSizesOnly() throws ZipException {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField();\r\n    final byte[] b = new byte[16];\r\n    System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\r\n    System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\r\n    f.parseFromLocalFileData(b, 0, b.length);\r\n    assertEquals(SIZE, f.getSize());\r\n    assertEquals(CSIZE, f.getCompressedSize());\r\n    assertNull(f.getRelativeHeaderOffset());\r\n    assertNull(f.getDiskStartNumber());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testReparseCDSingleEightByteData",
  "sourceCode" : "@Test\r\nvoid testReparseCDSingleEightByteData() throws ZipException {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField();\r\n    final byte[] b = new byte[8];\r\n    System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\r\n    f.parseFromCentralDirectoryData(b, 0, b.length);\r\n    f.reparseCentralDirectoryData(true, false, false, false);\r\n    assertEquals(SIZE, f.getSize());\r\n    assertNull(f.getCompressedSize());\r\n    assertNull(f.getRelativeHeaderOffset());\r\n    assertNull(f.getDiskStartNumber());\r\n    f.setSize(null);\r\n    f.reparseCentralDirectoryData(false, true, false, false);\r\n    assertNull(f.getSize());\r\n    assertEquals(SIZE, f.getCompressedSize());\r\n    assertNull(f.getRelativeHeaderOffset());\r\n    assertNull(f.getDiskStartNumber());\r\n    f.setCompressedSize(null);\r\n    f.reparseCentralDirectoryData(false, false, true, false);\r\n    assertNull(f.getSize());\r\n    assertNull(f.getCompressedSize());\r\n    assertEquals(SIZE, f.getRelativeHeaderOffset());\r\n    assertNull(f.getDiskStartNumber());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testWriteCDOnlySizes",
  "sourceCode" : "@Test\r\nvoid testWriteCDOnlySizes() {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField(SIZE, CSIZE);\r\n    assertEquals(new ZipShort(16), f.getCentralDirectoryLength());\r\n    final byte[] b = f.getCentralDirectoryData();\r\n    assertEquals(16, b.length);\r\n    checkSizes(b);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testWriteCDSizeAndDisk",
  "sourceCode" : "@Test\r\nvoid testWriteCDSizeAndDisk() {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField(SIZE, CSIZE, null, DISK);\r\n    assertEquals(new ZipShort(20), f.getCentralDirectoryLength());\r\n    final byte[] b = f.getCentralDirectoryData();\r\n    assertEquals(20, b.length);\r\n    checkSizes(b);\r\n    checkDisk(b, 16);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testWriteCDSizeAndOffset",
  "sourceCode" : "@Test\r\nvoid testWriteCDSizeAndOffset() {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField(SIZE, CSIZE, OFF, null);\r\n    assertEquals(new ZipShort(24), f.getCentralDirectoryLength());\r\n    final byte[] b = f.getCentralDirectoryData();\r\n    assertEquals(24, b.length);\r\n    checkSizes(b);\r\n    checkOffset(b, 16);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64ExtendedInformationExtraFieldTest.java",
  "methodName" : "testWriteCDSizeOffsetAndDisk",
  "sourceCode" : "@Test\r\nvoid testWriteCDSizeOffsetAndDisk() {\r\n    final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField(SIZE, CSIZE, OFF, DISK);\r\n    assertEquals(new ZipShort(28), f.getCentralDirectoryLength());\r\n    final byte[] b = f.getCentralDirectoryData();\r\n    assertEquals(28, b.length);\r\n    checkSizes(b);\r\n    checkOffset(b, 16);\r\n    checkDisk(b, 24);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedBy7ZIPUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedBy7ZIPUsingInputStream() throws Throwable {\r\n    read100KFilesImpl(get100KFileFileGeneratedBy7ZIP());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedBy7ZIPUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedBy7ZIPUsingZipFile() throws Throwable {\r\n    read100KFilesUsingZipFileImpl(get100KFileFileGeneratedBy7ZIP());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedByJava7JarUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedByJava7JarUsingInputStream() throws Throwable {\r\n    read100KFilesImpl(get100KFileFileGeneratedByJava7Jar());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedByJava7JarUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedByJava7JarUsingZipFile() throws Throwable {\r\n    read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByJava7Jar());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedByPKZipUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedByPKZipUsingInputStream() throws Throwable {\r\n    read100KFilesImpl(get100KFileFileGeneratedByPKZip());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedByPKZipUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedByPKZipUsingZipFile() throws Throwable {\r\n    read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByPKZip());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedByWinCFUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedByWinCFUsingInputStream() throws Throwable {\r\n    read100KFilesImpl(get100KFileFileGeneratedByWinCF());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedByWinCFUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedByWinCFUsingZipFile() throws Throwable {\r\n    read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByWinCF());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedByWinZIPUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedByWinZIPUsingInputStream() throws Throwable {\r\n    read100KFilesImpl(get100KFileFileGeneratedByWinZIP());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesGeneratedByWinZIPUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesGeneratedByWinZIPUsingZipFile() throws Throwable {\r\n    read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByWinZIP());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesUsingInputStream() throws Throwable {\r\n    read100KFilesImpl(get100KFileFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead100KFilesUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead100KFilesUsingZipFile() throws Throwable {\r\n    read100KFilesUsingZipFileImpl(get100KFileFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead3EntriesCreatingBigArchiveFileUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead3EntriesCreatingBigArchiveFileUsingZipFile() throws Throwable {\r\n    withTemporaryArchive(\"read3EntriesCreatingBigArchiveFileUsingZipFile\", (f, zos) -> {\r\n        write3EntriesCreatingBigArchiveToStream(zos);\r\n        ZipFile zf = null;\r\n        try {\r\n            zf = ZipFile.builder().setFile(f).get();\r\n            int idx = 0;\r\n            for (final Enumeration<ZipArchiveEntry> e = zf.getEntriesInPhysicalOrder(); e.hasMoreElements(); ) {\r\n                final ZipArchiveEntry zae = e.nextElement();\r\n                assertEquals(String.valueOf(idx), zae.getName());\r\n                if (idx++ < 2) {\r\n                    assertEquals(FIVE_BILLION / 2, zae.getSize());\r\n                } else {\r\n                    assertEquals(1, zae.getSize());\r\n                    try (InputStream i = zf.getInputStream(zae)) {\r\n                        assertNotNull(i);\r\n                        assertEquals(42, i.read());\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            ZipFile.closeQuietly(zf);\r\n        }\r\n    }, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosGeneratedBy7ZIPUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosGeneratedBy7ZIPUsingInputStream() throws Throwable {\r\n    read5GBOfZerosImpl(get5GBZerosFileGeneratedBy7ZIP(), \"5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosGeneratedBy7ZIPUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosGeneratedBy7ZIPUsingZipFile() throws Throwable {\r\n    read5GBOfZerosUsingZipFileImpl(get5GBZerosFileGeneratedBy7ZIP(), \"5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosGeneratedByJava7JarUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosGeneratedByJava7JarUsingInputStream() throws Throwable {\r\n    read5GBOfZerosImpl(get5GBZerosFileGeneratedByJava7Jar(), \"5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosGeneratedByJava7JarUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosGeneratedByJava7JarUsingZipFile() throws Throwable {\r\n    read5GBOfZerosUsingZipFileImpl(get5GBZerosFileGeneratedByJava7Jar(), \"5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosGeneratedByPKZipUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosGeneratedByPKZipUsingInputStream() throws Throwable {\r\n    read5GBOfZerosImpl(get5GBZerosFileGeneratedByPKZip(), \"zip6/5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosGeneratedByPKZipUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosGeneratedByPKZipUsingZipFile() throws Throwable {\r\n    read5GBOfZerosUsingZipFileImpl(get5GBZerosFileGeneratedByPKZip(), \"zip6/5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosGeneratedByWinZIPUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosGeneratedByWinZIPUsingInputStream() throws Throwable {\r\n    read5GBOfZerosImpl(get5GBZerosFileGeneratedByWinZIP(), \"5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosGeneratedByWinZIPUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosGeneratedByWinZIPUsingZipFile() throws Throwable {\r\n    read5GBOfZerosUsingZipFileImpl(get5GBZerosFileGeneratedByWinZIP(), \"5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosUsingInputStream",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosUsingInputStream() throws Throwable {\r\n    read5GBOfZerosImpl(get5GBZerosFile(), \"5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testRead5GBOfZerosUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testRead5GBOfZerosUsingZipFile() throws Throwable {\r\n    read5GBOfZerosUsingZipFileImpl(get5GBZerosFile(), \"5GB_of_Zeros\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testReadSelfGenerated100KFilesUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testReadSelfGenerated100KFilesUsingZipFile() throws Throwable {\r\n    withTemporaryArchive(\"readSelfGenerated100KFilesUsingZipFile()\", (f, zos) -> {\r\n        write100KFilesToStream(zos);\r\n        read100KFilesUsingZipFileImpl(f);\r\n    }, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite100KFilesFile",
  "sourceCode" : "@Test\r\nvoid testWrite100KFilesFile() throws Throwable {\r\n    withTemporaryArchive(\"write100KFilesFile\", write100KFiles(), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite100KFilesFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWrite100KFilesFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"write100KFilesFileModeAlways\", write100KFiles(Zip64Mode.Always), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite100KFilesFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWrite100KFilesFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"write100KFilesFileModeNever\", write100KFilesModeNever, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite100KFilesStream",
  "sourceCode" : "@Test\r\nvoid testWrite100KFilesStream() throws Throwable {\r\n    withTemporaryArchive(\"write100KFilesStream\", write100KFiles(), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite100KFilesStreamModeAlways",
  "sourceCode" : "@Test\r\nvoid testWrite100KFilesStreamModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"write100KFilesStreamModeAlways\", write100KFiles(Zip64Mode.Always), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite100KFilesStreamModeNever",
  "sourceCode" : "@Test\r\nvoid testWrite100KFilesStreamModeNever() throws Throwable {\r\n    withTemporaryArchive(\"write100KFilesStreamModeNever\", write100KFilesModeNever, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite3EntriesCreatingBigArchiveFile",
  "sourceCode" : "@Test\r\nvoid testWrite3EntriesCreatingBigArchiveFile() throws Throwable {\r\n    withTemporaryArchive(\"write3EntriesCreatingBigArchiveFile\", write3EntriesCreatingBigArchive(), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite3EntriesCreatingBigArchiveFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWrite3EntriesCreatingBigArchiveFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"write3EntriesCreatingBigArchiveFileModeAlways\", write3EntriesCreatingBigArchive(Zip64Mode.Always), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite3EntriesCreatingBigArchiveFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWrite3EntriesCreatingBigArchiveFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"write3EntriesCreatingBigArchiveFileModeNever\", write3EntriesCreatingBigArchiveModeNever, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite3EntriesCreatingBigArchiveStream",
  "sourceCode" : "@Test\r\nvoid testWrite3EntriesCreatingBigArchiveStream() throws Throwable {\r\n    withTemporaryArchive(\"write3EntriesCreatingBigArchiveStream\", write3EntriesCreatingBigArchive(), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite3EntriesCreatingBigArchiveStreamModeAlways",
  "sourceCode" : "@Test\r\nvoid testWrite3EntriesCreatingBigArchiveStreamModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"write3EntriesCreatingBigArchiveStreamModeAlways\", write3EntriesCreatingBigArchive(Zip64Mode.Always), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite3EntriesCreatingBigArchiveStreamModeNever",
  "sourceCode" : "@Test\r\nvoid testWrite3EntriesCreatingBigArchiveStreamModeNever() throws Throwable {\r\n    withTemporaryArchive(\"write3EntriesCreatingBigArchiveStreamModeNever\", write3EntriesCreatingBigArchiveModeNever, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite3EntriesCreatingManySplitArchiveFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWrite3EntriesCreatingManySplitArchiveFileModeAlways() throws Throwable {\r\n    // about 76,293 ZIP split segments will be created\r\n    withTemporaryArchive(\"write3EntriesCreatingManySplitArchiveFileModeAlways\", write3EntriesCreatingBigArchive(Zip64Mode.Always, true), true, 65536L);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWrite3EntriesCreatingManySplitArchiveFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWrite3EntriesCreatingManySplitArchiveFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"write3EntriesCreatingManySplitArchiveFileModeNever\", write3EntriesCreatingBigArchiveModeNever, true, 65536L);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteAndRead5GBOfZerosUsingZipFile",
  "sourceCode" : "@Test\r\nvoid testWriteAndRead5GBOfZerosUsingZipFile() throws Throwable {\r\n    File f = null;\r\n    try {\r\n        f = write5GBZerosFile(\"writeAndRead5GBOfZerosUsingZipFile\");\r\n        read5GBOfZerosUsingZipFileImpl(f, \"5GB_of_Zeros\");\r\n    } finally {\r\n        AbstractTest.forceDelete(f);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryKnownSizeToFile",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryKnownSizeToFile() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFile\", writeBigDeflatedEntryToFile(true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryKnownSizeToFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryKnownSizeToFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFileModeAlways\", writeBigDeflatedEntryToFile(true, Zip64Mode.Always), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryKnownSizeToFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryKnownSizeToFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFileModeNever\", writeBigDeflatedEntryToFileModeNever(true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryKnownSizeToStream",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryKnownSizeToStream() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStream\", writeBigDeflatedEntryToStream(true, Zip64Mode.AsNeeded), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryKnownSizeToStreamModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryKnownSizeToStreamModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStreamModeAlways\", writeBigDeflatedEntryToStream(true, Zip64Mode.Always), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryKnownSizeToStreamModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryKnownSizeToStreamModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStreamModeNever\", (f, zos) -> {\r\n        zos.setUseZip64(Zip64Mode.Never);\r\n        final Zip64RequiredException ex = assertThrows(Zip64RequiredException.class, () -> {\r\n            final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\r\n            zae.setSize(FIVE_BILLION);\r\n            zae.setMethod(ZipEntry.DEFLATED);\r\n            zos.putArchiveEntry(zae);\r\n        }, \"expected a Zip64RequiredException\");\r\n        assertTrue(ex.getMessage().startsWith(\"0's size\"));\r\n    }, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryUnknownSizeToFile",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryUnknownSizeToFile() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFile\", writeBigDeflatedEntryToFile(false), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryUnknownSizeToFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryUnknownSizeToFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFileModeAlways\", writeBigDeflatedEntryToFile(false, Zip64Mode.Always), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryUnknownSizeToFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryUnknownSizeToFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFileModeNever\", writeBigDeflatedEntryToFileModeNever(false), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryUnknownSizeToStream",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryUnknownSizeToStream() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToStream\", writeBigDeflatedEntryUnknownSizeToStream(Zip64Mode.AsNeeded), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryUnknownSizeToStreamModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryUnknownSizeToStreamModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToStreamModeAlways\", writeBigDeflatedEntryToStream(false, Zip64Mode.Always), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigDeflatedEntryUnknownSizeToStreamModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteBigDeflatedEntryUnknownSizeToStreamModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToStreamModeNever\", writeBigDeflatedEntryUnknownSizeToStream(Zip64Mode.Never), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryKnownSizeToFile",
  "sourceCode" : "@Test\r\nvoid testWriteBigStoredEntryKnownSizeToFile() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFile\", writeBigStoredEntry(true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryKnownSizeToFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteBigStoredEntryKnownSizeToFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFileModeAlways\", writeBigStoredEntry(true, Zip64Mode.Always), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryKnownSizeToFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteBigStoredEntryKnownSizeToFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFileModeNever\", writeBigStoredEntryModeNever(true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryToStream",
  "sourceCode" : "/*\r\n     * No Compression + Stream => sizes must be known before data is written.\r\n     */\r\n@Test\r\nvoid testWriteBigStoredEntryToStream() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryToStream\", writeBigStoredEntry(true), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryToStreamModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteBigStoredEntryToStreamModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryToStreamModeAlways\", writeBigStoredEntry(true, Zip64Mode.Always), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryToStreamModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteBigStoredEntryToStreamModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryToStreamModeNever\", writeBigStoredEntryModeNever(true), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryUnknownSizeToFile",
  "sourceCode" : "@Test\r\nvoid testWriteBigStoredEntryUnknownSizeToFile() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFile\", writeBigStoredEntry(false), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryUnknownSizeToFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteBigStoredEntryUnknownSizeToFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFileModeAlways\", writeBigStoredEntry(false, Zip64Mode.Always), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteBigStoredEntryUnknownSizeToFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteBigStoredEntryUnknownSizeToFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFileModeNever\", writeBigStoredEntryModeNever(false), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryKnownSizeToFile",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryKnownSizeToFile() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToFile\", writeSmallDeflatedEntryToFile(true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryKnownSizeToFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryKnownSizeToFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToFileModeAlways\", writeSmallDeflatedEntryToFileModeAlways(true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryKnownSizeToFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryKnownSizeToFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToFileModeNever\", writeSmallDeflatedEntryToFile(true, Zip64Mode.Never), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryKnownSizeToStream",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryKnownSizeToStream() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStream\", writeSmallDeflatedEntryToStream(true, Zip64Mode.AsNeeded), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryKnownSizeToStreamModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryKnownSizeToStreamModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStreamModeAlways\", writeSmallDeflatedEntryToStreamModeAlways(true), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryKnownSizeToStreamModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryKnownSizeToStreamModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStreamModeNever\", writeSmallDeflatedEntryToStream(true, Zip64Mode.Never), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryUnknownSizeToFile",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryUnknownSizeToFile() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFile\", writeSmallDeflatedEntryToFile(false), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryUnknownSizeToFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryUnknownSizeToFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFileModeAlways\", writeSmallDeflatedEntryToFileModeAlways(false), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryUnknownSizeToFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryUnknownSizeToFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFileModeNever\", writeSmallDeflatedEntryToFile(false, Zip64Mode.Never), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryUnknownSizeToStream",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryUnknownSizeToStream() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToStream\", writeSmallDeflatedEntryToStream(false, Zip64Mode.AsNeeded), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryUnknownSizeToStreamModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryUnknownSizeToStreamModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToStreamModeAlways\", writeSmallDeflatedEntryToStreamModeAlways(false), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallDeflatedEntryUnknownSizeToStreamModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteSmallDeflatedEntryUnknownSizeToStreamModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToStreamModeNever\", writeSmallDeflatedEntryToStream(false, Zip64Mode.Never), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryKnownSizeToFile",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryKnownSizeToFile() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryKnownSizeToFile\", writeSmallStoredEntry(true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryKnownSizeToFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryKnownSizeToFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryKnownSizeToFileModeAlways\", writeSmallStoredEntryModeAlways(true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryKnownSizeToFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryKnownSizeToFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryKnownSizeToFileModeNever\", writeSmallStoredEntry(true, Zip64Mode.Never), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryToStream",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryToStream() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryToStream\", writeSmallStoredEntry(true), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryToStreamModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryToStreamModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryToStreamModeAlways\", writeSmallStoredEntryModeAlways(true), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryToStreamModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryToStreamModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryToStreamModeNever\", writeSmallStoredEntry(true, Zip64Mode.Never), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryUnknownSizeToFile",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryUnknownSizeToFile() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryUnknownSizeToFile\", writeSmallStoredEntry(false), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryUnknownSizeToFileModeAlways",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryUnknownSizeToFileModeAlways() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryUnknownSizeToFileModeAlways\", writeSmallStoredEntryModeAlways(false), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testWriteSmallStoredEntryUnknownSizeToFileModeNever",
  "sourceCode" : "@Test\r\nvoid testWriteSmallStoredEntryUnknownSizeToFileModeNever() throws Throwable {\r\n    withTemporaryArchive(\"writeSmallStoredEntryUnknownSizeToFileModeNever\", writeSmallStoredEntry(false, Zip64Mode.Never), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\Zip64SupportIT.java",
  "methodName" : "testZip64ModeAlwaysWithCompatibility",
  "sourceCode" : "@Test\r\nvoid testZip64ModeAlwaysWithCompatibility() throws Throwable {\r\n    final File inputFile = getFile(\"test3.xml\");\r\n    // with Zip64Mode.AlwaysWithCompatibility, the relative header offset and disk number\r\n    // start will not be set in extra fields\r\n    final File zipUsingModeAlwaysWithCompatibility = buildZipWithZip64Mode(\"testZip64ModeAlwaysWithCompatibility-output-1\", Zip64Mode.AlwaysWithCompatibility, inputFile);\r\n    final ZipFile zipFileWithAlwaysWithCompatibility = ZipFile.builder().setFile(zipUsingModeAlwaysWithCompatibility).get();\r\n    ZipArchiveEntry entry = zipFileWithAlwaysWithCompatibility.getEntries().nextElement();\r\n    for (final ZipExtraField extraField : entry.getExtraFields()) {\r\n        if (!(extraField instanceof Zip64ExtendedInformationExtraField)) {\r\n            continue;\r\n        }\r\n        assertNull(((Zip64ExtendedInformationExtraField) extraField).getRelativeHeaderOffset());\r\n        assertNull(((Zip64ExtendedInformationExtraField) extraField).getDiskStartNumber());\r\n    }\r\n    // with Zip64Mode.Always, the relative header offset and disk number start will be\r\n    // set in extra fields\r\n    final File zipUsingModeAlways = buildZipWithZip64Mode(\"testZip64ModeAlwaysWithCompatibility-output-2\", Zip64Mode.Always, inputFile);\r\n    final ZipFile zipFileWithAlways = ZipFile.builder().setFile(zipUsingModeAlways).get();\r\n    entry = zipFileWithAlways.getEntries().nextElement();\r\n    for (final ZipExtraField extraField : entry.getExtraFields()) {\r\n        if (!(extraField instanceof Zip64ExtendedInformationExtraField)) {\r\n            continue;\r\n        }\r\n        assertNotNull(((Zip64ExtendedInformationExtraField) extraField).getRelativeHeaderOffset());\r\n        assertNotNull(((Zip64ExtendedInformationExtraField) extraField).getDiskStartNumber());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "bestEffortIncludesUnparseableExtraData",
  "sourceCode" : "@Test\r\nvoid bestEffortIncludesUnparseableExtraData() throws Exception {\r\n    final ZipExtraField[] extraFields = parsingModeBehaviorTestData();\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\r\n    ze.setExtraFields(extraFields);\r\n    final ZipExtraField[] read = ze.getExtraFields(ZipArchiveEntry.ExtraFieldParsingMode.BEST_EFFORT);\r\n    assertEquals(extraFields.length, read.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testAddAsFirstExtraField",
  "sourceCode" : "/**\r\n * test handling of extra fields\r\n */\r\n@Test\r\nvoid testAddAsFirstExtraField() {\r\n    final AsiExtraField a = new AsiExtraField();\r\n    a.setDirectory(true);\r\n    a.setMode(0755);\r\n    final UnrecognizedExtraField u = new UnrecognizedExtraField();\r\n    u.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\r\n    u.setLocalFileDataData(ArrayUtils.EMPTY_BYTE_ARRAY);\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\r\n    ze.setExtraFields(new ZipExtraField[] { a, u });\r\n    final byte[] data1 = ze.getExtra();\r\n    final UnrecognizedExtraField u2 = new UnrecognizedExtraField();\r\n    u2.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\r\n    u2.setLocalFileDataData(new byte[] { 1 });\r\n    ze.addAsFirstExtraField(u2);\r\n    final byte[] data2 = ze.getExtra();\r\n    ZipExtraField[] result = ze.getExtraFields();\r\n    assertEquals(2, result.length, \"second pass\");\r\n    assertSame(u2, result[0]);\r\n    assertSame(a, result[1]);\r\n    assertEquals(data1.length + 1, data2.length, \"length second pass\");\r\n    final UnrecognizedExtraField u3 = new UnrecognizedExtraField();\r\n    u3.setHeaderId(new ZipShort(2));\r\n    u3.setLocalFileDataData(new byte[] { 1 });\r\n    ze.addAsFirstExtraField(u3);\r\n    result = ze.getExtraFields();\r\n    assertEquals(3, result.length, \"third pass\");\r\n    assertSame(u3, result[0]);\r\n    assertSame(u2, result[1]);\r\n    assertSame(a, result[2]);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testCompressionMethod",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-93\">COMPRESS-93</a>.\r\n */\r\n@Test\r\nvoid testCompressionMethod() throws Exception {\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(new ByteArrayOutputStream())) {\r\n        final ZipArchiveEntry entry = new ZipArchiveEntry(\"foo\");\r\n        assertEquals(-1, entry.getMethod());\r\n        assertFalse(zos.canWriteEntryData(entry));\r\n        entry.setMethod(ZipEntry.STORED);\r\n        assertEquals(ZipEntry.STORED, entry.getMethod());\r\n        assertTrue(zos.canWriteEntryData(entry));\r\n        entry.setMethod(ZipEntry.DEFLATED);\r\n        assertEquals(ZipEntry.DEFLATED, entry.getMethod());\r\n        assertTrue(zos.canWriteEntryData(entry));\r\n        // Test the unsupported \"imploded\" compression method (6)\r\n        entry.setMethod(6);\r\n        assertEquals(6, entry.getMethod());\r\n        assertFalse(zos.canWriteEntryData(entry));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testCopyConstructor",
  "sourceCode" : "@Test\r\nvoid testCopyConstructor() throws Exception {\r\n    final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"fred\");\r\n    archiveEntry.setUnixMode(0664);\r\n    archiveEntry.setMethod(ZipEntry.DEFLATED);\r\n    archiveEntry.getGeneralPurposeBit().useStrongEncryption(true);\r\n    final ZipArchiveEntry copy = new ZipArchiveEntry(archiveEntry);\r\n    assertEquals(archiveEntry, copy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testDraconicThrowsOnUnparseableExtraData",
  "sourceCode" : "@Test\r\nvoid testDraconicThrowsOnUnparseableExtraData() throws Exception {\r\n    final ZipExtraField[] extraFields = parsingModeBehaviorTestData();\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\r\n    ze.setExtraFields(extraFields);\r\n    assertThrows(ZipException.class, () -> ze.getExtraFields(ZipArchiveEntry.ExtraFieldParsingMode.DRACONIC));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testExtraFieldMerging",
  "sourceCode" : "/**\r\n * test handling of extra fields via central directory\r\n */\r\n@Test\r\nvoid testExtraFieldMerging() {\r\n    final AsiExtraField a = new AsiExtraField();\r\n    a.setDirectory(true);\r\n    a.setMode(0755);\r\n    final UnrecognizedExtraField u = new UnrecognizedExtraField();\r\n    u.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\r\n    u.setLocalFileDataData(ArrayUtils.EMPTY_BYTE_ARRAY);\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\r\n    ze.setExtraFields(new ZipExtraField[] { a, u });\r\n    // merge\r\n    // Header-ID 1 + length 1 + one byte of data\r\n    final byte[] b = ExtraFieldUtilsTest.UNRECOGNIZED_HEADER.getBytes();\r\n    ze.setCentralDirectoryExtra(new byte[] { b[0], b[1], 1, 0, 127 });\r\n    ZipExtraField[] result = ze.getExtraFields();\r\n    assertEquals(2, result.length, \"first pass\");\r\n    assertSame(a, result[0]);\r\n    assertEquals(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER, result[1].getHeaderId());\r\n    assertEquals(new ZipShort(0), result[1].getLocalFileDataLength());\r\n    assertEquals(new ZipShort(1), result[1].getCentralDirectoryLength());\r\n    // add new\r\n    // Header-ID 2 + length 0\r\n    ze.setCentralDirectoryExtra(new byte[] { 2, 0, 0, 0 });\r\n    result = ze.getExtraFields();\r\n    assertEquals(3, result.length, \"second pass\");\r\n    // merge\r\n    // Header-ID 2 + length 1 + one byte of data\r\n    ze.setExtra(new byte[] { 2, 0, 1, 0, 127 });\r\n    result = ze.getExtraFields();\r\n    assertEquals(3, result.length, \"third pass\");\r\n    assertSame(a, result[0]);\r\n    assertEquals(new ZipShort(2), result[2].getHeaderId());\r\n    assertEquals(new ZipShort(1), result[2].getLocalFileDataLength());\r\n    assertEquals(new ZipShort(0), result[2].getCentralDirectoryLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testExtraFields",
  "sourceCode" : "/**\r\n * test handling of extra fields\r\n */\r\n@Test\r\nvoid testExtraFields() {\r\n    final AsiExtraField a = new AsiExtraField();\r\n    a.setDirectory(true);\r\n    a.setMode(0755);\r\n    final UnrecognizedExtraField u = new UnrecognizedExtraField();\r\n    u.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\r\n    u.setLocalFileDataData(ArrayUtils.EMPTY_BYTE_ARRAY);\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\r\n    ze.setExtraFields(new ZipExtraField[] { a, u });\r\n    final byte[] data1 = ze.getExtra();\r\n    ZipExtraField[] result = ze.getExtraFields();\r\n    assertEquals(2, result.length, \"first pass\");\r\n    assertSame(a, result[0]);\r\n    assertSame(u, result[1]);\r\n    final UnrecognizedExtraField u2 = new UnrecognizedExtraField();\r\n    u2.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\r\n    u2.setLocalFileDataData(new byte[] { 1 });\r\n    ze.addExtraField(u2);\r\n    final byte[] data2 = ze.getExtra();\r\n    result = ze.getExtraFields();\r\n    assertEquals(2, result.length, \"second pass\");\r\n    assertSame(a, result[0]);\r\n    assertSame(u2, result[1]);\r\n    assertEquals(data1.length + 1, data2.length, \"length second pass\");\r\n    final UnrecognizedExtraField u3 = new UnrecognizedExtraField();\r\n    u3.setHeaderId(new ZipShort(2));\r\n    u3.setLocalFileDataData(new byte[] { 1 });\r\n    ze.addExtraField(u3);\r\n    result = ze.getExtraFields();\r\n    assertEquals(3, result.length, \"third pass\");\r\n    ze.removeExtraField(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\r\n    final byte[] data3 = ze.getExtra();\r\n    result = ze.getExtraFields();\r\n    assertEquals(2, result.length, \"fourth pass\");\r\n    assertSame(a, result[0]);\r\n    assertSame(u3, result[1]);\r\n    assertEquals(data2.length, data3.length, \"length fourth pass\");\r\n    assertThrows(NoSuchElementException.class, () -> ze.removeExtraField(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER), \"should be no such element\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testIsUnixSymlink",
  "sourceCode" : "@Test\r\nvoid testIsUnixSymlink() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\r\n    ze.setUnixMode(UnixStat.LINK_FLAG);\r\n    assertTrue(ze.isUnixSymlink());\r\n    ze.setUnixMode(UnixStat.LINK_FLAG | UnixStat.DIR_FLAG);\r\n    assertFalse(ze.isUnixSymlink());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testIsUnixSymlinkIsFalseIfMoreThanOneFlagIsSet",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-379\"\r\n */\r\n@Test\r\nvoid testIsUnixSymlinkIsFalseIfMoreThanOneFlagIsSet() throws Exception {\r\n    try (ZipFile zf = ZipFile.builder().setFile(getFile(\"COMPRESS-379.jar\")).get()) {\r\n        final ZipArchiveEntry ze = zf.getEntry(\"META-INF/maven/\");\r\n        assertFalse(ze.isUnixSymlink());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testNotEquals",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-94\">COMPRESS-94</a>.\r\n */\r\n@Test\r\nvoid testNotEquals() {\r\n    final ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\r\n    final ZipArchiveEntry entry2 = new ZipArchiveEntry(\"bar\");\r\n    assertNotEquals(entry1, entry2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testNullCommentEqualsEmptyComment",
  "sourceCode" : "/**\r\n * Tests comment's influence on equals comparisons.\r\n *\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-187\"\r\n */\r\n@Test\r\nvoid testNullCommentEqualsEmptyComment() {\r\n    final ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\r\n    final ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\r\n    final ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\r\n    entry1.setComment(null);\r\n    entry2.setComment(\"\");\r\n    entry3.setComment(\"bar\");\r\n    assertEquals(entry1, entry2);\r\n    assertNotEquals(entry1, entry3);\r\n    assertNotEquals(entry2, entry3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testOnlyParseableLenientExcludesUnparseableExtraData",
  "sourceCode" : "@Test\r\nvoid testOnlyParseableLenientExcludesUnparseableExtraData() throws Exception {\r\n    final ZipExtraField[] extraFields = parsingModeBehaviorTestData();\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\r\n    ze.setExtraFields(extraFields);\r\n    final ZipExtraField[] read = ze.getExtraFields(ZipArchiveEntry.ExtraFieldParsingMode.ONLY_PARSEABLE_LENIENT);\r\n    assertEquals(extraFields.length, read.length + 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testOnlyParseableStrictExcludesUnparseableExtraData",
  "sourceCode" : "@Test\r\nvoid testOnlyParseableStrictExcludesUnparseableExtraData() throws Exception {\r\n    final ZipExtraField[] extraFields = parsingModeBehaviorTestData();\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\r\n    ze.setExtraFields(extraFields);\r\n    final ZipExtraField[] read = ze.getExtraFields(ZipArchiveEntry.ExtraFieldParsingMode.ONLY_PARSEABLE_STRICT);\r\n    assertEquals(extraFields.length, read.length + 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testReparsingUnicodeExtraWithUnsupportedversionThrowsInStrictMode",
  "sourceCode" : "@Test\r\nvoid testReparsingUnicodeExtraWithUnsupportedversionThrowsInStrictMode() throws Exception {\r\n    try (ZipFile zf = ZipFile.builder().setFile(getFile(\"COMPRESS-479.zip\")).get()) {\r\n        final ZipArchiveEntry ze = zf.getEntry(\"%U20AC_for_Dollar.txt\");\r\n        assertThrows(ZipException.class, () -> ze.getExtraFields(ZipArchiveEntry.ExtraFieldParsingMode.STRICT_FOR_KNOW_EXTRA_FIELDS));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testShouldNotSetExtraDateFieldsIfDateFitsInDosDates",
  "sourceCode" : "@Test\r\nvoid testShouldNotSetExtraDateFieldsIfDateFitsInDosDates() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    final FileTime time = FileTime.from(ZipUtilTest.toLocalInstant(\"2022-12-28T20:39:33.1234567\"));\r\n    ze.setTime(time);\r\n    assertEquals(time.toMillis(), ze.getTime());\r\n    assertEquals(time.toMillis(), ze.getLastModifiedTime().toMillis());\r\n    assertNull(ze.getExtraField(X5455_ExtendedTimestamp.HEADER_ID));\r\n    assertNull(ze.getExtraField(X000A_NTFS.HEADER_ID));\r\n    final long dosTime = ZipLong.getValue(ZipUtil.toDosTime(ze.getTime()));\r\n    // DOS dates only store even seconds\r\n    ZipUtilTest.assertDosDate(dosTime, 2022, 12, 28, 20, 39, 32);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testShouldNotSetInfoZipFieldIfAnyDatesExceedUnixTime",
  "sourceCode" : "@Test\r\nvoid testShouldNotSetInfoZipFieldIfAnyDatesExceedUnixTime() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    final FileTime accessTime = FileTime.from(Instant.parse(\"2022-12-29T21:40:34.1234567Z\"));\r\n    final FileTime creationTime = FileTime.from(Instant.parse(\"2038-12-28T20:39:33.1234567Z\"));\r\n    final long time = Instant.parse(\"2020-03-04T12:34:56.1234567Z\").toEpochMilli();\r\n    ze.setTime(time);\r\n    ze.setLastAccessTime(accessTime);\r\n    ze.setCreationTime(creationTime);\r\n    assertEquals(time, ze.getTime());\r\n    assertEquals(time, ze.getLastModifiedTime().toMillis());\r\n    assertNull(ze.getExtraField(X5455_ExtendedTimestamp.HEADER_ID));\r\n    final X000A_NTFS ntfs = (X000A_NTFS) ze.getExtraField(X000A_NTFS.HEADER_ID);\r\n    assertNotNull(ntfs);\r\n    assertEquals(TimeUtils.toNtfsTime(time), ntfs.getModifyTime().getLongValue());\r\n    assertEquals(FileTimes.toNtfsTime(accessTime), ntfs.getAccessTime().getLongValue());\r\n    assertEquals(FileTimes.toNtfsTime(creationTime), ntfs.getCreateTime().getLongValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testShouldNotSetInfoZipFieldIfDateExceedsUnixTime",
  "sourceCode" : "@Test\r\nvoid testShouldNotSetInfoZipFieldIfDateExceedsUnixTime() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    final FileTime time = FileTime.from(ZipUtilTest.toLocalInstant(\"2138-11-27T00:00:00\"));\r\n    ze.setTime(time.toMillis());\r\n    assertEquals(time.toMillis(), ze.getTime());\r\n    assertEquals(time, ze.getLastModifiedTime());\r\n    assertNull(ze.getExtraField(X5455_ExtendedTimestamp.HEADER_ID));\r\n    final X000A_NTFS ntfs = (X000A_NTFS) ze.getExtraField(X000A_NTFS.HEADER_ID);\r\n    assertNotNull(ntfs);\r\n    assertEquals(FileTimes.toNtfsTime(time), ntfs.getModifyTime().getLongValue());\r\n    assertEquals(0L, ntfs.getAccessTime().getLongValue());\r\n    assertEquals(0L, ntfs.getCreateTime().getLongValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testShouldSetExtraDateFieldsIfAccessDateIsSet",
  "sourceCode" : "@Test\r\nvoid testShouldSetExtraDateFieldsIfAccessDateIsSet() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    final FileTime lastAccessTime = FileTime.from(Instant.parse(\"2022-12-28T20:39:33.1234567Z\"));\r\n    final long time = Instant.parse(\"2020-03-04T12:34:56.1234567Z\").toEpochMilli();\r\n    ze.setTime(time);\r\n    ze.setLastAccessTime(lastAccessTime);\r\n    assertEquals(time, ze.getTime());\r\n    assertEquals(time, ze.getLastModifiedTime().toMillis());\r\n    final X5455_ExtendedTimestamp extendedTimestamp = (X5455_ExtendedTimestamp) ze.getExtraField(X5455_ExtendedTimestamp.HEADER_ID);\r\n    assertNotNull(extendedTimestamp);\r\n    assertEquals(FileTimes.toUnixTime(lastAccessTime), extendedTimestamp.getAccessTime().getValue());\r\n    assertNull(extendedTimestamp.getCreateTime());\r\n    final X000A_NTFS ntfs = (X000A_NTFS) ze.getExtraField(X000A_NTFS.HEADER_ID);\r\n    assertNotNull(ntfs);\r\n    assertEquals(TimeUtils.toNtfsTime(time), ntfs.getModifyTime().getLongValue());\r\n    assertEquals(FileTimes.toNtfsTime(lastAccessTime), ntfs.getAccessTime().getLongValue());\r\n    assertEquals(0L, ntfs.getCreateTime().getLongValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testShouldSetExtraDateFieldsIfAllDatesAreSet",
  "sourceCode" : "@Test\r\nvoid testShouldSetExtraDateFieldsIfAllDatesAreSet() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    final FileTime accessTime = FileTime.from(Instant.parse(\"2022-12-29T21:40:34.1234567Z\"));\r\n    final FileTime creationTime = FileTime.from(Instant.parse(\"2022-12-28T20:39:33.1234567Z\"));\r\n    final long time = Instant.parse(\"2020-03-04T12:34:56.1234567Z\").toEpochMilli();\r\n    ze.setTime(time);\r\n    ze.setLastAccessTime(accessTime);\r\n    ze.setCreationTime(creationTime);\r\n    assertEquals(time, ze.getTime());\r\n    assertEquals(time, ze.getLastModifiedTime().toMillis());\r\n    final X5455_ExtendedTimestamp extendedTimestamp = (X5455_ExtendedTimestamp) ze.getExtraField(X5455_ExtendedTimestamp.HEADER_ID);\r\n    assertNotNull(extendedTimestamp);\r\n    assertEquals(FileTimes.toUnixTime(accessTime), extendedTimestamp.getAccessTime().getValue());\r\n    assertEquals(FileTimes.toUnixTime(creationTime), extendedTimestamp.getCreateTime().getValue());\r\n    final X000A_NTFS ntfs = (X000A_NTFS) ze.getExtraField(X000A_NTFS.HEADER_ID);\r\n    assertNotNull(ntfs);\r\n    assertEquals(TimeUtils.toNtfsTime(time), ntfs.getModifyTime().getLongValue());\r\n    assertEquals(FileTimes.toNtfsTime(accessTime), ntfs.getAccessTime().getLongValue());\r\n    assertEquals(FileTimes.toNtfsTime(creationTime), ntfs.getCreateTime().getLongValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testShouldSetExtraDateFieldsIfCreationDateIsSet",
  "sourceCode" : "@Test\r\nvoid testShouldSetExtraDateFieldsIfCreationDateIsSet() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    final FileTime creationTime = FileTime.from(Instant.parse(\"2022-12-28T20:39:33.1234567Z\"));\r\n    final long time = Instant.parse(\"2020-03-04T12:34:56.1234567Z\").toEpochMilli();\r\n    ze.setTime(time);\r\n    ze.setCreationTime(creationTime);\r\n    assertEquals(time, ze.getTime());\r\n    assertEquals(time, ze.getLastModifiedTime().toMillis());\r\n    final X5455_ExtendedTimestamp extendedTimestamp = (X5455_ExtendedTimestamp) ze.getExtraField(X5455_ExtendedTimestamp.HEADER_ID);\r\n    assertNotNull(extendedTimestamp);\r\n    assertNull(extendedTimestamp.getAccessTime());\r\n    assertEquals(FileTimes.toUnixTime(creationTime), extendedTimestamp.getCreateTime().getValue());\r\n    final X000A_NTFS ntfs = (X000A_NTFS) ze.getExtraField(X000A_NTFS.HEADER_ID);\r\n    assertNotNull(ntfs);\r\n    assertEquals(TimeUtils.toNtfsTime(time), ntfs.getModifyTime().getLongValue());\r\n    assertEquals(0L, ntfs.getAccessTime().getLongValue());\r\n    assertEquals(FileTimes.toNtfsTime(creationTime), ntfs.getCreateTime().getLongValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testShouldSetExtraDateFieldsIfDateExceedsDosDate",
  "sourceCode" : "@Test\r\nvoid testShouldSetExtraDateFieldsIfDateExceedsDosDate() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    final FileTime time = FileTime.from(ZipUtilTest.toLocalInstant(\"1975-11-27T00:00:00\"));\r\n    ze.setTime(time.toMillis());\r\n    assertEquals(time.toMillis(), ze.getTime());\r\n    assertEquals(time, ze.getLastModifiedTime());\r\n    final X5455_ExtendedTimestamp extendedTimestamp = (X5455_ExtendedTimestamp) ze.getExtraField(X5455_ExtendedTimestamp.HEADER_ID);\r\n    assertNotNull(extendedTimestamp);\r\n    assertEquals(FileTimes.toUnixTime(time), extendedTimestamp.getModifyTime().getValue());\r\n    assertNull(extendedTimestamp.getAccessTime());\r\n    assertNull(extendedTimestamp.getCreateTime());\r\n    final X000A_NTFS ntfs = (X000A_NTFS) ze.getExtraField(X000A_NTFS.HEADER_ID);\r\n    assertNotNull(ntfs);\r\n    assertEquals(FileTimes.toNtfsTime(time), ntfs.getModifyTime().getLongValue());\r\n    assertEquals(0L, ntfs.getAccessTime().getLongValue());\r\n    assertEquals(0L, ntfs.getCreateTime().getLongValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testShouldSetExtraDateFieldsIfModifyDateIsExplicitlySet",
  "sourceCode" : "@Test\r\nvoid testShouldSetExtraDateFieldsIfModifyDateIsExplicitlySet() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    final FileTime time = FileTime.from(Instant.parse(\"2022-12-28T20:39:33.1234567Z\"));\r\n    ze.setLastModifiedTime(time);\r\n    assertEquals(time.toMillis(), ze.getTime());\r\n    assertEquals(time, ze.getLastModifiedTime());\r\n    final X5455_ExtendedTimestamp extendedTimestamp = (X5455_ExtendedTimestamp) ze.getExtraField(X5455_ExtendedTimestamp.HEADER_ID);\r\n    assertNotNull(extendedTimestamp);\r\n    assertEquals(FileTimes.toUnixTime(time), extendedTimestamp.getModifyTime().getValue());\r\n    assertNull(extendedTimestamp.getAccessTime());\r\n    assertNull(extendedTimestamp.getCreateTime());\r\n    final X000A_NTFS ntfs = (X000A_NTFS) ze.getExtraField(X000A_NTFS.HEADER_ID);\r\n    assertNotNull(ntfs);\r\n    assertEquals(FileTimes.toNtfsTime(time), ntfs.getModifyTime().getLongValue());\r\n    assertEquals(0L, ntfs.getAccessTime().getLongValue());\r\n    assertEquals(0L, ntfs.getCreateTime().getLongValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testStrictForKnowExtraFieldsIncludesUnparseableExtraData",
  "sourceCode" : "@Test\r\nvoid testStrictForKnowExtraFieldsIncludesUnparseableExtraData() throws Exception {\r\n    final ZipExtraField[] extraFields = parsingModeBehaviorTestData();\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\r\n    ze.setExtraFields(extraFields);\r\n    final ZipExtraField[] read = ze.getExtraFields(ZipArchiveEntry.ExtraFieldParsingMode.STRICT_FOR_KNOW_EXTRA_FIELDS);\r\n    assertEquals(extraFields.length, read.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testUnixMode",
  "sourceCode" : "@Test\r\nvoid testUnixMode() {\r\n    ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\r\n    assertEquals(0, ze.getPlatform());\r\n    ze.setUnixMode(0755);\r\n    assertEquals(3, ze.getPlatform());\r\n    assertEquals(0755, ze.getExternalAttributes() >> 16 & 0xFFFF);\r\n    assertEquals(0, ze.getExternalAttributes() & 0xFFFF);\r\n    ze.setUnixMode(0444);\r\n    assertEquals(3, ze.getPlatform());\r\n    assertEquals(0444, ze.getExternalAttributes() >> 16 & 0xFFFF);\r\n    assertEquals(1, ze.getExternalAttributes() & 0xFFFF);\r\n    ze = new ZipArchiveEntry(\"foo/\");\r\n    assertEquals(0, ze.getPlatform());\r\n    ze.setUnixMode(0777);\r\n    assertEquals(3, ze.getPlatform());\r\n    assertEquals(0777, ze.getExternalAttributes() >> 16 & 0xFFFF);\r\n    assertEquals(0x10, ze.getExternalAttributes() & 0xFFFF);\r\n    ze.setUnixMode(0577);\r\n    assertEquals(3, ze.getPlatform());\r\n    assertEquals(0577, ze.getExternalAttributes() >> 16 & 0xFFFF);\r\n    assertEquals(0x11, ze.getExternalAttributes() & 0xFFFF);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveEntryTest.java",
  "methodName" : "testZipArchiveClone",
  "sourceCode" : "@Test\r\nvoid testZipArchiveClone() throws Exception {\r\n    try (ZipFile zf = ZipFile.builder().setFile(getFile(\"COMPRESS-479.zip\")).get()) {\r\n        final ZipArchiveEntry ze = zf.getEntry(\"%U20AC_for_Dollar.txt\");\r\n        final ZipArchiveEntry clonedZe = (ZipArchiveEntry) ze.clone();\r\n        assertEquals(ze, clonedZe);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamMalformedTest.java",
  "methodName" : "test",
  "sourceCode" : "/**\r\n * If you want to see a MemoryLimitException, then run with {@code -Xmx64m}.\r\n */\r\n@Test\r\nvoid test() throws IOException {\r\n    final String fixture = \"target/ZipArchiveInputStreamMalformedTest.bin\";\r\n    try (FileOutputStream fos = new FileOutputStream(fixture)) {\r\n        // Local File Header (LFH).\r\n        // size of LFH without filename/extra.\r\n        final ByteBuffer buffer = ByteBuffer.allocate(30);\r\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\r\n        // Local file header signature.\r\n        buffer.putInt(0x04034B50);\r\n        // version needed to extract.\r\n        buffer.putShort((short) 20);\r\n        // general purpose bit flag (bit 3 set).\r\n        buffer.putShort((short) 0x08);\r\n        // compression method.\r\n        buffer.putShort((short) 0);\r\n        // last mod file time.\r\n        buffer.putShort((short) 0);\r\n        // last mod file date.\r\n        buffer.putShort((short) 0);\r\n        // CRC-32.\r\n        buffer.putInt(0);\r\n        // compressed size.\r\n        buffer.putInt(0);\r\n        // uncompressed size.\r\n        buffer.putInt(0);\r\n        // file name length.\r\n        buffer.putShort((short) 1);\r\n        // extra field length.\r\n        buffer.putShort((short) 0);\r\n        fos.write(buffer.array());\r\n        // Filename: \"a\".\r\n        fos.write('a');\r\n        // Payload: 110 MB of 'A'.\r\n        // 1 MB chunk.\r\n        final byte[] chunk = new byte[1024 * 1024];\r\n        Arrays.fill(chunk, (byte) 'A');\r\n        for (int i = 0; i < 110; i++) {\r\n            fos.write(chunk);\r\n        }\r\n    }\r\n    try (ZipArchiveInputStream zis = ZipArchiveInputStream.builder().setFile(fixture).setSupportStoredEntryDataDescriptor(true).get()) {\r\n        zis.getNextEntry();\r\n        assertThrows(CompressException.class, () -> IOUtils.toByteArray(zis));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testDecompressNextSymbol",
  "sourceCode" : "@Test\r\nvoid testDecompressNextSymbol() throws IOException {\r\n    try (ZipArchiveInputStream inputStream = ZipArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/zip/decompressNextSymbol.bin\")).get()) {\r\n        inputStream.getNextEntry();\r\n        assertThrows(IOException.class, inputStream::getNextEntry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testGetCompressedCountEmptyZip",
  "sourceCode" : "@Test\r\nvoid testGetCompressedCountEmptyZip() throws IOException {\r\n    try (ZipArchiveInputStream zin = ZipArchiveInputStream.builder().setByteArray(ArrayUtils.EMPTY_BYTE_ARRAY).get()) {\r\n        assertEquals(-1, zin.getCompressedCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testGetFirstEntryEmptyZip",
  "sourceCode" : "@Test\r\nvoid testGetFirstEntryEmptyZip() throws IOException {\r\n    try (ZipArchiveInputStream zin = ZipArchiveInputStream.builder().setByteArray(ArrayUtils.EMPTY_BYTE_ARRAY).get()) {\r\n        final ZipArchiveEntry entry = zin.getNextEntry();\r\n        assertNull(entry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testGetNextZipEntry",
  "sourceCode" : "@Test\r\nvoid testGetNextZipEntry() throws IOException {\r\n    try (ZipArchiveInputStream inputStream = ZipArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/zip/getNextZipEntry.bin\")).get()) {\r\n        assertThrows(IOException.class, () -> inputStream.forEach(IOConsumer.noop()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testGetUncompressedCountEmptyZip",
  "sourceCode" : "@Test\r\nvoid testGetUncompressedCountEmptyZip() throws IOException {\r\n    try (ZipArchiveInputStream zin = ZipArchiveInputStream.builder().setByteArray(ArrayUtils.EMPTY_BYTE_ARRAY).get()) {\r\n        assertEquals(0, zin.getUncompressedCount());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testMessageWithCorruptFileName",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-351\">COMPRESS-351</a>.\r\n */\r\n@Test\r\nvoid testMessageWithCorruptFileName() throws Exception {\r\n    try (ZipArchiveInputStream in = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-351.zip\")).get()) {\r\n        final EOFException ex = assertThrows(EOFException.class, () -> in.forEach(IOConsumer.noop()));\r\n        final String m = ex.getMessage();\r\n        // the first character is not printable\r\n        assertTrue(m.startsWith(\"Truncated ZIP entry: ?2016\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bzip2-zip.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bla.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-380/COMPRESS-380.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingExplode",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingExplode() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"imploding-8Kdict-3trees.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingStore",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingStore() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-264.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"SHRUNK.ZIP\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testMultiByteReadThrowsAtEofForCorruptedStoredEntry",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadThrowsAtEofForCorruptedStoredEntry() throws Exception {\r\n    final byte[] content = readAllBytes(\"COMPRESS-264.zip\");\r\n    // make size much bigger than entry's real size\r\n    Arrays.fill(content, 17, 26, (byte) 0xff);\r\n    final byte[] buf = new byte[2];\r\n    try (ZipArchiveInputStream archive = ZipArchiveInputStream.builder().setByteArray(content).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        final IOException ex1 = assertThrows(ArchiveException.class, () -> IOUtils.toByteArray(archive), \"expected exception\");\r\n        assertEquals(\"Truncated ZIP file\", ex1.getMessage());\r\n        final IOException ex2 = assertThrows(ArchiveException.class, () -> archive.read(buf), \"expected exception\");\r\n        assertEquals(\"Truncated ZIP file\", ex2.getMessage());\r\n        final IOException ex3 = assertThrows(ArchiveException.class, () -> archive.read(buf), \"expected exception\");\r\n        assertEquals(\"Truncated ZIP file\", ex3.getMessage());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testNameSourceDefaultsToName",
  "sourceCode" : "@Test\r\nvoid testNameSourceDefaultsToName() throws Exception {\r\n    nameSource(\"bla.zip\", \"test1.xml\", ZipArchiveEntry.NameSource.NAME);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testNameSourceIsSetToEFS",
  "sourceCode" : "@Test\r\nvoid testNameSourceIsSetToEFS() throws Exception {\r\n    nameSource(\"utf8-7zip-test.zip\", \"\\u20AC_for_Dollar.txt\", 3, ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testNameSourceIsSetToUnicodeExtraField",
  "sourceCode" : "@Test\r\nvoid testNameSourceIsSetToUnicodeExtraField() throws Exception {\r\n    nameSource(\"utf8-winzip-test.zip\", \"\\u20AC_for_Dollar.txt\", ZipArchiveEntry.NameSource.UNICODE_EXTRA_FIELD);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testOffsets",
  "sourceCode" : "/**\r\n * Test correct population of header and data offsets.\r\n */\r\n@Test\r\nvoid testOffsets() throws Exception {\r\n    // mixed.zip contains both inflated and stored files\r\n    try (ZipArchiveInputStream zipStream = ZipArchiveInputStream.builder().setURI(getURI(\"mixed.zip\")).get()) {\r\n        final ZipArchiveEntry inflatedEntry = zipStream.getNextZipEntry();\r\n        assertEquals(\"inflated.txt\", inflatedEntry.getName());\r\n        assertEquals(0x0000, inflatedEntry.getLocalHeaderOffset());\r\n        assertEquals(0x0046, inflatedEntry.getDataOffset());\r\n        final ZipArchiveEntry storedEntry = zipStream.getNextZipEntry();\r\n        assertEquals(\"stored.txt\", storedEntry.getName());\r\n        assertEquals(0x5892, storedEntry.getLocalHeaderOffset());\r\n        assertEquals(0x58d6, storedEntry.getDataOffset());\r\n        assertNull(zipStream.getNextZipEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testProperlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown",
  "sourceCode" : "@Test\r\nvoid testProperlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown() throws Exception {\r\n    // we never read any data\r\n    try (ZipArchiveInputStream zis = ZipArchiveInputStream.builder().setByteArray(ArrayUtils.EMPTY_BYTE_ARRAY).get()) {\r\n        final ZipArchiveEntry e = new ZipArchiveEntry(\"test\");\r\n        e.setMethod(ZipMethod.DEFLATED.getCode());\r\n        assertTrue(zis.canReadEntryData(e));\r\n        e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());\r\n        assertTrue(zis.canReadEntryData(e));\r\n        e.setMethod(ZipMethod.BZIP2.getCode());\r\n        assertFalse(zis.canReadEntryData(e));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testProperlyReadsStoredEntries",
  "sourceCode" : "@Test\r\nvoid testProperlyReadsStoredEntries() throws IOException {\r\n    try (ZipArchiveInputStream archive = ZipArchiveInputStream.builder().setURI(getURI(\"bla-stored.zip\")).get()) {\r\n        ZipArchiveEntry e = archive.getNextZipEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"test1.xml\", e.getName());\r\n        assertEquals(610, e.getCompressedSize());\r\n        assertEquals(610, e.getSize());\r\n        byte[] data = IOUtils.toByteArray(archive);\r\n        assertEquals(610, data.length);\r\n        e = archive.getNextZipEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"test2.xml\", e.getName());\r\n        assertEquals(82, e.getCompressedSize());\r\n        assertEquals(82, e.getSize());\r\n        data = IOUtils.toByteArray(archive);\r\n        assertEquals(82, data.length);\r\n        assertNull(archive.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testProperlyReadsStoredEntryWithDataDescriptorWithoutSignature",
  "sourceCode" : "@Test\r\nvoid testProperlyReadsStoredEntryWithDataDescriptorWithoutSignature() throws IOException {\r\n    try (ZipArchiveInputStream archive = ZipArchiveInputStream.builder().setURI(getURI(\"bla-stored-dd-nosig.zip\")).setSupportStoredEntryDataDescriptor(true).get()) {\r\n        final ZipArchiveEntry e = archive.getNextZipEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"test1.xml\", e.getName());\r\n        assertEquals(-1, e.getCompressedSize());\r\n        assertEquals(-1, e.getSize());\r\n        final byte[] data = IOUtils.toByteArray(archive);\r\n        assertEquals(610, data.length);\r\n        assertEquals(610, e.getCompressedSize());\r\n        assertEquals(610, e.getSize());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testProperlyReadsStoredEntryWithDataDescriptorWithSignature",
  "sourceCode" : "@Test\r\nvoid testProperlyReadsStoredEntryWithDataDescriptorWithSignature() throws IOException {\r\n    try (ZipArchiveInputStream archive = ZipArchiveInputStream.builder().setURI(getURI(\"bla-stored-dd.zip\")).setSupportStoredEntryDataDescriptor(true).get()) {\r\n        final ZipArchiveEntry e = archive.getNextZipEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"test1.xml\", e.getName());\r\n        assertEquals(-1, e.getCompressedSize());\r\n        assertEquals(-1, e.getSize());\r\n        final byte[] data = IOUtils.toByteArray(archive);\r\n        assertEquals(610, data.length);\r\n        assertEquals(610, e.getCompressedSize());\r\n        assertEquals(610, e.getSize());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testProperUseOfInflater",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-189\"\r\n */\r\n@Test\r\nvoid testProperUseOfInflater() throws Exception {\r\n    try (ZipFile zf = ZipFile.builder().setFile(getFile(\"COMPRESS-189.zip\")).get()) {\r\n        final ZipArchiveEntry zae = zf.getEntry(\"USD0558682-20080101.ZIP\");\r\n        try (ZipArchiveInputStream in = ZipArchiveInputStream.builder().setInputStream(new BufferedInputStream(zf.getInputStream(zae))).get()) {\r\n            ZipArchiveEntry innerEntry;\r\n            while ((innerEntry = in.getNextZipEntry()) != null) {\r\n                if (innerEntry.getName().endsWith(\"XML\")) {\r\n                    assertTrue(0 < in.read());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testReadDeflate64CompressedStream",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-380\"\r\n */\r\n@Test\r\nvoid testReadDeflate64CompressedStream() throws Exception {\r\n    final byte[] orig = readAllBytes(\"COMPRESS-380/COMPRESS-380-input\");\r\n    final File archive = getFile(\"COMPRESS-380/COMPRESS-380.zip\");\r\n    try (ZipArchiveInputStream zin = ZipArchiveInputStream.builder().setFile(archive).get()) {\r\n        assertNotNull(zin.getNextZipEntry());\r\n        final byte[] fromZip = IOUtils.toByteArray(zin);\r\n        assertArrayEquals(orig, fromZip);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testReadDeflate64CompressedStreamWithDataDescriptor",
  "sourceCode" : "@Test\r\nvoid testReadDeflate64CompressedStreamWithDataDescriptor() throws Exception {\r\n    // this is a copy of bla.jar with META-INF/MANIFEST.MF's method manually changed to ENHANCED_DEFLATED\r\n    final File archive = getFile(\"COMPRESS-380/COMPRESS-380-dd.zip\");\r\n    try (ZipArchiveInputStream zin = ZipArchiveInputStream.builder().setFile(archive).get()) {\r\n        final ZipArchiveEntry e = zin.getNextZipEntry();\r\n        assertEquals(-1, e.getSize());\r\n        assertEquals(ZipMethod.ENHANCED_DEFLATED.getCode(), e.getMethod());\r\n        final byte[] fromZip = IOUtils.toByteArray(zin);\r\n        final byte[] expected = { 'M', 'a', 'n', 'i', 'f', 'e', 's', 't', '-', 'V', 'e', 'r', 's', 'i', 'o', 'n', ':', ' ', '1', '.', '0', '\\r', '\\n', '\\r', '\\n' };\r\n        assertArrayEquals(expected, fromZip);\r\n        zin.getNextZipEntry();\r\n        assertEquals(25, e.getSize());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testReadingOfFirstStoredEntry",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-264\">COMPRESS-264</a>.\r\n */\r\n@Test\r\nvoid testReadingOfFirstStoredEntry() throws Exception {\r\n    try (ZipArchiveInputStream in = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-264.zip\")).get()) {\r\n        final ZipArchiveEntry ze = in.getNextZipEntry();\r\n        assertEquals(5, ze.getSize());\r\n        assertArrayEquals(new byte[] { 'd', 'a', 't', 'a', '\\n' }, IOUtils.toByteArray(in));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testRejectsStoredEntriesWithDataDescriptorByDefault",
  "sourceCode" : "@Test\r\nvoid testRejectsStoredEntriesWithDataDescriptorByDefault() throws IOException {\r\n    try (ZipArchiveInputStream archive = ZipArchiveInputStream.builder().setURI(getURI(\"bla-stored-dd.zip\")).get()) {\r\n        final ZipArchiveEntry e = archive.getNextZipEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"test1.xml\", e.getName());\r\n        assertEquals(-1, e.getCompressedSize());\r\n        assertEquals(-1, e.getSize());\r\n        assertThrows(UnsupportedZipFeatureException.class, () -> IOUtils.toByteArray(archive));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testShouldConsumeArchiveCompletely",
  "sourceCode" : "@Test\r\nvoid testShouldConsumeArchiveCompletely() throws Exception {\r\n    try (InputStream is = ZipArchiveInputStreamTest.class.getResourceAsStream(\"/archive_with_trailer.zip\");\r\n        ZipArchiveInputStream zip = ZipArchiveInputStream.builder().setInputStream(is).get()) {\r\n        getAllZipEntries(zip);\r\n        final byte[] expected = { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n' };\r\n        final byte[] actual = new byte[expected.length];\r\n        is.read(actual);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testShouldReadNestedZip",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-219\"\r\n */\r\n@Test\r\nvoid testShouldReadNestedZip() throws IOException {\r\n    try (ZipArchiveInputStream in = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-219.zip\")).get()) {\r\n        extractZipInputStream(in);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSingleArgumentConstructor",
  "sourceCode" : "@Test\r\nvoid testSingleArgumentConstructor() throws Exception {\r\n    final InputStream inputStream = mock(InputStream.class);\r\n    try (ZipArchiveInputStream archiveStream = new ZipArchiveInputStream(inputStream)) {\r\n        assertEquals(StandardCharsets.UTF_8, archiveStream.getCharset());\r\n        assertEquals(true, readDeclaredField(archiveStream, \"useUnicodeExtraFields\", true));\r\n        assertEquals(false, readDeclaredField(archiveStream, \"supportStoredEntryDataDescriptor\", true));\r\n        assertEquals(false, readDeclaredField(archiveStream, \"skipSplitSignature\", true));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bzip2-zip.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bla.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-380/COMPRESS-380.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingExplode",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingExplode() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"imploding-8Kdict-3trees.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingStore",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingStore() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-264.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"SHRUNK.ZIP\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSingleByteReadThrowsAtEofForCorruptedStoredEntry",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadThrowsAtEofForCorruptedStoredEntry() throws Exception {\r\n    final byte[] content = readAllBytes(\"COMPRESS-264.zip\");\r\n    // make size much bigger than entry's real size\r\n    for (int i = 17; i < 26; i++) {\r\n        content[i] = (byte) 0xff;\r\n    }\r\n    try (ZipArchiveInputStream archive = ZipArchiveInputStream.builder().setByteArray(content).get()) {\r\n        assertNotNull(archive.getNextEntry());\r\n        final IOException ex1 = assertThrows(ArchiveException.class, () -> IOUtils.toByteArray(archive), \"expected exception\");\r\n        assertEquals(\"Truncated ZIP file\", ex1.getMessage());\r\n        final IOException ex2 = assertThrows(ArchiveException.class, archive::read, \"expected exception\");\r\n        assertEquals(\"Truncated ZIP file\", ex2.getMessage());\r\n        final IOException ex3 = assertThrows(ArchiveException.class, archive::read, \"expected exception\");\r\n        assertEquals(\"Truncated ZIP file\", ex3.getMessage());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSplitZipCreatedByWinrar",
  "sourceCode" : "@Test\r\nvoid testSplitZipCreatedByWinrar() throws IOException {\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_winrar/split_zip_created_by_winrar.zip\");\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile);\r\n        InputStream inputStream = Channels.newInputStream(channel);\r\n        ZipArchiveInputStream splitInputStream = ZipArchiveInputStream.builder().setInputStream(inputStream).setSkipSplitSignature(true).get()) {\r\n        final File fileToCompare = getFile(\"COMPRESS-477/split_zip_created_by_winrar/zip_to_compare_created_by_winrar.zip\");\r\n        try (ZipArchiveInputStream inputStreamToCompare = ZipArchiveInputStream.builder().setFile(fileToCompare).setSkipSplitSignature(true).get()) {\r\n            ArchiveEntry entry;\r\n            while ((entry = splitInputStream.getNextEntry()) != null && inputStreamToCompare.getNextEntry() != null) {\r\n                if (entry.isDirectory()) {\r\n                    continue;\r\n                }\r\n                assertArrayEquals(IOUtils.toByteArray(splitInputStream), IOUtils.toByteArray(inputStreamToCompare));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSplitZipCreatedByZip",
  "sourceCode" : "@Test\r\nvoid testSplitZipCreatedByZip() throws IOException {\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile);\r\n        InputStream inputStream = Channels.newInputStream(channel);\r\n        ZipArchiveInputStream splitInputStream = ZipArchiveInputStream.builder().setInputStream(inputStream).setSkipSplitSignature(true).get()) {\r\n        final Path fileToCompare = getPath(\"COMPRESS-477/split_zip_created_by_zip/zip_to_compare_created_by_zip.zip\");\r\n        try (ZipArchiveInputStream inputStreamToCompare = new ZipArchiveInputStream(Files.newInputStream(fileToCompare), StandardCharsets.UTF_8.name(), true, false, true)) {\r\n            ArchiveEntry entry;\r\n            while ((entry = splitInputStream.getNextEntry()) != null && inputStreamToCompare.getNextEntry() != null) {\r\n                if (entry.isDirectory()) {\r\n                    continue;\r\n                }\r\n                assertArrayEquals(IOUtils.toByteArray(splitInputStream), IOUtils.toByteArray(inputStreamToCompare));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSplitZipCreatedByZipOfZip64",
  "sourceCode" : "@Test\r\nvoid testSplitZipCreatedByZipOfZip64() throws IOException {\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip_zip64.zip\");\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile);\r\n        InputStream inputStream = Channels.newInputStream(channel);\r\n        ZipArchiveInputStream splitInputStream = ZipArchiveInputStream.builder().setInputStream(inputStream).setSkipSplitSignature(true).get()) {\r\n        final Path fileToCompare = getPath(\"COMPRESS-477/split_zip_created_by_zip/zip_to_compare_created_by_zip_zip64.zip\");\r\n        try (ZipArchiveInputStream inputStreamToCompare = ZipArchiveInputStream.builder().setPath(fileToCompare).setSkipSplitSignature(true).get()) {\r\n            ArchiveEntry entry;\r\n            while ((entry = splitInputStream.getNextEntry()) != null && inputStreamToCompare.getNextEntry() != null) {\r\n                if (entry.isDirectory()) {\r\n                    continue;\r\n                }\r\n                assertArrayEquals(IOUtils.toByteArray(splitInputStream), IOUtils.toByteArray(inputStreamToCompare));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testSplitZipCreatedByZipThrowsException",
  "sourceCode" : "@Test\r\nvoid testSplitZipCreatedByZipThrowsException() throws IOException {\r\n    try (ZipArchiveInputStream inputStream = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\")).setSkipSplitSignature(true).get()) {\r\n        assertThrows(EOFException.class, () -> {\r\n            ArchiveEntry entry = inputStream.getNextEntry();\r\n            while (entry != null) {\r\n                entry = inputStream.getNextEntry();\r\n            }\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testThrowOnInvalidEntry",
  "sourceCode" : "/**\r\n * {@code getNextZipEntry()} should throw a {@code ZipException} rather than return {@code null} when an unexpected structure is encountered.\r\n */\r\n@Test\r\nvoid testThrowOnInvalidEntry() throws Exception {\r\n    try (ZipArchiveInputStream zip = ZipArchiveInputStream.builder().setURI(getURI(\"invalid-zip.zip\")).get()) {\r\n        final ZipException expected = assertThrows(ZipException.class, zip::getNextZipEntry, \"IOException expected\");\r\n        assertTrue(expected.getMessage().contains(\"Cannot find zip signature\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testThrowsIfStoredDDIsDifferentFromLengthRead",
  "sourceCode" : "@Test\r\nvoid testThrowsIfStoredDDIsDifferentFromLengthRead() throws IOException {\r\n    try (ZipArchiveInputStream archive = ZipArchiveInputStream.builder().setURI(getURI(\"bla-stored-dd-contradicts-actualsize.zip\")).setSupportStoredEntryDataDescriptor(true).get()) {\r\n        final ZipArchiveEntry e = archive.getNextZipEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"test1.xml\", e.getName());\r\n        assertEquals(-1, e.getCompressedSize());\r\n        assertEquals(-1, e.getSize());\r\n        assertThrows(ZipException.class, () -> IOUtils.toByteArray(archive));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testThrowsIfStoredDDIsInconsistent",
  "sourceCode" : "@Test\r\nvoid testThrowsIfStoredDDIsInconsistent() throws IOException {\r\n    try (ZipArchiveInputStream archive = ZipArchiveInputStream.builder().setURI(getURI(\"bla-stored-dd-sizes-differ.zip\")).setSupportStoredEntryDataDescriptor(true).get()) {\r\n        final ZipArchiveEntry e = archive.getNextZipEntry();\r\n        assertNotNull(e);\r\n        assertEquals(\"test1.xml\", e.getName());\r\n        assertEquals(-1, e.getCompressedSize());\r\n        assertEquals(-1, e.getSize());\r\n        assertThrows(ZipException.class, () -> IOUtils.toByteArray(archive));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testThrowsIfThereIsNoEocd",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-523\">COMPRESS-523</a>\r\n */\r\n@Test\r\nvoid testThrowsIfThereIsNoEocd() {\r\n    assertThrows(IOException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0xbe, 0x00, 0x00, 0x00, 0xb7, 0xe8, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testThrowsIfZip64ExtraCouldNotBeUnderstood",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-518\">COMPRESS-518</a>\r\n */\r\n@Test\r\nvoid testThrowsIfZip64ExtraCouldNotBeUnderstood() {\r\n    assertThrows(IOException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x03, 0x04, 0x2e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x84, 0xb6, 0xba, 0x46, 0x72, 0xb6, 0xfe, 0x77, 0x63, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x62, 0x62, 0x01, 0x00, 0x09, 0x00, 0x03, 0xe7, 0xce, 0x64, 0x55, 0xf3, 0xce, 0x64, 0x55, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0x5c, 0xf9, 0x01, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00 }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testThrowsIOExceptionIfThereIsCorruptedZip64Extra",
  "sourceCode" : "@Test\r\nvoid testThrowsIOExceptionIfThereIsCorruptedZip64Extra() throws IOException {\r\n    try (ZipArchiveInputStream zipInputStream = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-546.zip\")).get()) {\r\n        assertThrows(IOException.class, () -> getAllZipEntries(zipInputStream));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testUnshrinkEntry",
  "sourceCode" : "@Test\r\nvoid testUnshrinkEntry() throws Exception {\r\n    try (ZipArchiveInputStream in = ZipArchiveInputStream.builder().setURI(getURI(\"SHRUNK.ZIP\")).get()) {\r\n        ZipArchiveEntry entry = in.getNextZipEntry();\r\n        assertEquals(ZipMethod.UNSHRINKING.getCode(), entry.getMethod(), \"method\");\r\n        assertTrue(in.canReadEntryData(entry));\r\n        try (InputStream original = newInputStream(\"test1.xml\")) {\r\n            try {\r\n                assertArrayEquals(IOUtils.toByteArray(original), IOUtils.toByteArray(in));\r\n            } finally {\r\n                original.close();\r\n            }\r\n            entry = in.getNextZipEntry();\r\n            assertEquals(ZipMethod.UNSHRINKING.getCode(), entry.getMethod(), \"method\");\r\n            assertTrue(in.canReadEntryData(entry));\r\n        }\r\n        assertArrayEquals(readAllBytes(\"test2.xml\"), IOUtils.toByteArray(in));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testUnzipBZip2CompressedEntry",
  "sourceCode" : "@Test\r\nvoid testUnzipBZip2CompressedEntry() throws Exception {\r\n    try (ZipArchiveInputStream in = ZipArchiveInputStream.builder().setURI(getURI(\"bzip2-zip.zip\")).get()) {\r\n        final ZipArchiveEntry ze = in.getNextZipEntry();\r\n        assertEquals(42, ze.getSize());\r\n        final byte[] expected = ArrayFill.fill(new byte[42], (byte) 'a');\r\n        assertArrayEquals(expected, IOUtils.toByteArray(in));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testWinzipBackSlashWorkaround",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-176\"\r\n */\r\n@Test\r\nvoid testWinzipBackSlashWorkaround() throws Exception {\r\n    try (ZipArchiveInputStream in = ZipArchiveInputStream.builder().setURI(getURI(\"test-winzip.zip\")).get()) {\r\n        ZipArchiveEntry zae = in.getNextZipEntry();\r\n        zae = in.getNextZipEntry();\r\n        zae = in.getNextZipEntry();\r\n        assertEquals(\"\\u00e4/\", zae.getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testWithBytesAfterData",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-364\">COMPRESS-364</a>.\r\n */\r\n@Test\r\nvoid testWithBytesAfterData() throws Exception {\r\n    final int expectedNumEntries = 2;\r\n    try (ZipArchiveInputStream zip = ZipArchiveInputStream.builder().setURI(getURI(\"archive_with_bytes_after_data.zip\")).get()) {\r\n        int actualNumEntries = 0;\r\n        ZipArchiveEntry zae = zip.getNextZipEntry();\r\n        while (zae != null) {\r\n            actualNumEntries++;\r\n            readEntry(zip, zae);\r\n            zae = zip.getNextZipEntry();\r\n        }\r\n        assertEquals(expectedNumEntries, actualNumEntries);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testWriteZipWithLinks",
  "sourceCode" : "/**\r\n * Tests COMPRESS-689.\r\n */\r\n@Test\r\nvoid testWriteZipWithLinks() throws IOException {\r\n    try (OutputStream output = new FileOutputStream(\"target/zipWithLinks.zip\");\r\n        ZipArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(output)) {\r\n        zipOutputStream.putArchiveEntry(new ZipArchiveEntry(\"original\"));\r\n        zipOutputStream.write(\"original content\".getBytes());\r\n        zipOutputStream.closeArchiveEntry();\r\n        final ZipArchiveEntry entry = new ZipArchiveEntry(\"link\");\r\n        entry.setUnixMode(UnixStat.LINK_FLAG | 0444);\r\n        assertEquals(ZipArchiveEntry.PLATFORM_UNIX, entry.getPlatform());\r\n        assertTrue(entry.isUnixSymlink());\r\n        zipOutputStream.putArchiveEntry(entry);\r\n        zipOutputStream.write(\"original\".getBytes());\r\n        zipOutputStream.closeArchiveEntry();\r\n    }\r\n    // Reads the central directory\r\n    try (ZipFile zipFile = ZipFile.builder().setFile(\"target/zipWithLinks.zip\").get()) {\r\n        assertTrue(zipFile.getEntry(\"link\").isUnixSymlink(), \"'link' detected but it's not sym link\");\r\n        assertFalse(zipFile.getEntry(\"original\").isUnixSymlink(), \"'original' detected but it's not sym link\");\r\n    }\r\n    // Doesn't reads the central directory\r\n    try (ZipArchiveInputStream zipInputStream = ZipArchiveInputStream.builder().setFile(\"target/zipWithLinks.zip\").get()) {\r\n        ZipArchiveEntry entry;\r\n        int entriesCount = 0;\r\n        while ((entry = zipInputStream.getNextEntry()) != null) {\r\n            if (\"link\".equals(entry.getName())) {\r\n                // This information is only set in the central directory\r\n                // assertTrue(entry.isUnixSymlink(), \"'link' detected but it's not sym link\");\r\n            } else {\r\n                assertFalse(entry.isUnixSymlink(), \"'original' detected but it's sym link and should be regular file\");\r\n            }\r\n            entriesCount++;\r\n        }\r\n        assertEquals(2, entriesCount);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testZipArchiveInputStreamSubclassReplacement",
  "sourceCode" : "@Test\r\nvoid testZipArchiveInputStreamSubclassReplacement() throws IOException {\r\n    try (InputStream fs = newInputStream(\"COMPRESS-692/compress-692.zip\");\r\n        AirliftZipArchiveInputStream archive = new AirliftZipArchiveInputStream(fs)) {\r\n        assertFalse(archive.isUsed());\r\n        ZipArchiveEntry e = archive.getNextEntry();\r\n        assertNotNull(e);\r\n        assertEquals(ZipMethod.ZSTD.getCode(), e.getMethod());\r\n        assertEquals(\"dolor.txt\", e.getName());\r\n        assertEquals(635, e.getCompressedSize());\r\n        assertEquals(6066, e.getSize());\r\n        byte[] data = IOUtils.toByteArray(archive);\r\n        assertEquals(6066, data.length);\r\n        assertTrue(archive.isUsed());\r\n        e = archive.getNextEntry();\r\n        assertNotNull(e);\r\n        assertEquals(ZipMethod.ZSTD.getCode(), e.getMethod());\r\n        assertEquals(\"ipsum.txt\", e.getName());\r\n        assertEquals(636, e.getCompressedSize());\r\n        assertEquals(6072, e.getSize());\r\n        data = IOUtils.toByteArray(archive);\r\n        assertEquals(6072, data.length);\r\n        assertNotNull(archive.getNextEntry());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testZipInputStream",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(booleans = { true, false })\r\nvoid testZipInputStream(final boolean allowStoredEntriesWithDataDescriptor) {\r\n    try (ZipArchiveInputStream zIn = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-647/test.zip\")).setUseUnicodeExtraFields(false).setSupportStoredEntryDataDescriptor(allowStoredEntriesWithDataDescriptor).get()) {\r\n        ZipArchiveEntry zae = zIn.getNextEntry();\r\n        while (zae != null) {\r\n            zae = zIn.getNextEntry();\r\n        }\r\n    } catch (final IOException e) {\r\n        // Ignore expected exception\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testZipUsingStoredWithDDAndNoDDSignature",
  "sourceCode" : "@Test\r\nvoid testZipUsingStoredWithDDAndNoDDSignature() throws IOException {\r\n    try (InputStream inputStream = forgeZipInputStream();\r\n        ZipArchiveInputStream zipInputStream = ZipArchiveInputStream.builder().setInputStream(inputStream).setSupportStoredEntryDataDescriptor(true).get()) {\r\n        getAllZipEntries(zipInputStream);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testZipWithBadExtraFields",
  "sourceCode" : "@Test\r\nvoid testZipWithBadExtraFields() throws IOException {\r\n    try (ZipArchiveInputStream zipInputStream = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-548.zip\")).get()) {\r\n        getAllZipEntries(zipInputStream);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testZipWithLongerBeginningGarbage",
  "sourceCode" : "@Test\r\nvoid testZipWithLongerBeginningGarbage() throws IOException {\r\n    final Path path = createTempPath(\"preamble\", \".zip\");\r\n    try (OutputStream fos = Files.newOutputStream(path)) {\r\n        fos.write(\"#!/usr/bin/env some-program with quite a few arguments to make it longer than the local header\\n\".getBytes(StandardCharsets.UTF_8));\r\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(fos)) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(\"file-1.txt\");\r\n            entry.setMethod(ZipEntry.DEFLATED);\r\n            zos.putArchiveEntry(entry);\r\n            zos.writeUtf8(\"entry-content\\n\");\r\n            zos.closeArchiveEntry();\r\n        }\r\n    }\r\n    try (ZipArchiveInputStream zis = ZipArchiveInputStream.builder().setPath(path).get()) {\r\n        final ZipArchiveEntry entry = zis.getNextEntry();\r\n        assertEquals(\"file-1.txt\", entry.getName());\r\n        final byte[] content = IOUtils.toByteArray(zis);\r\n        assertArrayEquals(\"entry-content\\n\".getBytes(StandardCharsets.UTF_8), content);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveInputStreamTest.java",
  "methodName" : "testZipWithShortBeginningGarbage",
  "sourceCode" : "@Test\r\nvoid testZipWithShortBeginningGarbage() throws IOException {\r\n    final Path path = createTempPath(\"preamble\", \".zip\");\r\n    try (OutputStream fos = Files.newOutputStream(path)) {\r\n        fos.write(\"#!/usr/bin/unzip\\n\".getBytes(StandardCharsets.UTF_8));\r\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(fos)) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(\"file-1.txt\");\r\n            entry.setMethod(ZipEntry.DEFLATED);\r\n            zos.putArchiveEntry(entry);\r\n            zos.writeUtf8(\"entry-content\\n\");\r\n            zos.closeArchiveEntry();\r\n        }\r\n    }\r\n    try (ZipArchiveInputStream zis = ZipArchiveInputStream.builder().setPath(path).get()) {\r\n        final ZipArchiveEntry entry = zis.getNextEntry();\r\n        assertEquals(\"file-1.txt\", entry.getName());\r\n        final byte[] content = IOUtils.toByteArray(zis);\r\n        assertArrayEquals(\"entry-content\\n\".getBytes(StandardCharsets.UTF_8), content);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveOutputStreamTest.java",
  "methodName" : "testFileBasics",
  "sourceCode" : "@Test\r\nvoid testFileBasics() throws IOException {\r\n    final ZipArchiveOutputStream ref;\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(createTempFile())) {\r\n        ref = outputStream;\r\n        assertTrue(outputStream.isSeekable());\r\n    }\r\n    assertTrue(ref.isClosed());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveOutputStreamTest.java",
  "methodName" : "testOptionDefaults",
  "sourceCode" : "@Test\r\nvoid testOptionDefaults() throws IOException {\r\n    final ZipArchiveOutputStream ref;\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(createTempFile())) {\r\n        ref = outputStream;\r\n        assertTrue(outputStream.isSeekable());\r\n        outputStream.setComment(\"\");\r\n        outputStream.setLevel(Deflater.DEFAULT_COMPRESSION);\r\n        outputStream.setMethod(ZipEntry.DEFLATED);\r\n        outputStream.setFallbackToUTF8(false);\r\n    }\r\n    assertTrue(ref.isClosed());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveOutputStreamTest.java",
  "methodName" : "testOutputStreamBasics",
  "sourceCode" : "@Test\r\nvoid testOutputStreamBasics() throws IOException {\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(new ByteArrayOutputStream())) {\r\n        assertFalse(outputStream.isSeekable());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipArchiveOutputStreamTest.java",
  "methodName" : "testSetEncoding",
  "sourceCode" : "@Test\r\nvoid testSetEncoding() throws IOException {\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(createTempFile())) {\r\n        outputStream.setEncoding(StandardCharsets.UTF_8.name());\r\n        assertEquals(StandardCharsets.UTF_8.name(), outputStream.getEncoding());\r\n        outputStream.setEncoding(null);\r\n        assertEquals(Charset.defaultCharset().name(), outputStream.getEncoding());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipClassCoverageTest.java",
  "methodName" : "testConstantConstructor",
  "sourceCode" : "@Test\r\nvoid testConstantConstructor() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\r\n    final Class<ZipConstants> clazz = ZipConstants.class;\r\n    final Constructor<ZipConstants> constructor = clazz.getDeclaredConstructor();\r\n    assertFalse(constructor.isAccessible());\r\n    constructor.setAccessible(true);\r\n    final Object o = constructor.newInstance();\r\n    assertInstanceOf(clazz, o);\r\n    constructor.setAccessible(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipClassCoverageTest.java",
  "methodName" : "testConstructZip64RequiredException",
  "sourceCode" : "@Test\r\nvoid testConstructZip64RequiredException() {\r\n    final Zip64RequiredException e = new Zip64RequiredException(\"critique of pure\");\r\n    assertNotNull(e);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipClassCoverageTest.java",
  "methodName" : "testMessageException",
  "sourceCode" : "@Test\r\nvoid testMessageException() {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry(\"hello\");\r\n    final String entryTooBigMessage = Zip64RequiredException.getEntryTooBigMessage(ze);\r\n    assertEquals(\"hello's size exceeds the limit of 4GByte.\", entryTooBigMessage);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipCompressMethodXzTest.java",
  "methodName" : "testXzInputStream",
  "sourceCode" : "@Test\r\nvoid testXzInputStream() throws IOException {\r\n    // The file test-method-xz.zip was created with:\r\n    // \"\\Program Files\\7-Zip\\7z.exe\" a test-method-xz.zip -mm=xz LICENSE.txt\r\n    // The \"mm\" option specifies the compress method\r\n    final Path file = getPath(\"org/apache/commons/compress/zip/test-method-xz.zip\");\r\n    try (ZipFile zip = ZipFile.builder().setPath(file).get()) {\r\n        final ZipArchiveEntry entry = zip.getEntries().nextElement();\r\n        assertEquals(\"LICENSE.txt\", entry.getName());\r\n        assertTrue(zip.canReadEntryData(entry));\r\n        assertEquals(ZipMethod.XZ.getCode(), entry.getMethod());\r\n        try (InputStream inputStream = zip.getInputStream(entry)) {\r\n            final long actualSize = entry.getSize();\r\n            final byte[] buf = new byte[(int) actualSize];\r\n            inputStream.read(buf);\r\n            final String text = new String(buf);\r\n            assertTrue(text.startsWith(\"                                 Apache License\"), text);\r\n            assertTrue(text.endsWith(\"   limitations under the License.\\n\"), text);\r\n            assertEquals(11357, text.length());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipCompressMethodXzTest.java",
  "methodName" : "testXzMethodInZipFile",
  "sourceCode" : "@Test\r\nvoid testXzMethodInZipFile() throws IOException {\r\n    final String zipContentFile = \"testXzMethodInZipFile.txt\";\r\n    final byte[] text = \"The quick brown fox jumps over the lazy dog\".getBytes(StandardCharsets.UTF_8);\r\n    final Path file = tempDir.resolve(\"testXzMethodInZipFile.zip\");\r\n    // Create the Zip File\r\n    try (ZipArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(file)) {\r\n        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(zipContentFile);\r\n        archiveEntry.setMethod(ZipMethod.XZ.getCode());\r\n        archiveEntry.setSize(text.length);\r\n        zipOutputStream.putArchiveEntry(archiveEntry);\r\n        compress(new ByteArrayInputStream(text), zipOutputStream);\r\n        zipOutputStream.closeArchiveEntry();\r\n    }\r\n    // Read the Zip File\r\n    try (ZipFile zipFile = ZipFile.builder().setPath(file).get()) {\r\n        // Find the entry\r\n        final ZipArchiveEntry entry = zipFile.getEntry(zipContentFile);\r\n        // Check the compression method\r\n        assertEquals(entry.getMethod(), ZipMethod.XZ.getCode());\r\n        @SuppressWarnings(\"resource\")\r\n        final InputStream inputStream = zipFile.getInputStream(entry);\r\n        assertTrue(inputStream instanceof XZCompressorInputStream);\r\n        final long dataOffset = entry.getDataOffset();\r\n        final int uncompressedSize = (int) entry.getSize();\r\n        assertEquals(text.length, uncompressedSize);\r\n        final byte[] uncompressedData = new byte[uncompressedSize];\r\n        inputStream.read(uncompressedData, 0, uncompressedSize);\r\n        // Check the uncompressed data\r\n        assertEquals(new String(text), new String(uncompressedData));\r\n        try (InputStream fileInputStream = Files.newInputStream(file)) {\r\n            fileInputStream.skip(dataOffset);\r\n            final byte[] compressedData = new byte[6];\r\n            fileInputStream.read(compressedData);\r\n            assertTrue(XZUtils.matches(compressedData, 6));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipCompressMethodXzTest.java",
  "methodName" : "testXzMethodWriteRead",
  "sourceCode" : "@Test\r\nvoid testXzMethodWriteRead() throws IOException {\r\n    final String zipContentFile = \"testXzMethodWriteRead.txt\";\r\n    final byte[] text = \"The quick brown fox jumps over the lazy dog\".getBytes(StandardCharsets.UTF_8);\r\n    final Path file = tempDir.resolve(\"testXzMethodWriteRead.zip\");\r\n    // Create the Zip File\r\n    try (ZipArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(file)) {\r\n        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(zipContentFile);\r\n        archiveEntry.setMethod(ZipMethod.XZ.getCode());\r\n        archiveEntry.setSize(text.length);\r\n        zipOutputStream.putArchiveEntry(archiveEntry);\r\n        compress(new ByteArrayInputStream(text), zipOutputStream);\r\n        zipOutputStream.closeArchiveEntry();\r\n    }\r\n    // Read the Zip File\r\n    try (ZipFile zipFile = ZipFile.builder().setPath(file).get()) {\r\n        // Find the entry\r\n        final ZipArchiveEntry entry = zipFile.getEntry(zipContentFile);\r\n        // Check the compression method\r\n        assertEquals(entry.getMethod(), ZipMethod.XZ.getCode());\r\n        @SuppressWarnings(\"resource\")\r\n        final InputStream inputStream = zipFile.getInputStream(entry);\r\n        assertTrue(inputStream instanceof XZCompressorInputStream);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipCompressMethodZstdTest.java",
  "methodName" : "testZstdInputStream",
  "sourceCode" : "@Test\r\nvoid testZstdInputStream() throws IOException {\r\n    final Path file = getPath(\"COMPRESS-692/compress-692.zip\");\r\n    try (ZipFile zip = ZipFile.builder().setFile(file.toFile()).get()) {\r\n        final ZipArchiveEntry entry = zip.getEntries().nextElement();\r\n        assertEquals(\"Unexpected first entry\", \"dolor.txt\", entry.getName());\r\n        assertTrue(\"entry can't be read\", zip.canReadEntryData(entry));\r\n        assertEquals(\"Unexpected method\", ZipMethod.ZSTD.getCode(), entry.getMethod());\r\n        try (InputStream inputStream = zip.getInputStream(entry)) {\r\n            final long uncompSize = entry.getSize();\r\n            final byte[] buf = new byte[(int) uncompSize];\r\n            inputStream.read(buf);\r\n            final String uncompData = new String(buf);\r\n            assertTrue(uncompData.startsWith(\"dolor sit amet\"));\r\n            assertTrue(uncompData.endsWith(\"ex ea commodo\"));\r\n            assertEquals(6066, uncompData.length());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipCompressMethodZstdTest.java",
  "methodName" : "testZstdMethod",
  "sourceCode" : "@ParameterizedTest\r\n@EnumSource(names = { \"ZSTD\", \"ZSTD_DEPRECATED\" })\r\nvoid testZstdMethod(final ZipMethod zipMethod) throws IOException {\r\n    final String zipContentFile = \"Name.txt\";\r\n    final byte[] simpleText = \"This is a Simple Test File.\".getBytes();\r\n    final File file = Files.createTempFile(\"\", \".zip\").toFile();\r\n    // Create the Zip File\r\n    try (ZipArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(file)) {\r\n        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(zipContentFile);\r\n        archiveEntry.setMethod(zipMethod.getCode());\r\n        archiveEntry.setSize(simpleText.length);\r\n        zipOutputStream.putArchiveEntry(archiveEntry);\r\n        ZipCompressMethodZstdTest.compress(new ByteArrayInputStream(simpleText), zipOutputStream);\r\n        zipOutputStream.closeArchiveEntry();\r\n    }\r\n    // Read the Zip File\r\n    try (ZipFile zipFile = ZipFile.builder().setFile(file).get()) {\r\n        // Find the entry\r\n        final ZipArchiveEntry entry = zipFile.getEntry(zipContentFile);\r\n        // Check the Zstd compression method\r\n        assertEquals(entry.getMethod(), zipMethod.getCode());\r\n        final InputStream inputStream = zipFile.getInputStream(entry);\r\n        assertTrue(\"Input stream must be a ZstdInputStream\", inputStream instanceof ZstdCompressorInputStream);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipCompressMethodZstdTest.java",
  "methodName" : "testZstdMethodInZipFile",
  "sourceCode" : "@ParameterizedTest\r\n@EnumSource(names = { \"ZSTD\", \"ZSTD_DEPRECATED\" })\r\nvoid testZstdMethodInZipFile(final ZipMethod zipMethod) throws IOException {\r\n    final String zipContentFile = \"Name.txt\";\r\n    final byte[] simpleText = \"This is a Simple Test File.\".getBytes();\r\n    final File file = Files.createTempFile(\"\", \".zip\").toFile();\r\n    // Create the Zip File\r\n    try (ZipArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(file)) {\r\n        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(zipContentFile);\r\n        archiveEntry.setMethod(zipMethod.getCode());\r\n        archiveEntry.setSize(simpleText.length);\r\n        zipOutputStream.putArchiveEntry(archiveEntry);\r\n        ZipCompressMethodZstdTest.compress(new ByteArrayInputStream(simpleText), zipOutputStream);\r\n        zipOutputStream.closeArchiveEntry();\r\n    }\r\n    // Read the Zip File\r\n    try (ZipFile zipFile = ZipFile.builder().setFile(file).get()) {\r\n        // Find the entry\r\n        final ZipArchiveEntry entry = zipFile.getEntry(zipContentFile);\r\n        // Check the Zstd compression method\r\n        assertEquals(entry.getMethod(), zipMethod.getCode());\r\n        final InputStream inputStream = zipFile.getInputStream(entry);\r\n        assertTrue(inputStream instanceof ZstdCompressorInputStream);\r\n        final long dataOffset = entry.getDataOffset();\r\n        final int uncompressedSize = (int) entry.getSize();\r\n        assertEquals(simpleText.length, uncompressedSize);\r\n        final byte[] uncompressedData = new byte[uncompressedSize];\r\n        inputStream.read(uncompressedData, 0, uncompressedSize);\r\n        // Check the uncompressed data\r\n        assertEquals(new String(simpleText), new String(uncompressedData));\r\n        try (FileInputStream fileInputStream = new FileInputStream(file)) {\r\n            fileInputStream.skip(dataOffset);\r\n            final byte[] compressedData = new byte[4];\r\n            fileInputStream.read(compressedData);\r\n            assertTrue(\"Compressed data must begin with the magic bytes of Zstd\", ZstdUtils.matches(compressedData, 4));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testBIFromBytes",
  "sourceCode" : "/**\r\n * Tests conversion from bytes.\r\n */\r\n@Test\r\nvoid testBIFromBytes() {\r\n    final byte[] val = { (byte) 0xFE, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF };\r\n    final ZipEightByteInteger zl = new ZipEightByteInteger(val);\r\n    assertEquals(BigInteger.valueOf(Long.MAX_VALUE).shiftLeft(1), zl.getValue(), \"value from bytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testBIFromMaxValue",
  "sourceCode" : "/**\r\n * Tests conversion from max value.\r\n */\r\n@Test\r\nvoid testBIFromMaxValue() {\r\n    // https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\r\n    // 4.4.1.1 All fields unless otherwise noted are unsigned and stored in Intel low-byte:high-byte, low-word:high-word order.\r\n    final ZipEightByteInteger zipEightByteInteger = newMaxValue();\r\n    assertEquals(\"18446744073709551615\", zipEightByteInteger.getValue().toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testBILongFromBytes",
  "sourceCode" : "/**\r\n * Tests conversion from bytes.\r\n */\r\n@Test\r\nvoid testBILongFromBytes() {\r\n    final ZipEightByteInteger zl = newMaxValue();\r\n    assertEquals(0XFFFFFFFFFFFFFFFFL, zl.getLongValue(), \"longValue from bytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testBIToBytes",
  "sourceCode" : "/**\r\n * Tests conversion to bytes.\r\n */\r\n@Test\r\nvoid testBIToBytes() {\r\n    final byte[] result = getBytes(new ZipEightByteInteger(BigInteger.valueOf(Long.MAX_VALUE).shiftLeft(1)));\r\n    assertEquals((byte) 0xFE, result[0], \"first byte getBytes\");\r\n    assertEquals((byte) 0xFF, result[1], \"second byte getBytes\");\r\n    assertEquals((byte) 0xFF, result[2], \"third byte getBytes\");\r\n    assertEquals((byte) 0xFF, result[3], \"fourth byte getBytes\");\r\n    assertEquals((byte) 0xFF, result[4], \"fifth byte getBytes\");\r\n    assertEquals((byte) 0xFF, result[5], \"sixth byte getBytes\");\r\n    assertEquals((byte) 0xFF, result[6], \"seventh byte getBytes\");\r\n    assertEquals((byte) 0xFF, result[7], \"eighth byte getBytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testEquals",
  "sourceCode" : "/**\r\n * Tests the contract of the equals method.\r\n */\r\n@Test\r\nvoid testEquals() {\r\n    final ZipEightByteInteger zl = new ZipEightByteInteger(0x12345678);\r\n    final ZipEightByteInteger zl2 = new ZipEightByteInteger(0x12345678);\r\n    final ZipEightByteInteger zl3 = new ZipEightByteInteger(0x87654321);\r\n    assertEquals(zl, zl, \"reflexive\");\r\n    assertEquals(zl, zl2, \"works\");\r\n    assertNotEquals(zl, zl3, \"works, part two\");\r\n    assertEquals(zl2, zl, \"symmetric\");\r\n    assertNotEquals(null, zl, \"null handling\");\r\n    assertNotEquals(zl, Integer.valueOf(0x1234), \"non ZipEightByteInteger handling\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testLongFromBytes",
  "sourceCode" : "/**\r\n * Tests conversion from bytes.\r\n */\r\n@Test\r\nvoid testLongFromBytes() {\r\n    final byte[] val = { 0x78, 0x56, 0x34, 0x12, (byte) 0xAB, 0x00, 0x00, 0x00 };\r\n    final ZipEightByteInteger zl = new ZipEightByteInteger(val);\r\n    assertEquals(0xAB12345678L, zl.getLongValue(), \"longValue from bytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testLongToBytes",
  "sourceCode" : "/**\r\n * Tests conversion to bytes.\r\n */\r\n@Test\r\nvoid testLongToBytes() {\r\n    final byte[] result = getBytes(new ZipEightByteInteger(0xAB12345678L));\r\n    assertEquals(8, result.length, \"length getBytes\");\r\n    assertEquals(0x78, result[0], \"first byte getBytes\");\r\n    assertEquals(0x56, result[1], \"second byte getBytes\");\r\n    assertEquals(0x34, result[2], \"third byte getBytes\");\r\n    assertEquals(0x12, result[3], \"fourth byte getBytes\");\r\n    assertEquals((byte) 0xAB, result[4], \"fifth byte getBytes\");\r\n    assertEquals(0, result[5], \"sixth byte getBytes\");\r\n    assertEquals(0, result[6], \"seventh byte getBytes\");\r\n    assertEquals(0, result[7], \"eighth byte getBytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testSign",
  "sourceCode" : "/**\r\n * Tests sign handling.\r\n */\r\n@Test\r\nvoid testSign() {\r\n    assertEquals(BigInteger.valueOf(Long.MAX_VALUE).shiftLeft(1).setBit(0), newMaxValue().getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testToString",
  "sourceCode" : "/**\r\n * Tests {@link ZipEightByteInteger#toString()}.\r\n */\r\n@Test\r\nvoid testToString() {\r\n    assertEquals(\"0\", ZipEightByteInteger.ZERO.toString());\r\n    assertEquals(\"0\", ZipEightByteInteger.getValue(new byte[ZipEightByteInteger.BYTES]).toString());\r\n    assertEquals(Long.toString(Long.MAX_VALUE), new ZipEightByteInteger(BigInteger.valueOf(Long.MAX_VALUE)).toString());\r\n    assertEquals(\"18446744073709551615\", newMaxValue().toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEightByteIntegerTest.java",
  "methodName" : "testToUnsignedBigInteger",
  "sourceCode" : "/**\r\n * Tests {@link ZipEightByteInteger#toUnsignedBigInteger(long)}.\r\n */\r\n@Test\r\nvoid testToUnsignedBigInteger() {\r\n    assertEquals(BigInteger.valueOf(Long.MAX_VALUE), ZipEightByteInteger.toUnsignedBigInteger(Long.MAX_VALUE));\r\n    assertEquals(BigInteger.valueOf(Long.MAX_VALUE).shiftLeft(1), ZipEightByteInteger.toUnsignedBigInteger(0XFFFFFFFFFFFFFFFEL));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingHelperTest.java",
  "methodName" : "testGetZipEncodingForDefault",
  "sourceCode" : "@Test\r\nvoid testGetZipEncodingForDefault() {\r\n    assertEquals(Charset.defaultCharset(), ((NioZipEncoding) ZipEncodingHelper.getZipEncoding(Charset.defaultCharset().name())).getCharset());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingHelperTest.java",
  "methodName" : "testGetZipEncodingForIllegalName",
  "sourceCode" : "@Test\r\nvoid testGetZipEncodingForIllegalName() {\r\n    assertEquals(Charset.defaultCharset(), ((NioZipEncoding) ZipEncodingHelper.getZipEncoding(\"\")).getCharset());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingHelperTest.java",
  "methodName" : "testGetZipEncodingForNull",
  "sourceCode" : "@Test\r\nvoid testGetZipEncodingForNull() {\r\n    assertEquals(Charset.defaultCharset(), ((NioZipEncoding) ZipEncodingHelper.getZipEncoding((Charset) null)).getCharset());\r\n    assertEquals(Charset.defaultCharset(), ((NioZipEncoding) ZipEncodingHelper.getZipEncoding((String) null)).getCharset());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingHelperTest.java",
  "methodName" : "testGetZipEncodingForUnknown",
  "sourceCode" : "@Test\r\nvoid testGetZipEncodingForUnknown() {\r\n    assertEquals(Charset.defaultCharset(), ((NioZipEncoding) ZipEncodingHelper.getZipEncoding(\"X\")).getCharset());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingTest.java",
  "methodName" : "testEbcidic",
  "sourceCode" : "@Test\r\nvoid testEbcidic() throws IOException {\r\n    doSimpleEncodingTest(\"IBM1047\", null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingTest.java",
  "methodName" : "testGetNonexistentEncoding",
  "sourceCode" : "@Test\r\nvoid testGetNonexistentEncoding() {\r\n    final ZipEncoding ze = ZipEncodingHelper.getZipEncoding(\"I-am-a-banana\");\r\n    assertNotNull(ze);\r\n    if (ze instanceof CharsetAccessor) {\r\n        final CharsetAccessor hasCharset = (CharsetAccessor) ze;\r\n        Assertions.assertEquals(Charset.defaultCharset(), hasCharset.getCharset());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingTest.java",
  "methodName" : "testNioCp1252Encoding",
  "sourceCode" : "@Test\r\nvoid testNioCp1252Encoding() throws IOException {\r\n    // CP1252 has some undefined code points, these are\r\n    // the defined ones\r\n    // retrieved by\r\n    // awk '/^0x/ && NF>2 {print $1;}' CP1252.TXT\r\n    final byte[] b = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, (byte) 0x80, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x8A, (byte) 0x8B, (byte) 0x8C, (byte) 0x8E, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9A, (byte) 0x9B, (byte) 0x9C, (byte) 0x9E, (byte) 0x9F, (byte) 0xA0, (byte) 0xA1, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0xAA, (byte) 0xAB, (byte) 0xAC, (byte) 0xAD, (byte) 0xAE, (byte) 0xAF, (byte) 0xB0, (byte) 0xB1, (byte) 0xB2, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0xB6, (byte) 0xB7, (byte) 0xB8, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0xBD, (byte) 0xBE, (byte) 0xBF, (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF, (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF };\r\n    doSimpleEncodingTest(\"Cp1252\", b);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingTest.java",
  "methodName" : "testNothingToMakeCoverallsHappier",
  "sourceCode" : "@Test\r\nvoid testNothingToMakeCoverallsHappier() {\r\n    final Object o = new ZipEncodingHelper() {\r\n    };\r\n    assertNotNull(o);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingTest.java",
  "methodName" : "testSimpleCp437Encoding",
  "sourceCode" : "@Test\r\nvoid testSimpleCp437Encoding() throws IOException {\r\n    doSimpleEncodingsTest(437);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipEncodingTest.java",
  "methodName" : "testSimpleCp850Encoding",
  "sourceCode" : "@Test\r\nvoid testSimpleCp850Encoding() throws IOException {\r\n    doSimpleEncodingsTest(850);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileIgnoringLocalFileHeaderTest.java",
  "methodName" : "testDuplicateEntry",
  "sourceCode" : "@Test\r\nvoid testDuplicateEntry() throws Exception {\r\n    try (ZipFile zf = openZipWithoutLocalFileHeader(\"COMPRESS-227.zip\")) {\r\n        int numberOfEntries = 0;\r\n        for (final ZipArchiveEntry entry : zf.getEntries(\"test1.txt\")) {\r\n            numberOfEntries++;\r\n            try (InputStream inputStream = zf.getInputStream(entry)) {\r\n                assertNotNull(inputStream);\r\n            }\r\n        }\r\n        assertEquals(2, numberOfEntries);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileIgnoringLocalFileHeaderTest.java",
  "methodName" : "testGetEntryWorks",
  "sourceCode" : "@Test\r\nvoid testGetEntryWorks() throws IOException {\r\n    try (ZipFile zf = openZipWithoutLocalFileHeader(\"bla.zip\")) {\r\n        final ZipArchiveEntry ze = zf.getEntry(\"test1.xml\");\r\n        assertEquals(610, ze.getSize());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileIgnoringLocalFileHeaderTest.java",
  "methodName" : "testGetRawInputStreamReturnsNotNull",
  "sourceCode" : "@Test\r\nvoid testGetRawInputStreamReturnsNotNull() throws IOException {\r\n    try (ZipFile zf = openZipWithoutLocalFileHeader(\"bla.zip\")) {\r\n        final ZipArchiveEntry ze = zf.getEntry(\"test1.xml\");\r\n        try (InputStream rawInputStream = zf.getRawInputStream(ze)) {\r\n            assertNotNull(rawInputStream);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileIgnoringLocalFileHeaderTest.java",
  "methodName" : "testPhysicalOrder",
  "sourceCode" : "@Test\r\nvoid testPhysicalOrder() throws IOException {\r\n    try (ZipFile zf = openZipWithoutLocalFileHeader(\"ordertest.zip\")) {\r\n        final Enumeration<ZipArchiveEntry> e = zf.getEntriesInPhysicalOrder();\r\n        ZipArchiveEntry ze;\r\n        do {\r\n            ze = e.nextElement();\r\n        } while (e.hasMoreElements());\r\n        assertEquals(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\", ze.getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileIgnoringLocalFileHeaderTest.java",
  "methodName" : "testZipUnarchive",
  "sourceCode" : "/**\r\n * Simple unarchive test. Asserts nothing.\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testZipUnarchive() throws Exception {\r\n    try (ZipFile zipFile = openZipWithoutLocalFileHeaderDeprecated(\"bla.zip\")) {\r\n        zipFile.stream().forEach(entry -> {\r\n            try (InputStream inputStream = zipFile.getInputStream(entry)) {\r\n                Files.copy(inputStream, new File(dir, entry.getName()).toPath());\r\n            }\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testAlternativeZstdInputStream",
  "sourceCode" : "@Test\r\nvoid testAlternativeZstdInputStream() throws Exception {\r\n    final File archive = getFile(\"COMPRESS-692/compress-692.zip\");\r\n    try (AirliftZstdZipFile zf = new AirliftZstdZipFile(archive)) {\r\n        final byte[] buffer = new byte[7000];\r\n        final ZipArchiveEntry ze = zf.getEntry(\"dolor.txt\");\r\n        assertNotNull(ze);\r\n        try (InputStream inputStream = zf.getInputStream(ze)) {\r\n            assertNotNull(inputStream);\r\n            assertFalse(zf.isUsed());\r\n            final int bytesRead = org.apache.commons.compress.utils.IOUtils.readFully(inputStream, buffer);\r\n            assertEquals(6066, bytesRead);\r\n            assertTrue(zf.isUsed());\r\n        }\r\n    }\r\n    try (ZipFile builtZipFile = ZipFile.builder().setPath(archive.getAbsolutePath()).setZstdInputStreamFactory(ZstdInputStream::new).get()) {\r\n        final byte[] buffer = new byte[7000];\r\n        final ZipArchiveEntry ze = builtZipFile.getEntry(\"dolor.txt\");\r\n        assertNotNull(ze);\r\n        try (InputStream inputStream = builtZipFile.getInputStream(ze)) {\r\n            assertTrue(inputStream instanceof ZstdInputStream);\r\n            assertNotNull(inputStream);\r\n            final int bytesRead = org.apache.commons.compress.utils.IOUtils.readFully(inputStream, buffer);\r\n            assertEquals(6066, bytesRead);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testBuidlerGet",
  "sourceCode" : "@Test\r\nvoid testBuidlerGet() throws IOException {\r\n    assertThrows(ZipException.class, () -> ZipFile.builder().setPath(\"src/test/resources/org/apache/commons/compress/zip/getNextZipEntry.bin\").get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testCDOrder",
  "sourceCode" : "@Test\r\nvoid testCDOrder() throws Exception {\r\n    readOrderTest();\r\n    testCDOrderInMemory();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testCDOrderInMemory",
  "sourceCode" : "@Test\r\nvoid testCDOrderInMemory() throws Exception {\r\n    final byte[] data = readAllBytes(\"ordertest.zip\");\r\n    zf = ZipFile.builder().setByteArray(data).setCharset(StandardCharsets.UTF_8).get();\r\n    testCDOrderInMemory(zf);\r\n    try (SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data)) {\r\n        zf = ZipFile.builder().setSeekableByteChannel(channel).setCharset(StandardCharsets.UTF_8).get();\r\n        testCDOrderInMemory(zf);\r\n    }\r\n    try (SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data)) {\r\n        zf = new ZipFile(channel, StandardCharsets.UTF_8.name());\r\n        testCDOrderInMemory(zf);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testConcurrentReadFile",
  "sourceCode" : "@Test\r\nvoid testConcurrentReadFile() throws Exception {\r\n    // mixed.zip contains both inflated and stored files\r\n    final File archive = getFile(\"mixed.zip\");\r\n    zf = new ZipFile(archive);\r\n    final Map<String, byte[]> content = new HashMap<>();\r\n    zf.stream().forEach(entry -> {\r\n        try (InputStream inputStream = zf.getInputStream(entry)) {\r\n            content.put(entry.getName(), IOUtils.toByteArray(inputStream));\r\n        }\r\n    });\r\n    final AtomicInteger passedCount = new AtomicInteger();\r\n    final IORunnable run = () -> {\r\n        zf.stream().forEach(entry -> assertAllReadMethods(content.get(entry.getName()), zf, entry));\r\n        passedCount.incrementAndGet();\r\n    };\r\n    final Thread t0 = new Thread(run.asRunnable());\r\n    final Thread t1 = new Thread(run.asRunnable());\r\n    t0.start();\r\n    t1.start();\r\n    t0.join();\r\n    t1.join();\r\n    assertEquals(2, passedCount.get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testConcurrentReadSeekable",
  "sourceCode" : "@Test\r\nvoid testConcurrentReadSeekable() throws Exception {\r\n    // mixed.zip contains both inflated and stored files\r\n    final byte[] data;\r\n    try (InputStream fis = newInputStream(\"mixed.zip\")) {\r\n        data = IOUtils.toByteArray(fis);\r\n    }\r\n    try (SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data)) {\r\n        zf = ZipFile.builder().setSeekableByteChannel(channel).setCharset(StandardCharsets.UTF_8).get();\r\n        final Map<String, byte[]> content = new HashMap<>();\r\n        zf.stream().forEach(entry -> {\r\n            try (InputStream inputStream = zf.getInputStream(entry)) {\r\n                content.put(entry.getName(), IOUtils.toByteArray(inputStream));\r\n            }\r\n        });\r\n        final AtomicInteger passedCount = new AtomicInteger();\r\n        final IORunnable run = () -> {\r\n            zf.stream().forEach(entry -> assertAllReadMethods(content.get(entry.getName()), zf, entry));\r\n            passedCount.incrementAndGet();\r\n        };\r\n        final Thread t0 = new Thread(run.asRunnable());\r\n        final Thread t1 = new Thread(run.asRunnable());\r\n        t0.start();\r\n        t1.start();\r\n        t0.join();\r\n        t1.join();\r\n        assertEquals(2, passedCount.get());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testCreateBoundedInputStream",
  "sourceCode" : "@Test\r\nvoid testCreateBoundedInputStream() throws IOException {\r\n    try (ZipFile zipFile = ZipFile.builder().setPath(\"src/test/resources/org/apache/commons/compress/zip/createBoundedInputStream.bin\").get()) {\r\n        for (final ZipArchiveEntry entry : Collections.list(zipFile.getEntries())) {\r\n            assertThrows(ArchiveException.class, () -> zipFile.getInputStream(entry));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testDelayedOffsetsAndSizes",
  "sourceCode" : "/**\r\n * Test correct population of header and data offsets when they are written after stream.\r\n */\r\n@Test\r\nvoid testDelayedOffsetsAndSizes() throws Exception {\r\n    final ByteArrayOutputStream zipContent = new ByteArrayOutputStream();\r\n    try (ZipArchiveOutputStream zipOutput = new ZipArchiveOutputStream(zipContent)) {\r\n        final ZipArchiveEntry inflatedEntry = new ZipArchiveEntry(\"inflated.txt\");\r\n        inflatedEntry.setMethod(ZipEntry.DEFLATED);\r\n        zipOutput.putArchiveEntry(inflatedEntry);\r\n        zipOutput.write(\"Hello Deflated\\n\".getBytes());\r\n        zipOutput.closeArchiveEntry();\r\n        final byte[] storedContent = \"Hello Stored\\n\".getBytes();\r\n        final ZipArchiveEntry storedEntry = new ZipArchiveEntry(\"stored.txt\");\r\n        storedEntry.setMethod(ZipEntry.STORED);\r\n        storedEntry.setSize(storedContent.length);\r\n        storedEntry.setCrc(calculateCrc32(storedContent));\r\n        zipOutput.putArchiveEntry(storedEntry);\r\n        zipOutput.write(\"Hello Stored\\n\".getBytes());\r\n        zipOutput.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zf = ZipFile.builder().setByteArray(zipContent.toByteArray()).get()) {\r\n        final ZipArchiveEntry inflatedEntry = zf.getEntry(\"inflated.txt\");\r\n        assertNotEquals(-1L, inflatedEntry.getLocalHeaderOffset());\r\n        assertNotEquals(-1L, inflatedEntry.getDataOffset());\r\n        assertTrue(inflatedEntry.isStreamContiguous());\r\n        assertNotEquals(-1L, inflatedEntry.getCompressedSize());\r\n        assertNotEquals(-1L, inflatedEntry.getSize());\r\n        final ZipArchiveEntry storedEntry = zf.getEntry(\"stored.txt\");\r\n        assertNotEquals(-1L, storedEntry.getLocalHeaderOffset());\r\n        assertNotEquals(-1L, storedEntry.getDataOffset());\r\n        assertTrue(inflatedEntry.isStreamContiguous());\r\n        assertNotEquals(-1L, storedEntry.getCompressedSize());\r\n        assertNotEquals(-1L, storedEntry.getSize());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testDoubleClose",
  "sourceCode" : "@Test\r\nvoid testDoubleClose() throws Exception {\r\n    readOrderTest();\r\n    zf.close();\r\n    assertDoesNotThrow(zf::close, \"Caught exception of second close\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testDuplicateEntry",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-227\"\r\n */\r\n@Test\r\nvoid testDuplicateEntry() throws Exception {\r\n    final File archive = getFile(\"COMPRESS-227.zip\");\r\n    zf = new ZipFile(archive);\r\n    final ZipArchiveEntry ze = zf.getEntry(\"test1.txt\");\r\n    assertNotNull(ze);\r\n    try (InputStream inputStream = zf.getInputStream(ze)) {\r\n        assertNotNull(inputStream);\r\n        int numberOfEntries = 0;\r\n        for (final ZipArchiveEntry entry : zf.getEntries(\"test1.txt\")) {\r\n            numberOfEntries++;\r\n            try (InputStream inputStream2 = zf.getInputStream(entry)) {\r\n                assertNotNull(inputStream2);\r\n            }\r\n        }\r\n        assertEquals(2, numberOfEntries);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testEntryAlignment",
  "sourceCode" : "/**\r\n * Test entries alignment.\r\n */\r\n@Test\r\nvoid testEntryAlignment() throws Exception {\r\n    try (SeekableInMemoryByteChannel zipContent = new SeekableInMemoryByteChannel()) {\r\n        try (ZipArchiveOutputStream zipOutput = new ZipArchiveOutputStream(zipContent)) {\r\n            final ZipArchiveEntry inflatedEntry = new ZipArchiveEntry(\"inflated.txt\");\r\n            inflatedEntry.setMethod(ZipEntry.DEFLATED);\r\n            inflatedEntry.setAlignment(1024);\r\n            zipOutput.putArchiveEntry(inflatedEntry);\r\n            zipOutput.writeUtf8(\"Hello Deflated\\n\");\r\n            zipOutput.closeArchiveEntry();\r\n            final ZipArchiveEntry storedEntry = new ZipArchiveEntry(\"stored.txt\");\r\n            storedEntry.setMethod(ZipEntry.STORED);\r\n            storedEntry.setAlignment(1024);\r\n            zipOutput.putArchiveEntry(storedEntry);\r\n            zipOutput.writeUtf8(\"Hello Stored\\n\");\r\n            zipOutput.closeArchiveEntry();\r\n            final ZipArchiveEntry storedEntry2 = new ZipArchiveEntry(\"stored2.txt\");\r\n            storedEntry2.setMethod(ZipEntry.STORED);\r\n            storedEntry2.setAlignment(1024);\r\n            storedEntry2.addExtraField(new ResourceAlignmentExtraField(1));\r\n            zipOutput.putArchiveEntry(storedEntry2);\r\n            zipOutput.writeUtf8(\"Hello overload-alignment Stored\\n\");\r\n            zipOutput.closeArchiveEntry();\r\n            final ZipArchiveEntry storedEntry3 = new ZipArchiveEntry(\"stored3.txt\");\r\n            storedEntry3.setMethod(ZipEntry.STORED);\r\n            storedEntry3.addExtraField(new ResourceAlignmentExtraField(1024));\r\n            zipOutput.putArchiveEntry(storedEntry3);\r\n            zipOutput.writeUtf8(\"Hello copy-alignment Stored\\n\");\r\n            zipOutput.closeArchiveEntry();\r\n        }\r\n        try (ZipFile zf = ZipFile.builder().setByteArray(Arrays.copyOfRange(zipContent.array(), 0, (int) zipContent.getSize())).get()) {\r\n            final ZipArchiveEntry inflatedEntry = zf.getEntry(\"inflated.txt\");\r\n            final ResourceAlignmentExtraField inflatedAlignmentEx = (ResourceAlignmentExtraField) inflatedEntry.getExtraField(ResourceAlignmentExtraField.ID);\r\n            assertNotEquals(-1L, inflatedEntry.getCompressedSize());\r\n            assertNotEquals(-1L, inflatedEntry.getSize());\r\n            assertEquals(0L, inflatedEntry.getDataOffset() % 1024);\r\n            assertNotNull(inflatedAlignmentEx);\r\n            assertEquals(1024, inflatedAlignmentEx.getAlignment());\r\n            assertFalse(inflatedAlignmentEx.allowMethodChange());\r\n            try (InputStream stream = zf.getInputStream(inflatedEntry)) {\r\n                assertEquals(\"Hello Deflated\\n\", new String(IOUtils.toByteArray(stream), UTF_8));\r\n            }\r\n            final ZipArchiveEntry storedEntry = zf.getEntry(\"stored.txt\");\r\n            final ResourceAlignmentExtraField storedAlignmentEx = (ResourceAlignmentExtraField) storedEntry.getExtraField(ResourceAlignmentExtraField.ID);\r\n            assertNotEquals(-1L, storedEntry.getCompressedSize());\r\n            assertNotEquals(-1L, storedEntry.getSize());\r\n            assertEquals(0L, storedEntry.getDataOffset() % 1024);\r\n            assertNotNull(storedAlignmentEx);\r\n            assertEquals(1024, storedAlignmentEx.getAlignment());\r\n            assertFalse(storedAlignmentEx.allowMethodChange());\r\n            try (InputStream stream = zf.getInputStream(storedEntry)) {\r\n                assertEquals(\"Hello Stored\\n\", new String(IOUtils.toByteArray(stream), UTF_8));\r\n            }\r\n            final ZipArchiveEntry storedEntry2 = zf.getEntry(\"stored2.txt\");\r\n            final ResourceAlignmentExtraField stored2AlignmentEx = (ResourceAlignmentExtraField) storedEntry2.getExtraField(ResourceAlignmentExtraField.ID);\r\n            assertNotEquals(-1L, storedEntry2.getCompressedSize());\r\n            assertNotEquals(-1L, storedEntry2.getSize());\r\n            assertEquals(0L, storedEntry2.getDataOffset() % 1024);\r\n            assertNotNull(stored2AlignmentEx);\r\n            assertEquals(1024, stored2AlignmentEx.getAlignment());\r\n            assertFalse(stored2AlignmentEx.allowMethodChange());\r\n            try (InputStream stream = zf.getInputStream(storedEntry2)) {\r\n                assertEquals(\"Hello overload-alignment Stored\\n\", new String(IOUtils.toByteArray(stream), UTF_8));\r\n            }\r\n            final ZipArchiveEntry storedEntry3 = zf.getEntry(\"stored3.txt\");\r\n            final ResourceAlignmentExtraField stored3AlignmentEx = (ResourceAlignmentExtraField) storedEntry3.getExtraField(ResourceAlignmentExtraField.ID);\r\n            assertNotEquals(-1L, storedEntry3.getCompressedSize());\r\n            assertNotEquals(-1L, storedEntry3.getSize());\r\n            assertEquals(0L, storedEntry3.getDataOffset() % 1024);\r\n            assertNotNull(stored3AlignmentEx);\r\n            assertEquals(1024, stored3AlignmentEx.getAlignment());\r\n            assertFalse(stored3AlignmentEx.allowMethodChange());\r\n            try (InputStream stream = zf.getInputStream(storedEntry3)) {\r\n                assertEquals(\"Hello copy-alignment Stored\\n\", new String(IOUtils.toByteArray(stream), UTF_8));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testEntryAlignmentExceed",
  "sourceCode" : "/**\r\n * Test too big alignment, resulting into exceeding extra field limit.\r\n */\r\n@Test\r\nvoid testEntryAlignmentExceed() throws Exception {\r\n    try (SeekableInMemoryByteChannel zipContent = new SeekableInMemoryByteChannel();\r\n        ZipArchiveOutputStream zipOutput = new ZipArchiveOutputStream(zipContent)) {\r\n        final ZipArchiveEntry inflatedEntry = new ZipArchiveEntry(\"inflated.txt\");\r\n        inflatedEntry.setMethod(ZipEntry.STORED);\r\n        assertThrows(IllegalArgumentException.class, () -> inflatedEntry.setAlignment(0x20000));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testExcessDataInZip64ExtraField",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-228\"\r\n */\r\n@Test\r\nvoid testExcessDataInZip64ExtraField() throws Exception {\r\n    final File archive = getFile(\"COMPRESS-228.zip\");\r\n    zf = new ZipFile(archive);\r\n    // actually, if we get here, the test already has passed\r\n    final ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\r\n    assertEquals(26101, ze.getSize());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testExtractFileLiesAcrossSplitZipSegmentsCreatedByWinrar",
  "sourceCode" : "@Test\r\nvoid testExtractFileLiesAcrossSplitZipSegmentsCreatedByWinrar() throws Exception {\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_winrar/split_zip_created_by_winrar.zip\");\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile)) {\r\n        zf = ZipFile.builder().setSeekableByteChannel(channel).get();\r\n        // the compressed content of ZipArchiveInputStream.java lies between .z01 and .z02\r\n        final ZipArchiveEntry zipEntry = zf.getEntry(\"commons-compress/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\");\r\n        final File fileToCompare = getFile(\"COMPRESS-477/split_zip_created_by_winrar/file_to_compare_1\");\r\n        assertFileEqualsToEntry(fileToCompare, zipEntry, zf);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testExtractFileLiesAcrossSplitZipSegmentsCreatedByZip",
  "sourceCode" : "@Test\r\nvoid testExtractFileLiesAcrossSplitZipSegmentsCreatedByZip() throws Exception {\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile)) {\r\n        zf = new ZipFile(channel);\r\n        // the compressed content of UnsupportedCompressionAlgorithmException.java lies between .z01 and .z02\r\n        ZipArchiveEntry zipEntry = zf.getEntry(\"commons-compress/src/main/java/org/apache/commons/compress/archivers/dump/UnsupportedCompressionAlgorithmException.java\");\r\n        File fileToCompare = getFile(\"COMPRESS-477/split_zip_created_by_zip/file_to_compare_1\");\r\n        assertFileEqualsToEntry(fileToCompare, zipEntry, zf);\r\n        // the compressed content of DeflateParameters.java lies between .z02 and .zip\r\n        zipEntry = zf.getEntry(\"commons-compress/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateParameters.java\");\r\n        fileToCompare = getFile(\"COMPRESS-477/split_zip_created_by_zip/file_to_compare_2\");\r\n        assertFileEqualsToEntry(fileToCompare, zipEntry, zf);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testExtractFileLiesAcrossSplitZipSegmentsCreatedByZipOfZip64",
  "sourceCode" : "@Test\r\nvoid testExtractFileLiesAcrossSplitZipSegmentsCreatedByZipOfZip64() throws Exception {\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip_zip64.zip\");\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile)) {\r\n        zf = new ZipFile(channel);\r\n        // the compressed content of UnsupportedCompressionAlgorithmException.java lies between .z01 and .z02\r\n        ZipArchiveEntry zipEntry = zf.getEntry(\"commons-compress/src/main/java/org/apache/commons/compress/archivers/dump/UnsupportedCompressionAlgorithmException.java\");\r\n        File fileToCompare = getFile(\"COMPRESS-477/split_zip_created_by_zip/file_to_compare_1\");\r\n        assertFileEqualsToEntry(fileToCompare, zipEntry, zf);\r\n        // the compressed content of DeflateParameters.java lies between .z02 and .zip\r\n        zipEntry = zf.getEntry(\"commons-compress/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateParameters.java\");\r\n        fileToCompare = getFile(\"COMPRESS-477/split_zip_created_by_zip/file_to_compare_2\");\r\n        assertFileEqualsToEntry(fileToCompare, zipEntry, zf);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testGetEntries",
  "sourceCode" : "@Test\r\nvoid testGetEntries() throws Exception {\r\n    // mixed.zip contains both inflated and stored files\r\n    final File archive = getFile(\"mixed.zip\");\r\n    zf = new ZipFile(archive);\r\n    final Map<String, byte[]> content = new HashMap<>();\r\n    for (final ZipArchiveEntry entry : Collections.list(zf.getEntries())) {\r\n        try (InputStream inputStream = zf.getInputStream(entry)) {\r\n            content.put(entry.getName(), IOUtils.toByteArray(inputStream));\r\n        }\r\n    }\r\n    for (final ZipArchiveEntry entry : Collections.list(zf.getEntries())) {\r\n        assertAllReadMethods(content.get(entry.getName()), zf, entry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testGetEntriesInPhysicalOrder",
  "sourceCode" : "@Test\r\nvoid testGetEntriesInPhysicalOrder() throws Exception {\r\n    // mixed.zip contains both inflated and stored files\r\n    final File archive = getFile(\"mixed.zip\");\r\n    zf = new ZipFile(archive);\r\n    final Map<String, byte[]> content = new HashMap<>();\r\n    for (final ZipArchiveEntry entry : Collections.list(zf.getEntriesInPhysicalOrder())) {\r\n        try (InputStream inputStream = zf.getInputStream(entry)) {\r\n            content.put(entry.getName(), IOUtils.toByteArray(inputStream));\r\n        }\r\n    }\r\n    for (final ZipArchiveEntry entry : Collections.list(zf.getEntries())) {\r\n        assertAllReadMethods(content.get(entry.getName()), zf, entry);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testInvalidAlignment",
  "sourceCode" : "/**\r\n * Test non power of 2 alignment.\r\n */\r\n@Test\r\nvoid testInvalidAlignment() {\r\n    assertThrows(IllegalArgumentException.class, () -> new ZipArchiveEntry(\"dummy\").setAlignment(3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bzip2-zip.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bla.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-380/COMPRESS-380.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingExplode",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingExplode() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"imploding-8Kdict-3trees.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingStore",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingStore() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-264.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"SHRUNK.ZIP\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testNameSourceDefaultsToName",
  "sourceCode" : "@Test\r\nvoid testNameSourceDefaultsToName() throws Exception {\r\n    nameSource(\"bla.zip\", \"test1.xml\", ZipArchiveEntry.NameSource.NAME);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testNameSourceIsSetToEFS",
  "sourceCode" : "@Test\r\nvoid testNameSourceIsSetToEFS() throws Exception {\r\n    nameSource(\"utf8-7zip-test.zip\", \"\\u20AC_for_Dollar.txt\", ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testNameSourceIsSetToUnicodeExtraField",
  "sourceCode" : "@Test\r\nvoid testNameSourceIsSetToUnicodeExtraField() throws Exception {\r\n    nameSource(\"utf8-winzip-test.zip\", \"\\u20AC_for_Dollar.txt\", ZipArchiveEntry.NameSource.UNICODE_EXTRA_FIELD);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testOffsets",
  "sourceCode" : "/**\r\n * Test correct population of header and data offsets.\r\n */\r\n@Test\r\nvoid testOffsets() throws Exception {\r\n    // mixed.zip contains both inflated and stored files\r\n    final File archive = getFile(\"mixed.zip\");\r\n    try (ZipFile zf = new ZipFile(archive)) {\r\n        final ZipArchiveEntry inflatedEntry = zf.getEntry(\"inflated.txt\");\r\n        assertEquals(0x0000, inflatedEntry.getLocalHeaderOffset());\r\n        assertEquals(0x0046, inflatedEntry.getDataOffset());\r\n        assertTrue(inflatedEntry.isStreamContiguous());\r\n        final ZipArchiveEntry storedEntry = zf.getEntry(\"stored.txt\");\r\n        assertEquals(0x5892, storedEntry.getLocalHeaderOffset());\r\n        assertEquals(0x58d6, storedEntry.getDataOffset());\r\n        assertTrue(inflatedEntry.isStreamContiguous());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testPhysicalOrder",
  "sourceCode" : "@Test\r\nvoid testPhysicalOrder() throws Exception {\r\n    readOrderTest();\r\n    final ArrayList<ZipArchiveEntry> l = Collections.list(zf.getEntriesInPhysicalOrder());\r\n    assertEntryName(l, 0, \"AbstractUnicodeExtraField\");\r\n    assertEntryName(l, 1, \"AsiExtraField\");\r\n    assertEntryName(l, 2, \"ExtraFieldUtils\");\r\n    assertEntryName(l, 3, \"FallbackZipEncoding\");\r\n    assertEntryName(l, 4, \"GeneralPurposeBit\");\r\n    assertEntryName(l, 5, \"JarMarker\");\r\n    assertEntryName(l, 6, \"NioZipEncoding\");\r\n    assertEntryName(l, 7, \"Simple8BitZipEncoding\");\r\n    assertEntryName(l, 8, \"UnicodeCommentExtraField\");\r\n    assertEntryName(l, 9, \"UnicodePathExtraField\");\r\n    assertEntryName(l, 10, \"UnixStat\");\r\n    assertEntryName(l, 11, \"UnparseableExtraFieldData\");\r\n    assertEntryName(l, 12, \"UnrecognizedExtraField\");\r\n    assertEntryName(l, 13, \"ZipArchiveEntry\");\r\n    assertEntryName(l, 14, \"ZipArchiveInputStream\");\r\n    assertEntryName(l, 15, \"ZipArchiveOutputStream\");\r\n    assertEntryName(l, 16, \"ZipEncoding\");\r\n    assertEntryName(l, 17, \"ZipEncodingHelper\");\r\n    assertEntryName(l, 18, \"ZipExtraField\");\r\n    assertEntryName(l, 19, \"ZipFile\");\r\n    assertEntryName(l, 20, \"ZipLong\");\r\n    assertEntryName(l, 21, \"ZipShort\");\r\n    assertEntryName(l, 22, \"ZipUtil\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testPhysicalOrderOfSpecificFile",
  "sourceCode" : "@Test\r\nvoid testPhysicalOrderOfSpecificFile() throws Exception {\r\n    readOrderTest();\r\n    final String entryName = \"src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\";\r\n    final Iterable<ZipArchiveEntry> entries = zf.getEntriesInPhysicalOrder(entryName);\r\n    final Iterator<ZipArchiveEntry> iter = entries.iterator();\r\n    final ZipArchiveEntry entry = iter.next();\r\n    assertEquals(entryName, entry.getName());\r\n    assertFalse(iter.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testReadDeflate64CompressedStream",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-380\"\r\n */\r\n@Test\r\nvoid testReadDeflate64CompressedStream() throws Exception {\r\n    final File input = getFile(\"COMPRESS-380/COMPRESS-380-input\");\r\n    final File archive = getFile(\"COMPRESS-380/COMPRESS-380.zip\");\r\n    try (InputStream in = Files.newInputStream(input.toPath());\r\n        ZipFile zf = new ZipFile(archive)) {\r\n        final byte[] orig = IOUtils.toByteArray(in);\r\n        final ZipArchiveEntry e = zf.getEntry(\"input2\");\r\n        try (InputStream s = zf.getInputStream(e)) {\r\n            final byte[] fromZip = IOUtils.toByteArray(s);\r\n            assertArrayEquals(orig, fromZip);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testReadingOfExtraDataBeforeZip",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-621\">COMPRESS-621</a>.\r\n */\r\n@Test\r\nvoid testReadingOfExtraDataBeforeZip() throws IOException {\r\n    final byte[] fileHeader = \"Before Zip file\".getBytes(UTF_8);\r\n    final String entryName = \"COMPRESS-621.txt\";\r\n    final byte[] entryContent = \"https://issues.apache.org/jira/browse/COMPRESS-621\".getBytes(UTF_8);\r\n    try (ZipFile archive = new ZipFile(getFile(\"COMPRESS-621.zip\"))) {\r\n        assertEquals(fileHeader.length, archive.getFirstLocalFileHeaderOffset());\r\n        try (InputStream input = archive.getContentBeforeFirstLocalFileHeader()) {\r\n            assertArrayEquals(fileHeader, IOUtils.toByteArray(input));\r\n        }\r\n        final ZipArchiveEntry e = archive.getEntry(entryName);\r\n        assertEquals(entryContent.length, e.getSize());\r\n        try (InputStream input = archive.getInputStream(e)) {\r\n            assertArrayEquals(entryContent, IOUtils.toByteArray(input));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testReadingOfFirstStoredEntry",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-264\">COMPRESS-264</a>.\r\n */\r\n@Test\r\nvoid testReadingOfFirstStoredEntry() throws Exception {\r\n    final File archive = getFile(\"COMPRESS-264.zip\");\r\n    zf = new ZipFile(archive);\r\n    final ZipArchiveEntry ze = zf.getEntry(\"test.txt\");\r\n    assertEquals(5, ze.getSize());\r\n    try (InputStream inputStream = zf.getInputStream(ze)) {\r\n        assertArrayEquals(new byte[] { 'd', 'a', 't', 'a', '\\n' }, IOUtils.toByteArray(inputStream));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testReadingOfStoredEntry",
  "sourceCode" : "@Test\r\nvoid testReadingOfStoredEntry() throws Exception {\r\n    final File file = createTempFile(\"commons-compress-zipfiletest\", \".zip\");\r\n    ZipArchiveEntry ze;\r\n    try (OutputStream o = Files.newOutputStream(file.toPath());\r\n        ZipArchiveOutputStream zo = new ZipArchiveOutputStream(o)) {\r\n        ze = new ZipArchiveEntry(\"foo\");\r\n        ze.setMethod(ZipEntry.STORED);\r\n        ze.setSize(4);\r\n        ze.setCrc(0xb63cfbcdL);\r\n        zo.putArchiveEntry(ze);\r\n        zo.write(new byte[] { 1, 2, 3, 4 });\r\n        zo.closeArchiveEntry();\r\n    }\r\n    zf = new ZipFile(file);\r\n    ze = zf.getEntry(\"foo\");\r\n    assertNotNull(ze);\r\n    try (InputStream i = zf.getInputStream(ze)) {\r\n        final byte[] b = new byte[4];\r\n        assertEquals(4, i.read(b));\r\n        assertEquals(-1, i.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSelfExtractingZipUsingUnzipsfx",
  "sourceCode" : "@Test\r\nvoid testSelfExtractingZipUsingUnzipsfx() throws IOException, InterruptedException {\r\n    final File unzipsfx = new File(\"/usr/bin/unzipsfx\");\r\n    Assumptions.assumeTrue(unzipsfx.exists());\r\n    final File testZip = createTempFile(\"commons-compress-selfExtractZipTest\", \".zip\");\r\n    final String testEntryName = \"test_self_extract_zip/foo\";\r\n    final File extractedFile = new File(testZip.getParentFile(), testEntryName);\r\n    final byte[] testData = { 1, 2, 3, 4 };\r\n    final byte[] buffer = new byte[512];\r\n    int bytesRead;\r\n    try (InputStream unzipsfxInputStream = Files.newInputStream(unzipsfx.toPath())) {\r\n        try (OutputStream outputStream = Files.newOutputStream(testZip.toPath());\r\n            ZipArchiveOutputStream zo = new ZipArchiveOutputStream(outputStream)) {\r\n            while ((bytesRead = unzipsfxInputStream.read(buffer)) > 0) {\r\n                zo.writePreamble(buffer, 0, bytesRead);\r\n            }\r\n            final ZipArchiveEntry ze = new ZipArchiveEntry(testEntryName);\r\n            ze.setMethod(ZipEntry.STORED);\r\n            ze.setSize(4);\r\n            ze.setCrc(0xb63cfbcdL);\r\n            zo.putArchiveEntry(ze);\r\n            zo.write(testData);\r\n            zo.closeArchiveEntry();\r\n        }\r\n        final ProcessBuilder pbChmod = new ProcessBuilder(\"chmod\", \"+x\", testZip.getPath());\r\n        pbChmod.redirectErrorStream(true);\r\n        final Process processChmod = pbChmod.start();\r\n        try (InputStream processInputStream = processChmod.getInputStream()) {\r\n            assertEquals(0, processChmod.waitFor(), new String(IOUtils.toByteArray(processInputStream)));\r\n        }\r\n        final ProcessBuilder pb = new ProcessBuilder(testZip.getPath());\r\n        pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\r\n        pb.directory(testZip.getParentFile());\r\n        pb.redirectErrorStream(true);\r\n        final Process process = pb.start();\r\n        final int rc = process.waitFor();\r\n        if (rc == OUT_OF_MEMORY && SystemUtils.IS_OS_MAC) {\r\n            // On my old Mac mini, this test runs out of memory, so allow the build to continue.\r\n            Assume.assumeTrue(Boolean.getBoolean(\"skipReturnCode137\"));\r\n            return;\r\n        }\r\n        try (InputStream processInputStream = process.getInputStream()) {\r\n            assertEquals(0, rc, new String(IOUtils.toByteArray(processInputStream)));\r\n        }\r\n        if (!extractedFile.exists()) {\r\n            // fail if extracted file does not exist\r\n            fail(\"Can not find the extracted file\");\r\n        }\r\n        try (InputStream inputStream = Files.newInputStream(extractedFile.toPath())) {\r\n            bytesRead = org.apache.commons.compress.utils.IOUtils.readFully(inputStream, buffer);\r\n            assertEquals(testData.length, bytesRead);\r\n            assertArrayEquals(testData, Arrays.copyOfRange(buffer, 0, bytesRead));\r\n        }\r\n    } finally {\r\n        extractedFile.delete();\r\n        extractedFile.getParentFile().delete();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSetLevelTooBigForZipArchiveOutputStream",
  "sourceCode" : "@Test\r\nvoid testSetLevelTooBigForZipArchiveOutputStream() throws IOException {\r\n    try (ZipArchiveOutputStream fixture = new ZipArchiveOutputStream(new ByteArrayOutputStream())) {\r\n        assertThrows(IllegalArgumentException.class, () -> fixture.setLevel(Deflater.BEST_COMPRESSION + 1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSetLevelTooSmallForZipArchiveOutputStream",
  "sourceCode" : "@Test\r\nvoid testSetLevelTooSmallForZipArchiveOutputStream() throws IOException {\r\n    try (ZipArchiveOutputStream fixture = new ZipArchiveOutputStream(new ByteArrayOutputStream())) {\r\n        assertThrows(IllegalArgumentException.class, () -> fixture.setLevel(Deflater.DEFAULT_COMPRESSION - 1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bzip2-zip.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bla.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-380/COMPRESS-380.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingExplode",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingExplode() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"imploding-8Kdict-3trees.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingStore",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingStore() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-264.zip\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"SHRUNK.ZIP\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testSkipsPK00Prefix",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-208\">COMPRESS-208</a>.\r\n */\r\n@Test\r\nvoid testSkipsPK00Prefix() throws Exception {\r\n    final File archive = getFile(\"COMPRESS-208.zip\");\r\n    zf = new ZipFile(archive);\r\n    assertNotNull(zf.getEntry(\"test1.xml\"));\r\n    assertNotNull(zf.getEntry(\"test2.xml\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testThrowsExceptionWhenWritingPreamble",
  "sourceCode" : "@Test\r\nvoid testThrowsExceptionWhenWritingPreamble() throws IOException {\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(new ByteArrayOutputStream())) {\r\n        outputStream.putArchiveEntry(new ZipArchiveEntry());\r\n        assertThrows(IllegalStateException.class, () -> outputStream.writePreamble(ArrayUtils.EMPTY_BYTE_ARRAY));\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testUnixSymlinkSampleFile",
  "sourceCode" : "@Test\r\nvoid testUnixSymlinkSampleFile() throws Exception {\r\n    final String entryPrefix = \"COMPRESS-214_unix_symlinks/\";\r\n    final TreeMap<String, String> expectedVals = new TreeMap<>();\r\n    // I threw in some Japanese characters to keep things interesting.\r\n    expectedVals.put(entryPrefix + \"link1\", \"../COMPRESS-214_unix_symlinks/./a/b/c/../../../\\uF999\");\r\n    expectedVals.put(entryPrefix + \"link2\", \"../COMPRESS-214_unix_symlinks/./a/b/c/../../../g\");\r\n    expectedVals.put(entryPrefix + \"link3\", \"../COMPRESS-214_unix_symlinks/././a/b/c/../../../\\u76F4\\u6A39\");\r\n    expectedVals.put(entryPrefix + \"link4\", \"\\u82B1\\u5B50/\\u745B\\u5B50\");\r\n    expectedVals.put(entryPrefix + \"\\uF999\", \"./\\u82B1\\u5B50/\\u745B\\u5B50/\\u5897\\u8C37/\\uF999\");\r\n    expectedVals.put(entryPrefix + \"g\", \"./a/b/c/d/e/f/g\");\r\n    expectedVals.put(entryPrefix + \"\\u76F4\\u6A39\", \"./g\");\r\n    // Notice how a directory link might contain a trailing slash, or it might not.\r\n    // Also note: symlinks are always stored as files, even if they link to directories.\r\n    expectedVals.put(entryPrefix + \"link5\", \"../COMPRESS-214_unix_symlinks/././a/b\");\r\n    expectedVals.put(entryPrefix + \"link6\", \"../COMPRESS-214_unix_symlinks/././a/b/\");\r\n    // I looked into creating a test with hard links, but ZIP does not appear to\r\n    // support hard links, so nevermind.\r\n    final File archive = getFile(\"COMPRESS-214_unix_symlinks.zip\");\r\n    zf = new ZipFile(archive);\r\n    zf.stream().forEach(zae -> {\r\n        final String link = zf.getUnixSymlink(zae);\r\n        if (zae.isUnixSymlink()) {\r\n            final String name = zae.getName();\r\n            final String expected = expectedVals.get(name);\r\n            assertEquals(expected, link);\r\n        } else {\r\n            // Should be null if it's not a symlink!\r\n            assertNull(link);\r\n        }\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testUnshrinking",
  "sourceCode" : "@Test\r\nvoid testUnshrinking() throws Exception {\r\n    zf = new ZipFile(getFile(\"SHRUNK.ZIP\"));\r\n    ZipArchiveEntry test = zf.getEntry(\"TEST1.XML\");\r\n    try (InputStream original = newInputStream(\"test1.xml\");\r\n        InputStream inputStream = zf.getInputStream(test)) {\r\n        assertArrayEquals(IOUtils.toByteArray(original), IOUtils.toByteArray(inputStream));\r\n    }\r\n    test = zf.getEntry(\"TEST2.XML\");\r\n    try (InputStream original = newInputStream(\"test2.xml\");\r\n        InputStream inputStream = zf.getInputStream(test)) {\r\n        assertArrayEquals(IOUtils.toByteArray(original), IOUtils.toByteArray(inputStream));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testUnzipBZip2CompressedEntry",
  "sourceCode" : "@Test\r\nvoid testUnzipBZip2CompressedEntry() throws Exception {\r\n    final File archive = getFile(\"bzip2-zip.zip\");\r\n    zf = new ZipFile(archive);\r\n    final ZipArchiveEntry ze = zf.getEntry(\"lots-of-as\");\r\n    assertEquals(42, ze.getSize());\r\n    final byte[] expected = ArrayFill.fill(new byte[42], (byte) 'a');\r\n    try (InputStream inputStream = zf.getInputStream(ze)) {\r\n        assertArrayEquals(expected, IOUtils.toByteArray(inputStream));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testWinzipBackSlashWorkaround",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-176\"\r\n */\r\n@Test\r\nvoid testWinzipBackSlashWorkaround() throws Exception {\r\n    final File archive = getFile(\"test-winzip.zip\");\r\n    zf = new ZipFile(archive);\r\n    assertNull(zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\"));\r\n    assertNotNull(zf.getEntry(\"\\u00e4/\\u00fc.txt\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testZipWithShortBeginningGarbage",
  "sourceCode" : "@Test\r\nvoid testZipWithShortBeginningGarbage() throws IOException {\r\n    final Path path = createTempPath(\"preamble\", \".zip\");\r\n    try (OutputStream fos = Files.newOutputStream(path)) {\r\n        fos.write(\"#!/usr/bin/unzip\\n\".getBytes(StandardCharsets.UTF_8));\r\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(fos)) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(\"file-1.txt\");\r\n            entry.setMethod(ZipEntry.DEFLATED);\r\n            zos.putArchiveEntry(entry);\r\n            zos.writeUtf8(\"entry-content\\n\");\r\n            zos.closeArchiveEntry();\r\n        }\r\n    }\r\n    try (ZipFile zipFile = ZipFile.builder().setPath(path).get()) {\r\n        final ZipArchiveEntry entry = zipFile.getEntry(\"file-1.txt\");\r\n        assertEquals(\"file-1.txt\", entry.getName());\r\n        try (InputStream inputStream = zipFile.getInputStream(entry)) {\r\n            final byte[] content = IOUtils.toByteArray(inputStream);\r\n            assertArrayEquals(\"entry-content\\n\".getBytes(StandardCharsets.UTF_8), content);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipFileTest.java",
  "methodName" : "testZstdInputStreamErrorCloseWhenGc",
  "sourceCode" : "/*\r\n     * Tests [COMPRESS-708] ZstdCompressorInputStream closes the InputStream held by ZipArchiveInputStream garbage collection.\r\n     */\r\n@Test\r\nvoid testZstdInputStreamErrorCloseWhenGc() throws Exception {\r\n    final File archive = getFile(\"COMPRESS-692/compress-692.zip\");\r\n    for (int i = 0; i < 500; i++) {\r\n        try (FileInputStream fileInputStream = new FileInputStream(archive);\r\n            ZipArchiveInputStream zipArchiveInputStream = new ZipArchiveInputStream(fileInputStream)) {\r\n            ArchiveEntry entry;\r\n            while ((entry = zipArchiveInputStream.getNextEntry()) != null) {\r\n                if (entry.isDirectory()) {\r\n                    continue;\r\n                }\r\n                System.gc();\r\n                IOUtils.toByteArray(zipArchiveInputStream);\r\n            }\r\n        } catch (final IOException e) {\r\n            fail(\"testZstdInputStreamErrorCloseWhenGc error, test error at batch \" + (i + 1), e);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipIoUtilTest.java",
  "methodName" : "testWriteFully_whenFullAtOnce_thenSucceed",
  "sourceCode" : "@Test\r\nvoid testWriteFully_whenFullAtOnce_thenSucceed() throws IOException {\r\n    try (SeekableByteChannel channel = mockSeekableByteChannel()) {\r\n        when(channel.write((ByteBuffer) any())).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(5);\r\n            return 5;\r\n        }).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(6);\r\n            return 6;\r\n        });\r\n        ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8)));\r\n        ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"world\\n\".getBytes(StandardCharsets.UTF_8)));\r\n        verify(channel, times(2)).write((ByteBuffer) any());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipIoUtilTest.java",
  "methodName" : "testWriteFully_whenFullButPartial_thenSucceed",
  "sourceCode" : "@Test\r\nvoid testWriteFully_whenFullButPartial_thenSucceed() throws IOException {\r\n    try (SeekableByteChannel channel = mockSeekableByteChannel()) {\r\n        when(channel.write((ByteBuffer) any())).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(3);\r\n            return 3;\r\n        }).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(5);\r\n            return 2;\r\n        }).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(6);\r\n            return 6;\r\n        });\r\n        ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8)));\r\n        ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"world\\n\".getBytes(StandardCharsets.UTF_8)));\r\n        verify(channel, times(3)).write((ByteBuffer) any());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipIoUtilTest.java",
  "methodName" : "testWriteFully_whenPartial_thenFail",
  "sourceCode" : "@Test\r\nvoid testWriteFully_whenPartial_thenFail() throws IOException {\r\n    try (SeekableByteChannel channel = mockSeekableByteChannel()) {\r\n        when(channel.write((ByteBuffer) any())).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(3);\r\n            return 3;\r\n        }).thenAnswer(answer -> 0).thenAnswer(answer -> -1);\r\n        assertThrows(ArchiveException.class, () -> ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8))));\r\n        verify(channel, times(3)).write((ByteBuffer) any());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipIoUtilTest.java",
  "methodName" : "testWriteFullyAt_whenFullAtOnce_thenSucceed",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenFullAtOnce_thenSucceed() throws IOException {\r\n    try (FileChannel channel = mockFileChannel()) {\r\n        when(channel.write((ByteBuffer) any(), eq(20L))).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(5);\r\n            return 5;\r\n        });\r\n        when(channel.write((ByteBuffer) any(), eq(30L))).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(6);\r\n            return 6;\r\n        });\r\n        ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8)), 20);\r\n        ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"world\\n\".getBytes(StandardCharsets.UTF_8)), 30);\r\n        verify(channel, times(1)).write((ByteBuffer) any(), eq(20L));\r\n        verify(channel, times(1)).write((ByteBuffer) any(), eq(30L));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipIoUtilTest.java",
  "methodName" : "testWriteFullyAt_whenFullButPartial_thenSucceed",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenFullButPartial_thenSucceed() throws IOException {\r\n    try (FileChannel channel = mockFileChannel()) {\r\n        when(channel.write((ByteBuffer) any(), eq(20L))).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(3);\r\n            return 3;\r\n        });\r\n        when(channel.write((ByteBuffer) any(), eq(23L))).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(5);\r\n            return 2;\r\n        });\r\n        when(channel.write((ByteBuffer) any(), eq(30L))).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(6);\r\n            return 6;\r\n        });\r\n        ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8)), 20);\r\n        ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"world\\n\".getBytes(StandardCharsets.UTF_8)), 30);\r\n        verify(channel, times(1)).write((ByteBuffer) any(), eq(20L));\r\n        verify(channel, times(1)).write((ByteBuffer) any(), eq(23L));\r\n        verify(channel, times(1)).write((ByteBuffer) any(), eq(30L));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipIoUtilTest.java",
  "methodName" : "testWriteFullyAt_whenPartial_thenFail",
  "sourceCode" : "@Test\r\nvoid testWriteFullyAt_whenPartial_thenFail() throws IOException {\r\n    try (FileChannel channel = mockFileChannel()) {\r\n        when(channel.write((ByteBuffer) any(), eq(20L))).thenAnswer(answer -> {\r\n            ((ByteBuffer) answer.getArgument(0)).position(3);\r\n            return 3;\r\n        });\r\n        when(channel.write((ByteBuffer) any(), eq(23L))).thenAnswer(answer -> 0).thenAnswer(answer -> -1);\r\n        assertThrows(ArchiveException.class, () -> ZipIoUtil.writeAll(channel, ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8)), 20));\r\n        verify(channel, times(1)).write((ByteBuffer) any(), eq(20L));\r\n        verify(channel, times(2)).write((ByteBuffer) any(), eq(23L));\r\n        verify(channel, times(0)).write((ByteBuffer) any(), eq(25L));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipLongTest.java",
  "methodName" : "testClone",
  "sourceCode" : "@Test\r\nvoid testClone() {\r\n    final ZipLong s1 = new ZipLong(42);\r\n    final ZipLong s2 = (ZipLong) s1.clone();\r\n    assertNotSame(s1, s2);\r\n    assertEquals(s1, s2);\r\n    assertEquals(s1.getValue(), s2.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipLongTest.java",
  "methodName" : "testEquals",
  "sourceCode" : "/**\r\n * Test the contract of the equals method.\r\n */\r\n@Test\r\nvoid testEquals() {\r\n    final ZipLong zl = new ZipLong(0x12345678);\r\n    final ZipLong zl2 = new ZipLong(0x12345678);\r\n    final ZipLong zl3 = new ZipLong(0x87654321);\r\n    assertEquals(zl, zl, \"reflexive\");\r\n    assertEquals(zl, zl2, \"works\");\r\n    assertNotEquals(zl, zl3, \"works, part two\");\r\n    assertEquals(zl2, zl, \"symmetric\");\r\n    assertNotEquals(null, zl, \"null handling\");\r\n    assertNotEquals(zl, Integer.valueOf(0x1234), \"non ZipLong handling\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipLongTest.java",
  "methodName" : "testFromBytes",
  "sourceCode" : "/**\r\n * Test conversion from bytes.\r\n */\r\n@Test\r\nvoid testFromBytes() {\r\n    final byte[] val = { 0x78, 0x56, 0x34, 0x12 };\r\n    final ZipLong zl = new ZipLong(val);\r\n    assertEquals(0x12345678, zl.getValue(), \"value from bytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipLongTest.java",
  "methodName" : "testPut",
  "sourceCode" : "/**\r\n * Test conversion to bytes.\r\n */\r\n@Test\r\nvoid testPut() {\r\n    final byte[] arr = new byte[5];\r\n    ZipLong.putLong(0x12345678, arr, 1);\r\n    assertEquals(0x78, arr[1], \"first byte getBytes\");\r\n    assertEquals(0x56, arr[2], \"second byte getBytes\");\r\n    assertEquals(0x34, arr[3], \"third byte getBytes\");\r\n    assertEquals(0x12, arr[4], \"fourth byte getBytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipLongTest.java",
  "methodName" : "testSign",
  "sourceCode" : "/**\r\n * Test sign handling.\r\n */\r\n@Test\r\nvoid testSign() {\r\n    ZipLong zl = new ZipLong(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF });\r\n    assertEquals(0x00000000FFFFFFFFL, zl.getValue());\r\n    assertEquals(-1, zl.getIntValue());\r\n    zl = new ZipLong(0xFFFF_FFFFL);\r\n    assertEquals(0x00000000FFFFFFFFL, zl.getValue());\r\n    zl = new ZipLong(0xFFFF_FFFF);\r\n    assertEquals(0xFFFF_FFFF_FFFF_FFFFL, zl.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipLongTest.java",
  "methodName" : "testToBytes",
  "sourceCode" : "/**\r\n * Test conversion to bytes.\r\n */\r\n@Test\r\nvoid testToBytes() {\r\n    final ZipLong zl = new ZipLong(0x12345678);\r\n    final byte[] result = zl.getBytes();\r\n    assertEquals(4, result.length, \"length getBytes\");\r\n    assertEquals(0x78, result[0], \"first byte getBytes\");\r\n    assertEquals(0x56, result[1], \"second byte getBytes\");\r\n    assertEquals(0x34, result[2], \"third byte getBytes\");\r\n    assertEquals(0x12, result[3], \"fourth byte getBytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testForPathsReturnCorrectClassInMemory",
  "sourceCode" : "@Test\r\nvoid testForPathsReturnCorrectClassInMemory() throws IOException {\r\n    final Path firstFile = getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\r\n    final Path secondFile = getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\r\n    final Path lastFile = getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\r\n    final byte[] firstBytes = Files.readAllBytes(firstFile);\r\n    final byte[] secondBytes = Files.readAllBytes(secondFile);\r\n    final byte[] lastBytes = Files.readAllBytes(lastFile);\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        Files.write(fileSystem.getPath(\"split_zip_created_by_zip.z01\"), firstBytes);\r\n        Files.write(fileSystem.getPath(\"split_zip_created_by_zip.z02\"), secondBytes);\r\n        Files.write(fileSystem.getPath(\"split_zip_created_by_zip.zip\"), lastBytes);\r\n        final ArrayList<Path> list = new ArrayList<>();\r\n        list.add(firstFile);\r\n        list.add(secondFile);\r\n        try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forPaths(lastFile, list)) {\r\n            assertInstanceOf(ZipSplitReadOnlySeekableByteChannel.class, channel);\r\n        }\r\n        try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forPaths(firstFile, secondFile, lastFile)) {\r\n            assertInstanceOf(ZipSplitReadOnlySeekableByteChannel.class, channel);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testPositionToSomeZipSplitSegmentInMemory",
  "sourceCode" : "@Test\r\nvoid testPositionToSomeZipSplitSegmentInMemory() throws IOException {\r\n    final byte[] firstBytes = AbstractTest.readAllBytes(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\r\n    final byte[] secondBytes = AbstractTest.readAllBytes(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\r\n    final byte[] lastBytes = AbstractTest.readAllBytes(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\r\n    final int firstFileSize = firstBytes.length;\r\n    final int secondFileSize = secondBytes.length;\r\n    final int lastFileSize = lastBytes.length;\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path lastMemoryPath = fileSystem.getPath(\"split_zip_created_by_zip.zip\");\r\n        Files.write(fileSystem.getPath(\"split_zip_created_by_zip.z01\"), firstBytes);\r\n        Files.write(fileSystem.getPath(\"split_zip_created_by_zip.z02\"), secondBytes);\r\n        Files.write(lastMemoryPath, lastBytes);\r\n        final Random random = new Random();\r\n        final int randomDiskNumber = random.nextInt(3);\r\n        final int randomOffset = randomDiskNumber < 2 ? random.nextInt(firstFileSize) : random.nextInt(lastFileSize);\r\n        try (ZipSplitReadOnlySeekableByteChannel channel = (ZipSplitReadOnlySeekableByteChannel) ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastMemoryPath)) {\r\n            channel.position(randomDiskNumber, randomOffset);\r\n            long expectedPosition = randomOffset;\r\n            expectedPosition += randomDiskNumber > 0 ? firstFileSize : 0;\r\n            expectedPosition += randomDiskNumber > 1 ? secondFileSize : 0;\r\n            assertEquals(expectedPosition, channel.position());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testScatterFileInMemory",
  "sourceCode" : "@Test\r\nvoid testScatterFileInMemory() throws IOException {\r\n    final byte[] B_PAYLOAD = \"RBBBBBBS\".getBytes();\r\n    final byte[] A_PAYLOAD = \"XAAY\".getBytes();\r\n    final Path target = Files.createTempFile(dir, \"scattertest\", \".zip\");\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path scatterFile = fileSystem.getPath(\"scattertest.notzip\");\r\n        try (ScatterZipOutputStream scatterZipOutputStream = ScatterZipOutputStream.pathBased(scatterFile)) {\r\n            final ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\r\n            zab.setMethod(ZipEntry.DEFLATED);\r\n            final ByteArrayInputStream payload = new ByteArrayInputStream(B_PAYLOAD);\r\n            scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zab, createPayloadSupplier(payload)));\r\n            final ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\r\n            zae.setMethod(ZipEntry.DEFLATED);\r\n            final ByteArrayInputStream payload1 = new ByteArrayInputStream(A_PAYLOAD);\r\n            scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zae, createPayloadSupplier(payload1)));\r\n            try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target)) {\r\n                scatterZipOutputStream.writeTo(outputStream);\r\n            }\r\n        }\r\n        try (ZipFile zf = ZipFile.builder().setPath(target).get()) {\r\n            final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();\r\n            assertEquals(8, b_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(b_entry)) {\r\n                assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n            final ZipArchiveEntry a_entry = zf.getEntries(\"a.txt\").iterator().next();\r\n            assertEquals(4, a_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(a_entry)) {\r\n                assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n        }\r\n    } finally {\r\n        PathUtils.delete(target);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testScatterFileWithCompressionAndTargetInMemory",
  "sourceCode" : "@Test\r\nvoid testScatterFileWithCompressionAndTargetInMemory() throws IOException {\r\n    final byte[] B_PAYLOAD = \"RBBBBBBS\".getBytes();\r\n    final byte[] A_PAYLOAD = \"XAAY\".getBytes();\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path target = fileSystem.getPath(\"scattertest.zip\");\r\n        final Path scatterFile = fileSystem.getPath(\"scattertest.notzip\");\r\n        try (ScatterZipOutputStream scatterZipOutputStream = ScatterZipOutputStream.pathBased(scatterFile, Deflater.BEST_COMPRESSION)) {\r\n            final ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\r\n            zab.setMethod(ZipEntry.DEFLATED);\r\n            final ByteArrayInputStream payload = new ByteArrayInputStream(B_PAYLOAD);\r\n            scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zab, createPayloadSupplier(payload)));\r\n            final ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\r\n            zae.setMethod(ZipEntry.DEFLATED);\r\n            final ByteArrayInputStream payload1 = new ByteArrayInputStream(A_PAYLOAD);\r\n            scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zae, createPayloadSupplier(payload1)));\r\n            try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target)) {\r\n                scatterZipOutputStream.writeTo(outputStream);\r\n            }\r\n        }\r\n        try (ZipFile zf = ZipFile.builder().setPath(target).get()) {\r\n            final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();\r\n            assertEquals(8, b_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(b_entry)) {\r\n                assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n            final ZipArchiveEntry a_entry = zf.getEntries(\"a.txt\").iterator().next();\r\n            assertEquals(4, a_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(a_entry)) {\r\n                assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n        }\r\n        try (ZipFile zf = new ZipFile(Files.newByteChannel(target, StandardOpenOption.READ), target.getFileName().toString(), StandardCharsets.UTF_8.name(), true)) {\r\n            final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();\r\n            assertEquals(8, b_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(b_entry)) {\r\n                assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n            final ZipArchiveEntry a_entry = zf.getEntries(\"a.txt\").iterator().next();\r\n            assertEquals(4, a_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(a_entry)) {\r\n                assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n        }\r\n        try (ZipFile zf = new ZipFile(Files.newByteChannel(target, StandardOpenOption.READ), target.getFileName().toString(), StandardCharsets.UTF_8.name(), true, false)) {\r\n            final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();\r\n            assertEquals(8, b_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(b_entry)) {\r\n                assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n            final ZipArchiveEntry a_entry = zf.getEntries(\"a.txt\").iterator().next();\r\n            assertEquals(4, a_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(a_entry)) {\r\n                assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testScatterFileWithCompressionInMemory",
  "sourceCode" : "@Test\r\nvoid testScatterFileWithCompressionInMemory() throws IOException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path scatterFile = fileSystem.getPath(\"scattertest.notzip\");\r\n        final Path target = Files.createTempFile(dir, \"scattertest\", \".zip\");\r\n        final byte[] B_PAYLOAD = \"RBBBBBBS\".getBytes();\r\n        final byte[] A_PAYLOAD = \"XAAY\".getBytes();\r\n        try (ScatterZipOutputStream scatterZipOutputStream = ScatterZipOutputStream.pathBased(scatterFile, Deflater.BEST_COMPRESSION)) {\r\n            final ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\r\n            zab.setMethod(ZipEntry.DEFLATED);\r\n            final ByteArrayInputStream payload = new ByteArrayInputStream(B_PAYLOAD);\r\n            scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zab, createPayloadSupplier(payload)));\r\n            final ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\r\n            zae.setMethod(ZipEntry.DEFLATED);\r\n            final ByteArrayInputStream payload1 = new ByteArrayInputStream(A_PAYLOAD);\r\n            scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zae, createPayloadSupplier(payload1)));\r\n            try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target)) {\r\n                scatterZipOutputStream.writeTo(outputStream);\r\n            }\r\n        }\r\n        try (ZipFile zf = ZipFile.builder().setPath(target).get()) {\r\n            final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();\r\n            assertEquals(8, b_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(b_entry)) {\r\n                assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n            final ZipArchiveEntry a_entry = zf.getEntries(\"a.txt\").iterator().next();\r\n            assertEquals(4, a_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(a_entry)) {\r\n                assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipFileInMemory",
  "sourceCode" : "@Test\r\nvoid testZipFileInMemory() throws IOException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path scatterFile = fileSystem.getPath(\"scattertest.notzip\");\r\n        final Path target = fileSystem.getPath(\"scattertest.zip\");\r\n        final byte[] B_PAYLOAD = \"RBBBBBBS\".getBytes();\r\n        final byte[] A_PAYLOAD = \"XAAY\".getBytes();\r\n        try (ScatterZipOutputStream scatterZipOutputStream = ScatterZipOutputStream.pathBased(scatterFile, Deflater.BEST_COMPRESSION)) {\r\n            final ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\r\n            zab.setMethod(ZipEntry.DEFLATED);\r\n            final ByteArrayInputStream payload = new ByteArrayInputStream(B_PAYLOAD);\r\n            scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zab, createPayloadSupplier(payload)));\r\n            final ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\r\n            zae.setMethod(ZipEntry.DEFLATED);\r\n            final ByteArrayInputStream payload1 = new ByteArrayInputStream(A_PAYLOAD);\r\n            scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zae, createPayloadSupplier(payload1)));\r\n            try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target)) {\r\n                scatterZipOutputStream.writeTo(outputStream);\r\n            }\r\n        }\r\n        try (ZipFile zf = new ZipFile(target)) {\r\n            final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();\r\n            assertEquals(8, b_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(b_entry)) {\r\n                assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n            final ZipArchiveEntry a_entry = zf.getEntries(\"a.txt\").iterator().next();\r\n            assertEquals(4, a_entry.getSize());\r\n            try (InputStream inputStream = zf.getInputStream(a_entry)) {\r\n                assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(inputStream));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipFromMemoryFileSystemFile",
  "sourceCode" : "@Test\r\nvoid testZipFromMemoryFileSystemFile() throws IOException, NoSuchAlgorithmException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path textFileInMemSys = fileSystem.getPath(\"test.txt\");\r\n        final byte[] bytes = new byte[100 * 1024];\r\n        SecureRandom.getInstanceStrong().nextBytes(bytes);\r\n        Files.write(textFileInMemSys, bytes);\r\n        final Path zipInLocalSys = Files.createTempFile(dir, \"commons-compress-memoryfs\", \".zip\");\r\n        try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(zipInLocalSys.toFile())) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(textFileInMemSys, textFileInMemSys.getFileName().toString());\r\n            entry.setSize(Files.size(textFileInMemSys));\r\n            outputStream.putArchiveEntry(entry);\r\n            outputStream.write(textFileInMemSys);\r\n            outputStream.closeArchiveEntry();\r\n            outputStream.finish();\r\n            assertEquals(Files.size(zipInLocalSys), outputStream.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipFromMemoryFileSystemOutputStream",
  "sourceCode" : "@Test\r\nvoid testZipFromMemoryFileSystemOutputStream() throws IOException, ArchiveException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path path = fileSystem.getPath(\"test.txt\");\r\n        Files.write(path, \"Test\".getBytes(UTF_8));\r\n        final Path f = Files.createTempFile(dir, \"commons-compress-memoryfs\", \".zip\");\r\n        try (OutputStream out = Files.newOutputStream(f);\r\n            ArchiveOutputStream<ZipArchiveEntry> outputStream = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(ArchiveStreamFactory.ZIP, out)) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(path, path.getFileName().toString());\r\n            entry.setSize(Files.size(path));\r\n            outputStream.putArchiveEntry(entry);\r\n            outputStream.write(path);\r\n            outputStream.closeArchiveEntry();\r\n            assertEquals(Files.size(f), outputStream.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipFromMemoryFileSystemPath",
  "sourceCode" : "@Test\r\nvoid testZipFromMemoryFileSystemPath() throws IOException, NoSuchAlgorithmException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path textFileInMemSys = fileSystem.getPath(\"test.txt\");\r\n        final byte[] bytes = new byte[100 * 1024];\r\n        SecureRandom.getInstanceStrong().nextBytes(bytes);\r\n        Files.write(textFileInMemSys, bytes);\r\n        final Path zipInLocalSys = Files.createTempFile(dir, \"commons-compress-memoryfs\", \".zip\");\r\n        try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(zipInLocalSys)) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(textFileInMemSys, textFileInMemSys.getFileName().toString());\r\n            entry.setSize(Files.size(textFileInMemSys));\r\n            outputStream.putArchiveEntry(entry);\r\n            outputStream.write(textFileInMemSys);\r\n            outputStream.closeArchiveEntry();\r\n            outputStream.finish();\r\n            assertEquals(Files.size(zipInLocalSys), outputStream.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipFromMemoryFileSystemSeekableByteChannel",
  "sourceCode" : "@Test\r\nvoid testZipFromMemoryFileSystemSeekableByteChannel() throws IOException, NoSuchAlgorithmException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path textFileInMemSys = fileSystem.getPath(\"test.txt\");\r\n        final byte[] bytes = new byte[100 * 1024];\r\n        SecureRandom.getInstanceStrong().nextBytes(bytes);\r\n        Files.write(textFileInMemSys, bytes);\r\n        final Path zipInLocalSys = Files.createTempFile(dir, \"commons-compress-memoryfs\", \".zip\");\r\n        try (SeekableByteChannel byteChannel = Files.newByteChannel(zipInLocalSys, EnumSet.of(StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING));\r\n            ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(byteChannel)) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(textFileInMemSys, textFileInMemSys.getFileName().toString());\r\n            entry.setSize(Files.size(textFileInMemSys));\r\n            outputStream.putArchiveEntry(entry);\r\n            outputStream.write(textFileInMemSys);\r\n            outputStream.closeArchiveEntry();\r\n            outputStream.finish();\r\n            assertEquals(Files.size(zipInLocalSys), outputStream.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipFromMemoryFileSystemSplitFile",
  "sourceCode" : "@Test\r\nvoid testZipFromMemoryFileSystemSplitFile() throws IOException, NoSuchAlgorithmException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path textFileInMemSys = fileSystem.getPath(\"test.txt\");\r\n        final byte[] bytes = new byte[100 * 1024];\r\n        SecureRandom.getInstanceStrong().nextBytes(bytes);\r\n        Files.write(textFileInMemSys, bytes);\r\n        final Path zipInLocalSys = Files.createTempFile(dir, \"commons-compress-memoryfs\", \".zip\");\r\n        try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(zipInLocalSys.toFile(), 64 * 1024L)) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(textFileInMemSys, textFileInMemSys.getFileName().toString());\r\n            entry.setSize(Files.size(textFileInMemSys));\r\n            outputStream.putArchiveEntry(entry);\r\n            outputStream.write(textFileInMemSys);\r\n            outputStream.closeArchiveEntry();\r\n            outputStream.finish();\r\n            final List<Path> splitZips;\r\n            try (Stream<Path> paths = Files.walk(dir, 1)) {\r\n                splitZips = paths.filter(Files::isRegularFile).peek(path -> println(\"Found: \" + path.toAbsolutePath())).collect(Collectors.toList());\r\n            }\r\n            assertEquals(splitZips.size(), 2);\r\n            assertEquals(Files.size(splitZips.get(0)) + Files.size(splitZips.get(1)) - 4, outputStream.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipToMemoryFileSystemOutputStream",
  "sourceCode" : "@Test\r\nvoid testZipToMemoryFileSystemOutputStream() throws IOException, ArchiveException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path p = fileSystem.getPath(\"target.zip\");\r\n        try (OutputStream out = Files.newOutputStream(p);\r\n            ArchiveOutputStream<ZipArchiveEntry> zipOut = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(ArchiveStreamFactory.ZIP, out)) {\r\n            final String content = \"Test\";\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(\"test.txt\");\r\n            entry.setSize(content.length());\r\n            zipOut.putArchiveEntry(entry);\r\n            zipOut.writeUtf8(\"Test\");\r\n            zipOut.closeArchiveEntry();\r\n            assertTrue(Files.exists(p));\r\n            assertEquals(Files.size(p), zipOut.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipToMemoryFileSystemPath",
  "sourceCode" : "@Test\r\nvoid testZipToMemoryFileSystemPath() throws IOException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path zipInMemSys = fileSystem.getPath(\"target.zip\");\r\n        try (ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(zipInMemSys)) {\r\n            final String content = \"Test\";\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(\"test.txt\");\r\n            entry.setSize(content.length());\r\n            zipOut.putArchiveEntry(entry);\r\n            zipOut.writeUtf8(\"Test\");\r\n            zipOut.closeArchiveEntry();\r\n            assertTrue(Files.exists(zipInMemSys));\r\n            assertEquals(Files.size(zipInMemSys), zipOut.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipToMemoryFileSystemSeekableByteChannel",
  "sourceCode" : "@Test\r\nvoid testZipToMemoryFileSystemSeekableByteChannel() throws IOException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path zipInMemSys = fileSystem.getPath(\"target.zip\");\r\n        try (SeekableByteChannel byteChannel = Files.newByteChannel(zipInMemSys, EnumSet.of(StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE_NEW));\r\n            ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(byteChannel)) {\r\n            final String content = \"Test\";\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(\"test.txt\");\r\n            entry.setSize(content.length());\r\n            zipOut.putArchiveEntry(entry);\r\n            zipOut.writeUtf8(\"Test\");\r\n            zipOut.closeArchiveEntry();\r\n            assertTrue(Files.exists(zipInMemSys));\r\n            assertEquals(Files.size(zipInMemSys), zipOut.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipMemoryFileSystemTest.java",
  "methodName" : "testZipToMemoryFileSystemSplitPath",
  "sourceCode" : "@Test\r\nvoid testZipToMemoryFileSystemSplitPath() throws IOException, NoSuchAlgorithmException {\r\n    try (FileSystem fileSystem = MemoryFileSystemBuilder.newLinux().build()) {\r\n        final Path zipInMemSys = fileSystem.getPath(\"target.zip\");\r\n        final byte[] bytes = new byte[100 * 1024];\r\n        SecureRandom.getInstanceStrong().nextBytes(bytes);\r\n        try (ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(zipInMemSys, 64 * 1024L)) {\r\n            final ZipArchiveEntry entry = new ZipArchiveEntry(\"test.txt\");\r\n            entry.setSize(bytes.length);\r\n            zipOut.putArchiveEntry(entry);\r\n            zipOut.write(bytes);\r\n            zipOut.closeArchiveEntry();\r\n            zipOut.finish();\r\n            final List<Path> splitZips;\r\n            try (Stream<Path> paths = Files.walk(fileSystem.getPath(\".\"), 1)) {\r\n                splitZips = paths.filter(Files::isRegularFile).peek(path -> println(\"Found: \" + path.toAbsolutePath())).collect(Collectors.toList());\r\n            }\r\n            assertEquals(splitZips.size(), 2);\r\n            assertEquals(Files.size(splitZips.get(0)) + Files.size(splitZips.get(1)) - 4, zipOut.getBytesWritten());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipShortTest.java",
  "methodName" : "testClone",
  "sourceCode" : "@Test\r\nvoid testClone() {\r\n    final ZipShort s1 = new ZipShort(42);\r\n    final ZipShort s2 = (ZipShort) s1.clone();\r\n    assertNotSame(s1, s2);\r\n    assertEquals(s1, s2);\r\n    assertEquals(s1.getValue(), s2.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipShortTest.java",
  "methodName" : "testEquals",
  "sourceCode" : "/**\r\n * Test the contract of the equals method.\r\n */\r\n@Test\r\nvoid testEquals() {\r\n    final ZipShort zs = new ZipShort(0x1234);\r\n    final ZipShort zs2 = new ZipShort(0x1234);\r\n    final ZipShort zs3 = new ZipShort(0x5678);\r\n    assertEquals(zs, zs, \"reflexive\");\r\n    assertEquals(zs, zs2, \"works\");\r\n    assertNotEquals(zs, zs3, \"works, part two\");\r\n    assertEquals(zs2, zs, \"symmetric\");\r\n    assertNotEquals(null, zs, \"null handling\");\r\n    assertNotEquals(zs, Integer.valueOf(0x1234), \"non ZipShort handling\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipShortTest.java",
  "methodName" : "testFromBytes",
  "sourceCode" : "/**\r\n * Test conversion from bytes.\r\n */\r\n@Test\r\nvoid testFromBytes() {\r\n    final byte[] val = { 0x34, 0x12 };\r\n    final ZipShort zs = new ZipShort(val);\r\n    assertEquals(0x1234, zs.getValue(), \"value from bytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipShortTest.java",
  "methodName" : "testPut",
  "sourceCode" : "/**\r\n * Test conversion to bytes.\r\n */\r\n@Test\r\nvoid testPut() {\r\n    final byte[] arr = new byte[3];\r\n    ZipShort.putShort(0x1234, arr, 1);\r\n    assertEquals(0x34, arr[1], \"first byte getBytes\");\r\n    assertEquals(0x12, arr[2], \"second byte getBytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipShortTest.java",
  "methodName" : "testSign",
  "sourceCode" : "/**\r\n * Test sign handling.\r\n */\r\n@Test\r\nvoid testSign() {\r\n    final ZipShort zs = new ZipShort(new byte[] { (byte) 0xFF, (byte) 0xFF });\r\n    assertEquals(0x0000FFFF, zs.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipShortTest.java",
  "methodName" : "testToBytes",
  "sourceCode" : "/**\r\n * Test conversion to bytes.\r\n */\r\n@Test\r\nvoid testToBytes() {\r\n    final ZipShort zs = new ZipShort(0x1234);\r\n    final byte[] result = zs.getBytes();\r\n    assertEquals(2, result.length, \"length getBytes\");\r\n    assertEquals(0x34, result[0], \"first byte getBytes\");\r\n    assertEquals(0x12, result[1], \"second byte getBytes\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipSplitOutputStreamTest.java",
  "methodName" : "testCreateSplittedFiles",
  "sourceCode" : "@Test\r\nvoid testCreateSplittedFiles() throws IOException {\r\n    final File testOutputFile = newTempFile(\"testCreateSplittedFiles.zip\");\r\n    final int splitSize = 100 * 1024;\r\n    /* 100 KB */\r\n    final File fileToTest = getFile(\"COMPRESS-477/split_zip_created_by_zip/zip_to_compare_created_by_zip.zip\");\r\n    try (ZipSplitOutputStream zipSplitOutputStream = new ZipSplitOutputStream(testOutputFile, splitSize);\r\n        InputStream inputStream = Files.newInputStream(fileToTest.toPath())) {\r\n        IOUtils.copy(inputStream, zipSplitOutputStream);\r\n    }\r\n    File zipFile = new File(getTempDirFile().getPath(), \"testCreateSplittedFiles.z01\");\r\n    assertEquals(zipFile.length(), splitSize);\r\n    zipFile = new File(getTempDirFile().getPath(), \"testCreateSplittedFiles.z02\");\r\n    assertEquals(zipFile.length(), splitSize);\r\n    zipFile = new File(getTempDirFile().getPath(), \"testCreateSplittedFiles.z03\");\r\n    assertEquals(zipFile.length(), splitSize);\r\n    zipFile = new File(getTempDirFile().getPath(), \"testCreateSplittedFiles.z04\");\r\n    assertEquals(zipFile.length(), splitSize);\r\n    zipFile = new File(getTempDirFile().getPath(), \"testCreateSplittedFiles.z05\");\r\n    assertEquals(zipFile.length(), splitSize);\r\n    zipFile = new File(getTempDirFile().getPath(), \"testCreateSplittedFiles.zip\");\r\n    assertEquals(zipFile.length(), fileToTest.length() + 4 - splitSize * 5);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipSplitOutputStreamTest.java",
  "methodName" : "testSplitZipBeginsWithZipSplitSignature",
  "sourceCode" : "@Test\r\nvoid testSplitZipBeginsWithZipSplitSignature() throws IOException {\r\n    final File tempFile = createTempFile(\"temp\", \"zip\");\r\n    try (ZipSplitOutputStream is = new ZipSplitOutputStream(tempFile, 100 * 1024L);\r\n        InputStream inputStream = Files.newInputStream(tempFile.toPath())) {\r\n        final byte[] buffer = new byte[4];\r\n        inputStream.read(buffer);\r\n        assertEquals(ByteBuffer.wrap(ZipArchiveOutputStream.DD_SIG).getInt(), ByteBuffer.wrap(buffer).getInt());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipSplitOutputStreamTest.java",
  "methodName" : "testThrowsExceptionIfSplitSizeIsTooLarge",
  "sourceCode" : "@Test\r\nvoid testThrowsExceptionIfSplitSizeIsTooLarge() {\r\n    assertThrows(IllegalArgumentException.class, () -> new ZipSplitOutputStream(createTempFile(\"temp\", \"zip\"), 4 * 1024 * 1024 * 1024L));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipSplitOutputStreamTest.java",
  "methodName" : "testThrowsExceptionIfSplitSizeIsTooSmall",
  "sourceCode" : "@Test\r\nvoid testThrowsExceptionIfSplitSizeIsTooSmall() {\r\n    assertThrows(IllegalArgumentException.class, () -> new ZipSplitOutputStream(createTempFile(\"temp\", \"zip\"), 64 * 1024 - 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipSplitOutputStreamTest.java",
  "methodName" : "testThrowsIfUnsplittableSizeLargerThanSplitSize",
  "sourceCode" : "@Test\r\nvoid testThrowsIfUnsplittableSizeLargerThanSplitSize() throws IOException {\r\n    final long splitSize = 100 * 1024;\r\n    final ZipSplitOutputStream output = new ZipSplitOutputStream(createTempFile(\"temp\", \"zip\"), splitSize);\r\n    assertThrows(IllegalArgumentException.class, () -> output.prepareToWriteUnsplittableContent(splitSize + 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testAdjustToLong",
  "sourceCode" : "@Test\r\nvoid testAdjustToLong() {\r\n    assertEquals(Integer.MAX_VALUE, ZipUtil.adjustToLong(Integer.MAX_VALUE));\r\n    assertEquals((long) Integer.MAX_VALUE + 1, ZipUtil.adjustToLong(Integer.MAX_VALUE + 1));\r\n    assertEquals(2 * (long) Integer.MAX_VALUE, ZipUtil.adjustToLong(2 * Integer.MAX_VALUE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testBigToLong",
  "sourceCode" : "@Test\r\nvoid testBigToLong() {\r\n    final BigInteger big1 = BigInteger.valueOf(1);\r\n    final BigInteger big2 = BigInteger.valueOf(Long.MAX_VALUE);\r\n    final BigInteger big3 = BigInteger.valueOf(Long.MIN_VALUE);\r\n    assertEquals(1L, ZipUtil.toLong(big1));\r\n    assertEquals(Long.MAX_VALUE, ZipUtil.toLong(big2));\r\n    assertEquals(Long.MIN_VALUE, ZipUtil.toLong(big3));\r\n    final BigInteger big4 = big2.add(big1);\r\n    assertThrows(IllegalArgumentException.class, () -> ZipUtil.toLong(big4), \"Should have thrown IllegalArgumentException\");\r\n    final BigInteger big5 = big3.subtract(big1);\r\n    assertThrows(IllegalArgumentException.class, () -> ZipUtil.toLong(big5), \"ZipUtil.bigToLong(BigInteger) should have thrown IllegalArgumentException\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testFromDosTime",
  "sourceCode" : "@Test\r\nvoid testFromDosTime() {\r\n    ZipLong testDosTime = new ZipLong(1 << 21);\r\n    final Calendar cal = Calendar.getInstance();\r\n    cal.set(Calendar.YEAR, 1980);\r\n    cal.set(Calendar.MONTH, 0);\r\n    cal.set(Calendar.DATE, 0);\r\n    cal.set(Calendar.HOUR_OF_DAY, 0);\r\n    cal.set(Calendar.MINUTE, 0);\r\n    cal.set(Calendar.SECOND, 0);\r\n    cal.set(Calendar.MILLISECOND, 0);\r\n    Date testDate = ZipUtil.fromDosTime(testDosTime);\r\n    assertEquals(testDate.getTime(), cal.getTime().getTime());\r\n    testDosTime = ZipUtil.toDosTime(time);\r\n    testDate = ZipUtil.fromDosTime(testDosTime);\r\n    // the minimal time unit for dos time is 2 seconds\r\n    assertEquals(testDate.getTime() / 2000, time.getTime() / 2000);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testInsideCalendar",
  "sourceCode" : "@Test\r\nvoid testInsideCalendar() {\r\n    final long date = toLocalInstant(\"1985-02-01T09:00:00\").toEpochMilli();\r\n    final byte[] b1 = ZipUtil.toDosTime(date);\r\n    assertEquals(0, b1[0]);\r\n    assertEquals(72, b1[1]);\r\n    assertEquals(65, b1[2]);\r\n    assertEquals(10, b1[3]);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testInsideCalendar_bigValue",
  "sourceCode" : "@Test\r\nvoid testInsideCalendar_bigValue() {\r\n    final long date = toLocalInstant(\"2097-11-27T23:59:59\").toEpochMilli();\r\n    final long value = ZipLong.getValue(ZipUtil.toDosTime(date));\r\n    // DOS dates only store even seconds\r\n    assertDosDate(value, 2097, 11, 27, 23, 59, 58);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testInsideCalendar_long",
  "sourceCode" : "@Test\r\nvoid testInsideCalendar_long() {\r\n    final long date = toLocalInstant(\"1985-02-01T09:00:00\").toEpochMilli();\r\n    final long value = ZipLong.getValue(ZipUtil.toDosTime(date));\r\n    assertDosDate(value, 1985, 2, 1, 9, 0, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testInsideCalendar_modernDate",
  "sourceCode" : "@Test\r\nvoid testInsideCalendar_modernDate() {\r\n    final long date = toLocalInstant(\"2022-12-27T16:18:23\").toEpochMilli();\r\n    final long value = ZipLong.getValue(ZipUtil.toDosTime(date));\r\n    // DOS dates only store even seconds\r\n    assertDosDate(value, 2022, 12, 27, 16, 18, 22);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testIsDosTime",
  "sourceCode" : "@Test\r\nvoid testIsDosTime() {\r\n    assertFalse(ZipUtil.isDosTime(toLocalInstant(\"1975-01-31T23:00:00\").toEpochMilli()));\r\n    assertTrue(ZipUtil.isDosTime(toLocalInstant(\"1980-01-03T00:00:00\").toEpochMilli()));\r\n    assertTrue(ZipUtil.isDosTime(toLocalInstant(\"2097-11-27T00:00:00\").toEpochMilli()));\r\n    assertFalse(ZipUtil.isDosTime(toLocalInstant(\"2099-01-01T00:00:00\").toEpochMilli()));\r\n    // The lowest data/time expressable as DOS Time, see comment in ZipUtil#DOSTIME_BEFORE_1980\r\n    // 0x210000\r\n    final long lowestExpressableDosTime = 1 << 21 | 1 << 16;\r\n    assertTrue(ZipUtil.isDosTime(ZipUtil.dosToJavaTime(lowestExpressableDosTime)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testLongToBig",
  "sourceCode" : "@Test\r\nvoid testLongToBig() {\r\n    final long l0 = 0;\r\n    final long l1 = 1;\r\n    final long l2 = -1;\r\n    final long l3 = Integer.MIN_VALUE;\r\n    final long l4 = Long.MAX_VALUE;\r\n    final long l5 = Long.MIN_VALUE;\r\n    final BigInteger big0 = ZipUtil.longToBig(l0);\r\n    final BigInteger big1 = ZipUtil.longToBig(l1);\r\n    final BigInteger big2 = ZipUtil.longToBig(l2);\r\n    final BigInteger big3 = ZipUtil.longToBig(l3);\r\n    final BigInteger big4 = ZipUtil.longToBig(l4);\r\n    assertEquals(0, big0.longValue());\r\n    assertEquals(1, big1.longValue());\r\n    assertEquals(0xFFFFFFFFL, big2.longValue());\r\n    assertEquals(0x80000000L, big3.longValue());\r\n    assertEquals(Long.MAX_VALUE, big4.longValue());\r\n    assertThrows(IllegalArgumentException.class, () -> ZipUtil.longToBig(l5), \"ZipUtil.longToBig(long) should have thrown IllegalArgumentException\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testMinTime",
  "sourceCode" : "@Test\r\nvoid testMinTime() {\r\n    final byte[] b1 = ZipUtil.toDosTime(0);\r\n    // Save the first byte\r\n    final byte b10 = b1[0];\r\n    // change it\r\n    b1[0]++;\r\n    // get the same time\r\n    final byte[] b2 = ZipUtil.toDosTime(0);\r\n    // first byte should still be the same\r\n    assertEquals(b10, b2[0]);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testOutsideCalendar",
  "sourceCode" : "@Test\r\nvoid testOutsideCalendar() {\r\n    final long date = toLocalInstant(\"1975-01-31T23:00:00\").toEpochMilli();\r\n    final byte[] b1 = ZipUtil.toDosTime(date);\r\n    assertEquals(0, b1[0]);\r\n    assertEquals(0, b1[1]);\r\n    assertEquals(33, b1[2]);\r\n    assertEquals(0, b1[3]);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testOutsideCalendar_long",
  "sourceCode" : "@Test\r\nvoid testOutsideCalendar_long() {\r\n    final long date = toLocalInstant(\"1975-01-31T23:00:00\").toEpochMilli();\r\n    final long value = ZipLong.getValue(ZipUtil.toDosTime(date));\r\n    assertDosDate(value, 1980, 1, 1, 0, 0, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testReverse",
  "sourceCode" : "@Test\r\nvoid testReverse() {\r\n    final byte[][] bTest = new byte[6][];\r\n    bTest[0] = new byte[] {};\r\n    bTest[1] = new byte[] { 1 };\r\n    bTest[2] = new byte[] { 1, 2 };\r\n    bTest[3] = new byte[] { 1, 2, 3 };\r\n    bTest[4] = new byte[] { 1, 2, 3, 4 };\r\n    bTest[5] = new byte[] { 1, 2, 3, 4, 5 };\r\n    final byte[][] rTest = new byte[6][];\r\n    rTest[0] = new byte[] {};\r\n    rTest[1] = new byte[] { 1 };\r\n    rTest[2] = new byte[] { 2, 1 };\r\n    rTest[3] = new byte[] { 3, 2, 1 };\r\n    rTest[4] = new byte[] { 4, 3, 2, 1 };\r\n    rTest[5] = new byte[] { 5, 4, 3, 2, 1 };\r\n    assertEquals(bTest.length, rTest.length, \"test and result arrays are same length\");\r\n    for (int i = 0; i < bTest.length; i++) {\r\n        final byte[] result = ZipUtil.reverse(bTest[i]);\r\n        assertSame(bTest[i], result, \"reverse mutates in-place\");\r\n        assertArrayEquals(rTest[i], result, \"reverse actually reverses\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testSignedByteToUnsignedInt",
  "sourceCode" : "@Test\r\nvoid testSignedByteToUnsignedInt() {\r\n    // Yay, we can completely test all possible input values in this case!\r\n    int expectedVal = 128;\r\n    for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {\r\n        final byte b = (byte) i;\r\n        assertEquals(expectedVal, Byte.toUnsignedInt(b));\r\n        expectedVal++;\r\n        if (expectedVal == 256) {\r\n            expectedVal = 0;\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testUnknownMethod",
  "sourceCode" : "@Test\r\nvoid testUnknownMethod() throws Exception {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    ze.setMethod(100);\r\n    assertThrows(UnsupportedZipFeatureException.class, () -> ZipUtil.checkRequestedFeatures(ze));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testUnsignedIntToSignedByte",
  "sourceCode" : "@Test\r\nvoid testUnsignedIntToSignedByte() {\r\n    int unsignedVal = 128;\r\n    for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {\r\n        final byte expectedVal = (byte) i;\r\n        assertEquals(expectedVal, ZipUtil.unsignedIntToSignedByte(unsignedVal));\r\n        unsignedVal++;\r\n        if (unsignedVal == 256) {\r\n            unsignedVal = 0;\r\n        }\r\n    }\r\n    assertThrows(IllegalArgumentException.class, () -> ZipUtil.unsignedIntToSignedByte(-1), \"ZipUtil.unsignedIntToSignedByte(-1) should have thrown IllegalArgumentException\");\r\n    assertThrows(IllegalArgumentException.class, () -> ZipUtil.unsignedIntToSignedByte(256), \"ZipUtil.unsignedIntToSignedByte(256) should have thrown IllegalArgumentException\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testUnsupportedMethod",
  "sourceCode" : "@Test\r\nvoid testUnsupportedMethod() throws Exception {\r\n    final ZipArchiveEntry ze = new ZipArchiveEntry();\r\n    ze.setMethod(ZipMethod.EXPANDING_LEVEL_1.getCode());\r\n    assertThrows(UnsupportedZipFeatureException.class, () -> ZipUtil.checkRequestedFeatures(ze));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\zip\\ZipUtilTest.java",
  "methodName" : "testZipLong",
  "sourceCode" : "@Test\r\nvoid testZipLong() {\r\n    final ZipLong test = ZipUtil.toDosTime(time);\r\n    assertEquals(test.getValue(), zl.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testBuildArtificialSplitZip32Test",
  "sourceCode" : "/**\r\n * Tests split archive with 32-bit limit, both STORED and DEFLATED.\r\n */\r\n@Test\r\nvoid testBuildArtificialSplitZip32Test() throws IOException {\r\n    final File outputZipFile = newTempFile(\"artificialSplitZip.zip\");\r\n    final long splitSize = 64 * 1024L;\r\n    /* 64 KB */\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(outputZipFile, splitSize)) {\r\n        outputStream.setUseZip64(Zip64Mode.Never);\r\n        final ZipArchiveEntry ze1 = new ZipArchiveEntry(\"file01\");\r\n        ze1.setMethod(ZipEntry.STORED);\r\n        outputStream.putArchiveEntry(ze1);\r\n        outputStream.write(createArtificialData(65536));\r\n        outputStream.closeArchiveEntry();\r\n        final ZipArchiveEntry ze2 = new ZipArchiveEntry(\"file02\");\r\n        ze2.setMethod(ZipEntry.DEFLATED);\r\n        outputStream.putArchiveEntry(ze2);\r\n        outputStream.write(createArtificialData(65536));\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zipFile = ZipFile.builder().setPath(outputZipFile.toPath()).setMaxNumberOfDisks(Integer.MAX_VALUE).get()) {\r\n        assertArrayEquals(createArtificialData(65536), IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file01\"))));\r\n        assertArrayEquals(createArtificialData(65536), IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file02\"))));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testBuildArtificialSplitZip64Test",
  "sourceCode" : "/**\r\n * Tests split archive with 64-bit limit, both STORED and DEFLATED.\r\n */\r\n@Test\r\nvoid testBuildArtificialSplitZip64Test() throws IOException {\r\n    final File outputZipFile = newTempFile(\"artificialSplitZip.zip\");\r\n    final long splitSize = 64 * 1024L;\r\n    /* 64 KB */\r\n    final byte[] data = createArtificialData(128 * 1024);\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(outputZipFile, splitSize)) {\r\n        outputStream.setUseZip64(Zip64Mode.Always);\r\n        final ZipArchiveEntry ze1 = new ZipArchiveEntry(\"file01\");\r\n        ze1.setMethod(ZipEntry.STORED);\r\n        outputStream.putArchiveEntry(ze1);\r\n        outputStream.write(data);\r\n        outputStream.closeArchiveEntry();\r\n        final ZipArchiveEntry ze2 = new ZipArchiveEntry(\"file02\");\r\n        ze2.setMethod(ZipEntry.DEFLATED);\r\n        outputStream.putArchiveEntry(ze2);\r\n        outputStream.write(data);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zipFile = ZipFile.builder().setPath(outputZipFile.toPath()).setMaxNumberOfDisks(Integer.MAX_VALUE).get()) {\r\n        assertArrayEquals(data, IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file01\"))));\r\n        assertArrayEquals(data, IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file02\"))));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testBuildSplitZip32_endOfCentralDirectorySkipBoundary",
  "sourceCode" : "/**\r\n * Tests split archive with 32-bit limit, with end of central directory skipping lack of space in segment.\r\n */\r\n@Test\r\nvoid testBuildSplitZip32_endOfCentralDirectorySkipBoundary() throws IOException {\r\n    final File outputZipFile = newTempFile(\"artificialSplitZip.zip\");\r\n    final long splitSize = 64 * 1024L;\r\n    /* 64 KB */\r\n    // 4 is PK signature, 36 is size of header + local file header,\r\n    // 36 is length of central directory entry\r\n    // 1 is remaining byte in first archive, this should be skipped\r\n    final byte[] data1 = createArtificialData(64 * 1024 - 4 - 36 - 52 - 1);\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(outputZipFile, splitSize)) {\r\n        outputStream.setUseZip64(Zip64Mode.Never);\r\n        final ZipArchiveEntry ze1 = new ZipArchiveEntry(\"file01\");\r\n        ze1.setMethod(ZipEntry.STORED);\r\n        outputStream.putArchiveEntry(ze1);\r\n        outputStream.write(data1);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    assertEquals(64 * 1024L - 1, Files.size(outputZipFile.toPath().getParent().resolve(\"artificialSplitZip.z01\")));\r\n    try (ZipFile zipFile = ZipFile.builder().setPath(outputZipFile.toPath()).setMaxNumberOfDisks(Integer.MAX_VALUE).get()) {\r\n        assertArrayEquals(data1, IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file01\"))));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testBuildSplitZip32_metaCrossBoundary",
  "sourceCode" : "/**\r\n * Tests split archive with 32-bit limit, with file local headers crossing segment boundaries.\r\n */\r\n@Test\r\nvoid testBuildSplitZip32_metaCrossBoundary() throws IOException {\r\n    final File outputZipFile = newTempFile(\"artificialSplitZip.zip\");\r\n    final long splitSize = 64 * 1024L;\r\n    /* 64 KB */\r\n    // 4 is PK signature, 36 is size of header + local file header,\r\n    // 15 is next local file header up to second byte of CRC\r\n    final byte[] data1 = createArtificialData(64 * 1024 - 4 - 36 - 15);\r\n    // 21 is remaining size of second local file header\r\n    // 19 is next local file header up to second byte of compressed size\r\n    final byte[] data2 = createArtificialData(64 * 1024 - 21 - 19);\r\n    // 17 is remaining size of third local file header\r\n    // 23 is next local file header up to second byte of uncompressed size\r\n    final byte[] data3 = createArtificialData(64 * 1024 - 17 - 23);\r\n    // 13 is remaining size of third local file header\r\n    // 1 is to wrap to next part\r\n    final byte[] data4 = createArtificialData(64 * 1024 - 13 + 1);\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(outputZipFile, splitSize)) {\r\n        outputStream.setUseZip64(Zip64Mode.Never);\r\n        final ZipArchiveEntry ze1 = new ZipArchiveEntry(\"file01\");\r\n        ze1.setMethod(ZipEntry.STORED);\r\n        outputStream.putArchiveEntry(ze1);\r\n        outputStream.write(data1);\r\n        outputStream.closeArchiveEntry();\r\n        final ZipArchiveEntry ze2 = new ZipArchiveEntry(\"file02\");\r\n        ze2.setMethod(ZipEntry.STORED);\r\n        outputStream.putArchiveEntry(ze2);\r\n        outputStream.write(data2);\r\n        outputStream.closeArchiveEntry();\r\n        final ZipArchiveEntry ze3 = new ZipArchiveEntry(\"file03\");\r\n        ze3.setMethod(ZipEntry.STORED);\r\n        outputStream.putArchiveEntry(ze3);\r\n        outputStream.write(data3);\r\n        outputStream.closeArchiveEntry();\r\n        final ZipArchiveEntry ze4 = new ZipArchiveEntry(\"file04\");\r\n        ze4.setMethod(ZipEntry.STORED);\r\n        outputStream.putArchiveEntry(ze4);\r\n        outputStream.write(data4);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zipFile = ZipFile.builder().setPath(outputZipFile.toPath()).setMaxNumberOfDisks(Integer.MAX_VALUE).get()) {\r\n        assertArrayEquals(data1, IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file01\"))));\r\n        assertArrayEquals(data2, IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file02\"))));\r\n        assertArrayEquals(data3, IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file03\"))));\r\n        assertArrayEquals(data4, IOUtils.toByteArray(zipFile.getInputStream(zipFile.getEntry(\"file04\"))));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testBuildSplitZipTest",
  "sourceCode" : "@Test\r\nvoid testBuildSplitZipTest() throws IOException {\r\n    final File directoryToZip = getFilesToZip();\r\n    createTestSplitZipSegments();\r\n    final File lastFile = newTempFile(\"splitZip.zip\");\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile);\r\n        InputStream inputStream = Channels.newInputStream(channel);\r\n        ZipArchiveInputStream splitInputStream = ZipArchiveInputStream.builder().setInputStream(inputStream).setSkipSplitSignature(true).get()) {\r\n        ArchiveEntry entry;\r\n        final int filesNum = countNonDirectories(directoryToZip);\r\n        int filesCount = 0;\r\n        while ((entry = splitInputStream.getNextEntry()) != null) {\r\n            if (entry.isDirectory()) {\r\n                continue;\r\n            }\r\n            // compare all files one by one\r\n            assertArrayEquals(IOUtils.toByteArray(splitInputStream), Files.readAllBytes(Paths.get(entry.getName())));\r\n            filesCount++;\r\n        }\r\n        // and the number of files should equal\r\n        assertEquals(filesCount, filesNum);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testBuildSplitZipWithSegmentAlreadyExistThrowsException",
  "sourceCode" : "@Test\r\nvoid testBuildSplitZipWithSegmentAlreadyExistThrowsException() throws IOException {\r\n    final File directoryToZip = getFilesToZip();\r\n    final File outputZipFile = newTempFile(\"splitZip.zip\");\r\n    final long splitSize = 100 * 1024L;\r\n    /* 100 KB */\r\n    try (ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(outputZipFile, splitSize)) {\r\n        // create a file that has the same name of one of the created split segments\r\n        final File sameNameFile = newTempFile(\"splitZip.z01\");\r\n        sameNameFile.createNewFile();\r\n        assertThrows(ArchiveException.class, () -> addFilesToZip(zipArchiveOutputStream, directoryToZip));\r\n    } catch (final Exception e) {\r\n        // Ignore:\r\n        // java.io.IOException: This archive contains unclosed entries.\r\n        // at org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.finish(ZipArchiveOutputStream.java:563)\r\n        // at org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.close(ZipArchiveOutputStream.java:1119)\r\n        // at org.apache.commons.compress.archivers.ZipTestCase.buildSplitZipWithSegmentAlreadyExistThrowsException(ZipTestCase.java:715)\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testBuildSplitZipWithTooLargeSizeThrowsException",
  "sourceCode" : "@Test\r\nvoid testBuildSplitZipWithTooLargeSizeThrowsException() throws IOException {\r\n    final Path file = Files.createTempFile(\"temp\", \"zip\");\r\n    try {\r\n        assertThrows(IllegalArgumentException.class, () -> new ZipArchiveOutputStream(file, 4294967295L + 1));\r\n    } finally {\r\n        Files.delete(file);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testBuildSplitZipWithTooSmallSizeThrowsException",
  "sourceCode" : "@Test\r\nvoid testBuildSplitZipWithTooSmallSizeThrowsException() throws IOException {\r\n    createTempFile(\"temp\", \"zip\").toPath();\r\n    assertThrows(IllegalArgumentException.class, () -> new ZipArchiveOutputStream(createTempFile(\"temp\", \"zip\"), 64 * 1024 - 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testCopyRawEntriesFromFile",
  "sourceCode" : "@Test\r\nvoid testCopyRawEntriesFromFile() throws IOException {\r\n    final File reference = createReferenceFile(Zip64Mode.Never, \"expected.\");\r\n    final File file1 = createTempFile(\"src1.\", \".zip\");\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(file1)) {\r\n        zos.setUseZip64(Zip64Mode.Never);\r\n        createFirstEntry(zos).close();\r\n    }\r\n    final File file2 = createTempFile(\"src2.\", \".zip\");\r\n    try (ZipArchiveOutputStream zos1 = new ZipArchiveOutputStream(file2)) {\r\n        zos1.setUseZip64(Zip64Mode.Never);\r\n        createSecondEntry(zos1).close();\r\n    }\r\n    try (ZipFile zipFile1 = newZipFile(file1);\r\n        ZipFile zipFile2 = newZipFile(file2)) {\r\n        final File fileResult = createTempFile(\"file-actual.\", \".zip\");\r\n        try (ZipArchiveOutputStream zos2 = new ZipArchiveOutputStream(fileResult)) {\r\n            zipFile1.copyRawEntries(zos2, allFilesPredicate);\r\n            zipFile2.copyRawEntries(zos2, allFilesPredicate);\r\n        }\r\n        // copyRawEntries does not add superfluous zip64 header like regular ZIP output stream\r\n        // does when using Zip64Mode.AsNeeded so all the source material has to be Zip64Mode.Never,\r\n        // if exact binary equality is to be achieved\r\n        assertSameFileContents(reference, fileResult);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testCopyRawZip64EntryFromFile",
  "sourceCode" : "@Test\r\nvoid testCopyRawZip64EntryFromFile() throws IOException {\r\n    final File reference = createTempFile(\"z64reference.\", \".zip\");\r\n    try (ZipArchiveOutputStream zos1 = new ZipArchiveOutputStream(reference)) {\r\n        zos1.setUseZip64(Zip64Mode.Always);\r\n        createFirstEntry(zos1);\r\n    }\r\n    final File file1 = createTempFile(\"zip64src.\", \".zip\");\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(file1)) {\r\n        zos.setUseZip64(Zip64Mode.Always);\r\n        createFirstEntry(zos).close();\r\n    }\r\n    final File fileResult = createTempFile(\"file-actual.\", \".zip\");\r\n    try (ZipFile zipFile1 = newZipFile(file1)) {\r\n        try (ZipArchiveOutputStream zos2 = new ZipArchiveOutputStream(fileResult)) {\r\n            zos2.setUseZip64(Zip64Mode.Always);\r\n            zipFile1.copyRawEntries(zos2, allFilesPredicate);\r\n        }\r\n        assertSameFileContents(reference, fileResult);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testDirectoryEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testDirectoryEntryFromFile() throws Exception {\r\n    final File tmp = getTempDirFile();\r\n    final File archive = createTempFile(\"test.\", \".zip\");\r\n    final long beforeArchiveWrite;\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(archive)) {\r\n        beforeArchiveWrite = tmp.lastModified();\r\n        final ZipArchiveEntry in = new ZipArchiveEntry(tmp, \"foo\");\r\n        zos.putArchiveEntry(in);\r\n        zos.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zf = newZipFile(archive)) {\r\n        final ZipArchiveEntry out = zf.getEntry(\"foo/\");\r\n        assertNotNull(out);\r\n        assertEquals(\"foo/\", out.getName());\r\n        assertEquals(0, out.getSize());\r\n        // ZIP stores time with a granularity of 2 seconds\r\n        assertEquals(beforeArchiveWrite / 2000, out.getLastModifiedDate().getTime() / 2000);\r\n        assertTrue(out.isDirectory());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testExplicitDirectoryEntry",
  "sourceCode" : "@Test\r\nvoid testExplicitDirectoryEntry() throws Exception {\r\n    final File archive = createTempFile(\"test.\", \".zip\");\r\n    final long beforeArchiveWrite;\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(archive)) {\r\n        beforeArchiveWrite = getTempDirFile().lastModified();\r\n        final ZipArchiveEntry in = new ZipArchiveEntry(\"foo/\");\r\n        in.setTime(beforeArchiveWrite);\r\n        zos.putArchiveEntry(in);\r\n        zos.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zf = newZipFile(archive)) {\r\n        final ZipArchiveEntry out = zf.getEntry(\"foo/\");\r\n        assertNotNull(out);\r\n        assertEquals(\"foo/\", out.getName());\r\n        assertEquals(0, out.getSize());\r\n        assertEquals(beforeArchiveWrite / 2000, out.getLastModifiedDate().getTime() / 2000);\r\n        assertTrue(out.isDirectory());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testExplicitFileEntry",
  "sourceCode" : "@Test\r\nvoid testExplicitFileEntry() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".zip\");\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(archive)) {\r\n        final ZipArchiveEntry in = new ZipArchiveEntry(\"foo\");\r\n        in.setTime(file.lastModified());\r\n        in.setSize(file.length());\r\n        outputStream.putArchiveEntry(in);\r\n        outputStream.write(file);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zf = newZipFile(archive)) {\r\n        final ZipArchiveEntry out = zf.getEntry(\"foo\");\r\n        assertNotNull(out);\r\n        assertEquals(\"foo\", out.getName());\r\n        assertEquals(file.length(), out.getSize());\r\n        assertEquals(file.lastModified() / 2000, out.getLastModifiedDate().getTime() / 2000);\r\n        assertFalse(out.isDirectory());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testFileEntryFromFile",
  "sourceCode" : "@Test\r\nvoid testFileEntryFromFile() throws Exception {\r\n    final File file = createTempFile();\r\n    final File archive = createTempFile(\"test.\", \".zip\");\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(archive)) {\r\n        final ZipArchiveEntry in = new ZipArchiveEntry(file, \"foo\");\r\n        outputStream.putArchiveEntry(in);\r\n        outputStream.write(file);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zf = newZipFile(archive)) {\r\n        final ZipArchiveEntry out = zf.getEntry(\"foo\");\r\n        assertNotNull(out);\r\n        assertEquals(\"foo\", out.getName());\r\n        assertEquals(file.length(), out.getSize());\r\n        assertEquals(file.lastModified() / 2000, out.getLastModifiedDate().getTime() / 2000);\r\n        assertFalse(out.isDirectory());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testInputStreamStatisticsForBzip2Entry",
  "sourceCode" : "@Test\r\nvoid testInputStreamStatisticsForBzip2Entry() throws IOException, ArchiveException {\r\n    final Map<String, List<Long>> expected = new HashMap<>();\r\n    expected.put(\"lots-of-as\", Arrays.asList(42L, 39L));\r\n    testInputStreamStatistics(\"bzip2-zip.zip\", expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testInputStreamStatisticsForDeflate64Entry",
  "sourceCode" : "@Test\r\nvoid testInputStreamStatisticsForDeflate64Entry() throws IOException, ArchiveException {\r\n    final Map<String, List<Long>> expected = new HashMap<>();\r\n    expected.put(\"input2\", Arrays.asList(3072L, 2111L));\r\n    testInputStreamStatistics(\"COMPRESS-380/COMPRESS-380.zip\", expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testInputStreamStatisticsForImplodedEntry",
  "sourceCode" : "@Test\r\nvoid testInputStreamStatisticsForImplodedEntry() throws IOException, ArchiveException {\r\n    final Map<String, List<Long>> expected = new HashMap<>();\r\n    expected.put(\"LICENSE.TXT\", Arrays.asList(11560L, 4131L));\r\n    testInputStreamStatistics(\"imploding-8Kdict-3trees.zip\", expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testInputStreamStatisticsForShrunkEntry",
  "sourceCode" : "@Test\r\nvoid testInputStreamStatisticsForShrunkEntry() throws IOException, ArchiveException {\r\n    final Map<String, List<Long>> expected = new HashMap<>();\r\n    expected.put(\"TEST1.XML\", Arrays.asList(76L, 66L));\r\n    expected.put(\"TEST2.XML\", Arrays.asList(81L, 76L));\r\n    testInputStreamStatistics(\"SHRUNK.ZIP\", expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testInputStreamStatisticsForStoredEntry",
  "sourceCode" : "@Test\r\nvoid testInputStreamStatisticsForStoredEntry() throws IOException, ArchiveException {\r\n    final Map<String, List<Long>> expected = new HashMap<>();\r\n    expected.put(\"test.txt\", Arrays.asList(5L, 5L));\r\n    testInputStreamStatistics(\"COMPRESS-264.zip\", expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testInputStreamStatisticsOfZipBombExcel",
  "sourceCode" : "@Test\r\nvoid testInputStreamStatisticsOfZipBombExcel() throws IOException, ArchiveException {\r\n    final Map<String, List<Long>> expected = new HashMap<>();\r\n    expected.put(\"[Content_Types].xml\", Arrays.asList(8390036L, 8600L));\r\n    expected.put(\"xl/worksheets/sheet1.xml\", Arrays.asList(1348L, 508L));\r\n    testInputStreamStatistics(\"zipbomb.xlsx\", expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testListAllFilesWithNestedArchive",
  "sourceCode" : "/**\r\n * Checks if all entries from a nested archive can be read. The archive: OSX_ArchiveWithNestedArchive.zip contains: NestedArchiv.zip and test.xml3.\r\n *\r\n * The nested archive: NestedArchive.zip contains test1.xml and test2.xml\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testListAllFilesWithNestedArchive() throws Exception {\r\n    final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\r\n    final List<String> results = new ArrayList<>();\r\n    final List<ZipException> expectedExceptions = new ArrayList<>();\r\n    try (InputStream fis = Files.newInputStream(input.toPath());\r\n        ZipArchiveInputStream in = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"zip\", fis)) {\r\n        ZipArchiveEntry entry;\r\n        while ((entry = in.getNextEntry()) != null) {\r\n            results.add(entry.getName());\r\n            final ZipArchiveInputStream nestedIn = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"zip\", in);\r\n            try {\r\n                ZipArchiveEntry nestedEntry;\r\n                while ((nestedEntry = nestedIn.getNextEntry()) != null) {\r\n                    results.add(nestedEntry.getName());\r\n                }\r\n            } catch (final ZipException ex) {\r\n                // expected since you cannot create a final ArchiveInputStream from test3.xml\r\n                expectedExceptions.add(ex);\r\n            }\r\n            // nested stream must not be closed here\r\n        }\r\n    }\r\n    assertTrue(results.contains(\"NestedArchiv.zip\"));\r\n    assertTrue(results.contains(\"test1.xml\"));\r\n    assertTrue(results.contains(\"test2.xml\"));\r\n    assertTrue(results.contains(\"test3.xml\"));\r\n    assertEquals(1, expectedExceptions.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testSkipEntryWithUnsupportedCompressionMethod",
  "sourceCode" : "/**\r\n * Test case for being able to skip an entry in an {@link ZipArchiveInputStream} even if the compression method of that entry is unsupported.\r\n *\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-93\">COMPRESS-93</a>\r\n */\r\n@Test\r\nvoid testSkipEntryWithUnsupportedCompressionMethod() throws IOException {\r\n    try (ZipArchiveInputStream zip = ZipArchiveInputStream.builder().setURI(getURI(\"moby.zip\")).get()) {\r\n        final ZipArchiveEntry entry = zip.getNextZipEntry();\r\n        assertEquals(ZipMethod.TOKENIZATION.getCode(), entry.getMethod(), \"method\");\r\n        assertEquals(\"README\", entry.getName());\r\n        assertFalse(zip.canReadEntryData(entry));\r\n        assertDoesNotThrow(() -> assertNull(zip.getNextZipEntry()), \"COMPRESS-93: Unable to skip an unsupported ZIP entry\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testSkipsPK00Prefix",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-208\">COMPRESS-208</a>.\r\n */\r\n@Test\r\nvoid testSkipsPK00Prefix() throws Exception {\r\n    final ArrayList<String> al = new ArrayList<>();\r\n    al.add(\"test1.xml\");\r\n    al.add(\"test2.xml\");\r\n    try (ZipArchiveInputStream inputStream = ZipArchiveInputStream.builder().setURI(getURI(\"COMPRESS-208.zip\")).get()) {\r\n        checkArchiveContent(inputStream, al);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testTokenizationCompressionMethod",
  "sourceCode" : "/**\r\n * Test case for <a href=\"https://issues.apache.org/jira/browse/COMPRESS-93\">COMPRESS-93</a>.\r\n */\r\n@Test\r\nvoid testTokenizationCompressionMethod() throws IOException {\r\n    try (ZipFile moby = ZipFile.builder().setFile(getFile(\"moby.zip\")).get()) {\r\n        final ZipArchiveEntry entry = moby.getEntry(\"README\");\r\n        assertEquals(ZipMethod.TOKENIZATION.getCode(), entry.getMethod(), \"method\");\r\n        assertFalse(moby.canReadEntryData(entry));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testUnixModeInAddRaw",
  "sourceCode" : "@Test\r\nvoid testUnixModeInAddRaw() throws IOException {\r\n    final File file1 = createTempFile(\"unixModeBits.\", \".zip\");\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(file1)) {\r\n        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"fred\");\r\n        archiveEntry.setUnixMode(0664);\r\n        archiveEntry.setMethod(ZipEntry.STORED);\r\n        archiveEntry.setSize(3);\r\n        archiveEntry.setCompressedSize(3);\r\n        zos.addRawArchiveEntry(archiveEntry, new ByteArrayInputStream(\"fud\".getBytes()));\r\n    }\r\n    try (ZipFile zf1 = newZipFile(file1)) {\r\n        final ZipArchiveEntry fred = zf1.getEntry(\"fred\");\r\n        assertEquals(0664, fred.getUnixMode());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testUnsupportedCompressionMethodInAddRaw",
  "sourceCode" : "@Test\r\nvoid testUnsupportedCompressionMethodInAddRaw() throws IOException {\r\n    final File file1 = createTempFile(\"unsupportedCompressionMethod.\", \".zip\");\r\n    try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(file1)) {\r\n        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"fred\");\r\n        archiveEntry.setMethod(Integer.MAX_VALUE);\r\n        archiveEntry.setSize(3);\r\n        archiveEntry.setCompressedSize(3);\r\n        archiveEntry.setCrc(0);\r\n        zos.addRawArchiveEntry(archiveEntry, new ByteArrayInputStream(\"fud\".getBytes()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testZipArchiveCreation",
  "sourceCode" : "/**\r\n * Archives 2 files and unarchives it again. If the file length of result and source is the same, it looks like the operations have worked\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testZipArchiveCreation() throws Exception {\r\n    // Archive\r\n    final File output = newTempFile(\"bla.zip\");\r\n    final File file1 = getFile(\"test1.xml\");\r\n    final File file2 = getFile(\"test2.xml\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath())) {\r\n        try (ArchiveOutputStream<ZipArchiveEntry> os = ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(\"zip\", out)) {\r\n            // entry 1\r\n            os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\r\n            os.write(file1);\r\n            os.closeArchiveEntry();\r\n            // entry 2\r\n            os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\r\n            os.write(file2);\r\n            os.closeArchiveEntry();\r\n        }\r\n    }\r\n    // Unarchive the same\r\n    final List<File> results = new ArrayList<>();\r\n    try (InputStream fileInputStream = Files.newInputStream(output.toPath())) {\r\n        try (ArchiveInputStream<ZipArchiveEntry> archiveInputStream = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"zip\", fileInputStream)) {\r\n            archiveInputStream.forEach(entry -> {\r\n                final File outfile = new File(tempResultDir.getCanonicalPath() + \"/result/\" + entry.getName());\r\n                outfile.getParentFile().mkdirs();\r\n                Files.copy(archiveInputStream, outfile.toPath());\r\n                results.add(outfile);\r\n            });\r\n        }\r\n    }\r\n    assertEquals(results.size(), 2);\r\n    File result = results.get(0);\r\n    assertEquals(file1.length(), result.length());\r\n    result = results.get(1);\r\n    assertEquals(file2.length(), result.length());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testZipArchiveCreationInMemory",
  "sourceCode" : "/**\r\n * Archives 2 files and unarchives it again. If the file contents of result and source is the same, it looks like the operations have worked\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testZipArchiveCreationInMemory() throws Exception {\r\n    final byte[] file1Contents = readAllBytes(\"test1.xml\");\r\n    final byte[] file2Contents = readAllBytes(\"test2.xml\");\r\n    final List<byte[]> results = new ArrayList<>();\r\n    try (SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel()) {\r\n        try (ZipArchiveOutputStream os = new ZipArchiveOutputStream(channel)) {\r\n            os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\r\n            os.write(file1Contents);\r\n            os.closeArchiveEntry();\r\n            os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\r\n            os.write(file2Contents);\r\n            os.closeArchiveEntry();\r\n        }\r\n        // Unarchive the same\r\n        try (ZipArchiveInputStream inputStream = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"zip\", new ByteArrayInputStream(channel.array()))) {\r\n            ZipArchiveEntry entry;\r\n            while ((entry = inputStream.getNextEntry()) != null) {\r\n                final byte[] result = new byte[(int) entry.getSize()];\r\n                IOUtils.readFully(inputStream, result);\r\n                results.add(result);\r\n            }\r\n        }\r\n    }\r\n    assertArrayEquals(results.get(0), file1Contents);\r\n    assertArrayEquals(results.get(1), file2Contents);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testZipArchiveEntryNewFromPath",
  "sourceCode" : "@Test\r\nvoid testZipArchiveEntryNewFromPath() throws Exception {\r\n    final Path archivePath;\r\n    final File tmpFile = createTempFile();\r\n    final Path tmpFilePath = tmpFile.toPath();\r\n    final File archiveFile = createTempFile(\"test.\", \".zip\");\r\n    archivePath = archiveFile.toPath();\r\n    try (ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(archivePath)) {\r\n        final ZipArchiveEntry in = outputStream.createArchiveEntry(tmpFilePath, \"foo\");\r\n        outputStream.putArchiveEntry(in);\r\n        outputStream.write(tmpFilePath);\r\n        outputStream.closeArchiveEntry();\r\n    }\r\n    try (ZipFile zf = newZipFile(archiveFile)) {\r\n        final ZipArchiveEntry out = zf.getEntry(\"foo\");\r\n        assertNotNull(out);\r\n        assertEquals(\"foo\", out.getName());\r\n        assertEquals(tmpFile.length(), out.getSize());\r\n        assertEquals(tmpFile.lastModified() / 2000, out.getLastModifiedDate().getTime() / 2000);\r\n        assertFalse(out.isDirectory());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\archivers\\ZipTest.java",
  "methodName" : "testZipUnarchive",
  "sourceCode" : "/**\r\n * Simple unarchive test. Asserts nothing.\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testZipUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.zip\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<ZipArchiveEntry> in = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"zip\", is)) {\r\n        final ZipArchiveEntry entry = in.getNextEntry();\r\n        Files.copy(in, newTempFile(entry.getName()).toPath());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testAsciiConversions",
  "sourceCode" : "@Test\r\nvoid testAsciiConversions() {\r\n    asciiToByteAndBackOK(\"\");\r\n    asciiToByteAndBackOK(\"abcd\");\r\n    asciiToByteAndBackFail(\"\\u8025\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testCompareAscii",
  "sourceCode" : "@Test\r\nvoid testCompareAscii() {\r\n    final byte[] buffer1 = { 'a', 'b', 'c' };\r\n    final byte[] buffer2 = { 'd', 'e', 'f', 0 };\r\n    assertTrue(ArchiveUtils.matchAsciiBuffer(\"abc\", buffer1));\r\n    assertFalse(ArchiveUtils.matchAsciiBuffer(\"abc\\0\", buffer1));\r\n    assertTrue(ArchiveUtils.matchAsciiBuffer(\"def\\0\", buffer2));\r\n    assertFalse(ArchiveUtils.matchAsciiBuffer(\"def\", buffer2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testCompareBA",
  "sourceCode" : "@Test\r\nvoid testCompareBA() {\r\n    final byte[] buffer1 = { 1, 2, 3 };\r\n    final byte[] buffer2 = { 1, 2, 3, 0 };\r\n    final byte[] buffer3 = { 1, 2, 3 };\r\n    assertTrue(ArchiveUtils.isEqual(buffer1, buffer2, true));\r\n    assertFalse(ArchiveUtils.isEqual(buffer1, buffer2, false));\r\n    assertFalse(ArchiveUtils.isEqual(buffer1, buffer2));\r\n    assertTrue(ArchiveUtils.isEqual(buffer2, buffer1, true));\r\n    assertFalse(ArchiveUtils.isEqual(buffer2, buffer1, false));\r\n    assertFalse(ArchiveUtils.isEqual(buffer2, buffer1));\r\n    assertTrue(ArchiveUtils.isEqual(buffer1, buffer3));\r\n    assertTrue(ArchiveUtils.isEqual(buffer3, buffer1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testIsEqual",
  "sourceCode" : "@Test\r\nvoid testIsEqual() {\r\n    assertTrue(ArchiveUtils.isEqual(null, 0, 0, null, 0, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testIsEqualWithNullWithPositive",
  "sourceCode" : "@Test\r\nvoid testIsEqualWithNullWithPositive() {\r\n    final byte[] byteArray = new byte[8];\r\n    byteArray[1] = (byte) -77;\r\n    assertFalse(ArchiveUtils.isEqualWithNull(byteArray, 0, (byte) 0, byteArray, (byte) 0, (byte) 80));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testSanitizeLeavesShortStringsAlone",
  "sourceCode" : "@Test\r\nvoid testSanitizeLeavesShortStringsAlone() {\r\n    final String input = \"012345678901234567890123456789012345678901234567890123456789\";\r\n    assertEquals(input, ArchiveUtils.sanitize(input));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testSanitizeRemovesUnprintableCharacters",
  "sourceCode" : "@Test\r\nvoid testSanitizeRemovesUnprintableCharacters() {\r\n    final String input = \"\\b12345678901234567890123456789012345678901234567890123456789\";\r\n    final String expected = \"?12345678901234567890123456789012345678901234567890123456789\";\r\n    assertEquals(expected, ArchiveUtils.sanitize(input));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testSanitizeShortensString",
  "sourceCode" : "@Test\r\nvoid testSanitizeShortensString() {\r\n    // @formatter:off\r\n    final String input = \"012345678901234567890123456789012345678901234567890123456789\" + \"012345678901234567890123456789012345678901234567890123456789\" + \"012345678901234567890123456789012345678901234567890123456789\" + \"012345678901234567890123456789012345678901234567890123456789\" + \"012345678901234567890123456789012345678901234567890123456789\";\r\n    final String expected = \"012345678901234567890123456789012345678901234567890123456789\" + \"012345678901234567890123456789012345678901234567890123456789\" + \"012345678901234567890123456789012345678901234567890123456789\" + \"012345678901234567890123456789012345678901234567890123456789\" + \"012345678901...\";\r\n    // @formatter:on\r\n    assertEquals(expected, ArchiveUtils.sanitize(input));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testToAsciiBytes",
  "sourceCode" : "@Test\r\nvoid testToAsciiBytes() {\r\n    final byte[] byteArray = ArchiveUtils.toAsciiBytes(\"SOCKET\");\r\n    assertArrayEquals(new byte[] { (byte) 83, (byte) 79, (byte) 67, (byte) 75, (byte) 69, (byte) 84 }, byteArray);\r\n    assertFalse(ArchiveUtils.isEqualWithNull(byteArray, 0, 46, byteArray, 63, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testToAsciiStringThrowsStringIndexOutOfBoundsException",
  "sourceCode" : "@Test\r\nvoid testToAsciiStringThrowsStringIndexOutOfBoundsException() {\r\n    final byte[] byteArray = new byte[3];\r\n    assertThrows(StringIndexOutOfBoundsException.class, () -> ArchiveUtils.toAsciiString(byteArray, 940, 2730));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ArchiveUtilsTest.java",
  "methodName" : "testToStringWithNonNull",
  "sourceCode" : "@Test\r\nvoid testToStringWithNonNull() {\r\n    final SevenZArchiveEntry sevenZArchiveEntry = new SevenZArchiveEntry();\r\n    assertEquals(\"-       0 null\", ArchiveUtils.toString(sevenZArchiveEntry));\r\n    sevenZArchiveEntry.setDirectory(true);\r\n    assertEquals(\"d       0 null\", ArchiveUtils.toString(sevenZArchiveEntry));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ChainingTest.java",
  "methodName" : "testTarBzip2",
  "sourceCode" : "@Test\r\nvoid testTarBzip2() throws Exception {\r\n    try (TarArchiveInputStream is = TarArchiveInputStream.builder().setInputStream(new BZip2CompressorInputStream(newInputStream(\"bla.tar.bz2\"))).get()) {\r\n        final TarArchiveEntry entry = is.getNextEntry();\r\n        assertNotNull(entry);\r\n        assertEquals(\"test1.xml\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\ChainingTest.java",
  "methodName" : "testTarGzip",
  "sourceCode" : "@Test\r\nvoid testTarGzip() throws Exception {\r\n    try (TarArchiveInputStream is = TarArchiveInputStream.builder().setInputStream(GzipCompressorInputStream.builder().setURI(getURI(\"bla.tgz\")).get()).get()) {\r\n        final TarArchiveEntry entry = is.getNextEntry();\r\n        assertNotNull(entry);\r\n        assertEquals(\"test1.xml\", entry.getName());\r\n        assertEquals(TarConstants.LF_NORMAL, entry.getLinkFlag());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testAddAlreadyExistingWithReplaceFalse",
  "sourceCode" : "/**\r\n * Adds a file with the same file name as an existing file from the stream. Should lead to a replacement.\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testAddAlreadyExistingWithReplaceFalse(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(getPath(\"test.txt\"))) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        final ArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\r\n        changeSet.add(entry, csInputStream, false);\r\n        final ChangeSetResults results = new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n        assertTrue(results.getAddedFromStream().contains(\"testdata/test1.xml\"));\r\n        assertTrue(results.getAddedFromChangeSet().isEmpty());\r\n        assertTrue(results.getDeleted().isEmpty());\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(inputPath);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testAddAlreadyExistingWithReplaceTrue",
  "sourceCode" : "/**\r\n * Adds a file with the same file name as an existing file from the stream. Should lead to a replacement.\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testAddAlreadyExistingWithReplaceTrue(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(getPath(\"test.txt\"))) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        final ArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\r\n        changeSet.add(entry, csInputStream, true);\r\n        final ChangeSetResults results = new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n        assertTrue(results.getAddedFromChangeSet().contains(\"testdata/test1.xml\"));\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testAddChangeTwice",
  "sourceCode" : "/**\r\n * Adds an ArchiveEntry with the same name two times. Only the latest addition should be found in the ChangeSet, the first add should be replaced.\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testAddChangeTwice() throws Exception {\r\n    try (InputStream inputStream = newInputStream(\"test.txt\");\r\n        InputStream inputStream2 = newInputStream(\"test2.xml\")) {\r\n        final ArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\r\n        final ArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.add(e, inputStream);\r\n        changeSet.add(e2, inputStream2);\r\n        final Set<Change> changeSet2 = changeSet.getChanges();\r\n        assertEquals(1, changeSet2.size());\r\n        final Change change = changeSet2.iterator().next();\r\n        // Not allocated here\r\n        @SuppressWarnings(\"resource\")\r\n        final InputStream csInputStream = change.getInputStream();\r\n        assertEquals(inputStream2, csInputStream);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testAddChangeTwiceWithoutReplace",
  "sourceCode" : "/**\r\n * Adds an ArchiveEntry with the same name two times. Only the first addition should be found in the ChangeSet, the second add should never be added since\r\n * replace = false\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testAddChangeTwiceWithoutReplace() throws Exception {\r\n    try (InputStream inputStream = newInputStream(\"test.txt\");\r\n        InputStream inputStream2 = newInputStream(\"test2.xml\")) {\r\n        final ArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\r\n        final ArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.add(e, inputStream, true);\r\n        changeSet.add(e2, inputStream2, false);\r\n        final Set<Change> changes = changeSet.getChanges();\r\n        assertEquals(1, changes.size());\r\n        final Change c = changes.iterator().next();\r\n        @SuppressWarnings(\"resource\")\r\n        final InputStream csInputStream = c.getInputStream();\r\n        assertEquals(inputStream, csInputStream);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testAddDeleteAdd",
  "sourceCode" : "/**\r\n * add blub/test.txt + delete blub Should add blub/test.txt and delete it afterwards. In this example, the archive should stay untouched.\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testAddDeleteAdd() throws Exception {\r\n    final String archiverName = \"cpio\";\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(getPath(\"test.txt\"))) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        final ArchiveEntry entry = new CpioArchiveEntry(\"blub/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"blub/test.txt\");\r\n        changeSet.deleteDir(\"blub\");\r\n        archiveListDeleteDir(\"blub\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testAddDeleteToOneFileArchive",
  "sourceCode" : "/**\r\n * Check can add and delete a file to an archive with a single file\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testAddDeleteToOneFileArchive(final String archiverName) throws Exception {\r\n    final Path inputPath = createSingleEntryArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    final File file = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(file.toPath())) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ArchiveEntry entry = archiveOutputStream.createArchiveEntry(file, \"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        changeSet.delete(\"test1.xml\");\r\n        archiveListDelete(\"test1.xml\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testAddMoveDelete",
  "sourceCode" : "/**\r\n * TODO: Move operations are not supported currently\r\n *\r\n * add dir1/bla.txt + mv dir1/test.text dir2/test.txt + delete dir1\r\n *\r\n * Add dir1/bla.txt should be suppressed. All other dir1 files will be deleted, except dir1/test.text will be moved\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\nvoid testAddMoveDelete() throws Exception {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testAddToEmptyArchive",
  "sourceCode" : "/**\r\n * Check can add a file to an empty archive.\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getEmptyOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testAddToEmptyArchive(final String archiverName) throws Exception {\r\n    final Path inputPath = createEmptyArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(getPath(\"test.txt\"))) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ArchiveEntry entry = new ZipArchiveEntry(\"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testChangeSetResults",
  "sourceCode" : "/**\r\n * Checks for the correct ChangeSetResults\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testChangeSetResults(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.deleteDir(\"bla\");\r\n        archiveListDeleteDir(\"bla\");\r\n        // Add a file\r\n        final ArchiveEntry entry = archiveOutputStream.createArchiveEntry(file1, \"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        final ChangeSetResults results = new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n        inputStream.close();\r\n        // Checks\r\n        assertEquals(1, results.getAddedFromChangeSet().size());\r\n        assertEquals(\"bla/test.txt\", results.getAddedFromChangeSet().iterator().next());\r\n        assertEquals(3, results.getDeleted().size());\r\n        assertTrue(results.getDeleted().contains(\"bla/test4.xml\"));\r\n        assertTrue(results.getDeleted().contains(\"bla/test5.xml\"));\r\n        assertTrue(results.getDeleted().contains(\"bla/blubber/test6.xml\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"testdata/test1.xml\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"testdata/test2.xml\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"test/test3.xml\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"test.txt\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"something/bla\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"test with spaces.txt\"));\r\n        assertEquals(6, results.getAddedFromStream().size());\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteAddDelete",
  "sourceCode" : "/**\r\n * delete bla + add bla/test.txt + delete bla Deletes dir1/* first, then suppresses the add of bla.txt because there is a delete operation later.\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteAddDelete() throws Exception {\r\n    final String archiverName = \"cpio\";\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(getPath(\"test.txt\"))) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.deleteDir(\"bla\");\r\n        final ArchiveEntry entry = new CpioArchiveEntry(\"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        changeSet.deleteDir(\"bla\");\r\n        archiveListDeleteDir(\"bla\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteAddToOneFileArchive",
  "sourceCode" : "/**\r\n * Check can delete and add a file to an archive with a single file\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteAddToOneFileArchive(final String archiverName) throws Exception {\r\n    final Path inputPath = createSingleEntryArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    final File file = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(file.toPath())) {\r\n        setLongFileMode(archiveOutputStream);\r\n        changeSet.delete(\"test1.xml\");\r\n        archiveListDelete(\"test1.xml\");\r\n        final ArchiveEntry entry = archiveOutputStream.createArchiveEntry(file, \"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteDir",
  "sourceCode" : "/**\r\n * Tries to delete the folder \"bla\" from an archive file. This should result in the deletion of bla/*, which actually means bla/test4.xml should be removed\r\n * from the archive. The file something/bla (without ending, named like the folder) should not be deleted.\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteDir(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.deleteDir(\"bla\");\r\n        archiveListDeleteDir(\"bla\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteDir2",
  "sourceCode" : "/**\r\n * Tries to delete the folder \"la\" from an archive file. This should result in the deletion of la/*, which should not match any files/folders.\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteDir2(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.deleteDir(\"la\");\r\n        archiveListDeleteDir(\"la\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteDir3",
  "sourceCode" : "/**\r\n * Tries to delete the folder \"test.txt\" from an archive file. This should not match any files/folders.\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteDir3(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.deleteDir(\"test.txt\");\r\n        archiveListDeleteDir(\"test.txt\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFile",
  "sourceCode" : "/**\r\n * Tries to delete the file \"bla/test5.xml\" from an archive. This should result in the deletion of \"bla/test5.xml\".\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFile(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.delete(\"bla/test5.xml\");\r\n        archiveListDelete(\"bla/test5.xml\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFile2",
  "sourceCode" : "/**\r\n * Tries to delete the file \"bla\" from an archive. This should result in the deletion of nothing.\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFile2(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.delete(\"bla\");\r\n        // archiveListDelete(\"bla\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromAndAddToAr",
  "sourceCode" : "/**\r\n * Deletes a file from an AR-archive and adds another\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromAndAddToAr() throws Exception {\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File file1 = getFile(\"test.txt\");\r\n    final ArArchiveEntry entry = new ArArchiveEntry(\"test.txt\", file1.length());\r\n    final Path result = getTempDirFile().toPath().resolve(\"bla.ar\");\r\n    final String archiverName = \"ar\";\r\n    try (InputStream inputStream = Files.newInputStream(getPath(\"bla.ar\"));\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        changeSet.add(entry, csInputStream);\r\n        setLongFileMode(archiveOutputStream);\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    expected.add(\"test.txt\");\r\n    checkArchiveContent(result, expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromAndAddToJar",
  "sourceCode" : "/**\r\n * Delete from a jar file and add another file\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromAndAddToJar() throws Exception {\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    changeSet.deleteDir(\"META-INF\");\r\n    changeSet.delete(\".classpath\");\r\n    changeSet.delete(\".project\");\r\n    final File input = getFile(\"bla.jar\");\r\n    final Path result = getTempDirFile().toPath().resolve(\"bla.jar\");\r\n    final String archiverName = \"jar\";\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(getPath(\"test.txt\"))) {\r\n        changeSet.add(new JarArchiveEntry(\"testdata/test.txt\"), csInputStream);\r\n        setLongFileMode(archiveOutputStream);\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    expected.add(\"testdata/test.txt\");\r\n    checkArchiveContent(result, expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromAndAddToTar",
  "sourceCode" : "@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromAndAddToTar() throws Exception {\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File file1 = getFile(\"test.txt\");\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"testdata/test.txt\");\r\n    entry.setModTime(0);\r\n    entry.setSize(file1.length());\r\n    entry.setUserId(0);\r\n    entry.setGroupId(0);\r\n    entry.setUserName(\"avalon\");\r\n    entry.setGroupName(\"excalibur\");\r\n    entry.setMode(0100000);\r\n    final File result = newTempFile(\"bla.tar\");\r\n    final String archiverName = \"tar\";\r\n    try (InputStream inputStream = Files.newInputStream(getPath(\"bla.tar\"));\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        changeSet.add(entry, csInputStream);\r\n        setLongFileMode(archiveOutputStream);\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    expected.add(\"testdata/test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(result.toPath());\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream)) {\r\n        checkArchiveContent(archiveInputStream, expected);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromAndAddToZip",
  "sourceCode" : "/**\r\n * Adds a file to a ZIP archive. Deletes another file.\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromAndAddToZip() throws Exception {\r\n    final String archiverName = \"zip\";\r\n    final Path input = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(getPath(\"test.txt\"))) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        final ArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"blub/test.txt\");\r\n        changeSet.delete(\"testdata/test1.xml\");\r\n        archiveListDelete(\"testdata/test1.xml\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromAndAddToZipUsingZipFilePerform",
  "sourceCode" : "/**\r\n * Adds a file to a ZIP archive. Deletes another file.\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromAndAddToZipUsingZipFilePerform() throws Exception {\r\n    final String archiverName = \"zip\";\r\n    final Path input = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try (ZipFile archiveInputStream = ZipFile.builder().setPath(input).get();\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(getPath(\"test.txt\"))) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        final ArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"blub/test.txt\");\r\n        changeSet.delete(\"testdata/test1.xml\");\r\n        archiveListDelete(\"testdata/test1.xml\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromAr",
  "sourceCode" : "/**\r\n * Simple delete from an ar file\r\n *\r\n * @throws Exception Thrown on test failure. Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromAr() throws Exception {\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File input = getFile(\"bla.ar\");\r\n    final File result = newTempFile(\"bla.ar\");\r\n    final String archiverName = \"ar\";\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    checkArchiveContent(result, expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromJar",
  "sourceCode" : "/**\r\n * Simple delete from a jar file\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromJar(final String archiverName) throws Exception {\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    changeSet.deleteDir(\"META-INF\");\r\n    changeSet.delete(\".classpath\");\r\n    changeSet.delete(\".project\");\r\n    final File input = getFile(\"bla.jar\");\r\n    final File result = newTempFile(\"bla.jar\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    checkArchiveContent(result, expected);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromTar",
  "sourceCode" : "/**\r\n * Simple delete from a tar file\r\n *\r\n * @throws Exception Thrown on test failure.\r\n */\r\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromTar() throws Exception {\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File result = newTempFile(\"bla.tar\");\r\n    final String archiverName = \"tar\";\r\n    try (InputStream inputStream = Files.newInputStream(getFile(\"bla.tar\").toPath());\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    checkArchiveContent(result, expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeleteFromZip",
  "sourceCode" : "/**\r\n * Simple Delete from a ZIP file.\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeleteFromZip(final String archiverName) throws Exception {\r\n    final ChangeSet changeSet = new ChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File inputFile = getFile(\"bla.zip\");\r\n    final Path result = Files.createTempFile(\"test\", \".zip\");\r\n    try (InputStream inputStream = Files.newInputStream(inputFile.toPath());\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream)) {\r\n        setLongFileMode(archiveOutputStream);\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        final List<String> expected = new ArrayList<>();\r\n        expected.add(\"test1.xml\");\r\n        checkArchiveContent(result, expected);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeletePlusAdd",
  "sourceCode" : "/**\r\n * Tries to delete a directory with a file and adds a new directory with a new file and with the same name. Should delete dir1/* and add dir1/test.txt at\r\n * the end\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeletePlusAdd(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(inputPath);\r\n        ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream newOutputStream = Files.newOutputStream(result);\r\n        ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        setLongFileMode(archiveOutputStream);\r\n        final ChangeSet changeSet = new ChangeSet();\r\n        changeSet.deleteDir(\"bla\");\r\n        archiveListDeleteDir(\"bla\");\r\n        // Add a file\r\n        final ArchiveEntry entry = archiveOutputStream.createArchiveEntry(file1, \"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        new ChangeSetPerformer(changeSet).perform(archiveInputStream, archiveOutputStream);\r\n    } finally {\r\n        checkArchiveContent(result, archiveList);\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testDeletePlusAddSame",
  "sourceCode" : "/**\r\n * Tries to delete and then add a file with the same name. Should delete test/test3.xml and adds test.txt with the name test/test3.xml\r\n *\r\n * @param archiverName archiver name.\r\n * @throws Exception Thrown on test failure.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid testDeletePlusAddSame(final String archiverName) throws Exception {\r\n    final Path inputPath = createArchive(archiverName);\r\n    final File testTxt = getFile(\"test.txt\");\r\n    final Path result = Files.createTempFile(\"test\", \".\" + archiverName);\r\n    try {\r\n        try (InputStream inputStream = Files.newInputStream(inputPath);\r\n            ArchiveInputStream archiveInputStream = factory.createArchiveInputStream(archiverName, inputStream);\r\n            OutputStream newOutputStream = Files.newOutputStream(result);\r\n            ArchiveOutputStream archiveOutputStream = factory.createArchiveOutputStream(archiverName, newOutputStream);\r\n            InputStream csInputStream = Files.newInputStream(testTxt.toPath())) {\r\n            setLongFileMode(archiveOutputStream);\r\n            final ChangeSet changes = new ChangeSet();\r\n            changes.delete(\"test/test3.xml\");\r\n            archiveListDelete(\"test/test3.xml\");\r\n            // Add a file\r\n            final ArchiveEntry entry = archiveOutputStream.createArchiveEntry(testTxt, \"test/test3.xml\");\r\n            changes.add(entry, csInputStream);\r\n            archiveList.add(\"test/test3.xml\");\r\n            new ChangeSetPerformer(changes).perform(archiveInputStream, archiveOutputStream);\r\n        }\r\n        // Checks\r\n        try (BufferedInputStream buf = new BufferedInputStream(Files.newInputStream(result));\r\n            ArchiveInputStream in = factory.createArchiveInputStream(buf)) {\r\n            final File check = checkArchiveContent(in, archiveList, false);\r\n            final File test3xml = new File(check, \"result/test/test3.xml\");\r\n            assertEquals(testTxt.length(), test3xml.length());\r\n            try (BufferedReader reader = new BufferedReader(Files.newBufferedReader(test3xml.toPath()))) {\r\n                String str;\r\n                while ((str = reader.readLine()) != null) {\r\n                    // All lines look like this\r\n                    \"111111111111111111111111111000101011\".equals(str);\r\n                }\r\n            }\r\n            forceDelete(check);\r\n        }\r\n    } finally {\r\n        forceDelete(result);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetRawTypesTest.java",
  "methodName" : "testRenameAndDelete",
  "sourceCode" : "/**\r\n * TODO: Move operations are not supported currently\r\n *\r\n * mv dir1/test.text dir2/test.txt + delete dir1 Moves the file to dir2 and deletes everything in dir1\r\n */\r\n@Test\r\nvoid testRenameAndDelete() {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddAlreadyExistingWithReplaceFalse",
  "sourceCode" : "/**\r\n * Adds a file with the same file name as an existing file from the stream. Should lead to a replacement.\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testAddAlreadyExistingWithReplaceFalse() throws Exception {\r\n    final String archiverName = \"zip\";\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ZipArchiveInputStream ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ZipArchiveOutputStream out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n        final ZipArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\r\n        changeSet.add(entry, csInputStream, false);\r\n        final ChangeSetResults results = new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n        assertTrue(results.getAddedFromStream().contains(\"testdata/test1.xml\"));\r\n        assertTrue(results.getAddedFromChangeSet().isEmpty());\r\n        assertTrue(results.getDeleted().isEmpty());\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddAlreadyExistingWithReplaceTrue",
  "sourceCode" : "/**\r\n * Adds a file with the same file name as an existing file from the stream. Should lead to a replacement.\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testAddAlreadyExistingWithReplaceTrue() throws Exception {\r\n    final String archiverName = \"zip\";\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ZipArchiveInputStream ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ZipArchiveOutputStream out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n        final ZipArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\r\n        changeSet.add(entry, csInputStream, true);\r\n        final ChangeSetResults results = new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n        assertTrue(results.getAddedFromChangeSet().contains(\"testdata/test1.xml\"));\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddChangeTwice",
  "sourceCode" : "/**\r\n * Adds an ArchiveEntry with the same name two times. Only the latest addition should be found in the ChangeSet, the first add should be replaced.\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testAddChangeTwice() throws Exception {\r\n    try (InputStream in = newInputStream(\"test.txt\");\r\n        InputStream in2 = newInputStream(\"test2.xml\")) {\r\n        final ZipArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\r\n        final ZipArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\r\n        final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n        changeSet.add(e, in);\r\n        changeSet.add(e2, in2);\r\n        assertEquals(1, changeSet.getChanges().size());\r\n        final Change<ZipArchiveEntry> change = changeSet.getChanges().iterator().next();\r\n        @SuppressWarnings(\"resource\")\r\n        final InputStream cInputStream = change.getInputStream();\r\n        assertEquals(in2, cInputStream);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddChangeTwiceWithoutReplace",
  "sourceCode" : "/**\r\n * Adds an ArchiveEntry with the same name two times. Only the first addition should be found in the ChangeSet, the second add should never be added since\r\n * replace = false\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testAddChangeTwiceWithoutReplace() throws Exception {\r\n    try (InputStream in = newInputStream(\"test.txt\");\r\n        InputStream in2 = newInputStream(\"test2.xml\")) {\r\n        final ZipArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\r\n        final ZipArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\r\n        final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n        changeSet.add(e, in, true);\r\n        changeSet.add(e2, in2, false);\r\n        assertEquals(1, changeSet.getChanges().size());\r\n        final Change<ZipArchiveEntry> change = changeSet.getChanges().iterator().next();\r\n        @SuppressWarnings(\"resource\")\r\n        final InputStream cInputStream = change.getInputStream();\r\n        assertEquals(in, cInputStream);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddDeleteAdd",
  "sourceCode" : "/**\r\n * add blub/test.txt + delete blub Should add blub/test.txt and delete it afterwards. In this example, the archive should stay untouched.\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testAddDeleteAdd() throws Exception {\r\n    final String archiverName = \"cpio\";\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        CpioArchiveInputStream ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        CpioArchiveOutputStream out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        final ChangeSet<CpioArchiveEntry> changeSet = createChangeSet();\r\n        changeSet.add(new CpioArchiveEntry(\"blub/test.txt\"), csInputStream);\r\n        archiveList.add(\"blub/test.txt\");\r\n        changeSet.deleteDir(\"blub\");\r\n        archiveListDeleteDir(\"blub\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddDeleteToOneFileArchive",
  "sourceCode" : "/**\r\n * Check can add and delete a file to an archive with a single file\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testAddDeleteToOneFileArchive() throws Exception {\r\n    final String archiverName = \"cpio\";\r\n    final Path input = createSingleEntryArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final ChangeSet<CpioArchiveEntry> changeSet = createChangeSet();\r\n    final File file = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        CpioArchiveInputStream ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        CpioArchiveOutputStream out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file.toPath())) {\r\n        changeSet.add(out.createArchiveEntry(file, \"bla/test.txt\"), csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        changeSet.delete(\"test1.xml\");\r\n        archiveListDelete(\"test1.xml\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddMoveDelete",
  "sourceCode" : "/**\r\n * TODO: Move operations are not supported currently\r\n *\r\n * add dir1/bla.txt + mv dir1/test.text dir2/test.txt + delete dir1\r\n *\r\n * Add dir1/bla.txt should be suppressed. All other dir1 files will be deleted, except dir1/test.text will be moved\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testAddMoveDelete() throws Exception {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddToEmptyArchive",
  "sourceCode" : "/**\r\n * Check can add a file to an empty archive.\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getEmptyOutputArchiveNames\")\r\nvoid testAddToEmptyArchive(final String archiverName) throws Exception {\r\n    // final String archiverName = \"zip\";\r\n    final Path input = createEmptyArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final ChangeSet<E> changeSet = createChangeSet();\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        changeSet.add(out.createArchiveEntry(file1, \"bla/test.txt\"), csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddToEmptyZipArchive",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\nvoid testAddToEmptyZipArchive(final String archiverName) throws Exception {\r\n    // final String archiverName = \"zip\";\r\n    final Path input = createEmptyArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ZipArchiveInputStream ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ZipArchiveOutputStream out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        changeSet.add(new ZipArchiveEntry(\"bla/test.txt\"), csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testAddToEmptyZipParamArchive",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\nvoid testAddToEmptyZipParamArchive(final String archiverName) throws Exception {\r\n    final Path input = createEmptyArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<ZipArchiveEntry> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<ZipArchiveEntry> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        changeSet.add(new ZipArchiveEntry(\"bla/test.txt\"), csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testChangeSetResults",
  "sourceCode" : "/**\r\n * Checks for the correct ChangeSetResults\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\nvoid testChangeSetResults(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        final ChangeSet<E> changeSet = createChangeSet();\r\n        changeSet.deleteDir(\"bla\");\r\n        archiveListDeleteDir(\"bla\");\r\n        // Add a file\r\n        final E entry = out.createArchiveEntry(file1, \"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        final ChangeSetResults results = new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n        inputStream.close();\r\n        // Checks\r\n        assertEquals(1, results.getAddedFromChangeSet().size());\r\n        assertEquals(\"bla/test.txt\", results.getAddedFromChangeSet().iterator().next());\r\n        assertEquals(3, results.getDeleted().size());\r\n        assertTrue(results.getDeleted().contains(\"bla/test4.xml\"));\r\n        assertTrue(results.getDeleted().contains(\"bla/test5.xml\"));\r\n        assertTrue(results.getDeleted().contains(\"bla/blubber/test6.xml\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"testdata/test1.xml\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"testdata/test2.xml\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"test/test3.xml\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"test.txt\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"something/bla\"));\r\n        assertTrue(results.getAddedFromStream().contains(\"test with spaces.txt\"));\r\n        assertEquals(6, results.getAddedFromStream().size());\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteAddDelete",
  "sourceCode" : "/**\r\n * delete bla + add bla/test.txt + delete bla Deletes dir1/* first, then suppresses the add of bla.txt because there is a delete operation later.\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testDeleteAddDelete() throws Exception {\r\n    final String archiverName = \"cpio\";\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        CpioArchiveInputStream ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        CpioArchiveOutputStream out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        final ChangeSet<CpioArchiveEntry> changeSet = createChangeSet();\r\n        changeSet.deleteDir(\"bla\");\r\n        changeSet.add(new CpioArchiveEntry(\"bla/test.txt\"), csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        changeSet.deleteDir(\"bla\");\r\n        archiveListDeleteDir(\"bla\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteAddToOneFileArchive",
  "sourceCode" : "/**\r\n * Check can delete and add a file to an archive with a single file\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testDeleteAddToOneFileArchive() throws Exception {\r\n    final String archiverName = \"zip\";\r\n    final Path input = createSingleEntryArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n    final File file = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ZipArchiveInputStream ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ZipArchiveOutputStream out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file.toPath())) {\r\n        changeSet.delete(\"test1.xml\");\r\n        archiveListDelete(\"test1.xml\");\r\n        final ZipArchiveEntry entry = out.createArchiveEntry(file, \"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteDir",
  "sourceCode" : "/**\r\n * Tries to delete the folder \"bla\" from an archive file. This should result in the deletion of bla/*, which actually means bla/test4.xml should be removed\r\n * from the archive. The file something/bla (without ending, named like the folder) should not be deleted.\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\nvoid testDeleteDir(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        final ChangeSet<E> changeSet = createChangeSet();\r\n        changeSet.deleteDir(\"bla\");\r\n        archiveListDeleteDir(\"bla\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteDir2",
  "sourceCode" : "/**\r\n * Tries to delete the folder \"la\" from an archive file. This should result in the deletion of la/*, which should not match any files/folders.\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\nvoid testDeleteDir2(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        final ChangeSet<E> changeSet = createChangeSet();\r\n        changeSet.deleteDir(\"la\");\r\n        archiveListDeleteDir(\"la\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteDir3",
  "sourceCode" : "/**\r\n * Tries to delete the folder \"test.txt\" from an archive file. This should not match any files/folders.\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\nvoid testDeleteDir3(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        final ChangeSet<E> changeSet = createChangeSet();\r\n        changeSet.deleteDir(\"test.txt\");\r\n        archiveListDeleteDir(\"test.txt\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFileCpio",
  "sourceCode" : "/**\r\n * Tries to delete the file \"bla/test5.xml\" from an archive. This should result in the deletion of \"bla/test5.xml\".\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\nvoid testDeleteFileCpio(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        final ChangeSet<E> changeSet = createChangeSet();\r\n        changeSet.delete(\"bla/test5.xml\");\r\n        archiveListDelete(\"bla/test5.xml\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFileCpio2",
  "sourceCode" : "/**\r\n * Tries to delete the file \"bla\" from an archive. This should result in the deletion of nothing.\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\nvoid testDeleteFileCpio2(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        final ChangeSet<E> changeSet = createChangeSet();\r\n        changeSet.delete(\"bla\");\r\n        // archiveListDelete(\"bla\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromAndAddToAr",
  "sourceCode" : "/**\r\n * Deletes a file from an AR-archive and adds another\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testDeleteFromAndAddToAr() throws Exception {\r\n    final String archiverName = \"ar\";\r\n    final ChangeSet<ArArchiveEntry> changeSet = createChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File file1 = getFile(\"test.txt\");\r\n    final ArArchiveEntry entry = new ArArchiveEntry(\"test.txt\", file1.length());\r\n    final File input = getFile(\"bla.ar\");\r\n    final File result = newTempFile(\"bla.ar\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<ArArchiveEntry> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<ArArchiveEntry> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        changeSet.add(entry, csInputStream);\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    expected.add(\"test.txt\");\r\n    checkArchiveContent(result, expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromAndAddToJar",
  "sourceCode" : "/**\r\n * Delete from a jar file and add another file\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testDeleteFromAndAddToJar() throws Exception {\r\n    final String archiverName = \"jar\";\r\n    final ChangeSet<JarArchiveEntry> changeSet = createChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    changeSet.deleteDir(\"META-INF\");\r\n    changeSet.delete(\".classpath\");\r\n    changeSet.delete(\".project\");\r\n    final File file1 = getFile(\"test.txt\");\r\n    final JarArchiveEntry entry = new JarArchiveEntry(\"testdata/test.txt\");\r\n    final File input = getFile(\"bla.jar\");\r\n    final File result = newTempFile(\"bla.jar\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<JarArchiveEntry> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<JarArchiveEntry> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        changeSet.add(entry, csInputStream);\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    expected.add(\"testdata/test.txt\");\r\n    checkArchiveContent(result, expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromAndAddToTar",
  "sourceCode" : "@Test\r\nvoid testDeleteFromAndAddToTar() throws Exception {\r\n    final String archiverName = \"tar\";\r\n    final ChangeSet<TarArchiveEntry> changeSet = createChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File file1 = getFile(\"test.txt\");\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"testdata/test.txt\");\r\n    entry.setModTime(0);\r\n    entry.setSize(file1.length());\r\n    entry.setUserId(0);\r\n    entry.setGroupId(0);\r\n    entry.setUserName(\"avalon\");\r\n    entry.setGroupName(\"excalibur\");\r\n    entry.setMode(0100000);\r\n    final File input = getFile(\"bla.tar\");\r\n    final File result = newTempFile(\"bla.tar\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<TarArchiveEntry> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<TarArchiveEntry> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        changeSet.add(entry, csInputStream);\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    expected.add(\"testdata/test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(result.toPath());\r\n        ArchiveInputStream<TarArchiveEntry> archiveInputStream = createArchiveInputStream(archiverName, inputStream)) {\r\n        checkArchiveContent(archiveInputStream, expected);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromAndAddToZip",
  "sourceCode" : "/**\r\n * Adds a file to a ZIP archive. Deletes another file.\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\nvoid testDeleteFromAndAddToZip(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<ZipArchiveEntry> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<ZipArchiveEntry> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n        final ZipArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"blub/test.txt\");\r\n        changeSet.delete(\"testdata/test1.xml\");\r\n        archiveListDelete(\"testdata/test1.xml\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromAndAddToZipUsingZipFilePerform",
  "sourceCode" : "/**\r\n * Adds a file to a ZIP archive. Deletes another file.\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\nvoid testDeleteFromAndAddToZipUsingZipFilePerform(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (ZipFile ais = ZipFile.builder().setPath(input).get();\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<ZipArchiveEntry> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        final ChangeSet<ZipArchiveEntry> changeSet = createChangeSet();\r\n        final ZipArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"blub/test.txt\");\r\n        changeSet.delete(\"testdata/test1.xml\");\r\n        archiveListDelete(\"testdata/test1.xml\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromAr",
  "sourceCode" : "/**\r\n * Simple delete from an ar file\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testDeleteFromAr() throws Exception {\r\n    final String archiverName = \"ar\";\r\n    final ChangeSet<E> changeSet = createChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File input = getFile(\"bla.ar\");\r\n    final File temp = newTempFile(\"bla.ar\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(temp.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    checkArchiveContent(temp, expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromJar",
  "sourceCode" : "/**\r\n * Simple delete from a jar file\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\nvoid testDeleteFromJar(final String archiverName) throws Exception {\r\n    final ChangeSet<E> changeSet = createChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    changeSet.deleteDir(\"META-INF\");\r\n    changeSet.delete(\".classpath\");\r\n    changeSet.delete(\".project\");\r\n    final File input = getFile(\"bla.jar\");\r\n    final File temp = newTempFile(\"bla.jar\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(temp.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    checkArchiveContent(temp, expected);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromTar",
  "sourceCode" : "/**\r\n * Simple delete from a tar file\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testDeleteFromTar() throws Exception {\r\n    final String archiverName = \"tar\";\r\n    final ChangeSet<E> changeSet = createChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File input = getFile(\"bla.tar\");\r\n    final File temp = newTempFile(\"bla.tar\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(temp.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    checkArchiveContent(temp, expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeleteFromZip",
  "sourceCode" : "/**\r\n * Simple Delete from a ZIP file.\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getZipOutputArchiveNames\")\r\nvoid testDeleteFromZip(final String archiverName) throws Exception {\r\n    final ChangeSet<E> changeSet = createChangeSet();\r\n    changeSet.delete(\"test2.xml\");\r\n    final File input = getFile(\"bla.zip\");\r\n    final File temp = createTempFile(\"test\", \".zip\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(temp.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream)) {\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    final List<String> expected = new ArrayList<>();\r\n    expected.add(\"test1.xml\");\r\n    checkArchiveContent(temp, expected);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeletePlusAdd",
  "sourceCode" : "/**\r\n * Tries to delete a directory with a file and adds a new directory with a new file and with the same name. Should delete dir1/* and add dir1/test.txt at\r\n * the end\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\nvoid testDeletePlusAdd(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File file1 = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(file1.toPath())) {\r\n        final ChangeSet<E> changeSet = createChangeSet();\r\n        changeSet.deleteDir(\"bla\");\r\n        archiveListDeleteDir(\"bla\");\r\n        // Add a file\r\n        final E entry = out.createArchiveEntry(file1, \"bla/test.txt\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"bla/test.txt\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    checkArchiveContent(result, archiveList);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testDeletePlusAddSame",
  "sourceCode" : "/**\r\n * Tries to delete and then add a file with the same name. Should delete test/test3.xml and adds test.txt with the name test/test3.xml\r\n *\r\n * @param archiverName Archiver name.\r\n * @throws Exception\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"org.apache.commons.compress.changes.TestFixtures#getOutputArchiveNames\")\r\nvoid testDeletePlusAddSame(final String archiverName) throws Exception {\r\n    final Path input = createArchive(archiverName);\r\n    final File result = createTempFile(\"test\", \".\" + archiverName);\r\n    final File testTxt = getFile(\"test.txt\");\r\n    try (InputStream inputStream = Files.newInputStream(input);\r\n        ArchiveInputStream<E> ais = createArchiveInputStream(archiverName, inputStream);\r\n        OutputStream outputStream = Files.newOutputStream(result.toPath());\r\n        ArchiveOutputStream<E> out = createArchiveOutputStream(archiverName, outputStream);\r\n        InputStream csInputStream = Files.newInputStream(testTxt.toPath())) {\r\n        final ChangeSet<E> changeSet = createChangeSet();\r\n        changeSet.delete(\"test/test3.xml\");\r\n        archiveListDelete(\"test/test3.xml\");\r\n        // Add a file\r\n        final E entry = out.createArchiveEntry(testTxt, \"test/test3.xml\");\r\n        changeSet.add(entry, csInputStream);\r\n        archiveList.add(\"test/test3.xml\");\r\n        new ChangeSetPerformer<>(changeSet).perform(ais, out);\r\n    }\r\n    // Checks\r\n    try (BufferedInputStream buf = new BufferedInputStream(Files.newInputStream(result.toPath()));\r\n        ArchiveInputStream<E> in = createArchiveInputStream(buf)) {\r\n        final File check = checkArchiveContent(in, archiveList, false);\r\n        final File test3xml = new File(check, \"result/test/test3.xml\");\r\n        assertEquals(testTxt.length(), test3xml.length());\r\n        try (BufferedReader reader = new BufferedReader(Files.newBufferedReader(test3xml.toPath()))) {\r\n            String str;\r\n            while ((str = reader.readLine()) != null) {\r\n                // All lines look like this\r\n                \"111111111111111111111111111000101011\".equals(str);\r\n            }\r\n        }\r\n        forceDelete(check);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeSetSafeTypesTest.java",
  "methodName" : "testRenameAndDelete",
  "sourceCode" : "/**\r\n * TODO: Move operations are not supported currently\r\n *\r\n * mv dir1/test.text dir2/test.txt + delete dir1 Moves the file to dir2 and deletes everything in dir1\r\n */\r\n@Test\r\nvoid testRenameAndDelete() {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeTest.java",
  "methodName" : "testFailsToCreateChangeTakingFourArgumentsThrowsNullPointerExceptionOne",
  "sourceCode" : "@Test\r\nvoid testFailsToCreateChangeTakingFourArgumentsThrowsNullPointerExceptionOne() {\r\n    final MemoryArchiveEntry memoryArchiveEntry = new MemoryArchiveEntry(\"x\");\r\n    assertThrows(NullPointerException.class, () -> new Change<>(memoryArchiveEntry, null, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeTest.java",
  "methodName" : "testFailsToCreateChangeTakingFourArgumentsThrowsNullPointerExceptionTwo",
  "sourceCode" : "@Test\r\nvoid testFailsToCreateChangeTakingFourArgumentsThrowsNullPointerExceptionTwo() throws IOException {\r\n    try (PipedInputStream pipedInputStream = new PipedInputStream(1)) {\r\n        assertThrows(NullPointerException.class, () -> new Change<>(null, pipedInputStream, false));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\changes\\ChangeTest.java",
  "methodName" : "testFailsToCreateChangeTakingThreeArgumentsThrowsNullPointerException",
  "sourceCode" : "@Test\r\nvoid testFailsToCreateChangeTakingThreeArgumentsThrowsNullPointerException() {\r\n    assertThrows(NullPointerException.class, () -> new Change<>(null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testAvailableShouldReturnZero",
  "sourceCode" : "@Test\r\nvoid testAvailableShouldReturnZero() throws IOException {\r\n    try (InputStream is = newInputStream(\"brotli.testdata.compressed\");\r\n        BrotliCompressorInputStream in = new BrotliCompressorInputStream(is)) {\r\n        assertEquals(0, in.available());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testBrotliDecode",
  "sourceCode" : "/**\r\n * Tests bridge.\r\n *\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBrotliDecode() throws IOException {\r\n    try (InputStream inputStream = newInputStream(\"brotli.testdata.compressed\");\r\n        BrotliCompressorInputStream brotliInputStream = new BrotliCompressorInputStream(inputStream)) {\r\n        final byte[] expected = readAllBytes(\"brotli.testdata.uncompressed\");\r\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        IOUtils.copy(brotliInputStream, bos);\r\n        assertArrayEquals(expected, bos.toByteArray());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testBrotliUnarchive",
  "sourceCode" : "@Test\r\nvoid testBrotliUnarchive() throws Exception {\r\n    final File output = newTempFile(\"bla.tar\");\r\n    try (InputStream is = newInputStream(\"bla.tar.br\")) {\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"br\", is)) {\r\n            Files.copy(in, output.toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testCachingIsEnabledByDefaultAndBrotliIsPresent",
  "sourceCode" : "@Test\r\nvoid testCachingIsEnabledByDefaultAndBrotliIsPresent() {\r\n    assertEquals(BrotliUtils.CachedAvailability.CACHED_AVAILABLE, BrotliUtils.getCachedBrotliAvailability());\r\n    assertTrue(BrotliUtils.isBrotliCompressionAvailable());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testCanTurnOffCaching",
  "sourceCode" : "@Test\r\nvoid testCanTurnOffCaching() {\r\n    try {\r\n        BrotliUtils.setCacheBrotliAvailablity(false);\r\n        assertEquals(BrotliUtils.CachedAvailability.DONT_CACHE, BrotliUtils.getCachedBrotliAvailability());\r\n        assertTrue(BrotliUtils.isBrotliCompressionAvailable());\r\n    } finally {\r\n        BrotliUtils.setCacheBrotliAvailablity(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = newInputStream(\"brotli.testdata.compressed\");\r\n        BrotliCompressorInputStream in = new BrotliCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testShouldBeAbleToSkipAByte",
  "sourceCode" : "@Test\r\nvoid testShouldBeAbleToSkipAByte() throws IOException {\r\n    try (InputStream is = newInputStream(\"brotli.testdata.compressed\");\r\n        BrotliCompressorInputStream in = new BrotliCompressorInputStream(is)) {\r\n        assertEquals(1, in.skip(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    try (InputStream is = newInputStream(\"brotli.testdata.compressed\");\r\n        BrotliCompressorInputStream in = new BrotliCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadWorksAsExpected",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadWorksAsExpected() throws IOException {\r\n    try (InputStream is = newInputStream(\"brotli.testdata.compressed\");\r\n        BrotliCompressorInputStream in = new BrotliCompressorInputStream(is)) {\r\n        // starts with file name \"XXX\"\r\n        assertEquals('X', in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\brotli\\BrotliCompressorInputStreamTest.java",
  "methodName" : "testTurningOnCachingReEvaluatesAvailability",
  "sourceCode" : "@Test\r\nvoid testTurningOnCachingReEvaluatesAvailability() {\r\n    try {\r\n        BrotliUtils.setCacheBrotliAvailablity(false);\r\n        assertEquals(BrotliUtils.CachedAvailability.DONT_CACHE, BrotliUtils.getCachedBrotliAvailability());\r\n        BrotliUtils.setCacheBrotliAvailablity(true);\r\n        assertEquals(BrotliUtils.CachedAvailability.CACHED_AVAILABLE, BrotliUtils.getCachedBrotliAvailability());\r\n    } finally {\r\n        BrotliUtils.setCacheBrotliAvailablity(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BlockSortTest.java",
  "methodName" : "testFallbackSort",
  "sourceCode" : "@Test\r\nvoid testFallbackSort() {\r\n    final BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\r\n    final BlockSort s = new BlockSort(data);\r\n    final int[] fmap = new int[FIXTURE.length];\r\n    s.fallbackSort(fmap, FIXTURE, FIXTURE.length);\r\n    assertArrayEquals(FIXTURE_SORTED, fmap);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BlockSortTest.java",
  "methodName" : "testSortFixture",
  "sourceCode" : "@Test\r\nvoid testSortFixture() {\r\n    final DS ds = setUpFixture();\r\n    ds.s.blockSort(ds.data, FIXTURE.length - 1);\r\n    assertFixtureSorted(ds.data);\r\n    assertEquals(0, ds.data.origPtr);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BlockSortTest.java",
  "methodName" : "testSortFixture2",
  "sourceCode" : "@Test\r\nvoid testSortFixture2() {\r\n    final DS ds = setUpFixture2();\r\n    ds.s.blockSort(ds.data, FIXTURE2.length - 1);\r\n    assertFixture2Sorted(ds.data);\r\n    assertEquals(1, ds.data.origPtr);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BlockSortTest.java",
  "methodName" : "testSortFixture2FallbackSort",
  "sourceCode" : "@Test\r\nvoid testSortFixture2FallbackSort() {\r\n    final DS ds = setUpFixture2();\r\n    ds.s.fallbackSort(ds.data, FIXTURE2.length - 1);\r\n    assertFixture2Sorted(ds.data);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BlockSortTest.java",
  "methodName" : "testSortFixture2MainSort",
  "sourceCode" : "@Test\r\nvoid testSortFixture2MainSort() {\r\n    final DS ds = setUpFixture2();\r\n    ds.s.mainSort(ds.data, FIXTURE2.length - 1);\r\n    assertFixture2Sorted(ds.data);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BlockSortTest.java",
  "methodName" : "testSortFixtureFallbackSort",
  "sourceCode" : "@Test\r\nvoid testSortFixtureFallbackSort() {\r\n    final DS ds = setUpFixture();\r\n    ds.s.fallbackSort(ds.data, FIXTURE.length - 1);\r\n    assertFixtureSorted(ds.data);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BlockSortTest.java",
  "methodName" : "testSortFixtureMainSort",
  "sourceCode" : "@Test\r\nvoid testSortFixtureMainSort() {\r\n    final DS ds = setUpFixture();\r\n    ds.s.mainSort(ds.data, FIXTURE.length - 1);\r\n    assertFixtureSorted(ds.data);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2Compress651Test.java",
  "methodName" : "testCompress651",
  "sourceCode" : "@Test\r\nvoid testCompress651() throws IOException {\r\n    final int buffersize = 102_400;\r\n    final Path pathIn = Paths.get(\"src/test/resources/org/apache/commons/compress/COMPRESS-651/my10m.tar.bz2\");\r\n    final Path pathOut = Paths.get(\"target/COMPRESS-651/test.tar\");\r\n    Files.createDirectories(pathOut.getParent());\r\n    try (BZip2CompressorInputStream inputStream = new BZip2CompressorInputStream(new BufferedInputStream(Files.newInputStream(pathIn)), true);\r\n        OutputStream outputStream = Files.newOutputStream(pathOut)) {\r\n        IOUtils.copy(inputStream, outputStream, buffersize);\r\n    }\r\n    // expected size confirmed locally on macOS\r\n    assertEquals(10_496_000, Files.size(pathOut));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testCreateHuffmanDecodingTablesWithLargeAlphaSize",
  "sourceCode" : "@Test\r\nvoid testCreateHuffmanDecodingTablesWithLargeAlphaSize() {\r\n    final Data data = new Data(1);\r\n    // Use a codeLengths array with length equal to MAX_ALPHA_SIZE (258) to test array bounds.\r\n    final char[] codeLengths = new char[258];\r\n    for (int i = 0; i < codeLengths.length; i++) {\r\n        // Use all code lengths within valid range [1, 20]\r\n        codeLengths[i] = (char) ((i % MAX_CODE_LEN) + 1);\r\n    }\r\n    data.temp_charArray2d[0] = codeLengths;\r\n    assertDoesNotThrow(() -> BZip2CompressorInputStream.createHuffmanDecodingTables(codeLengths.length, 1, data), \"createHuffmanDecodingTables should not throw for valid codeLengths array of MAX_ALPHA_SIZE\");\r\n    assertEquals(data.minLens[0], 1, \"Minimum code length should be 1\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testHbCreateDecodeTables",
  "sourceCode" : "@Test\r\nvoid testHbCreateDecodeTables() throws IOException {\r\n    assertThrows(CompressorException.class, () -> new BZip2CompressorInputStream(Files.newInputStream(Paths.get(\"src/test/resources/org/apache/commons/compress/bzip2/hbCreateDecodeTables.bin\"))));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.txt.bz2\");\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        BZip2CompressorInputStream in = new BZip2CompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testReadOfLength0ShouldReturn0",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-309\"\r\n */\r\n@Test\r\nvoid testReadOfLength0ShouldReturn0() throws Exception {\r\n    // Create a big random piece of data\r\n    final byte[] rawData = new byte[1048576];\r\n    for (int i = 0; i < rawData.length; ++i) {\r\n        rawData[i] = (byte) Math.floor(Math.random() * 256);\r\n    }\r\n    // Compress it\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos)) {\r\n        bzipOut.write(rawData);\r\n        bzipOut.flush();\r\n        bzipOut.close();\r\n        assertTrue(bzipOut.isClosed());\r\n        baos.flush();\r\n    }\r\n    // Try to read it back in\r\n    final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\r\n    try (BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais)) {\r\n        final byte[] buffer = new byte[1024];\r\n        assertEquals(1024, bzipIn.read(buffer, 0, 1024));\r\n        assertEquals(0, bzipIn.read(buffer, 1024, 0));\r\n        assertEquals(1024, bzipIn.read(buffer, 0, 1024));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testRecvDecodingTablesWithOutOfRangeCodeLength",
  "sourceCode" : "@ParameterizedTest(name = \"code length {0} -> must be rejected\")\r\n@ValueSource(ints = { MIN_CODE_LEN - 1, MAX_CODE_LEN + 1 })\r\nvoid testRecvDecodingTablesWithOutOfRangeCodeLength(final int codeLength) throws IOException {\r\n    try (BitInputStream tables = prepareDecodingTables(codeLength)) {\r\n        final Data data = new Data(1);\r\n        final CompressorException ex = assertThrows(CompressorException.class, () -> BZip2CompressorInputStream.recvDecodingTables(tables, data), \"Expected CompressorException for invalid code length \" + codeLength);\r\n        final String msg = ex.getMessage();\r\n        assertNotNull(msg, \"Exception message must not be null\");\r\n        assertTrue(msg.toLowerCase().contains(\"code length\"), \"Message should mention 'code length'\");\r\n        assertTrue(msg.contains(\"[\" + MIN_CODE_LEN + \", \" + MAX_CODE_LEN + \"]\"), \"Message should mention valid range [\" + MIN_CODE_LEN + \", \" + MAX_CODE_LEN + \"]\");\r\n        assertTrue(msg.contains(Integer.toString(codeLength)), \"Message should include the offending value \" + codeLength);\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testRecvDecodingTablesWithValidCodeLength",
  "sourceCode" : "@ParameterizedTest(name = \"code length {0} -> accepted and stored\")\r\n@ValueSource(ints = { MIN_CODE_LEN, MAX_CODE_LEN })\r\nvoid testRecvDecodingTablesWithValidCodeLength(final int codeLength) throws IOException {\r\n    try (BitInputStream tables = prepareDecodingTables(codeLength)) {\r\n        final Data data = new Data(1);\r\n        assertDoesNotThrow(() -> BZip2CompressorInputStream.recvDecodingTables(tables, data), \"Should accept code length \" + codeLength + \" within [\" + MIN_CODE_LEN + \", \" + MAX_CODE_LEN + \"]\");\r\n        // We encoded 2 Huffman groups; both minLens should equal the encoded codeLength\r\n        assertEquals(codeLength, data.minLens[0], \"Group 0 min code length mismatch\");\r\n        assertEquals(codeLength, data.minLens[1], \"Group 1 min code length mismatch\");\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowAnIOExceptionWhenAppliedToAZipFile",
  "sourceCode" : "@Test\r\nvoid testShouldThrowAnIOExceptionWhenAppliedToAZipFile() throws Exception {\r\n    try (InputStream in = newInputStream(\"bla.zip\")) {\r\n        assertThrows(CompressorException.class, () -> new BZip2CompressorInputStream(in));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS516",
  "sourceCode" : "/**\r\n * Tests <a href=\"https://issues.apache.org/jira/browse/COMPRESS-516\">COMPRESS-516</a>.\r\n *\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-516\">COMPRESS-516</a>\r\n */\r\n@Test\r\nvoid testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS516() {\r\n    assertThrows(CompressorException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x03, 0x04, 0x2e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x84, 0xb6, 0xba, 0x46, 0x72, 0xb6, 0xfe, 0x77, 0x63, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x62, 0x62, 0x55, 0x54, 0x09, 0x00, 0x03, 0xe7, 0xce, 0x64, 0x55, 0xf3, 0xce, 0x64, 0x55, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0x5c, 0xf9, 0x01, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00, 0x42, 0x5a, 0x68, 0x34, 0x31, 0x41, 0x59, 0x26, 0x53, 0x59, 0x62, 0xe4, 0x4f, 0x51, 0x00, 0x00, 0x0d, 0xd1, 0x80, 0x00, 0x10, 0x40, 0x00, 0x35, 0xf9, 0x8b, 0x00, 0x20, 0x00, 0x48, 0x89, 0xfa, 0x94, 0xf2, 0x9e, 0x29, 0xe8, 0xd2, 0x11, 0x8a, 0x4f, 0x53, 0x34, 0x0f, 0x51, 0x7a, 0xed, 0x86, 0x65, 0xd6, 0xed, 0x61, 0xee, 0x68, 0x89, 0x48, 0x7d, 0x07, 0x71, 0x92, 0x2a, 0x50, 0x60, 0x04, 0x95, 0x61, 0x35, 0x47, 0x73, 0x31, 0x29, 0xc2, 0xdd, 0x5e, 0xc7, 0x4a, 0x15, 0x14, 0x32, 0x4c, 0xda, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS519",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-519\">COMPRESS-519</a>\r\n */\r\n@Test\r\nvoid testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS519() {\r\n    assertThrows(CompressorException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x03, 0x04, 0x2e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x84, 0xb6, 0xba, 0x46, 0x72, 0xb6, 0xfe, 0x77, 0x63, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x62, 0x62, 0x55, 0x54, 0x09, 0x00, 0x03, 0xe7, 0xce, 0x64, 0x55, 0xf3, 0xce, 0x64, 0x55, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0x5c, 0xf9, 0x01, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00, 0x42, 0x5a, 0x68, 0x34, 0x31, 0x41, 0x59, 0x26, 0x53, 0x59, 0x62, 0xe4, 0x4f, 0x51, 0x80, 0x00, 0x0d, 0xd1, 0x80, 0x00, 0x10, 0x40, 0x00, 0x35, 0xf9, 0x8b, 0x00, 0x20, 0x00, 0x48, 0x89, 0xfa, 0x94, 0xf2, 0x9e, 0x29, 0xe8, 0xd2, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2CompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.txt.bz2\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        BZip2CompressorInputStream in = new BZip2CompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\BZip2NSelectorsOverflowTest.java",
  "methodName" : "testShouldDecompressBlockWithNSelectorOverflow",
  "sourceCode" : "/**\r\n * See https://sourceware.org/ml/bzip2-devel/2019-q3/msg00007.html\r\n */\r\n@Test\r\nvoid testShouldDecompressBlockWithNSelectorOverflow() throws Exception {\r\n    final File toDecompress = getFile(\"lbzip2_32767.bz2\");\r\n    try (InputStream is = Files.newInputStream(toDecompress.toPath());\r\n        BZip2CompressorInputStream in = new BZip2CompressorInputStream(is)) {\r\n        int l = 0;\r\n        while (in.read() != -1) {\r\n            l++;\r\n        }\r\n        assertEquals(5, l);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\Compress686Test.java",
  "methodName" : "testRoundtrip",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(booleans = { true, false })\r\nvoid testRoundtrip(final boolean bufferCompressOutput) throws Exception {\r\n    final Path file = tempDir.resolve(\"test.txt\");\r\n    final String contents = \"a\";\r\n    try (Writer w = Files.newBufferedWriter(file, StandardCharsets.UTF_8)) {\r\n        IOUtils.write(contents, w);\r\n    }\r\n    final Path compressedFile = compressFile(file, bufferCompressOutput);\r\n    decompressBzip2File(compressedFile);\r\n    assertEquals(contents, IOUtils.toString(file.toUri(), StandardCharsets.UTF_8));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\PythonTruncatedBzip2Test.java",
  "methodName" : "testPartialReadTruncatedData",
  "sourceCode" : "@Test\r\nvoid testPartialReadTruncatedData() throws IOException {\r\n    // with BZ2File(self.filename) as f:\r\n    // self.assertEqual(f.read(len(self.TEXT)), self.TEXT)\r\n    // self.assertRaises(EOFError, f.read, 1)\r\n    final int length = TEXT.length();\r\n    final ByteBuffer buffer1 = ByteBuffer.allocate(length);\r\n    bz2Channel.read(buffer1);\r\n    assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length), buffer1.array());\r\n    // subsequent read should throw\r\n    final ByteBuffer buffer2 = ByteBuffer.allocate(1);\r\n    assertThrows(CompressorException.class, () -> bz2Channel.read(buffer2), \"The read should have thrown.\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\bzip2\\PythonTruncatedBzip2Test.java",
  "methodName" : "testTruncatedData",
  "sourceCode" : "@Test\r\nvoid testTruncatedData() {\r\n    // with BZ2File(self.filename) as f:\r\n    // self.assertRaises(EOFError, f.read)\r\n    final ByteBuffer buffer = ByteBuffer.allocate(8192);\r\n    assertThrows(CompressorException.class, () -> bz2Channel.read(buffer));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\BZip2Test.java",
  "methodName" : "testBzip2Unarchive",
  "sourceCode" : "@Test\r\nvoid testBzip2Unarchive() throws Exception {\r\n    final File input = getFile(\"bla.txt.bz2\");\r\n    final File output = newTempFile(\"bla.txt\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"bzip2\", is)) {\r\n        Files.copy(in, output.toPath());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\BZip2Test.java",
  "methodName" : "testBzipCreation",
  "sourceCode" : "@Test\r\nvoid testBzipCreation() throws Exception {\r\n    final File output;\r\n    final File input = getFile(\"test.txt\");\r\n    {\r\n        output = newTempFile(\"test.txt.bz2\");\r\n        try (OutputStream out = Files.newOutputStream(output.toPath());\r\n            CompressorOutputStream<?> cos = new CompressorStreamFactory().createCompressorOutputStream(\"bzip2\", out)) {\r\n            cos.write(input);\r\n        }\r\n    }\r\n    final File decompressed = newTempFile(\"decompressed.txt\");\r\n    {\r\n        try (InputStream is = Files.newInputStream(output.toPath());\r\n            CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"bzip2\", is)) {\r\n            Files.copy(in, decompressed.toPath());\r\n        }\r\n    }\r\n    assertEquals(input.length(), decompressed.length());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\BZip2Test.java",
  "methodName" : "testCOMPRESS131",
  "sourceCode" : "@Test\r\nvoid testCOMPRESS131() throws Exception {\r\n    final File input = getFile(\"COMPRESS-131.bz2\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new BZip2CompressorInputStream(is, true)) {\r\n            int l = 0;\r\n            while (in.read() != -1) {\r\n                l++;\r\n            }\r\n            assertEquals(539, l);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\BZip2Test.java",
  "methodName" : "testConcatenatedStreamsReadFirstOnly",
  "sourceCode" : "@Test\r\nvoid testConcatenatedStreamsReadFirstOnly() throws Exception {\r\n    final File input = getFile(\"multiple.bz2\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"bzip2\", is)) {\r\n            assertEquals('a', in.read());\r\n            assertEquals(-1, in.read());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\BZip2Test.java",
  "methodName" : "testConcatenatedStreamsReadFully",
  "sourceCode" : "@Test\r\nvoid testConcatenatedStreamsReadFully() throws Exception {\r\n    final File input = getFile(\"multiple.bz2\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new BZip2CompressorInputStream(is, true)) {\r\n            assertEquals('a', in.read());\r\n            assertEquals('b', in.read());\r\n            assertEquals(0, in.available());\r\n            assertEquals(-1, in.read());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\BZip2UtilsTest.java",
  "methodName" : "testGetCompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testGetCompressedFilename() {\r\n    assertEquals(\".bz2\", BZip2Utils.getCompressedFilename(\"\"));\r\n    assertEquals(\".bz2\", BZip2Utils.getCompressedFileName(\"\"));\r\n    assertEquals(\" .bz2\", BZip2Utils.getCompressedFilename(\" \"));\r\n    assertEquals(\" .bz2\", BZip2Utils.getCompressedFileName(\" \"));\r\n    assertEquals(\"x.bz2\", BZip2Utils.getCompressedFilename(\"x\"));\r\n    assertEquals(\"x.bz2\", BZip2Utils.getCompressedFileName(\"x\"));\r\n    assertEquals(\"X.bz2\", BZip2Utils.getCompressedFilename(\"X\"));\r\n    assertEquals(\"X.bz2\", BZip2Utils.getCompressedFileName(\"X\"));\r\n    assertEquals(\"x.tar.bz2\", BZip2Utils.getCompressedFilename(\"x.tar\"));\r\n    assertEquals(\"x.tar.bz2\", BZip2Utils.getCompressedFileName(\"x.tar\"));\r\n    assertEquals(\"x.tar.bz2\", BZip2Utils.getCompressedFilename(\"x.TAR\"));\r\n    assertEquals(\"x.tar.bz2\", BZip2Utils.getCompressedFileName(\"x.TAR\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\BZip2UtilsTest.java",
  "methodName" : "testGetUncompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testGetUncompressedFilename() {\r\n    assertEquals(\"\", BZip2Utils.getUncompressedFilename(\"\"));\r\n    assertEquals(\"\", BZip2Utils.getUncompressedFileName(\"\"));\r\n    assertEquals(\".bz2\", BZip2Utils.getUncompressedFilename(\".bz2\"));\r\n    assertEquals(\".bz2\", BZip2Utils.getUncompressedFileName(\".bz2\"));\r\n    assertEquals(\"x.tar\", BZip2Utils.getUncompressedFilename(\"x.tbz2\"));\r\n    assertEquals(\"x.tar\", BZip2Utils.getUncompressedFileName(\"x.tbz2\"));\r\n    assertEquals(\"x.tar\", BZip2Utils.getUncompressedFilename(\"x.tbz\"));\r\n    assertEquals(\"x.tar\", BZip2Utils.getUncompressedFileName(\"x.tbz\"));\r\n    assertEquals(\"x\", BZip2Utils.getUncompressedFilename(\"x.bz2\"));\r\n    assertEquals(\"x\", BZip2Utils.getUncompressedFileName(\"x.bz2\"));\r\n    assertEquals(\"x\", BZip2Utils.getUncompressedFilename(\"x.bz\"));\r\n    assertEquals(\"x\", BZip2Utils.getUncompressedFileName(\"x.bz\"));\r\n    assertEquals(\"x.tar\", BZip2Utils.getUncompressedFilename(\"x.TBZ2\"));\r\n    assertEquals(\"x.tar\", BZip2Utils.getUncompressedFileName(\"x.TBZ2\"));\r\n    assertEquals(\"X.tar\", BZip2Utils.getUncompressedFilename(\"X.Tbz2\"));\r\n    assertEquals(\"X.tar\", BZip2Utils.getUncompressedFileName(\"X.Tbz2\"));\r\n    assertEquals(\"X.tar\", BZip2Utils.getUncompressedFilename(\"X.tbZ2\"));\r\n    assertEquals(\"X.tar\", BZip2Utils.getUncompressedFileName(\"X.tbZ2\"));\r\n    assertEquals(\"x.bz \", BZip2Utils.getUncompressedFilename(\"x.bz \"));\r\n    assertEquals(\"x.bz \", BZip2Utils.getUncompressedFileName(\"x.bz \"));\r\n    assertEquals(\"x.tbz\\n\", BZip2Utils.getUncompressedFilename(\"x.tbz\\n\"));\r\n    assertEquals(\"x.tbz\\n\", BZip2Utils.getUncompressedFileName(\"x.tbz\\n\"));\r\n    assertEquals(\"x.tbz2.y\", BZip2Utils.getUncompressedFilename(\"x.tbz2.y\"));\r\n    assertEquals(\"x.tbz2.y\", BZip2Utils.getUncompressedFileName(\"x.tbz2.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\BZip2UtilsTest.java",
  "methodName" : "testIsCompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testIsCompressedFilename() {\r\n    assertFalse(BZip2Utils.isCompressedFilename(\"\"));\r\n    assertFalse(BZip2Utils.isCompressedFileName(\"\"));\r\n    assertFalse(BZip2Utils.isCompressedFilename(\".gz\"));\r\n    assertFalse(BZip2Utils.isCompressedFileName(\".gz\"));\r\n    assertTrue(BZip2Utils.isCompressedFilename(\"x.tbz2\"));\r\n    assertTrue(BZip2Utils.isCompressedFileName(\"x.tbz2\"));\r\n    assertTrue(BZip2Utils.isCompressedFilename(\"x.tbz\"));\r\n    assertTrue(BZip2Utils.isCompressedFileName(\"x.tbz\"));\r\n    assertTrue(BZip2Utils.isCompressedFilename(\"x.bz2\"));\r\n    assertTrue(BZip2Utils.isCompressedFileName(\"x.bz2\"));\r\n    assertTrue(BZip2Utils.isCompressedFilename(\"x.bz\"));\r\n    assertTrue(BZip2Utils.isCompressedFileName(\"x.bz\"));\r\n    assertFalse(BZip2Utils.isCompressedFilename(\"xbz2\"));\r\n    assertFalse(BZip2Utils.isCompressedFilename(\"xbz2\"));\r\n    assertFalse(BZip2Utils.isCompressedFilename(\"xbz\"));\r\n    assertFalse(BZip2Utils.isCompressedFileName(\"xbz\"));\r\n    assertTrue(BZip2Utils.isCompressedFilename(\"x.TBZ2\"));\r\n    assertTrue(BZip2Utils.isCompressedFileName(\"x.TBZ2\"));\r\n    assertTrue(BZip2Utils.isCompressedFilename(\"x.Tbz2\"));\r\n    assertTrue(BZip2Utils.isCompressedFileName(\"x.Tbz2\"));\r\n    assertTrue(BZip2Utils.isCompressedFilename(\"x.tbZ2\"));\r\n    assertTrue(BZip2Utils.isCompressedFileName(\"x.tbZ2\"));\r\n    assertFalse(BZip2Utils.isCompressedFilename(\"x.bz \"));\r\n    assertFalse(BZip2Utils.isCompressedFileName(\"x.bz \"));\r\n    assertFalse(BZip2Utils.isCompressedFilename(\"x.tbz\\n\"));\r\n    assertFalse(BZip2Utils.isCompressedFileName(\"x.tbz\\n\"));\r\n    assertFalse(BZip2Utils.isCompressedFilename(\"x.tbz2.y\"));\r\n    assertFalse(BZip2Utils.isCompressedFileName(\"x.tbz2.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\CompressorServiceLoaderTest.java",
  "methodName" : "testInputStream",
  "sourceCode" : "@Test\r\nvoid testInputStream() {\r\n    assertThrows(InvocationConfirmationException.class, () -> new CompressorStreamFactory().createCompressorInputStream(\"TestInput1\", new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\CompressorServiceLoaderTest.java",
  "methodName" : "testOutputStream",
  "sourceCode" : "@Test\r\nvoid testOutputStream() {\r\n    assertThrows(InvocationConfirmationException.class, () -> new CompressorStreamFactory().createCompressorOutputStream(\"TestOutput1\", new ByteArrayOutputStream()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\CompressorStreamFactoryRoundtripTest.java",
  "methodName" : "testCompressorStreamFactoryRoundtrip",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"data\")\r\nvoid testCompressorStreamFactoryRoundtrip(final String compressorName) throws Exception {\r\n    final CompressorStreamProvider factory = new CompressorStreamFactory();\r\n    final ByteArrayOutputStream compressedOs = new ByteArrayOutputStream();\r\n    final String fixture = \"The quick brown fox jumps over the lazy dog\";\r\n    try (CompressorOutputStream<?> compressorOutputStream = factory.createCompressorOutputStream(compressorName, compressedOs)) {\r\n        compressorOutputStream.writeUtf8(fixture);\r\n        compressorOutputStream.flush();\r\n    }\r\n    final ByteArrayInputStream is = new ByteArrayInputStream(compressedOs.toByteArray());\r\n    try (CompressorInputStream compressorInputStream = factory.createCompressorInputStream(compressorName, is, false);\r\n        ByteArrayOutputStream decompressedOs = new ByteArrayOutputStream()) {\r\n        IOUtils.copy(compressorInputStream, decompressedOs);\r\n        compressorInputStream.close();\r\n        decompressedOs.flush();\r\n        decompressedOs.close();\r\n        assertEquals(fixture, decompressedOs.toString(StandardCharsets.UTF_8.name()));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateCompressorInputStreamTest.java",
  "methodName" : "testAvailableShouldReturnNonZero",
  "sourceCode" : "@Test\r\nvoid testAvailableShouldReturnNonZero() throws IOException {\r\n    try (InputStream is = Files.newInputStream(AbstractTest.getPath(\"bla.tar.deflatez\"));\r\n        DeflateCompressorInputStream in = new DeflateCompressorInputStream(is)) {\r\n        assertTrue(in.available() > 0);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateCompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(AbstractTest.getPath(\"bla.tar.deflatez\"));\r\n        DeflateCompressorInputStream in = new DeflateCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateCompressorInputStreamTest.java",
  "methodName" : "testShouldBeAbleToSkipAByte",
  "sourceCode" : "@Test\r\nvoid testShouldBeAbleToSkipAByte() throws IOException {\r\n    try (InputStream is = Files.newInputStream(AbstractTest.getPath(\"bla.tar.deflatez\"));\r\n        DeflateCompressorInputStream in = new DeflateCompressorInputStream(is)) {\r\n        assertEquals(1, in.skip(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    try (InputStream is = Files.newInputStream(AbstractTest.getPath(\"bla.tar.deflatez\"));\r\n        DeflateCompressorInputStream in = new DeflateCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadWorksAsExpected",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadWorksAsExpected() throws IOException {\r\n    try (InputStream is = Files.newInputStream(AbstractTest.getPath(\"bla.tar.deflatez\"));\r\n        DeflateCompressorInputStream in = new DeflateCompressorInputStream(is)) {\r\n        // tar header starts with file name \"test1.xml\"\r\n        assertEquals('t', in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateCompressorOutputStreamTest.java",
  "methodName" : "testCanReadASingleByteFlushAndFinish",
  "sourceCode" : "@Test\r\nvoid testCanReadASingleByteFlushAndFinish() throws IOException {\r\n    try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        DeflateCompressorOutputStream cos = new DeflateCompressorOutputStream(bos)) {\r\n        cos.write(99);\r\n        cos.flush();\r\n        cos.finish();\r\n        assertTrue(bos.toByteArray().length > 0);\r\n        cos.close();\r\n        assertTrue(cos.isClosed());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateParametersTest.java",
  "methodName" : "testShouldBeAbleToSetCompressionLevel",
  "sourceCode" : "@Test\r\nvoid testShouldBeAbleToSetCompressionLevel() {\r\n    final DeflateParameters p = new DeflateParameters();\r\n    p.setCompressionLevel(5);\r\n    assertEquals(5, p.getCompressionLevel());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateParametersTest.java",
  "methodName" : "testShouldNotBeAbleToSetCompressionLevelToADoubleDigitValue",
  "sourceCode" : "@Test\r\nvoid testShouldNotBeAbleToSetCompressionLevelToADoubleDigitValue() {\r\n    final DeflateParameters p = new DeflateParameters();\r\n    assertThrows(IllegalArgumentException.class, () -> p.setCompressionLevel(DeflateParameters.MAX_LEVEL + 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate\\DeflateParametersTest.java",
  "methodName" : "testShouldNotBeAbleToSetCompressionLevelToANegativeValue",
  "sourceCode" : "@Test\r\nvoid testShouldNotBeAbleToSetCompressionLevelToANegativeValue() {\r\n    final DeflateParameters p = new DeflateParameters();\r\n    assertThrows(IllegalArgumentException.class, () -> p.setCompressionLevel(DeflateParameters.MIN_LEVEL - 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64BugsTest.java",
  "methodName" : "testReadBeyondMemoryException",
  "sourceCode" : "@Test\r\nvoid testReadBeyondMemoryException() throws Exception {\r\n    try (ZipFile zipFile = ZipFile.builder().setFile(getFile(\"COMPRESS-380/COMPRESS-380-readbeyondmemory.zip\")).get()) {\r\n        zipFile.stream().forEach(e -> {\r\n            final byte[] buf = new byte[1024 * 8];\r\n            try (InputStream is = zipFile.getInputStream(e)) {\r\n                while (true) {\r\n                    final int read = is.read(buf);\r\n                    if (read == -1) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testCloseCallsDecoder",
  "sourceCode" : "@Test\r\nvoid testCloseCallsDecoder() throws Exception {\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(decoder)) {\r\n        // empty\r\n    }\r\n    Mockito.verify(decoder, times(1)).close();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testCloseIsDelegatedJustOnce",
  "sourceCode" : "@Test\r\nvoid testCloseIsDelegatedJustOnce() throws Exception {\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(decoder)) {\r\n        input.close();\r\n    }\r\n    Mockito.verify(decoder, times(1)).close();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testDelegatesAvailable",
  "sourceCode" : "@Test\r\nvoid testDelegatesAvailable() throws Exception {\r\n    Mockito.when(decoder.available()).thenReturn(1024);\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(decoder)) {\r\n        assertEquals(1024, input.available());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    final byte[] buf = new byte[2];\r\n    try (Deflate64CompressorInputStream in = new Deflate64CompressorInputStream(nullDecoder)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testProperSizeWhenClosed",
  "sourceCode" : "@Test\r\nvoid testProperSizeWhenClosed() throws Exception {\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(nullDecoder)) {\r\n        assertEquals(0, input.available());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testReadWhenClosed",
  "sourceCode" : "@Test\r\nvoid testReadWhenClosed() throws Exception {\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(nullDecoder)) {\r\n        assertEquals(-1, input.read());\r\n        assertEquals(-1, input.read(new byte[1]));\r\n        assertEquals(-1, input.read(new byte[1], 0, 1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS521",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-521\">COMPRESS-521</a>\r\n */\r\n@Test\r\nvoid testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS521() {\r\n    assertThrows(CompressorException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x03, 0x04, 0x2e, 0x00, 0xb6, 0x00, 0x09, 0x00, 0x84, 0xb6, 0xba, 0x46, 0x72, 0x00, 0xfe, 0x77, 0x63, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x62, 0x62, 0x55, 0x54, 0x0c, 0x00, 0x03, 0xe7, 0xce, 0x64, 0x55, 0xf3, 0xce, 0x65, 0x55, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0x5c, 0xf9, 0x01, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00, 0x42, 0x5a, 0x68, 0x34 }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS522",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-522\">COMPRESS-522</a>\r\n */\r\n@Test\r\nvoid testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS522() {\r\n    assertThrows(CompressorException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x4a, 0x84, 0x02, 0x40, 0x00, 0x01, 0x00, 0xff, 0xff }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS525",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-525\">COMPRESS-525</a>\r\n */\r\n@Test\r\nvoid testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS525() {\r\n    assertThrows(CompressorException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x78, 0x00, 0x61, 0x4a, 0x04, 0x04, 0x00, 0x00, 0xff, 0xff, 0x50, 0x53, 0x07, 0x08, 0x43, 0xbe, 0xb7, 0xe8, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x4a, 0x02, 0x04, 0x00, 0x00, 0xff, 0xff, 0x50, 0x4b, 0x7f, 0x08, 0xf9, 0xef, 0xbe, 0x71, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x63, 0x4a, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x50, 0x4b, 0x07, 0x08, 0x6f, 0xdf }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS526",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-526\">COMPRESS-526</a>\r\n */\r\n@Test\r\nvoid testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS526() {\r\n    assertThrows(CompressorException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00, 0x61, 0x4a, 0x04, 0x04, 0x00, 0x00, 0xff, 0xff, 0x50, 0x53, 0x07, 0x08, 0x43, 0xbe, 0xb7, 0xe8, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x4a, 0x02, 0x04, 0x00, 0x00, 0xff, 0xff, 0x50, 0x4b, 0x7f, 0x08, 0xf9, 0xef, 0xbe, 0x71, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x63, 0x4a, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x50, 0x4b, 0x07, 0x08, 0x01, 0xdf, 0xb9, 0x06, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00, 0x08 }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS527",
  "sourceCode" : "/**\r\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-527\">COMPRESS-527</a>\r\n */\r\n@Test\r\nvoid testShouldThrowIOExceptionInsteadOfRuntimeExceptionCOMPRESS527() {\r\n    assertThrows(CompressorException.class, () -> fuzzingTest(new int[] { 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x00, 0x00, 0x09, 0x00, 0x84, 0xb6, 0xba, 0x46, 0x72, 0xb6, 0xfe, 0x77, 0x4a, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x62, 0x62, 0x55, 0x54, 0x09, 0x00, 0x03, 0xe7, 0xce, 0x64, 0x55, 0xf3, 0xce, 0x64, 0x55, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0x5c, 0xf9, 0x01, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00, 0x1d, 0x8b, 0xc1, 0x0d, 0xc0, 0x30, 0x08, 0x03, 0xff, 0x99, 0xc2, 0xab, 0x81, 0x50, 0x1a, 0xa8, 0x44, 0x1e, 0x56, 0x30, 0x7f, 0x21, 0x1f, 0x5b, 0x3e, 0x9d, 0x85, 0x6e }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testShouldThrowsEOFExceptionOnTruncatedStreams",
  "sourceCode" : "@Test\r\nvoid testShouldThrowsEOFExceptionOnTruncatedStreams() throws IOException {\r\n    final byte[] data = { 1, 11, 0, -12, -1, 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l' };\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(new ByteArrayInputStream(data));\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(input))) {\r\n        assertThrows(EOFException.class, () -> br.readLine());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    try (Deflate64CompressorInputStream in = new Deflate64CompressorInputStream(nullDecoder)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testStreamIgnoresExtraBytesAfterDeflatedInput",
  "sourceCode" : "@Test\r\nvoid testStreamIgnoresExtraBytesAfterDeflatedInput() throws Exception {\r\n    final byte[] data = { 1, 11, 0, -12, -1, 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', 'X' };\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(new ByteArrayInputStream(data));\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(input))) {\r\n        assertEquals(\"Hello World\", br.readLine());\r\n        assertNull(br.readLine());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testUncompressedBlock",
  "sourceCode" : "@Test\r\nvoid testUncompressedBlock() throws Exception {\r\n    final byte[] data = { 1, 11, 0, -12, -1, 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(new ByteArrayInputStream(data));\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(input))) {\r\n        assertEquals(\"Hello World\", br.readLine());\r\n        assertNull(br.readLine());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testUncompressedBlockAvailable",
  "sourceCode" : "@Test\r\nvoid testUncompressedBlockAvailable() throws Exception {\r\n    final byte[] data = { 1, 11, 0, -12, -1, 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };\r\n    try (Deflate64CompressorInputStream input = new Deflate64CompressorInputStream(new ByteArrayInputStream(data))) {\r\n        assertEquals('H', input.read());\r\n        assertEquals(10, input.available());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\Deflate64CompressorInputStreamTest.java",
  "methodName" : "testUncompressedBlockViaFactory",
  "sourceCode" : "@Test\r\nvoid testUncompressedBlockViaFactory() throws Exception {\r\n    final byte[] data = { 1, 11, 0, -12, -1, 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };\r\n    try (InputStream input = new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.DEFLATE64, new ByteArrayInputStream(data));\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(input))) {\r\n        assertEquals(\"Hello World\", br.readLine());\r\n        assertNull(br.readLine());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\HuffmanDecoderTest.java",
  "methodName" : "testDecodeFixedHuffmanBlockWithMemoryLookup",
  "sourceCode" : "@Test\r\nvoid testDecodeFixedHuffmanBlockWithMemoryLookup() throws Exception {\r\n    final byte[] data = { // |--- binary filling ---|76543210\r\n    // final block + fixed huffman + H\r\n    0b11111111111111111111111111110011, // H + e\r\n    0b00000000000000000000000001001000, // e + l\r\n    0b11111111111111111111111111001101, // l + l\r\n    0b11111111111111111111111111001001, // l + o\r\n    0b11111111111111111111111111001001, // o + ' '\r\n    0b00000000000000000000000001010111, // ' ' + W\r\n    0b00000000000000000000000000001000, // W + o\r\n    0b11111111111111111111111111001111, // o + r\r\n    0b00000000000000000000000000101111, // r + l\r\n    0b11111111111111111111111111001010, // l + d\r\n    0b00000000000000000000000001001001, // d + '\\n'\r\n    0b11111111111111111111111111100001, // '\\n' + <len>\r\n    0b00000000000000000000000000100010, // <len> + offset <001> + dist6\r\n    0b11111111111111111111111110000110, // dist6 + offset <11> + end of block (000000)\r\n    0b00000000000000000000000000001101, // end of block (0000) + garbage\r\n    0b11111111111111111111111111111000 };\r\n    try (HuffmanDecoder decoder = new HuffmanDecoder(new ByteArrayInputStream(data))) {\r\n        final byte[] result = new byte[100];\r\n        final int len = decoder.decode(result);\r\n        assertEquals(48, len);\r\n        assertEquals(\"Hello World\\nHello World\\nHello World\\nHello World\\n\", new String(result, 0, len));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\HuffmanDecoderTest.java",
  "methodName" : "testDecodeFixedHuffmanBlockWithMemoryLookupInExactBuffer",
  "sourceCode" : "@Test\r\nvoid testDecodeFixedHuffmanBlockWithMemoryLookupInExactBuffer() throws Exception {\r\n    final byte[] data = { // |--- binary filling ---|76543210\r\n    // final block + fixed huffman + H\r\n    0b11111111111111111111111111110011, // H + e\r\n    0b00000000000000000000000001001000, // e + l\r\n    0b11111111111111111111111111001101, // l + l\r\n    0b11111111111111111111111111001001, // l + o\r\n    0b11111111111111111111111111001001, // o + ' '\r\n    0b00000000000000000000000001010111, // ' ' + W\r\n    0b00000000000000000000000000001000, // W + o\r\n    0b11111111111111111111111111001111, // o + r\r\n    0b00000000000000000000000000101111, // r + l\r\n    0b11111111111111111111111111001010, // l + d\r\n    0b00000000000000000000000001001001, // d + '\\n'\r\n    0b11111111111111111111111111100001, // '\\n' + <len>\r\n    0b00000000000000000000000000100010, // <len> + offset <001> + dist6\r\n    0b11111111111111111111111110000110, // dist6 + offset <11> + end of block (000000)\r\n    0b00000000000000000000000000001101, // end of block (0000) + garbage\r\n    0b11111111111111111111111111111000 };\r\n    try (HuffmanDecoder decoder = new HuffmanDecoder(new ByteArrayInputStream(data))) {\r\n        final byte[] result = new byte[48];\r\n        int len;\r\n        len = decoder.decode(result);\r\n        assertEquals(48, len);\r\n        assertEquals(\"Hello World\\nHello World\\nHello World\\nHello World\\n\", new String(result, 0, len));\r\n        len = decoder.decode(result);\r\n        assertEquals(-1, len);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\HuffmanDecoderTest.java",
  "methodName" : "testDecodeFixedHuffmanBlockWithMemoryLookupInSmallBuffer",
  "sourceCode" : "@Test\r\nvoid testDecodeFixedHuffmanBlockWithMemoryLookupInSmallBuffer() throws Exception {\r\n    final byte[] data = { // |--- binary filling ---|76543210\r\n    // final block + fixed huffman + H\r\n    0b11111111111111111111111111110011, // H + e\r\n    0b00000000000000000000000001001000, // e + l\r\n    0b11111111111111111111111111001101, // l + l\r\n    0b11111111111111111111111111001001, // l + o\r\n    0b11111111111111111111111111001001, // o + ' '\r\n    0b00000000000000000000000001010111, // ' ' + W\r\n    0b00000000000000000000000000001000, // W + o\r\n    0b11111111111111111111111111001111, // o + r\r\n    0b00000000000000000000000000101111, // r + l\r\n    0b11111111111111111111111111001010, // l + d\r\n    0b00000000000000000000000001001001, // d + '\\n'\r\n    0b11111111111111111111111111100001, // '\\n' + <len>\r\n    0b00000000000000000000000000100010, // <len> + offset <001> + dist6\r\n    0b11111111111111111111111110000110, // dist6 + offset <11> + end of block (000000)\r\n    0b00000000000000000000000000001101, // end of block (0000) + garbage\r\n    0b11111111111111111111111111111000 };\r\n    try (HuffmanDecoder decoder = new HuffmanDecoder(new ByteArrayInputStream(data))) {\r\n        final byte[] result = new byte[30];\r\n        int len;\r\n        len = decoder.decode(result);\r\n        assertEquals(30, len);\r\n        assertEquals(\"Hello World\\nHello World\\nHello \", new String(result, 0, len));\r\n        len = decoder.decode(result);\r\n        assertEquals(18, len);\r\n        assertEquals(\"World\\nHello World\\n\", new String(result, 0, len));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\HuffmanDecoderTest.java",
  "methodName" : "testDecodeSimpleFixedHuffmanBlock",
  "sourceCode" : "@Test\r\nvoid testDecodeSimpleFixedHuffmanBlock() throws Exception {\r\n    final byte[] data = { // |--- binary filling ---|76543210\r\n    // final block + fixed huffman + H\r\n    0b11111111111111111111111111110011, // H + e\r\n    0b00000000000000000000000001001000, // e + l\r\n    0b11111111111111111111111111001101, // l + l\r\n    0b11111111111111111111111111001001, // l + o\r\n    0b11111111111111111111111111001001, // o + ' '\r\n    0b00000000000000000000000001010111, // ' ' + W\r\n    0b00000000000000000000000000001000, // W + o\r\n    0b11111111111111111111111111001111, // o + r\r\n    0b00000000000000000000000000101111, // r + l\r\n    0b11111111111111111111111111001010, // l + d\r\n    0b00000000000000000000000001001001, // d + end of block\r\n    0b00000000000000000000000000000001, // end of block (00) + garbage\r\n    0b11111111111111111111111111111100 };\r\n    try (HuffmanDecoder decoder = new HuffmanDecoder(new ByteArrayInputStream(data))) {\r\n        final byte[] result = new byte[100];\r\n        final int len = decoder.decode(result);\r\n        assertEquals(11, len);\r\n        assertEquals(\"Hello World\", new String(result, 0, len));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\HuffmanDecoderTest.java",
  "methodName" : "testDecodeSimpleFixedHuffmanBlockToSmallBuffer",
  "sourceCode" : "@Test\r\nvoid testDecodeSimpleFixedHuffmanBlockToSmallBuffer() throws Exception {\r\n    final byte[] data = { // |--- binary filling ---|76543210\r\n    // final block + fixed huffman + H\r\n    0b11111111111111111111111111110011, // H + e\r\n    0b00000000000000000000000001001000, // e + l\r\n    0b11111111111111111111111111001101, // l + l\r\n    0b11111111111111111111111111001001, // l + o\r\n    0b11111111111111111111111111001001, // o + ' '\r\n    0b00000000000000000000000001010111, // ' ' + W\r\n    0b00000000000000000000000000001000, // W + o\r\n    0b11111111111111111111111111001111, // o + r\r\n    0b00000000000000000000000000101111, // r + l\r\n    0b11111111111111111111111111001010, // l + d\r\n    0b00000000000000000000000001001001, // d + end of block\r\n    0b00000000000000000000000000000001, // end of block (00) + garbage\r\n    0b11111111111111111111111111111100 };\r\n    try (HuffmanDecoder decoder = new HuffmanDecoder(new ByteArrayInputStream(data))) {\r\n        final byte[] result = new byte[10];\r\n        int len;\r\n        len = decoder.decode(result);\r\n        assertEquals(10, len);\r\n        assertEquals(\"Hello Worl\", new String(result, 0, len));\r\n        len = decoder.decode(result);\r\n        assertEquals(1, len);\r\n        assertEquals(\"d\", new String(result, 0, len));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\HuffmanDecoderTest.java",
  "methodName" : "testDecodeUncompressedBlock",
  "sourceCode" : "@Test\r\nvoid testDecodeUncompressedBlock() throws Exception {\r\n    final byte[] data = { // end of block + no compression mode\r\n    0b1, // len & ~len\r\n    11, // len & ~len\r\n    0, // len & ~len\r\n    -12, // len & ~len\r\n    -1, 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };\r\n    try (HuffmanDecoder decoder = new HuffmanDecoder(new ByteArrayInputStream(data))) {\r\n        final byte[] result = new byte[100];\r\n        final int len = decoder.decode(result);\r\n        assertEquals(11, len);\r\n        assertEquals(\"Hello World\", new String(result, 0, len));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\deflate64\\HuffmanDecoderTest.java",
  "methodName" : "testDecodeUncompressedBlockWithInvalidLenNLenValue",
  "sourceCode" : "@Test\r\nvoid testDecodeUncompressedBlockWithInvalidLenNLenValue() throws Exception {\r\n    final byte[] data = { // end of block + no compression mode\r\n    0b1, // len & ~len\r\n    11, // len & ~len\r\n    0, // len & ~len\r\n    -12, // len & ~len\r\n    -2, 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };\r\n    try (HuffmanDecoder decoder = new HuffmanDecoder(new ByteArrayInputStream(data))) {\r\n        final byte[] result = new byte[100];\r\n        final IllegalStateException e = assertThrows(IllegalStateException.class, () -> {\r\n            final int len = decoder.decode(result);\r\n            fail(\"Should have failed but returned \" + len + \" entries: \" + Arrays.toString(Arrays.copyOf(result, len)));\r\n        });\r\n        assertEquals(\"Illegal LEN / NLEN values\", e.getMessage());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DeflateTest.java",
  "methodName" : "testDeflateCreation",
  "sourceCode" : "/**\r\n * Tests the creation of a DEFLATE archive with zlib header\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testDeflateCreation() throws Exception {\r\n    final File input = getFile(\"test1.xml\");\r\n    final File output = newTempFile(\"test1.xml.deflatez\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath())) {\r\n        try (CompressorOutputStream<?> cos = new CompressorStreamFactory().createCompressorOutputStream(\"deflate\", out)) {\r\n            cos.write(input);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DeflateTest.java",
  "methodName" : "testDeflateUnarchive",
  "sourceCode" : "/**\r\n * Tests the extraction of a DEFLATE archive with zlib header\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testDeflateUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.tar.deflatez\");\r\n    final File output = newTempFile(\"bla.tar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        // zlib header is expected by default\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"deflate\", is)) {\r\n            Files.copy(in, output.toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DeflateTest.java",
  "methodName" : "testRawDeflateCreation",
  "sourceCode" : "/**\r\n * Tests the creation of a \"raw\" DEFLATE archive (without zlib header)\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testRawDeflateCreation() throws Exception {\r\n    final File input = getFile(\"test1.xml\");\r\n    final File output = newTempFile(\"test1.xml.deflate\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath())) {\r\n        final DeflateParameters params = new DeflateParameters();\r\n        params.setWithZlibHeader(false);\r\n        try (CompressorOutputStream<?> cos = new DeflateCompressorOutputStream(out, params)) {\r\n            cos.write(input);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DeflateTest.java",
  "methodName" : "testRawDeflateUnarchive",
  "sourceCode" : "/**\r\n * Tests the extraction of a \"raw\" DEFLATE archive (without zlib header)\r\n *\r\n * @throws Exception\r\n */\r\n@Test\r\nvoid testRawDeflateUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.tar.deflate\");\r\n    final File output = newTempFile(\"bla.tar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        final DeflateParameters params = new DeflateParameters();\r\n        params.setWithZlibHeader(false);\r\n        try (CompressorInputStream in = new DeflateCompressorInputStream(is, params)) {\r\n            Files.copy(in, output.toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testCreateLimitedByName",
  "sourceCode" : "@Test\r\nvoid testCreateLimitedByName() throws Exception {\r\n    try (CompressorInputStream bzip2 = createCompressorInputStream(\"bla.txt.bz2\", Collections.singleton(CompressorStreamFactory.BZIP2))) {\r\n        assertNotNull(bzip2);\r\n        assertInstanceOf(BZip2CompressorInputStream.class, bzip2);\r\n    }\r\n    try (CompressorInputStream gzip = createCompressorInputStream(\"bla.tgz\", Collections.singleton(CompressorStreamFactory.GZIP))) {\r\n        assertNotNull(gzip);\r\n        assertInstanceOf(GzipCompressorInputStream.class, gzip);\r\n    }\r\n    try (CompressorInputStream pack200 = createCompressorInputStream(\"bla.pack\", Collections.singleton(CompressorStreamFactory.PACK200))) {\r\n        assertNotNull(pack200);\r\n        assertInstanceOf(Pack200CompressorInputStream.class, pack200);\r\n    }\r\n    try (CompressorInputStream xz = createCompressorInputStream(\"bla.tar.xz\", Collections.singleton(CompressorStreamFactory.XZ))) {\r\n        assertNotNull(xz);\r\n        assertInstanceOf(XZCompressorInputStream.class, xz);\r\n    }\r\n    try (CompressorInputStream zlib = createCompressorInputStream(\"bla.tar.deflatez\", Collections.singleton(CompressorStreamFactory.DEFLATE))) {\r\n        assertNotNull(zlib);\r\n        assertInstanceOf(DeflateCompressorInputStream.class, zlib);\r\n    }\r\n    try (CompressorInputStream zstd = createCompressorInputStream(\"bla.tar.zst\", Collections.singleton(CompressorStreamFactory.ZSTANDARD))) {\r\n        assertNotNull(zstd);\r\n        assertInstanceOf(ZstdCompressorInputStream.class, zstd);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testCreateLimitedByNameNotFound",
  "sourceCode" : "@Test\r\nvoid testCreateLimitedByNameNotFound() throws Exception {\r\n    assertThrows(CompressorException.class, () -> createCompressorInputStream(\"bla.txt.bz2\", Collections.singleton(CompressorStreamFactory.BROTLI)));\r\n    assertThrows(CompressorException.class, () -> createCompressorInputStream(\"bla.tgz\", Collections.singleton(CompressorStreamFactory.Z)));\r\n    assertThrows(CompressorException.class, () -> createCompressorInputStream(\"bla.pack\", Collections.singleton(CompressorStreamFactory.SNAPPY_FRAMED)));\r\n    assertThrows(CompressorException.class, () -> createCompressorInputStream(\"bla.tar.xz\", Collections.singleton(CompressorStreamFactory.GZIP)));\r\n    assertThrows(CompressorException.class, () -> createCompressorInputStream(\"bla.tar.deflatez\", Collections.singleton(CompressorStreamFactory.PACK200)));\r\n    assertThrows(CompressorException.class, () -> createCompressorInputStream(\"bla.tar.zst\", Collections.singleton(CompressorStreamFactory.LZ4_FRAMED)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testCreateWithAutoDetection",
  "sourceCode" : "@Test\r\nvoid testCreateWithAutoDetection() throws Exception {\r\n    try (CompressorInputStream bzip2 = createCompressorInputStream(\"bla.txt.bz2\")) {\r\n        assertNotNull(bzip2);\r\n        assertInstanceOf(BZip2CompressorInputStream.class, bzip2);\r\n    }\r\n    try (CompressorInputStream gzip = createCompressorInputStream(\"bla.tgz\")) {\r\n        assertNotNull(gzip);\r\n        assertInstanceOf(GzipCompressorInputStream.class, gzip);\r\n    }\r\n    try (CompressorInputStream pack200 = createCompressorInputStream(\"bla.pack\")) {\r\n        assertNotNull(pack200);\r\n        assertInstanceOf(Pack200CompressorInputStream.class, pack200);\r\n    }\r\n    try (CompressorInputStream xz = createCompressorInputStream(\"bla.tar.xz\")) {\r\n        assertNotNull(xz);\r\n        assertInstanceOf(XZCompressorInputStream.class, xz);\r\n    }\r\n    try (CompressorInputStream zlib = createCompressorInputStream(\"bla.tar.deflatez\")) {\r\n        assertNotNull(zlib);\r\n        assertInstanceOf(DeflateCompressorInputStream.class, zlib);\r\n    }\r\n    try (CompressorInputStream zstd = createCompressorInputStream(\"bla.tar.zst\")) {\r\n        assertNotNull(zstd);\r\n        assertInstanceOf(ZstdCompressorInputStream.class, zstd);\r\n    }\r\n    assertThrows(CompressorException.class, () -> factory.createCompressorInputStream(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testDetect",
  "sourceCode" : "@Test\r\nvoid testDetect() throws Exception {\r\n    assertEquals(CompressorStreamFactory.BZIP2, detect(\"bla.txt.bz2\"));\r\n    assertEquals(CompressorStreamFactory.GZIP, detect(\"bla.tgz\"));\r\n    assertEquals(CompressorStreamFactory.PACK200, detect(\"bla.pack\"));\r\n    assertEquals(CompressorStreamFactory.XZ, detect(\"bla.tar.xz\"));\r\n    assertEquals(CompressorStreamFactory.DEFLATE, detect(\"bla.tar.deflatez\"));\r\n    assertEquals(CompressorStreamFactory.LZ4_FRAMED, detect(\"bla.tar.lz4\"));\r\n    assertEquals(CompressorStreamFactory.LZMA, detect(\"bla.tar.lzma\"));\r\n    assertEquals(CompressorStreamFactory.SNAPPY_FRAMED, detect(\"bla.tar.sz\"));\r\n    assertEquals(CompressorStreamFactory.Z, detect(\"bla.tar.Z\"));\r\n    assertEquals(CompressorStreamFactory.ZSTANDARD, detect(\"bla.tar.zst\"));\r\n    // make sure we don't oom on detect\r\n    assertEquals(CompressorStreamFactory.Z, detect(\"COMPRESS-386\"));\r\n    assertEquals(CompressorStreamFactory.LZMA, detect(\"COMPRESS-382\"));\r\n    assertThrows(CompressorException.class, () -> CompressorStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY))));\r\n    final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> CompressorStreamFactory.detect(null), \"shouldn't be able to detect null stream\");\r\n    assertEquals(\"Stream must not be null.\", e.getMessage());\r\n    final CompressorException ce = assertThrows(CompressorException.class, () -> CompressorStreamFactory.detect(new BufferedInputStream(new BrokenInputStream())), \"Expected IOException\");\r\n    assertEquals(\"Failed to read signature.\", ce.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testDetectLimitedByName",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"getDetectLimitedByNameParams\")\r\nvoid testDetectLimitedByName(final String filename, final String compressorName) throws Exception {\r\n    assertEquals(compressorName, detect(filename, Collections.singleton(compressorName)));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testDetectLimitedByNameNotFound",
  "sourceCode" : "@Test\r\nvoid testDetectLimitedByNameNotFound() throws Exception {\r\n    final Set<String> compressorNames = Collections.singleton(CompressorStreamFactory.DEFLATE);\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.txt.bz2\", compressorNames));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.tgz\", compressorNames));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.pack\", compressorNames));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.tar.xz\", compressorNames));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.tar.deflatez\", Collections.singleton(CompressorStreamFactory.BZIP2)));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.tar.lz4\", compressorNames));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.tar.lzma\", compressorNames));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.tar.sz\", compressorNames));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.tar.Z\", compressorNames));\r\n    assertThrows(CompressorException.class, () -> detect(\"bla.tar.zst\", compressorNames));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testDetectNullOrEmptyCompressorNames",
  "sourceCode" : "@Test\r\nvoid testDetectNullOrEmptyCompressorNames() throws Exception {\r\n    assertThrows(IllegalArgumentException.class, () -> CompressorStreamFactory.detect(createCompressorInputStream(\"bla.txt.bz2\"), (Set<String>) null));\r\n    assertThrows(IllegalArgumentException.class, () -> CompressorStreamFactory.detect(createCompressorInputStream(\"bla.tgz\"), new HashSet<>()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testLZMAMemoryLimit",
  "sourceCode" : "@Test\r\nvoid testLZMAMemoryLimit() throws Exception {\r\n    assertThrows(MemoryLimitException.class, () -> createInputStream(\"COMPRESS-382\", 100));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testMultiples",
  "sourceCode" : "@Test\r\nvoid testMultiples() throws Exception {\r\n    for (int i = 0; i < tests.length; i++) {\r\n        final TestData test = tests[i];\r\n        final CompressorStreamFactory fac = test.factory;\r\n        assertNotNull(fac, \"Test entry \" + i);\r\n        assertEquals(test.concat, fac.getDecompressConcatenated(), \"Test entry \" + i);\r\n        try (CompressorInputStream in = createCompressorInputStream(test.fileName, fac)) {\r\n            assertNotNull(in, \"Test entry \" + i);\r\n            for (final char entry : test.entryNames) {\r\n                assertEquals(entry, in.read(), \"Test entry\" + i);\r\n            }\r\n            assertEquals(0, in.available());\r\n            assertEquals(-1, in.read());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testOverride",
  "sourceCode" : "@Test\r\nvoid testOverride() {\r\n    final CompressorStreamFactory fac1 = new CompressorStreamFactory();\r\n    assertFalse(fac1.getDecompressConcatenated());\r\n    fac1.setDecompressConcatenated(true);\r\n    assertTrue(fac1.getDecompressConcatenated());\r\n    final CompressorStreamFactory fac2 = new CompressorStreamFactory(false);\r\n    assertFalse(fac2.getDecompressConcatenated());\r\n    assertThrows(IllegalStateException.class, () -> fac2.setDecompressConcatenated(true), \"Expected IllegalStateException\");\r\n    final CompressorStreamFactory fac3 = new CompressorStreamFactory(true);\r\n    assertTrue(fac3.getDecompressConcatenated());\r\n    assertThrows(IllegalStateException.class, () -> fac3.setDecompressConcatenated(true), \"Expected IllegalStateException\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testXZMemoryLimitOnRead",
  "sourceCode" : "@Test\r\nvoid testXZMemoryLimitOnRead() throws Exception {\r\n    // Even though the file is very small, the memory limit\r\n    // has to be quite large (8296 KiB) because of the dictionary size\r\n    // This is triggered on read(); not during initialization.\r\n    // This test is here instead of the xz unit test to make sure\r\n    // that the parameter is properly passed via the CompressorStreamFactory\r\n    try (InputStream compressorIs = createInputStream(\"bla.tar.xz\", 100)) {\r\n        assertThrows(MemoryLimitException.class, () -> compressorIs.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testXZMemoryLimitOnSkip",
  "sourceCode" : "@Test\r\nvoid testXZMemoryLimitOnSkip() throws Exception {\r\n    try (InputStream compressorIs = createInputStream(\"bla.tar.xz\", 100)) {\r\n        assertThrows(MemoryLimitException.class, () -> compressorIs.skip(10));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\DetectCompressorTest.java",
  "methodName" : "testZMemoryLimit",
  "sourceCode" : "@Test\r\nvoid testZMemoryLimit() throws Exception {\r\n    assertThrows(MemoryLimitException.class, () -> createInputStream(\"COMPRESS-386\", 100));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\FramedSnappyTest.java",
  "methodName" : "testDefaultExtraction",
  "sourceCode" : "@Test\r\nvoid testDefaultExtraction() throws Exception {\r\n    testUnarchive(FramedSnappyCompressorInputStream::new);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\FramedSnappyTest.java",
  "methodName" : "testDefaultExtractionViaFactory",
  "sourceCode" : "@Test\r\nvoid testDefaultExtractionViaFactory() throws Exception {\r\n    testUnarchive(is -> new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.SNAPPY_FRAMED, is));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\FramedSnappyTest.java",
  "methodName" : "testDefaultExtractionViaFactoryAutodetection",
  "sourceCode" : "@Test\r\nvoid testDefaultExtractionViaFactoryAutodetection() throws Exception {\r\n    testUnarchive(is -> new CompressorStreamFactory().createCompressorInputStream(is));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\FramedSnappyTest.java",
  "methodName" : "testRoundtrip",
  "sourceCode" : "@Test\r\nvoid testRoundtrip() throws Exception {\r\n    testRoundtrip(getFile(\"test.txt\"));\r\n    testRoundtrip(getFile(\"bla.tar\"));\r\n    testRoundtrip(getFile(\"COMPRESS-256.7z\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\FramedSnappyTest.java",
  "methodName" : "testRoundtripWithOneBigWrite",
  "sourceCode" : "@Test\r\nvoid testRoundtripWithOneBigWrite() throws Exception {\r\n    final Random r = new Random();\r\n    final File input = newTempFile(\"bigChunkTest\");\r\n    try (OutputStream fs = Files.newOutputStream(input.toPath())) {\r\n        for (int i = 0; i < 1 << 17; i++) {\r\n            fs.write(r.nextInt(256));\r\n        }\r\n    }\r\n    final File outputSz = newTempFile(input.getName() + \".sz\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        OutputStream os = Files.newOutputStream(outputSz.toPath());\r\n        CompressorOutputStream<?> sos = new CompressorStreamFactory().createCompressorOutputStream(\"snappy-framed\", os)) {\r\n        final byte[] b = IOUtils.toByteArray(is);\r\n        sos.write(b[0]);\r\n        // must be split into multiple compressed chunks\r\n        sos.write(b, 1, b.length - 1);\r\n    }\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        CompressorInputStream sis = new CompressorStreamFactory().createCompressorInputStream(\"snappy-framed\", Files.newInputStream(outputSz.toPath()))) {\r\n        final byte[] expected = IOUtils.toByteArray(is);\r\n        final byte[] actual = IOUtils.toByteArray(sis);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\ExtraFieldTest.java",
  "methodName" : "testEquals",
  "sourceCode" : "@Test\r\nvoid testEquals() throws IOException {\r\n    assertEquals(new ExtraField(), new ExtraField());\r\n    assertEquals(new ExtraField().addSubField(\"BB\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)), new ExtraField().addSubField(\"BB\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)));\r\n    // not equals\r\n    assertNotEquals(new ExtraField().addSubField(\"XX\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)), new ExtraField().addSubField(\"BB\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)));\r\n    assertNotEquals(new ExtraField().addSubField(\"XX\", \"AAAA\".getBytes(StandardCharsets.ISO_8859_1)), new ExtraField().addSubField(\"XX\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\ExtraFieldTest.java",
  "methodName" : "testHashCode",
  "sourceCode" : "@Test\r\nvoid testHashCode() throws IOException {\r\n    assertEquals(new ExtraField().hashCode(), new ExtraField().hashCode());\r\n    assertEquals(new ExtraField().addSubField(\"BB\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)).hashCode(), new ExtraField().addSubField(\"BB\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)).hashCode());\r\n    // not equals\r\n    assertNotEquals(new ExtraField().addSubField(\"XX\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)).hashCode(), new ExtraField().addSubField(\"BB\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)).hashCode());\r\n    assertNotEquals(new ExtraField().addSubField(\"XX\", \"AAAA\".getBytes(StandardCharsets.ISO_8859_1)).hashCode(), new ExtraField().addSubField(\"XX\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1)).hashCode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorInputStreamTest.java",
  "methodName" : "testCompress705",
  "sourceCode" : "@Test\r\nvoid testCompress705() throws IOException {\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setFile(\"src/test/resources/org/apache/commons/compress/COMPRESS-705/grafana-9.2.9.tgz\").setIgnoreExtraField(true).get()) {\r\n        // COMPRESS-705 didn't get you here\r\n        assertEquals(\"Helm\", gis.getMetaData().getComment());\r\n        assertEquals(41, gis.getMetaData().getExtraFieldXlen());\r\n        final List<String> fileNames = new ArrayList<>();\r\n        try (TarArchiveInputStream tar = TarArchiveInputStream.builder().setInputStream(gis).get()) {\r\n            TarArchiveEntry entry;\r\n            while ((entry = tar.getNextEntry()) != null) {\r\n                fileNames.add(entry.getName());\r\n            }\r\n        }\r\n        // @formatter:off\r\n        final List<String> expected = Arrays.asList(\"grafana/Chart.yaml\", \"grafana/values.yaml\", \"grafana/templates/NOTES.txt\", \"grafana/templates/_config.tpl\", \"grafana/templates/_helpers.tpl\", \"grafana/templates/_pod.tpl\", \"grafana/templates/clusterrole.yaml\", \"grafana/templates/clusterrolebinding.yaml\", \"grafana/templates/configSecret.yaml\", \"grafana/templates/configmap-dashboard-provider.yaml\", \"grafana/templates/configmap.yaml\", \"grafana/templates/dashboards-json-configmap.yaml\", \"grafana/templates/deployment.yaml\", \"grafana/templates/extra-manifests.yaml\", \"grafana/templates/headless-service.yaml\", \"grafana/templates/hpa.yaml\", \"grafana/templates/image-renderer-deployment.yaml\", \"grafana/templates/image-renderer-hpa.yaml\", \"grafana/templates/image-renderer-network-policy.yaml\", \"grafana/templates/image-renderer-service.yaml\", \"grafana/templates/image-renderer-servicemonitor.yaml\", \"grafana/templates/ingress.yaml\", \"grafana/templates/networkpolicy.yaml\", \"grafana/templates/poddisruptionbudget.yaml\", \"grafana/templates/podsecuritypolicy.yaml\", \"grafana/templates/pvc.yaml\", \"grafana/templates/role.yaml\", \"grafana/templates/rolebinding.yaml\", \"grafana/templates/route.yaml\", \"grafana/templates/secret-env.yaml\", \"grafana/templates/secret.yaml\", \"grafana/templates/service.yaml\", \"grafana/templates/serviceaccount.yaml\", \"grafana/templates/servicemonitor.yaml\", \"grafana/templates/statefulset.yaml\", \"grafana/templates/tests/test-configmap.yaml\", \"grafana/templates/tests/test-podsecuritypolicy.yaml\", \"grafana/templates/tests/test-role.yaml\", \"grafana/templates/tests/test-rolebinding.yaml\", \"grafana/templates/tests/test-serviceaccount.yaml\", \"grafana/templates/tests/test.yaml\", \"grafana/.helmignore\", \"grafana/README.md\", \"grafana/ci/default-values.yaml\", \"grafana/ci/with-affinity-values.yaml\", \"grafana/ci/with-dashboard-json-values.yaml\", \"grafana/ci/with-dashboard-values.yaml\", \"grafana/ci/with-extraconfigmapmounts-values.yaml\", \"grafana/ci/with-image-renderer-values.yaml\", \"grafana/ci/with-nondefault-values.yaml\", \"grafana/ci/with-persistence.yaml\", \"grafana/ci/with-sidecars-envvaluefrom-values.yaml\", \"grafana/dashboards/custom-dashboard.json\");\r\n        // @formatter:on\r\n        assertEquals(expected, fileNames);\r\n    }\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setFile(\"src/test/resources/org/apache/commons/compress/COMPRESS-705/grafana-9.2.9.tgz\").setIgnoreExtraField(true).get()) {\r\n        // COMPRESS-705 didn't get you here\r\n        try (InputStream tarInputStream = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/commons/compress/COMPRESS-705/grafana-9.2.9.tar\"))) {\r\n            IOUtils.contentEquals(tarInputStream, gis);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorInputStreamTest.java",
  "methodName" : "testGzipParametersMembersIo",
  "sourceCode" : "@Test\r\n@Disabled\r\nvoid testGzipParametersMembersIo() throws IOException {\r\n    final Path targetFile = tempDir.resolve(\"test.gz\");\r\n    final String sourceFileName1 = \"file1\";\r\n    final String sourceFileName2 = \"file2\";\r\n    final Path tempSourceFile1 = tempDir.resolve(sourceFileName1);\r\n    final Path tempSourceFile2 = tempDir.resolve(sourceFileName2);\r\n    final byte[] bytes1 = \"<text>Hello World 1!</text>\".getBytes(StandardCharsets.UTF_8);\r\n    final byte[] bytes2 = \"<text>Hello World 2!</text>\".getBytes(StandardCharsets.UTF_8);\r\n    Files.write(tempSourceFile1, bytes1);\r\n    Files.write(tempSourceFile2, bytes2);\r\n    final GzipParameters parameters1 = new GzipParameters();\r\n    final GzipParameters parameters2 = new GzipParameters();\r\n    parameters1.setFileName(sourceFileName1);\r\n    parameters2.setFileName(sourceFileName2);\r\n    try (OutputStream fos = Files.newOutputStream(targetFile);\r\n        GzipCompressorOutputStream gos = new GzipCompressorOutputStream(fos, parameters1)) {\r\n        gos.write(tempSourceFile1);\r\n        gos.finish();\r\n        gos.write(tempSourceFile2);\r\n        gos.finish();\r\n    }\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setPath(targetFile).setDecompressConcatenated(false).get()) {\r\n        assertEquals(parameters1, gis.getMetaData());\r\n        assertArrayEquals(bytes1, IOUtils.toByteArray(gis));\r\n    }\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setPath(targetFile).setDecompressConcatenated(true).get()) {\r\n        assertEquals(parameters1, gis.getMetaData());\r\n        // assertArrayEquals(ArrayUtils.addAll(bytes1, bytes2), IOUtils.toByteArray(gis));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorInputStreamTest.java",
  "methodName" : "testOnMemberFirstAll",
  "sourceCode" : "/**\r\n * Tests file from gzip 1.13.\r\n *\r\n * <pre>{@code\r\n * gzip --keep --name --best -c hello1.txt >members.gz\r\n * gzip --keep --name --best -c hello2.txt >>members.gz\r\n * }</pre>\r\n *\r\n * @throws IOException on test failure.\r\n */\r\n@Test\r\nvoid testOnMemberFirstAll() throws IOException {\r\n    final List<GzipParameters> parametersStart = new ArrayList<>();\r\n    final List<GzipParameters> parametersEnd = new ArrayList<>();\r\n    // Concatenated members, same file\r\n    // @formatter:off\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setFile(\"src/test/resources/org/apache/commons/compress/gzip/members.gz\").setDecompressConcatenated(true).setOnMemberStart(in -> parametersStart.add(in.getMetaData())).setOnMemberEnd(in -> parametersEnd.add(in.getMetaData())).get()) {\r\n        // @formatter:on\r\n        assertEquals(\"hello1.txt\", gis.getMetaData().getFileName());\r\n        assertEquals(\"Hello1\\nHello2\\n\", IOUtils.toString(gis, StandardCharsets.ISO_8859_1));\r\n        assertEquals(\"hello2.txt\", gis.getMetaData().getFileName());\r\n    }\r\n    assertEquals(2, parametersStart.size());\r\n    assertEquals(2, parametersEnd.size());\r\n    assertEquals(parametersStart, parametersEnd);\r\n    // Make sure we are not reusing GzipParameters anymore.\r\n    assertEquals(2, new HashSet<>(parametersStart).size());\r\n    assertEquals(2, new HashSet<>(parametersEnd).size());\r\n    // trailers\r\n    assertEquals(4202744527L, parametersEnd.get(0).getTrailerCrc());\r\n    assertEquals(7, parametersEnd.get(0).getTrailerISize());\r\n    assertEquals(3517815052L, parametersEnd.get(1).getTrailerCrc());\r\n    assertEquals(7, parametersEnd.get(1).getTrailerISize());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorInputStreamTest.java",
  "methodName" : "testOnMemberFirstOnly",
  "sourceCode" : "/**\r\n * Tests file from gzip 1.13.\r\n *\r\n * <pre>{@code\r\n * gzip --keep --name --best -c hello1.txt >members.gz\r\n * gzip --keep --name --best -c hello2.txt >>members.gz\r\n * }</pre>\r\n *\r\n * @throws IOException on test failure.\r\n */\r\n@Test\r\nvoid testOnMemberFirstOnly() throws IOException {\r\n    final List<GzipParameters> parametersStart = new ArrayList<>();\r\n    final List<GzipParameters> parametersEnd = new ArrayList<>();\r\n    // First member only\r\n    // @formatter:off\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setFile(\"src/test/resources/org/apache/commons/compress/gzip/members.gz\").setDecompressConcatenated(false).setOnMemberStart(in -> parametersStart.add(in.getMetaData())).setOnMemberEnd(in -> parametersEnd.add(in.getMetaData())).get()) {\r\n        // @formatter:on\r\n        assertEquals(\"hello1.txt\", gis.getMetaData().getFileName());\r\n        assertEquals(\"Hello1\\n\", IOUtils.toString(gis, StandardCharsets.ISO_8859_1));\r\n        assertEquals(\"hello1.txt\", gis.getMetaData().getFileName());\r\n    }\r\n    assertEquals(1, parametersStart.size());\r\n    assertEquals(1, parametersEnd.size());\r\n    assertEquals(parametersStart, parametersEnd);\r\n    // trailer\r\n    assertEquals(4202744527L, parametersEnd.get(0).getTrailerCrc());\r\n    assertEquals(7, parametersEnd.get(0).getTrailerISize());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorInputStreamTest.java",
  "methodName" : "testOnMemberSaveAsFiles",
  "sourceCode" : "/**\r\n * Tests file from gzip 1.13.\r\n *\r\n * <pre>{@code\r\n * gzip --keep --name --best -c hello1.txt >members.gz\r\n * gzip --keep --name --best -c hello2.txt >>members.gz\r\n * }</pre>\r\n *\r\n * @throws IOException on test failure.\r\n */\r\n@Test\r\nvoid testOnMemberSaveAsFiles() throws IOException {\r\n    final List<Path> resolved = extractMembers(\"src/test/resources/org/apache/commons/compress/gzip/members.gz\");\r\n    assertEquals(\"Hello1\\n\", PathUtils.readString(resolved.get(0), StandardCharsets.ISO_8859_1));\r\n    assertEquals(\"Hello2\\n\", PathUtils.readString(resolved.get(1), StandardCharsets.ISO_8859_1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorInputStreamTest.java",
  "methodName" : "testOnMemberSaveAsSize0Files",
  "sourceCode" : "/**\r\n * Tests file from gzip 1.13 for input files of size 0.\r\n *\r\n * <pre>{@code\r\n * gzip --keep --name --best -c hello-size-0-a.txt >members-size-0.gz\r\n * gzip --keep --name --best -c hello-size-0-b.txt >>members-size-0.gz\r\n * gzip --keep --name --best -c hello-size-0-c.txt >>members-size-0.gz\r\n * }</pre>\r\n *\r\n * @throws IOException on test failure.\r\n */\r\n@SuppressWarnings(\"resource\")\r\n@Test\r\nvoid testOnMemberSaveAsSize0Files() throws IOException {\r\n    final List<Path> resolved = extractMembers(\"src/test/resources/org/apache/commons/compress/gzip/members-size-0.gz\");\r\n    assertEquals(3, resolved.size());\r\n    IOStream.of(resolved).forEach(p -> {\r\n        assertEquals(0, Files.size(p));\r\n        assertEquals(\"\", PathUtils.readString(p, StandardCharsets.ISO_8859_1));\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorInputStreamTest.java",
  "methodName" : "testReadGzipFileCreatedByCli",
  "sourceCode" : "/**\r\n * Tests file from gzip 1.13.\r\n *\r\n * <pre>{@code\r\n * gzip --keep --name --best -c hello1.txt >members.gz\r\n * gzip --keep --name --best -c hello2.txt >>members.gz\r\n * }</pre>\r\n *\r\n * @throws IOException on test failure.\r\n */\r\n@Test\r\nvoid testReadGzipFileCreatedByCli() throws IOException {\r\n    // First member only\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setFile(\"src/test/resources/org/apache/commons/compress/gzip/members.gz\").get()) {\r\n        assertEquals(\"hello1.txt\", gis.getMetaData().getFileName());\r\n        assertEquals(\"Hello1\\n\", IOUtils.toString(gis, StandardCharsets.ISO_8859_1));\r\n        assertEquals(\"hello1.txt\", gis.getMetaData().getFileName());\r\n    }\r\n    // Concatenated members, same file\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setFile(\"src/test/resources/org/apache/commons/compress/gzip/members.gz\").setDecompressConcatenated(true).get()) {\r\n        assertEquals(\"hello1.txt\", gis.getMetaData().getFileName());\r\n        assertEquals(\"Hello1\\nHello2\\n\", IOUtils.toString(gis, StandardCharsets.ISO_8859_1));\r\n        assertEquals(\"hello2.txt\", gis.getMetaData().getFileName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorOutputStreamTest.java",
  "methodName" : "testChineseFileNameGBK",
  "sourceCode" : "/**\r\n * Tests Chinese file name for Windows behavior.\r\n *\r\n * @throws IOException When the test fails.\r\n */\r\n@Test\r\nvoid testChineseFileNameGBK() throws IOException {\r\n    assumeTrue(Charset.isSupported(\"GBK\"));\r\n    testChineseFileName(EXPECTED_FILE_NAME, EXPECTED_FILE_NAME, Charset.forName(\"GBK\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorOutputStreamTest.java",
  "methodName" : "testChineseFileNameUTF8",
  "sourceCode" : "/**\r\n * Tests Chinese file name for Windows behavior.\r\n *\r\n * @throws IOException When the test fails.\r\n */\r\n@Test\r\nvoid testChineseFileNameUTF8() throws IOException {\r\n    testChineseFileName(EXPECTED_FILE_NAME, EXPECTED_FILE_NAME, StandardCharsets.UTF_8);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorOutputStreamTest.java",
  "methodName" : "testExtraSubfields",
  "sourceCode" : "/**\r\n * Tests the gzip extra header containing subfields.\r\n *\r\n * @throws IOException When the test has issues with the underlying file system or unexpected gzip operations.\r\n */\r\n@ParameterizedTest\r\n// @formatter:off\r\n@CsvSource({ \"0,    42, false\", \"1,      , true\", \"1,     0, false\", \"1, 65531, false\", \"1, 65532, true\", \"2,     0, false\", \"2, 32764, true\", \"2, 32763, false\" })\r\n// @formatter:on\r\nvoid testExtraSubfields(final int subFieldCount, final Integer payloadSize, final boolean shouldFail) throws IOException {\r\n    final Path tempSourceFile = Files.createTempFile(\"test_gzip_extra_\", \".txt\");\r\n    final Path targetFile = Files.createTempFile(\"test_gzip_extra_\", \".txt.gz\");\r\n    Files.write(tempSourceFile, \"Hello World!\".getBytes(StandardCharsets.ISO_8859_1));\r\n    final GzipParameters parameters = new GzipParameters();\r\n    final ExtraField extra = new ExtraField();\r\n    boolean failed = false;\r\n    final byte[][] payloads = new byte[subFieldCount][];\r\n    for (int i = 0; i < subFieldCount; i++) {\r\n        if (payloadSize != null) {\r\n            payloads[i] = ArrayFill.fill(new byte[payloadSize], (byte) ('a' + i));\r\n        }\r\n        try {\r\n            extra.addSubField(\"z\" + i, payloads[i]);\r\n        } catch (final NullPointerException | IOException e) {\r\n            failed = true;\r\n            break;\r\n        }\r\n    }\r\n    assertEquals(shouldFail, failed, \"add subfield \" + (shouldFail ? \"succes\" : \"failure\") + \" was not expected.\");\r\n    if (shouldFail) {\r\n        return;\r\n    }\r\n    if (subFieldCount > 0) {\r\n        assertThrows(UnsupportedOperationException.class, () -> extra.iterator().remove());\r\n    }\r\n    parameters.setExtraField(extra);\r\n    try (OutputStream fos = Files.newOutputStream(targetFile);\r\n        GzipCompressorOutputStream gos = new GzipCompressorOutputStream(fos, parameters)) {\r\n        gos.write(tempSourceFile);\r\n        gos.close();\r\n        assertTrue(gos.isClosed());\r\n    }\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setPath(targetFile).setIgnoreExtraField(false).get()) {\r\n        final ExtraField extra2 = gis.getMetaData().getExtraField();\r\n        assertEquals(parameters, gis.getMetaData());\r\n        assertEquals(subFieldCount == 0, extra2.isEmpty());\r\n        assertEquals(subFieldCount, extra2.size());\r\n        assertEquals(4 * subFieldCount + subFieldCount * payloadSize, extra2.getEncodedSize());\r\n        final ArrayList<SubField> listCopy = new ArrayList<>();\r\n        extra2.forEach(listCopy::add);\r\n        assertEquals(subFieldCount, listCopy.size());\r\n        for (int i = 0; i < subFieldCount; i++) {\r\n            final SubField sf = extra2.getSubField(i);\r\n            assertSame(sf, listCopy.get(i));\r\n            assertSame(sf, extra2.findFirstSubField(\"z\" + i));\r\n            // id was saved/loaded correctly\r\n            assertEquals(\"z\" + i, sf.getId());\r\n            assertArrayEquals(payloads[i], sf.getPayload(), \"field \" + i + \" has wrong payload\");\r\n        }\r\n        extra2.clear();\r\n        assertTrue(extra2.isEmpty());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorOutputStreamTest.java",
  "methodName" : "testExtraSubfieldsEmpty",
  "sourceCode" : "@Test\r\nvoid testExtraSubfieldsEmpty() {\r\n    final ExtraField extra = new ExtraField();\r\n    assertEquals(0, extra.toByteArray().length);\r\n    assertFalse(extra.iterator().hasNext());\r\n    extra.forEach(e -> fail(\"Not empty.\"));\r\n    assertThrows(IndexOutOfBoundsException.class, () -> extra.getSubField(0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorOutputStreamTest.java",
  "methodName" : "testFileNameAscii",
  "sourceCode" : "@Test\r\nvoid testFileNameAscii() throws IOException {\r\n    testFileName(\"ASCII.xml\", \"ASCII.xml\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorOutputStreamTest.java",
  "methodName" : "testFileNameChinesePercentEncoded",
  "sourceCode" : "/**\r\n * Tests COMPRESS-638. Use {@link GzipParameters#setFileNameCharset(Charset)} if you want non-ISO-8859-1 characters.\r\n *\r\n * GZip RFC requires ISO 8859-1 (LATIN-1).\r\n *\r\n * @throws IOException When the test fails.\r\n */\r\n@Test\r\nvoid testFileNameChinesePercentEncoded() throws IOException {\r\n    // \"Test Chinese name\"\r\n    testFileName(\"??????.xml\", EXPECTED_FILE_NAME);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipCompressorOutputStreamTest.java",
  "methodName" : "testHeaderCrc",
  "sourceCode" : "/**\r\n * Tests the gzip header CRC.\r\n *\r\n * @throws IOException When the test has issues with the underlying file system or unexpected gzip operations.\r\n */\r\n@Test\r\nvoid testHeaderCrc() throws IOException, DecoderException {\r\n    final GzipParameters parameters = new GzipParameters();\r\n    parameters.setHeaderCRC(true);\r\n    // avoid changing time\r\n    parameters.setModificationTime(0x66554433);\r\n    parameters.setFileName(\"AAAA\");\r\n    parameters.setComment(\"ZZZZ\");\r\n    parameters.setOS(OS.UNIX);\r\n    final ExtraField extra = new ExtraField();\r\n    extra.addSubField(\"BB\", \"CCCC\".getBytes(StandardCharsets.ISO_8859_1));\r\n    parameters.setExtraField(extra);\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (GzipCompressorOutputStream gos = new GzipCompressorOutputStream(baos, parameters)) {\r\n        // nothing to write for this test.\r\n    }\r\n    final byte[] result = baos.toByteArray();\r\n    // @formatter:off\r\n    final byte[] expected = Hex.decodeHex(// id1 id2\r\n    \"1f8b\" + // cm\r\n    \"08\" + // flg(FEXTRA|FNAME|FCOMMENT|FHCRC)\r\n    \"1e\" + // mtime little-endian\r\n    \"33445566\" + \"00\" + // xfl os\r\n    \"03\" + // xlen\r\n    \"0800\" + // sfid\r\n    \"4242\" + // sflen\r\n    \"0400\" + // \"CCCC\"\r\n    \"43434343\" + // \"AAAA\" with \\0\r\n    \"4141414100\" + // \"ZZZZ\" with \\0\r\n    \"5a5a5a5a00\" + // crc32 = 839242d8\r\n    \"d842\" + // empty deflate stream\r\n    \"0300\" + // crs32\r\n    \"00000000\" + // isize\r\n    \"00000000\");\r\n    // @formatter:on\r\n    assertArrayEquals(expected, result);\r\n    assertDoesNotThrow(() -> {\r\n        try (GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(result))) {\r\n            // if it does not fail, the hcrc is good.\r\n        }\r\n    });\r\n    try (GzipCompressorInputStream gis = GzipCompressorInputStream.builder().setByteArray(result).setIgnoreExtraField(false).get()) {\r\n        final GzipParameters metaData = gis.getMetaData();\r\n        assertTrue(metaData.getHeaderCRC());\r\n        assertEquals(0x66554433, metaData.getModificationTime());\r\n        assertEquals(1, metaData.getExtraField().size());\r\n        final SubField sf = metaData.getExtraField().iterator().next();\r\n        assertEquals(\"BB\", sf.getId());\r\n        assertEquals(\"CCCC\", new String(sf.getPayload(), StandardCharsets.ISO_8859_1));\r\n        assertEquals(\"AAAA\", metaData.getFileName());\r\n        assertEquals(\"ZZZZ\", metaData.getComment());\r\n        assertEquals(OS.UNIX, metaData.getOS());\r\n        assertEquals(parameters, metaData);\r\n    }\r\n    // verify that the constructor normally fails on bad HCRC\r\n    assertThrows(ZipException.class, () -> {\r\n        // corrupt the low byte of header CRC\r\n        result[30] = 0x77;\r\n        try (GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(result))) {\r\n            // if it does not fail, the hcrc is good.\r\n        }\r\n    }, \"Header CRC verification is no longer feasible with JDK classes. The earlier assertion would have passed despite a bad header CRC.\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipParametersTest.java",
  "methodName" : "testDeflaterStrategy",
  "sourceCode" : "@Test\r\nvoid testDeflaterStrategy() {\r\n    final GzipParameters gzipParameters = new GzipParameters();\r\n    assertEquals(Deflater.DEFAULT_STRATEGY, gzipParameters.getDeflateStrategy());\r\n    gzipParameters.setDeflateStrategy(Deflater.HUFFMAN_ONLY);\r\n    assertEquals(Deflater.HUFFMAN_ONLY, gzipParameters.getDeflateStrategy());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipParametersTest.java",
  "methodName" : "testEquals",
  "sourceCode" : "@Test\r\nvoid testEquals() throws IOException {\r\n    final GzipParameters gzipParameters1 = new GzipParameters();\r\n    final GzipParameters gzipParameters2 = new GzipParameters();\r\n    assertEquals(gzipParameters1, gzipParameters2);\r\n    gzipParameters1.setExtraField(new ExtraField().addSubField(\"AA\", \"XXXX\".getBytes(StandardCharsets.ISO_8859_1)));\r\n    gzipParameters2.setExtraField(new ExtraField().addSubField(\"AA\", \"XXXX\".getBytes(StandardCharsets.ISO_8859_1)));\r\n    assertEquals(gzipParameters1, gzipParameters1);\r\n    assertEquals(gzipParameters1, gzipParameters2);\r\n    assertEquals(gzipParameters2, gzipParameters1);\r\n    // not equals\r\n    gzipParameters2.setExtraField(new ExtraField().addSubField(\"BB\", \"XXXX\".getBytes(StandardCharsets.ISO_8859_1)));\r\n    assertNotEquals(gzipParameters1, gzipParameters2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipParametersTest.java",
  "methodName" : "testHashCode",
  "sourceCode" : "@Test\r\nvoid testHashCode() throws IOException {\r\n    final GzipParameters gzipParameters1 = new GzipParameters();\r\n    final GzipParameters gzipParameters2 = new GzipParameters();\r\n    assertEquals(gzipParameters1.hashCode(), gzipParameters2.hashCode());\r\n    gzipParameters1.setExtraField(new ExtraField().addSubField(\"AA\", \"XXXX\".getBytes(StandardCharsets.ISO_8859_1)));\r\n    gzipParameters2.setExtraField(new ExtraField().addSubField(\"AA\", \"XXXX\".getBytes(StandardCharsets.ISO_8859_1)));\r\n    assertEquals(gzipParameters1.hashCode(), gzipParameters1.hashCode());\r\n    assertEquals(gzipParameters1.hashCode(), gzipParameters2.hashCode());\r\n    assertEquals(gzipParameters2.hashCode(), gzipParameters1.hashCode());\r\n    // not equals\r\n    gzipParameters2.setExtraField(new ExtraField().addSubField(\"BB\", \"XXXX\".getBytes(StandardCharsets.ISO_8859_1)));\r\n    assertNotEquals(gzipParameters1.hashCode(), gzipParameters2.hashCode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipParametersTest.java",
  "methodName" : "testIllegalCommentOrFileName",
  "sourceCode" : "@ParameterizedTest\r\n// @formatter:off\r\n@CsvSource({ \"          , hello\\0world, false\", \"ISO-8859-1, hello\\0world, false\", \"UTF-8     , hello\\0world, false\", \"UTF-16BE  , helloworld, false\" })\r\n// @formatter:on\r\nvoid testIllegalCommentOrFileName(final Charset charset, final String text) {\r\n    final GzipParameters gzipParameters = new GzipParameters();\r\n    // null resets to default value\r\n    gzipParameters.setFileNameCharset(charset);\r\n    assertThrows(IllegalArgumentException.class, () -> gzipParameters.setComment(text));\r\n    assertNull(gzipParameters.getComment());\r\n    assertThrows(IllegalArgumentException.class, () -> gzipParameters.setFilename(text));\r\n    assertNull(gzipParameters.getFileName());\r\n    assertThrows(IllegalArgumentException.class, () -> gzipParameters.setFileName(text));\r\n    assertNull(gzipParameters.getFileName());\r\n    assertEquals(gzipParameters, gzipParameters);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipParametersTest.java",
  "methodName" : "testLegalCommentOrFileName",
  "sourceCode" : "@ParameterizedTest\r\n// @formatter:off\r\n@CsvSource({ \"          , helloworld\", \"          , helloworld\", \"ISO-8859-1, helloworld\", \"ISO-8859-1, helloworld\", \"UTF-8     , helloworld\", \"UTF-8     , helloworld\" })\r\n// @formatter:on\r\nvoid testLegalCommentOrFileName(final Charset charset, final String text) {\r\n    final GzipParameters gzipParameters = new GzipParameters();\r\n    // null resets to default value\r\n    gzipParameters.setFileNameCharset(charset);\r\n    gzipParameters.setComment(text);\r\n    assertEquals(text, gzipParameters.getComment());\r\n    gzipParameters.setFilename(text);\r\n    assertEquals(text, gzipParameters.getFileName());\r\n    gzipParameters.setFileName(text);\r\n    assertEquals(text, gzipParameters.getFileName());\r\n    assertEquals(gzipParameters, gzipParameters);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipParametersTest.java",
  "methodName" : "testOperatingSystem",
  "sourceCode" : "@Test\r\nvoid testOperatingSystem() {\r\n    final GzipParameters gzipParameters = new GzipParameters();\r\n    assertThrows(CompressException.class, () -> gzipParameters.setOperatingSystem(99));\r\n    assertEquals(OS.UNKNOWN, gzipParameters.getOS());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\GzipParametersTest.java",
  "methodName" : "testToString",
  "sourceCode" : "@Test\r\nvoid testToString() {\r\n    final GzipParameters gzipParameters = new GzipParameters();\r\n    assertTrue(gzipParameters.toString().contains(\"UNKNOWN\"));\r\n    gzipParameters.setOS(GzipParameters.OS.Z_SYSTEM);\r\n    assertTrue(gzipParameters.toString().contains(\"Z_SYSTEM\"));\r\n    assertEquals(gzipParameters, gzipParameters);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\SubFieldTest.java",
  "methodName" : "testEquals",
  "sourceCode" : "@Test\r\nvoid testEquals() {\r\n    assertEquals(new SubField((byte) 0, (byte) 0, new byte[0]), new SubField((byte) 0, (byte) 0, new byte[0]));\r\n    assertEquals(new SubField((byte) 9, (byte) 9, new byte[9]), new SubField((byte) 9, (byte) 9, new byte[9]));\r\n    // not equals\r\n    assertNotEquals(new SubField((byte) 0, (byte) 9, new byte[9]), new SubField((byte) 9, (byte) 9, new byte[9]));\r\n    assertNotEquals(new SubField((byte) 9, (byte) 0, new byte[9]), new SubField((byte) 9, (byte) 9, new byte[9]));\r\n    assertNotEquals(new SubField((byte) 9, (byte) 9, new byte[0]), new SubField((byte) 9, (byte) 9, new byte[9]));\r\n    assertNotEquals(new SubField((byte) 9, (byte) 9, new byte[9]), new SubField((byte) 9, (byte) 9, new byte[] { 9 }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\gzip\\SubFieldTest.java",
  "methodName" : "testHashCode",
  "sourceCode" : "@Test\r\nvoid testHashCode() {\r\n    assertEquals(new SubField((byte) 0, (byte) 0, new byte[0]).hashCode(), new SubField((byte) 0, (byte) 0, new byte[0]).hashCode());\r\n    assertEquals(new SubField((byte) 9, (byte) 9, new byte[9]).hashCode(), new SubField((byte) 9, (byte) 9, new byte[9]).hashCode());\r\n    // not equals\r\n    assertNotEquals(new SubField((byte) 0, (byte) 9, new byte[9]).hashCode(), new SubField((byte) 9, (byte) 9, new byte[9]).hashCode());\r\n    assertNotEquals(new SubField((byte) 9, (byte) 0, new byte[9]).hashCode(), new SubField((byte) 9, (byte) 9, new byte[9]).hashCode());\r\n    assertNotEquals(new SubField((byte) 9, (byte) 9, new byte[0]).hashCode(), new SubField((byte) 9, (byte) 9, new byte[9]).hashCode());\r\n    assertNotEquals(new SubField((byte) 9, (byte) 9, new byte[9]).hashCode(), new SubField((byte) 9, (byte) 9, new byte[] { 9 }).hashCode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testConcatenatedStreamsReadFirstOnly",
  "sourceCode" : "@Test\r\nvoid testConcatenatedStreamsReadFirstOnly() throws Exception {\r\n    final File input = getFile(\"multiple.gz\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"gz\", is)) {\r\n            assertEquals('a', in.read());\r\n            assertEquals(-1, in.read());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testConcatenatedStreamsReadFully",
  "sourceCode" : "@Test\r\nvoid testConcatenatedStreamsReadFully() throws Exception {\r\n    final File input = getFile(\"multiple.gz\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new GzipCompressorInputStream(is, true)) {\r\n            assertEquals('a', in.read());\r\n            assertEquals('b', in.read());\r\n            assertEquals(0, in.available());\r\n            assertEquals(-1, in.read());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testCorruptedInput",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-84\"\r\n */\r\n@Test\r\nvoid testCorruptedInput() throws Exception {\r\n    final byte[] data = readAllBytes(\"bla.tgz\");\r\n    try (InputStream in = new ByteArrayInputStream(data, 0, data.length - 1);\r\n        CompressorInputStream cin = new CompressorStreamFactory().createCompressorInputStream(\"gz\", in);\r\n        OutputStream out = new ByteArrayOutputStream()) {\r\n        assertThrows(IOException.class, () -> IOUtils.copy(cin, out), \"Expected an exception\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testExtraFlagsBestCompression",
  "sourceCode" : "@Test\r\nvoid testExtraFlagsBestCompression() throws Exception {\r\n    testExtraFlags(Deflater.BEST_COMPRESSION, 2, 1024);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testExtraFlagsDefaultCompression",
  "sourceCode" : "@Test\r\nvoid testExtraFlagsDefaultCompression() throws Exception {\r\n    testExtraFlags(Deflater.DEFAULT_COMPRESSION, 0, 4096);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testExtraFlagsFastestCompression",
  "sourceCode" : "@Test\r\nvoid testExtraFlagsFastestCompression() throws Exception {\r\n    testExtraFlags(Deflater.BEST_SPEED, 4, 128);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testGzipCreation",
  "sourceCode" : "@Test\r\nvoid testGzipCreation() throws Exception {\r\n    final File input = getFile(\"test1.xml\");\r\n    final File output = newTempFile(\"test1.xml.gz\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath())) {\r\n        try (CompressorOutputStream<?> cos = new CompressorStreamFactory().createCompressorOutputStream(\"gz\", out)) {\r\n            cos.write(input);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testGzipUnarchive",
  "sourceCode" : "@Test\r\nvoid testGzipUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.tgz\");\r\n    final File output = newTempFile(\"bla.tar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"gz\", is)) {\r\n            Files.copy(in, output.toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testInteroperabilityWithGzipCompressorInputStream",
  "sourceCode" : "@Test\r\nvoid testInteroperabilityWithGzipCompressorInputStream() throws Exception {\r\n    final byte[] content = readAllBytes(\"test3.xml\");\r\n    final ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n    final GzipParameters parameters = new GzipParameters();\r\n    parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\r\n    parameters.setOperatingSystem(3);\r\n    parameters.setFilename(\"test3.xml\");\r\n    assertEquals(parameters.getFilename(), parameters.getFileName());\r\n    parameters.setFileName(\"test3.xml\");\r\n    assertEquals(parameters.getFilename(), parameters.getFileName());\r\n    parameters.setComment(\"Test file\");\r\n    parameters.setModificationTime(System.currentTimeMillis());\r\n    try (GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters)) {\r\n        out.write(content);\r\n        out.flush();\r\n    }\r\n    try (GzipCompressorInputStream in = new GzipCompressorInputStream(new ByteArrayInputStream(bout.toByteArray()))) {\r\n        final byte[] content2 = IOUtils.toByteArray(in);\r\n        assertArrayEquals(content, content2, \"uncompressed content\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testInteroperabilityWithGZIPInputStream",
  "sourceCode" : "@Test\r\nvoid testInteroperabilityWithGZIPInputStream() throws Exception {\r\n    final byte[] content = readAllBytes(\"test3.xml\");\r\n    final ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n    final GzipParameters parameters = new GzipParameters();\r\n    parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\r\n    parameters.setOperatingSystem(3);\r\n    parameters.setFilename(\"test3.xml\");\r\n    assertEquals(parameters.getFilename(), parameters.getFileName());\r\n    parameters.setFileName(\"test3.xml\");\r\n    assertEquals(parameters.getFilename(), parameters.getFileName());\r\n    parameters.setComment(\"Test file\");\r\n    parameters.setModificationTime(System.currentTimeMillis());\r\n    try (GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters)) {\r\n        out.write(content);\r\n        out.flush();\r\n    }\r\n    final GZIPInputStream in = new GZIPInputStream(new ByteArrayInputStream(bout.toByteArray()));\r\n    final byte[] content2 = IOUtils.toByteArray(in);\r\n    assertArrayEquals(content, content2, \"uncompressed content\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testInvalidBufferSize",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 0, -1 })\r\nvoid testInvalidBufferSize(final int bufferSize) {\r\n    final GzipParameters parameters = new GzipParameters();\r\n    assertThrows(IllegalArgumentException.class, () -> parameters.setBufferSize(bufferSize), \"IllegalArgumentException not thrown\");\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testInvalidCompressionLevel",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 10, -5 })\r\nvoid testInvalidCompressionLevel(final int compressionLevel) {\r\n    final GzipParameters parameters = new GzipParameters();\r\n    assertThrows(IllegalArgumentException.class, () -> parameters.setCompressionLevel(compressionLevel), \"IllegalArgumentException not thrown\");\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testMetadataRoundTrip",
  "sourceCode" : "@Test\r\nvoid testMetadataRoundTrip() throws Exception {\r\n    final ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n    final GzipParameters parameters = new GzipParameters();\r\n    parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\r\n    assertEquals(0, parameters.getModificationTime());\r\n    parameters.setModificationInstant(null);\r\n    assertEquals(0, parameters.getModificationTime());\r\n    parameters.setModificationInstant(MTIME_INSTANT);\r\n    assertEquals(MTIME_INSTANT.getEpochSecond(), parameters.getModificationTime());\r\n    assertEquals(MTIME_INSTANT, parameters.getModificationInstant());\r\n    parameters.setOS(GzipParameters.OS.Z_SYSTEM);\r\n    assertEquals(GzipParameters.OS.Z_SYSTEM, parameters.getOS());\r\n    parameters.setOS(null);\r\n    assertEquals(GzipParameters.OS.UNKNOWN, parameters.getOS());\r\n    parameters.setOperatingSystem(13);\r\n    assertEquals(GzipParameters.OS.ACORN_RISCOS, parameters.getOS());\r\n    parameters.setFilename(\"test3.xml\");\r\n    assertEquals(parameters.getFilename(), parameters.getFileName());\r\n    parameters.setFileName(\"test3.xml\");\r\n    assertEquals(parameters.getFilename(), parameters.getFileName());\r\n    parameters.setComment(\"Umlaute mglich?\");\r\n    try (GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters)) {\r\n        out.write(getFile(\"test3.xml\"));\r\n    }\r\n    final GzipCompressorInputStream input = new GzipCompressorInputStream(new ByteArrayInputStream(bout.toByteArray()));\r\n    input.close();\r\n    final GzipParameters readParams = input.getMetaData();\r\n    assertEquals(Deflater.BEST_COMPRESSION, readParams.getCompressionLevel());\r\n    assertEquals(123456000, readParams.getModificationTime());\r\n    assertEquals(13, readParams.getOperatingSystem());\r\n    assertEquals(GzipParameters.OS.ACORN_RISCOS, readParams.getOS());\r\n    assertEquals(\"test3.xml\", readParams.getFileName());\r\n    assertEquals(\"test3.xml\", readParams.getFilename());\r\n    assertEquals(\"Umlaute mglich?\", readParams.getComment());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tgz\");\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        GzipCompressorInputStream in = new GzipCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testOverWrite",
  "sourceCode" : "@Test\r\nvoid testOverWrite() throws Exception {\r\n    final GzipCompressorOutputStream out = new GzipCompressorOutputStream(new ByteArrayOutputStream());\r\n    out.close();\r\n    assertThrows(IOException.class, () -> out.write(0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GZipTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tgz\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        GzipCompressorInputStream in = new GzipCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GzipUtilsTest.java",
  "methodName" : "testGetCompressedFileName",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testGetCompressedFileName() {\r\n    assertEquals(\".gz\", GzipUtils.getCompressedFilename(\"\"));\r\n    assertEquals(\".gz\", GzipUtils.getCompressedFileName(\"\"));\r\n    assertEquals(\"x.gz\", GzipUtils.getCompressedFilename(\"x\"));\r\n    assertEquals(\"x.gz\", GzipUtils.getCompressedFileName(\"x\"));\r\n    assertEquals(\"x.tgz\", GzipUtils.getCompressedFilename(\"x.tar\"));\r\n    assertEquals(\"x.tgz\", GzipUtils.getCompressedFileName(\"x.tar\"));\r\n    assertEquals(\"x.svgz\", GzipUtils.getCompressedFilename(\"x.svg\"));\r\n    assertEquals(\"x.svgz\", GzipUtils.getCompressedFileName(\"x.svg\"));\r\n    assertEquals(\"x.cpgz\", GzipUtils.getCompressedFilename(\"x.cpio\"));\r\n    assertEquals(\"x.cpgz\", GzipUtils.getCompressedFileName(\"x.cpio\"));\r\n    assertEquals(\"x.wmz\", GzipUtils.getCompressedFilename(\"x.wmf\"));\r\n    assertEquals(\"x.wmz\", GzipUtils.getCompressedFileName(\"x.wmf\"));\r\n    assertEquals(\"x.emz\", GzipUtils.getCompressedFilename(\"x.emf\"));\r\n    assertEquals(\"x.emz\", GzipUtils.getCompressedFileName(\"x.emf\"));\r\n    assertEquals(\"x.svgz\", GzipUtils.getCompressedFilename(\"x.SVG\"));\r\n    assertEquals(\"x.svgz\", GzipUtils.getCompressedFileName(\"x.SVG\"));\r\n    assertEquals(\"X.svgz\", GzipUtils.getCompressedFilename(\"X.SVG\"));\r\n    assertEquals(\"X.svgz\", GzipUtils.getCompressedFileName(\"X.SVG\"));\r\n    assertEquals(\"X.svgz\", GzipUtils.getCompressedFilename(\"X.svG\"));\r\n    assertEquals(\"X.svgz\", GzipUtils.getCompressedFileName(\"X.svG\"));\r\n    assertEquals(\"x.wmf .gz\", GzipUtils.getCompressedFilename(\"x.wmf \"));\r\n    assertEquals(\"x.wmf .gz\", GzipUtils.getCompressedFileName(\"x.wmf \"));\r\n    assertEquals(\"x.wmf\\n.gz\", GzipUtils.getCompressedFilename(\"x.wmf\\n\"));\r\n    assertEquals(\"x.wmf\\n.gz\", GzipUtils.getCompressedFileName(\"x.wmf\\n\"));\r\n    assertEquals(\"x.wmf.y.gz\", GzipUtils.getCompressedFilename(\"x.wmf.y\"));\r\n    assertEquals(\"x.wmf.y.gz\", GzipUtils.getCompressedFileName(\"x.wmf.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GzipUtilsTest.java",
  "methodName" : "testGetUncompressedFileName",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testGetUncompressedFileName() {\r\n    assertEquals(\"\", GzipUtils.getUncompressedFilename(\"\"));\r\n    assertEquals(\"\", GzipUtils.getUncompressedFileName(\"\"));\r\n    assertEquals(\".gz\", GzipUtils.getUncompressedFilename(\".gz\"));\r\n    assertEquals(\".gz\", GzipUtils.getUncompressedFileName(\".gz\"));\r\n    assertEquals(\"tar\", GzipUtils.getUncompressedFileName(\"tar.gz\"));\r\n    assertEquals(\".tar\", GzipUtils.getUncompressedFileName(\".tar.gz\"));\r\n    assertEquals(\"x.tar\", GzipUtils.getUncompressedFileName(\"x.tar.gz\"));\r\n    assertEquals(\"x.tar\", GzipUtils.getUncompressedFilename(\"x.tgz\"));\r\n    assertEquals(\"x.tar\", GzipUtils.getUncompressedFileName(\"x.tgz\"));\r\n    assertEquals(\"x.tar\", GzipUtils.getUncompressedFilename(\"x.taz\"));\r\n    assertEquals(\"x.tar\", GzipUtils.getUncompressedFileName(\"x.taz\"));\r\n    assertEquals(\"x.svg\", GzipUtils.getUncompressedFilename(\"x.svgz\"));\r\n    assertEquals(\"x.svg\", GzipUtils.getUncompressedFileName(\"x.svgz\"));\r\n    assertEquals(\"x.cpio\", GzipUtils.getUncompressedFilename(\"x.cpgz\"));\r\n    assertEquals(\"x.cpio\", GzipUtils.getUncompressedFileName(\"x.cpgz\"));\r\n    assertEquals(\"x.wmf\", GzipUtils.getUncompressedFilename(\"x.wmz\"));\r\n    assertEquals(\"x.wmf\", GzipUtils.getUncompressedFileName(\"x.wmz\"));\r\n    assertEquals(\"x.emf\", GzipUtils.getUncompressedFilename(\"x.emz\"));\r\n    assertEquals(\"x.emf\", GzipUtils.getUncompressedFileName(\"x.emz\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFilename(\"x.gz\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFileName(\"x.gz\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFilename(\"x.z\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFileName(\"x.z\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFilename(\"x-gz\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFileName(\"x-gz\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFilename(\"x-z\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFileName(\"x-z\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFilename(\"x_z\"));\r\n    assertEquals(\"x\", GzipUtils.getUncompressedFileName(\"x_z\"));\r\n    assertEquals(\"x.svg\", GzipUtils.getUncompressedFilename(\"x.SVGZ\"));\r\n    assertEquals(\"x.svg\", GzipUtils.getUncompressedFileName(\"x.SVGZ\"));\r\n    assertEquals(\"X.svg\", GzipUtils.getUncompressedFilename(\"X.SVGZ\"));\r\n    assertEquals(\"X.svg\", GzipUtils.getUncompressedFileName(\"X.SVGZ\"));\r\n    assertEquals(\"X.svg\", GzipUtils.getUncompressedFilename(\"X.svGZ\"));\r\n    assertEquals(\"X.svg\", GzipUtils.getUncompressedFileName(\"X.svGZ\"));\r\n    assertEquals(\"x.wmz \", GzipUtils.getUncompressedFilename(\"x.wmz \"));\r\n    assertEquals(\"x.wmz \", GzipUtils.getUncompressedFileName(\"x.wmz \"));\r\n    assertEquals(\"x.wmz\\n\", GzipUtils.getUncompressedFilename(\"x.wmz\\n\"));\r\n    assertEquals(\"x.wmz\\n\", GzipUtils.getUncompressedFileName(\"x.wmz\\n\"));\r\n    assertEquals(\"x.wmz.y\", GzipUtils.getUncompressedFilename(\"x.wmz.y\"));\r\n    assertEquals(\"x.wmz.y\", GzipUtils.getUncompressedFileName(\"x.wmz.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\GzipUtilsTest.java",
  "methodName" : "testIsCompressedFileName",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testIsCompressedFileName() {\r\n    assertFalse(GzipUtils.isCompressedFilename(\"\"));\r\n    assertFalse(GzipUtils.isCompressedFileName(\"\"));\r\n    assertFalse(GzipUtils.isCompressedFilename(\".gz\"));\r\n    assertFalse(GzipUtils.isCompressedFileName(\".gz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.tgz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.tgz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.taz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.taz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.svgz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.svgz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.cpgz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.cpgz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.wmz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.wmz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.emz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.emz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.gz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.gz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.z\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.z\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x-gz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x-gz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x-z\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x-z\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x_z\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x_z\"));\r\n    assertFalse(GzipUtils.isCompressedFilename(\"xxgz\"));\r\n    assertFalse(GzipUtils.isCompressedFileName(\"xxgz\"));\r\n    assertFalse(GzipUtils.isCompressedFilename(\"xzz\"));\r\n    assertFalse(GzipUtils.isCompressedFileName(\"xzz\"));\r\n    assertFalse(GzipUtils.isCompressedFilename(\"xaz\"));\r\n    assertFalse(GzipUtils.isCompressedFileName(\"xaz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.SVGZ\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.SVGZ\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.Svgz\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.Svgz\"));\r\n    assertTrue(GzipUtils.isCompressedFilename(\"x.svGZ\"));\r\n    assertTrue(GzipUtils.isCompressedFileName(\"x.svGZ\"));\r\n    assertFalse(GzipUtils.isCompressedFilename(\"x.wmz \"));\r\n    assertFalse(GzipUtils.isCompressedFileName(\"x.wmz \"));\r\n    assertFalse(GzipUtils.isCompressedFilename(\"x.wmz\\n\"));\r\n    assertFalse(GzipUtils.isCompressedFileName(\"x.wmz\\n\"));\r\n    assertFalse(GzipUtils.isCompressedFilename(\"x.wmz.y\"));\r\n    assertFalse(GzipUtils.isCompressedFileName(\"x.wmz.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tar.block_lz4\");\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        BlockLZ4CompressorInputStream in = new BlockLZ4CompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadBlaLz4",
  "sourceCode" : "@Test\r\nvoid testReadBlaLz4() throws IOException {\r\n    try (InputStream a = new BlockLZ4CompressorInputStream(newInputStream(\"bla.tar.block_lz4\"));\r\n        InputStream e = newInputStream(\"bla.tar\")) {\r\n        final byte[] expected = IOUtils.toByteArray(e);\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tar.block_lz4\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        BlockLZ4CompressorInputStream in = new BlockLZ4CompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "canWriteBackReferenceFollowedByShortLiteralIfLengthIsBigEnough",
  "sourceCode" : "@Test\r\n@Disabled(\"would pass if the algorithm used for rewriting the final pairs was smarter\")\r\npublic void canWriteBackReferenceFollowedByShortLiteralIfLengthIsBigEnough() {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 10));\r\n    assertTrue(p.canBeWritten(5));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "canWriteBackReferenceFollowedByShortLiteralIfOffsetIsBigEnough",
  "sourceCode" : "@Test\r\n@Disabled(\"would pass if the algorithm used for rewriting the final pairs was smarter\")\r\npublic void canWriteBackReferenceFollowedByShortLiteralIfOffsetIsBigEnough() {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(10, 4));\r\n    assertTrue(p.canBeWritten(5));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testCantWriteBackReferenceFollowedByLiteralThatIsTooShort",
  "sourceCode" : "@Test\r\nvoid testCantWriteBackReferenceFollowedByLiteralThatIsTooShort() {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(10, 14));\r\n    assertFalse(p.canBeWritten(4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testCantWriteBackReferenceIfAccumulatedOffsetIsTooShort",
  "sourceCode" : "@Test\r\nvoid testCantWriteBackReferenceIfAccumulatedOffsetIsTooShort() {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 4));\r\n    assertFalse(p.canBeWritten(5));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testCanWriteBackReferenceFollowedByLongLiteral",
  "sourceCode" : "@Test\r\nvoid testCanWriteBackReferenceFollowedByLongLiteral() {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 4));\r\n    // a length of 11 would be enough according to the spec, but\r\n    // the algorithm we use for rewriting the last block requires\r\n    // 16 bytes\r\n    assertTrue(p.canBeWritten(16));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testCanWritePairWithoutBackReference",
  "sourceCode" : "@Test\r\nvoid testCanWritePairWithoutBackReference() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    final byte[] b = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    p.addLiteral(new LZ77Compressor.LiteralBlock(b, 1, 4));\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { 4 << 4, 2, 3, 4, 5 }, bos.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testCanWritePairWithoutLiterals",
  "sourceCode" : "@Test\r\nvoid testCanWritePairWithoutLiterals() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 4));\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { 0, 1, 0 }, bos.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testPairAccumulatesLengths",
  "sourceCode" : "@Test\r\nvoid testPairAccumulatesLengths() {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 4));\r\n    final byte[] b = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    p.addLiteral(new LZ77Compressor.LiteralBlock(b, 1, 4));\r\n    p.addLiteral(new LZ77Compressor.LiteralBlock(b, 2, 5));\r\n    assertEquals(13, p.length());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testPairSeesBackReferenceWhenSet",
  "sourceCode" : "@Test\r\nvoid testPairSeesBackReferenceWhenSet() {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    assertFalse(p.hasBackReference());\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 4));\r\n    assertTrue(p.hasBackReference());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testRewritingOfFinalBlockWithoutTrailingLZ77Literals",
  "sourceCode" : "@Test\r\nvoid testRewritingOfFinalBlockWithoutTrailingLZ77Literals() throws IOException {\r\n    for (int i = 1; i < 13; i++) {\r\n        // according to the spec these are all too short be compressed\r\n        // LZ77Compressor will create a single byte literal\r\n        // followed by a back-reference starting with i = 5,\r\n        // though. (4 is the minimum length for a back-reference\r\n        // in LZ4\r\n        final byte[] compressed = compress(i);\r\n        final byte[] expected = prepareExpected(i + 1);\r\n        expected[0] = (byte) (i << 4);\r\n        assertArrayEquals(expected, compressed, \"input length is \" + i);\r\n    }\r\n    for (int i = 13; i < 17; i++) {\r\n        // LZ77Compressor will still create a single byte literal\r\n        // followed by a back-reference\r\n        // according to the spec the back-reference could be split\r\n        // as we can cut out a five byte literal and the offset\r\n        // would be big enough, but our algorithm insists on a\r\n        // twelve byte literal trailer and the back-reference\r\n        // would fall below the minimal size\r\n        final byte[] compressed = compress(i);\r\n        final byte[] expected = prepareExpected(i < 15 ? i + 1 : i + 2);\r\n        if (i < 15) {\r\n            expected[0] = (byte) (i << 4);\r\n        } else {\r\n            expected[0] = (byte) (15 << 4);\r\n            expected[1] = (byte) (i - 15);\r\n        }\r\n        assertArrayEquals(expected, compressed, \"input length is \" + i);\r\n    }\r\n    for (int i = 17; i < 20; i++) {\r\n        // LZ77Compressor will still create a single byte literal\r\n        // followed by a back-reference\r\n        // this time even our algorithm is willing to break up the\r\n        // back-reference\r\n        final byte[] compressed = compress(i);\r\n        final byte[] expected = prepareExpected(17);\r\n        expected[0] = (byte) (1 << 4 | i - 17);\r\n        // two-byte offset\r\n        expected[2] = 1;\r\n        expected[3] = 0;\r\n        expected[4] = (byte) (12 << 4);\r\n        assertArrayEquals(expected, compressed, \"input length is \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testRewritingOfFinalBlockWithTrailingLZ77Literals",
  "sourceCode" : "@Test\r\nvoid testRewritingOfFinalBlockWithTrailingLZ77Literals() throws IOException {\r\n    for (int i = 1; i < 5; i++) {\r\n        // LZ77Compressor will create a single byte literal\r\n        // followed by a back-reference of length 15 followed by a\r\n        // literal of length i\r\n        // we can split the back-reference and merge it with the literal\r\n        final byte[] compressed = compress(16, i);\r\n        final byte[] expected = prepareExpected(17);\r\n        expected[0] = (byte) (1 << 4 | i - 1);\r\n        // two-byte offset\r\n        expected[2] = 1;\r\n        expected[3] = 0;\r\n        expected[4] = (byte) (12 << 4);\r\n        for (int j = 0; j < i; j++) {\r\n            expected[expected.length - 1 - j] = 1;\r\n        }\r\n        assertArrayEquals(expected, compressed, \"trailer length is \" + i);\r\n    }\r\n    for (int i = 5; i < 12; i++) {\r\n        // LZ77Compressor will create a single byte literal\r\n        // followed by a back-reference of length 15 followed by\r\n        // another single byte literal and another back-reference\r\n        // of length i-1\r\n        // according to the spec we could completely satisfy the\r\n        // requirements by just rewriting the last Pair, but our\r\n        // algorithm will chip off a few bytes from the first Pair\r\n        final byte[] compressed = compress(16, i);\r\n        final byte[] expected = prepareExpected(17);\r\n        expected[0] = (byte) (1 << 4 | i - 1);\r\n        // two-byte offset\r\n        expected[2] = 1;\r\n        expected[3] = 0;\r\n        expected[4] = (byte) (12 << 4);\r\n        for (int j = 0; j < i; j++) {\r\n            expected[expected.length - 1 - j] = 1;\r\n        }\r\n        assertArrayEquals(expected, compressed, \"trailer length is \" + i);\r\n    }\r\n    for (int i = 12; i < 15; i++) {\r\n        // LZ77Compressor will create a single byte literal\r\n        // followed by a back-reference of length 15 followed by\r\n        // another single byte literal and another back-reference\r\n        // of length i-1\r\n        // this shouldn't affect the first pair at all as\r\n        // rewriting the second one is sufficient\r\n        final byte[] compressed = compress(16, i);\r\n        final byte[] expected = prepareExpected(i + 5);\r\n        expected[0] = (byte) (1 << 4 | 11);\r\n        // two-byte offset\r\n        expected[2] = 1;\r\n        expected[3] = 0;\r\n        expected[4] = (byte) (i << 4);\r\n        for (int j = 0; j < i; j++) {\r\n            expected[expected.length - 1 - j] = 1;\r\n        }\r\n        assertArrayEquals(expected, compressed, \"trailer length is \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testRewritingOfFourPairs",
  "sourceCode" : "@Test\r\nvoid testRewritingOfFourPairs() throws IOException {\r\n    // LZ77Compressor creates three times a literal block followed\r\n    // by a back-reference (once 5 bytes long and twice four bytes\r\n    // long and a final literal block of length 1\r\n    // in the result the three last pairs are merged into a single\r\n    // literal and one byte is chopped off of the first pair's\r\n    // back-reference\r\n    final byte[] compressed = compress(6, 5, 5, 1);\r\n    final byte[] expected = prepareExpected(17);\r\n    expected[0] = (byte) (1 << 4);\r\n    // two-byte offset\r\n    expected[2] = 1;\r\n    expected[3] = 0;\r\n    expected[4] = (byte) (12 << 4);\r\n    for (int i = 6; i < 11; i++) {\r\n        expected[i] = 1;\r\n    }\r\n    for (int i = 11; i < 16; i++) {\r\n        expected[i] = 2;\r\n    }\r\n    expected[16] = 3;\r\n    assertArrayEquals(expected, compressed);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testRewritingWithFinalBackreferenceAndOffsetBiggerThan1",
  "sourceCode" : "@Test\r\nvoid testRewritingWithFinalBackreferenceAndOffsetBiggerThan1() throws IOException {\r\n    // this caused trouble when expandFromList() fell into the \"offsetRemaining is negative\" self-copy case as the\r\n    // calculation of copyOffset was wrong\r\n    final byte[] toCompress = prepareExpected(25);\r\n    for (int i = 0; i < toCompress.length; i += 4) {\r\n        toCompress[i] = 1;\r\n    }\r\n    // LZ77Compressor creates a four byte literal and a back-reference with offset 4 and length 21\r\n    // we'll need to split the back-reference and chop off the last 12 bytes\r\n    final byte[] compressed = compress(toCompress);\r\n    final byte[] expected = prepareExpected(1 + 4 + 2 + 1 + 12);\r\n    expected[0] = (byte) (4 << 4 | 5);\r\n    expected[1] = 1;\r\n    expected[5] = 4;\r\n    expected[6] = 0;\r\n    expected[7] = (byte) (12 << 4);\r\n    for (int i = 11; i < expected.length; i += 4) {\r\n        expected[i] = 1;\r\n    }\r\n    assertArrayEquals(expected, compressed);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testWritesCompletePair",
  "sourceCode" : "@Test\r\nvoid testWritesCompletePair() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    final byte[] b = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    p.addLiteral(new LZ77Compressor.LiteralBlock(b, 1, 4));\r\n    b[2] = 19;\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 5));\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { (4 << 4) + 1, 2, 3, 4, 5, 1, 0 }, bos.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testWritesCorrectSizeFor15ByteLengthLiteral",
  "sourceCode" : "@Test\r\nvoid testWritesCorrectSizeFor15ByteLengthLiteral() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    final byte[] b = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 9));\r\n    p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 6));\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { (byte) (15 << 4), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6 }, bos.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testWritesCorrectSizeFor19ByteLengthBackReference",
  "sourceCode" : "@Test\r\nvoid testWritesCorrectSizeFor19ByteLengthBackReference() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 19));\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { 15, 1, 0, 0 }, bos.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testWritesCorrectSizeFor269ByteLengthLiteral",
  "sourceCode" : "@Test\r\nvoid testWritesCorrectSizeFor269ByteLengthLiteral() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    final byte[] b = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n    for (int i = 0; i < 26; i++) {\r\n        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 10));\r\n    }\r\n    p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 9));\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { (byte) (15 << 4), (byte) 254, 1 }, Arrays.copyOfRange(bos.toByteArray(), 0, 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testWritesCorrectSizeFor270ByteLengthLiteral",
  "sourceCode" : "@Test\r\nvoid testWritesCorrectSizeFor270ByteLengthLiteral() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    final byte[] b = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n    for (int i = 0; i < 27; i++) {\r\n        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 10));\r\n    }\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { (byte) (15 << 4), (byte) 255, 0, 1 }, Arrays.copyOfRange(bos.toByteArray(), 0, 4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testWritesCorrectSizeFor273ByteLengthBackReference",
  "sourceCode" : "@Test\r\nvoid testWritesCorrectSizeFor273ByteLengthBackReference() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 273));\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { 15, 1, 0, (byte) 254 }, bos.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorOutputStreamTest.java",
  "methodName" : "testWritesCorrectSizeFor274ByteLengthBackReference",
  "sourceCode" : "@Test\r\nvoid testWritesCorrectSizeFor274ByteLengthBackReference() throws IOException {\r\n    final BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\r\n    p.setBackReference(new LZ77Compressor.BackReference(1, 274));\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    p.writeTo(bos);\r\n    assertArrayEquals(new byte[] { 15, 1, 0, (byte) 255, 0 }, bos.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorRoundtripTest.java",
  "methodName" : "biggerFileRoundtrip",
  "sourceCode" : "// yields no compression at all\r\n@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void biggerFileRoundtrip(final String config, final Parameters params) throws IOException {\r\n    roundTripTest(\"COMPRESS-256.7z\", config, params);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorRoundtripTest.java",
  "methodName" : "blaTarRoundtrip",
  "sourceCode" : "// should yield decent compression\r\n@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void blaTarRoundtrip(final String config, final Parameters params) throws IOException {\r\n    roundTripTest(\"bla.tar\", config, params);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\BlockLZ4CompressorRoundtripTest.java",
  "methodName" : "gzippedLoremIpsumRoundtrip",
  "sourceCode" : "// yields no compression at all\r\n@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void gzippedLoremIpsumRoundtrip(final String config, final Parameters params) throws IOException {\r\n    roundTripTest(\"lorem-ipsum.txt.gz\", config, params);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FactoryTest.java",
  "methodName" : "testBlockRoundtripViaFactory",
  "sourceCode" : "@Test\r\nvoid testBlockRoundtripViaFactory() throws Exception {\r\n    roundtripViaFactory(CompressorStreamFactory.getLZ4Block());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FactoryTest.java",
  "methodName" : "testFrameRoundtripViaFactory",
  "sourceCode" : "@Test\r\nvoid testFrameRoundtripViaFactory() throws Exception {\r\n    roundtripViaFactory(CompressorStreamFactory.getLZ4Framed());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testBackreferenceAtStartCausesIOException",
  "sourceCode" : "@Test\r\nvoid testBackreferenceAtStartCausesIOException() {\r\n    expectIOException(\"COMPRESS-490/ArrayIndexOutOfBoundsException1.lz4\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testBackreferenceOfSize0CausesIOException",
  "sourceCode" : "@Test\r\nvoid testBackreferenceOfSize0CausesIOException() {\r\n    expectIOException(\"COMPRESS-490/ArithmeticException.lz4\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testBackreferenceWithOffsetTooBigCausesIOException",
  "sourceCode" : "@Test\r\nvoid testBackreferenceWithOffsetTooBigCausesIOException() {\r\n    expectIOException(\"COMPRESS-490/ArrayIndexOutOfBoundsException2.lz4\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testMatches",
  "sourceCode" : "@Test\r\nvoid testMatches() throws IOException {\r\n    assertFalse(FramedLZ4CompressorInputStream.matches(new byte[10], 4));\r\n    final byte[] expected = readAllBytes(\"bla.tar.lz4\");\r\n    assertFalse(FramedLZ4CompressorInputStream.matches(expected, 3));\r\n    assertTrue(FramedLZ4CompressorInputStream.matches(expected, 4));\r\n    assertTrue(FramedLZ4CompressorInputStream.matches(expected, 5));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tar.lz4\");\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        FramedLZ4CompressorInputStream in = new FramedLZ4CompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadBlaDumpLz4",
  "sourceCode" : "@Test\r\nvoid testReadBlaDumpLz4() throws IOException {\r\n    try (InputStream a = new FramedLZ4CompressorInputStream(newInputStream(\"bla.dump.lz4\"));\r\n        InputStream e = newInputStream(\"bla.dump\")) {\r\n        final byte[] expected = IOUtils.toByteArray(e);\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadBlaLz4",
  "sourceCode" : "@Test\r\nvoid testReadBlaLz4() throws IOException {\r\n    try (InputStream a = new FramedLZ4CompressorInputStream(newInputStream(\"bla.tar.lz4\"));\r\n        InputStream e = newInputStream(\"bla.tar\")) {\r\n        final byte[] expected = IOUtils.toByteArray(e);\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadBlaLz4ViaFactory",
  "sourceCode" : "@Test\r\nvoid testReadBlaLz4ViaFactory() throws Exception {\r\n    try (InputStream a = new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(), newInputStream(\"bla.tar.lz4\"));\r\n        InputStream e = newInputStream(\"bla.tar\")) {\r\n        final byte[] expected = IOUtils.toByteArray(e);\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadBlaLz4ViaFactoryAutoDetection",
  "sourceCode" : "@Test\r\nvoid testReadBlaLz4ViaFactoryAutoDetection() throws Exception {\r\n    try (InputStream a = new CompressorStreamFactory().createCompressorInputStream(new BufferedInputStream(newInputStream(\"bla.tar.lz4\")));\r\n        InputStream e = newInputStream(\"bla.tar\")) {\r\n        final byte[] expected = IOUtils.toByteArray(e);\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadBlaLz4ViaFactoryWithDecompressConcatenated",
  "sourceCode" : "@Test\r\nvoid testReadBlaLz4ViaFactoryWithDecompressConcatenated() throws Exception {\r\n    try (InputStream a = new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(), newInputStream(\"bla.tar.lz4\"), true);\r\n        InputStream e = newInputStream(\"bla.tar\")) {\r\n        final byte[] expected = IOUtils.toByteArray(e);\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadBlaLz4WithDecompressConcatenated",
  "sourceCode" : "@Test\r\nvoid testReadBlaLz4WithDecompressConcatenated() throws IOException {\r\n    try (InputStream a = new FramedLZ4CompressorInputStream(newInputStream(\"bla.tar.lz4\"), true);\r\n        InputStream e = newInputStream(\"bla.tar\")) {\r\n        final byte[] expected = IOUtils.toByteArray(e);\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadDoubledBlaLz4ViaFactoryWithDecompressConcatenatedFalse",
  "sourceCode" : "@Test\r\nvoid testReadDoubledBlaLz4ViaFactoryWithDecompressConcatenatedFalse() throws Exception {\r\n    readDoubledBlaLz4(in -> new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(), in, false), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadDoubledBlaLz4ViaFactoryWithDecompressConcatenatedTrue",
  "sourceCode" : "@Test\r\nvoid testReadDoubledBlaLz4ViaFactoryWithDecompressConcatenatedTrue() throws Exception {\r\n    readDoubledBlaLz4(in -> new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(), in, true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadDoubledBlaLz4ViaFactoryWithoutExplicitDecompressConcatenated",
  "sourceCode" : "@Test\r\nvoid testReadDoubledBlaLz4ViaFactoryWithoutExplicitDecompressConcatenated() throws Exception {\r\n    readDoubledBlaLz4(in -> new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(), in), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadDoubledBlaLz4WithDecompressConcatenatedFalse",
  "sourceCode" : "@Test\r\nvoid testReadDoubledBlaLz4WithDecompressConcatenatedFalse() throws Exception {\r\n    readDoubledBlaLz4(in -> new FramedLZ4CompressorInputStream(in, false), false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadDoubledBlaLz4WithDecompressConcatenatedTrue",
  "sourceCode" : "@Test\r\nvoid testReadDoubledBlaLz4WithDecompressConcatenatedTrue() throws Exception {\r\n    readDoubledBlaLz4(in -> new FramedLZ4CompressorInputStream(in, true), true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadDoubledBlaLz4WithoutExplicitDecompressConcatenated",
  "sourceCode" : "@Test\r\nvoid testReadDoubledBlaLz4WithoutExplicitDecompressConcatenated() throws Exception {\r\n    readDoubledBlaLz4(FramedLZ4CompressorInputStream::new, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadsUncompressedBlocks",
  "sourceCode" : "@Test\r\nvoid testReadsUncompressedBlocks() throws IOException {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0 };\r\n    try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(new byte[] { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!' }, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testReadsUncompressedBlocksUsingSingleByteRead",
  "sourceCode" : "@Test\r\nvoid testReadsUncompressedBlocksUsingSingleByteRead() throws IOException {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0 };\r\n    try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n        final int h = a.read();\r\n        assertEquals('H', h);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsBlocksWithoutChecksum",
  "sourceCode" : "@Test\r\nvoid testRejectsBlocksWithoutChecksum() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, with block checksum, no content size, no content checksum\r\n    0x70, // block size 4MB\r\n    0x70, // checksum\r\n    114, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!' };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"block checksum\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsFileWithBadHeaderChecksum",
  "sourceCode" : "@Test\r\nvoid testRejectsFileWithBadHeaderChecksum() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, with content checksum\r\n    0x64, // block size 4MB\r\n    0x70, 0 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            // do nothing\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"header checksum mismatch\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsFileWithInsufficientContentSize",
  "sourceCode" : "@Test\r\nvoid testRejectsFileWithInsufficientContentSize() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, with content size, with content checksum\r\n    0x6C, // block size 4MB\r\n    0x70 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            // do nothing\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"content size\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsFileWithoutBlockSizeByte",
  "sourceCode" : "@Test\r\nvoid testRejectsFileWithoutBlockSizeByte() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, with content checksum\r\n    0x64 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            // do nothing\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"BD byte\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsFileWithoutFrameDescriptor",
  "sourceCode" : "@Test\r\nvoid testRejectsFileWithoutFrameDescriptor() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            // do nothing\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"frame flags\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsFileWithoutHeaderChecksum",
  "sourceCode" : "@Test\r\nvoid testRejectsFileWithoutHeaderChecksum() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, with content checksum\r\n    0x64, // block size 4MB\r\n    0x70 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            // do nothing\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"header checksum\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsFileWithWrongVersion",
  "sourceCode" : "@Test\r\nvoid testRejectsFileWithWrongVersion() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 00, block independent, no block checksum, no content size, with content checksum\r\n    0x24 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            // do nothing\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"version\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsNonLZ4Stream",
  "sourceCode" : "@Test\r\nvoid testRejectsNonLZ4Stream() {\r\n    assertThrows(CompressorException.class, () -> new FramedLZ4CompressorInputStream(newInputStream(\"bla.tar\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsSkippableFrameFollowedByJunk",
  "sourceCode" : "@Test\r\nvoid testRejectsSkippableFrameFollowedByJunk() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // skippable frame signature\r\n    0x50, // skippable frame signature\r\n    0x2a, // skippable frame signature\r\n    0x4d, // skippable frame signature\r\n    0x18, // skippable frame has length 2\r\n    2, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // content of skippable frame\r\n    1, // content of skippable frame\r\n    2, // bad signature\r\n    1, // bad signature\r\n    0x22, // bad signature\r\n    0x4d, // bad signature\r\n    0x18 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"garbage\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsSkippableFrameFollowedByTooFewBytes",
  "sourceCode" : "@Test\r\nvoid testRejectsSkippableFrameFollowedByTooFewBytes() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // skippable frame signature\r\n    0x52, // skippable frame signature\r\n    0x2a, // skippable frame signature\r\n    0x4d, // skippable frame signature\r\n    0x18, // skippable frame has length 2\r\n    2, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // content of skippable frame\r\n    1, // content of skippable frame\r\n    2, // too short for signature\r\n    4 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"garbage\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsSkippableFrameWithBadSignaturePrefix",
  "sourceCode" : "@Test\r\nvoid testRejectsSkippableFrameWithBadSignaturePrefix() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // broken skippable frame signature\r\n    0x60, // broken skippable frame signature\r\n    0x2a, // broken skippable frame signature\r\n    0x4d, // broken skippable frame signature\r\n    0x18 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n            IOUtils.toByteArray(a);\r\n            fail();\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"garbage\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsSkippableFrameWithBadSignatureTrailer",
  "sourceCode" : "@Test\r\nvoid testRejectsSkippableFrameWithBadSignatureTrailer() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // broken skippable frame signature\r\n    0x51, // broken skippable frame signature\r\n    0x2a, // broken skippable frame signature\r\n    0x4d, // broken skippable frame signature\r\n    0x17 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"garbage\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsSkippableFrameWithPrematureEnd",
  "sourceCode" : "@Test\r\nvoid testRejectsSkippableFrameWithPrematureEnd() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // skippable frame signature\r\n    0x50, // skippable frame signature\r\n    0x2a, // skippable frame signature\r\n    0x4d, // skippable frame signature\r\n    0x18, // skippable frame has length 2\r\n    2, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // content of skippable frame (should be two bytes)\r\n    1 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"Premature end of stream while skipping frame\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsSkippableFrameWithPrematureEndInLengthBytes",
  "sourceCode" : "@Test\r\nvoid testRejectsSkippableFrameWithPrematureEndInLengthBytes() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // skippable frame signature\r\n    0x55, // skippable frame signature\r\n    0x2a, // skippable frame signature\r\n    0x4d, // skippable frame signature\r\n    0x18, // should be four byte length\r\n    2, // should be four byte length\r\n    0, // should be four byte length\r\n    0 };\r\n    final IOException ex = assertThrows(IOException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"Premature end of data\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsStreamsWithBadContentChecksum",
  "sourceCode" : "@Test\r\nvoid testRejectsStreamsWithBadContentChecksum() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, with content checksum\r\n    0x64, // block size 4MB\r\n    0x70, // checksum\r\n    (byte) 185, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, 1, 2, 3, 4 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"content checksum mismatch\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsStreamsWithoutContentChecksum",
  "sourceCode" : "@Test\r\nvoid testRejectsStreamsWithoutContentChecksum() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, with content checksum\r\n    0x64, // block size 4MB\r\n    0x70, // checksum\r\n    (byte) 185, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0 };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"content checksum\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testRejectsTrailingBytesAfterValidFrame",
  "sourceCode" : "@Test\r\nvoid testRejectsTrailingBytesAfterValidFrame() {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // too short for any signature\r\n    0x56, // too short for any signature\r\n    0x2a, // too short for any signature\r\n    0x4d };\r\n    final IOException ex = assertThrows(CompressorException.class, () -> {\r\n        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n            IOUtils.toByteArray(a);\r\n        }\r\n    }, \"expected exception\");\r\n    assertTrue(ex.getMessage().contains(\"garbage\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tar.lz4\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        FramedLZ4CompressorInputStream in = new FramedLZ4CompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testSkipsOverSkippableFrames",
  "sourceCode" : "@Test\r\nvoid testSkipsOverSkippableFrames() throws IOException {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // skippable frame signature\r\n    0x5f, // skippable frame signature\r\n    0x2a, // skippable frame signature\r\n    0x4d, // skippable frame signature\r\n    0x18, // skippable frame has length 2\r\n    2, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // content of skippable frame\r\n    1, // content of skippable frame\r\n    2, // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 1 bytes length and uncompressed bit set\r\n    1, // 1 bytes length and uncompressed bit set\r\n    0, // 1 bytes length and uncompressed bit set\r\n    0, // 1 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0 };\r\n    try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(new byte[] { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '!' }, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorInputStreamTest.java",
  "methodName" : "testSkipsOverTrailingSkippableFrames",
  "sourceCode" : "@Test\r\nvoid testSkipsOverTrailingSkippableFrames() throws IOException {\r\n    final byte[] input = { // signature\r\n    4, // signature\r\n    0x22, // signature\r\n    0x4d, // signature\r\n    0x18, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\r\n    0x60, // block size 4MB\r\n    0x70, // checksum\r\n    115, // 13 bytes length and uncompressed bit set\r\n    13, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    0, // 13 bytes length and uncompressed bit set\r\n    (byte) 0x80, // content\r\n    'H', // content\r\n    'e', // content\r\n    'l', // content\r\n    'l', // content\r\n    'o', // content\r\n    ',', // content\r\n    ' ', // content\r\n    'w', // content\r\n    'o', // content\r\n    'r', // content\r\n    'l', // content\r\n    'd', // content\r\n    '!', // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // empty block marker\r\n    0, // skippable frame signature\r\n    0x51, // skippable frame signature\r\n    0x2a, // skippable frame signature\r\n    0x4d, // skippable frame signature\r\n    0x18, // skippable frame has length 2\r\n    2, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // skippable frame has length 2\r\n    0, // content of skippable frame\r\n    1, // content of skippable frame\r\n    2 };\r\n    try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(new byte[] { 'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!' }, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorOutputStreamTest.java",
  "methodName" : "testFinishWithNoWrite",
  "sourceCode" : "@Test\r\nvoid testFinishWithNoWrite() throws IOException {\r\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    try (FramedLZ4CompressorOutputStream compressor = new FramedLZ4CompressorOutputStream(buffer, new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.K64, true, false, false))) {\r\n        // do nothing here. this will test that flush on close doesn't throw any exceptions if no data is written.\r\n    }\r\n    assertTrue(buffer.size() == 15, \"Only the trailer gets written.\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorOutputStreamTest.java",
  "methodName" : "testWriteByteArrayVsWriteByte",
  "sourceCode" : "@Test\r\nvoid testWriteByteArrayVsWriteByte() throws IOException {\r\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    final byte[] bytes = \"abcdefghijklmnop\".getBytes();\r\n    try (FramedLZ4CompressorOutputStream compressor = new FramedLZ4CompressorOutputStream(buffer, new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.K64, true, false, false))) {\r\n        compressor.write(bytes);\r\n        compressor.finish();\r\n        compressor.close();\r\n        assertTrue(compressor.isClosed());\r\n    }\r\n    final byte[] bulkOutput = buffer.toByteArray();\r\n    buffer = new ByteArrayOutputStream();\r\n    try (FramedLZ4CompressorOutputStream compressor = new FramedLZ4CompressorOutputStream(buffer, new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.K64, true, false, false))) {\r\n        for (final byte element : bytes) {\r\n            compressor.write(element);\r\n        }\r\n        compressor.finish();\r\n        compressor.close();\r\n        assertTrue(compressor.isClosed());\r\n    }\r\n    assertTrue(Arrays.equals(bulkOutput, buffer.toByteArray()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorRoundtripTest.java",
  "methodName" : "biggerFileRoundtrip",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void biggerFileRoundtrip(final FramedLZ4CompressorOutputStream.Parameters params) throws IOException {\r\n    roundTripTest(\"COMPRESS-256.7z\", params);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorRoundtripTest.java",
  "methodName" : "blaTarRoundtrip",
  "sourceCode" : "// should yield decent compression\r\n@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void blaTarRoundtrip(final FramedLZ4CompressorOutputStream.Parameters params) throws IOException {\r\n    roundTripTest(\"bla.tar\", params);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorRoundtripTest.java",
  "methodName" : "gzippedLoremIpsumRoundtrip",
  "sourceCode" : "// yields no compression at all\r\n@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void gzippedLoremIpsumRoundtrip(final FramedLZ4CompressorOutputStream.Parameters params) throws IOException {\r\n    roundTripTest(\"lorem-ipsum.txt.gz\", params);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\FramedLZ4CompressorRoundtripTest.java",
  "methodName" : "test64KMultipleBlocks",
  "sourceCode" : "@Test\r\nvoid test64KMultipleBlocks() throws IOException {\r\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    final byte[] expected = new byte[98304];\r\n    new Random(0).nextBytes(expected);\r\n    try (FramedLZ4CompressorOutputStream compressor = new FramedLZ4CompressorOutputStream(buffer, new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.K64, true, false, false))) {\r\n        compressor.write(expected);\r\n    }\r\n    try (FramedLZ4CompressorInputStream sis = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(buffer.toByteArray()))) {\r\n        assertArrayEquals(expected, IOUtils.toByteArray(sis));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz4\\XXHash32Test.java",
  "methodName" : "verifyChecksum",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"factory\")\r\npublic void verifyChecksum(final String fileName, final String expectedChecksum) throws IOException {\r\n    final XXHash32 h = new XXHash32();\r\n    final File file = AbstractTest.getFile(fileName);\r\n    try (InputStream s = Files.newInputStream(file.toPath())) {\r\n        final byte[] b = IOUtils.toByteArray(s);\r\n        h.update(b, 0, b.length);\r\n    }\r\n    assertEquals(expectedChecksum, Long.toHexString(h.getValue()), \"checksum for \" + file.getName());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\AbstractLZ77CompressorInputStreamTest.java",
  "methodName" : "testCantPrefillAfterDataHasBeenRead",
  "sourceCode" : "@Test\r\nvoid testCantPrefillAfterDataHasBeenRead() throws IOException {\r\n    final byte[] data = { 1, 2, 3, 4 };\r\n    try (TestStream s = new TestStream(new ByteArrayInputStream(data))) {\r\n        s.literal(3);\r\n        assertEquals(1, s.read());\r\n        assertThrows(IllegalStateException.class, () -> s.prefill(new byte[] { 1, 2, 3 }));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\AbstractLZ77CompressorInputStreamTest.java",
  "methodName" : "testIfPrefillExceedsWindowSizeTheLastBytesAreUsed",
  "sourceCode" : "@Test\r\nvoid testIfPrefillExceedsWindowSizeTheLastBytesAreUsed() throws IOException {\r\n    final byte[] data = new byte[2048];\r\n    data[2046] = 3;\r\n    data[2047] = 4;\r\n    try (TestStream s = new TestStream(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY))) {\r\n        s.prefill(data);\r\n        s.startBackReference(2, 4);\r\n        final byte[] r = new byte[4];\r\n        assertEquals(4, s.read(r));\r\n        assertArrayEquals(new byte[] { 3, 4, 3, 4 }, r);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\AbstractLZ77CompressorInputStreamTest.java",
  "methodName" : "testPrefillCanBeUsedForBackReferences",
  "sourceCode" : "@Test\r\nvoid testPrefillCanBeUsedForBackReferences() throws IOException {\r\n    final byte[] data = { 1, 2, 3, 4 };\r\n    try (TestStream s = new TestStream(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY))) {\r\n        s.prefill(data);\r\n        s.startBackReference(2, 4);\r\n        final byte[] r = new byte[4];\r\n        assertEquals(4, s.read(r));\r\n        assertArrayEquals(new byte[] { 3, 4, 3, 4 }, r);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorBlockTest.java",
  "methodName" : "testBackReferenceBlockToString",
  "sourceCode" : "@Test\r\nvoid testBackReferenceBlockToString() {\r\n    assertTrue(new BackReference(1, 2).toString().contains(BlockType.BACK_REFERENCE.name()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorBlockTest.java",
  "methodName" : "testDeprecatedBlock",
  "sourceCode" : "@Test\r\nvoid testDeprecatedBlock() {\r\n    assertNotNull(new DeprecatedBlock().toString().contains(DeprecatedBlock.class.getSimpleName()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorBlockTest.java",
  "methodName" : "testEodBlockToString",
  "sourceCode" : "@Test\r\nvoid testEodBlockToString() {\r\n    assertTrue(new EOD().toString().contains(BlockType.EOD.name()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorBlockTest.java",
  "methodName" : "testLiteralBlockToString",
  "sourceCode" : "@Test\r\nvoid testLiteralBlockToString() {\r\n    assertTrue(new LiteralBlock(new byte[10], 1, 2).toString().contains(BlockType.LITERAL.name()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testBlaExampleSmallerWindowSize",
  "sourceCode" : "@Test\r\nvoid testBlaExampleSmallerWindowSize() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(8), BLA);\r\n    assertSize(6, blocks);\r\n    assertLiteralBlock(\"Blah b\", blocks.get(0));\r\n    assertBackReference(5, 7, blocks.get(1));\r\n    assertBackReference(5, 3, blocks.get(2));\r\n    assertBackReference(5, 7, blocks.get(3));\r\n    assertLiteralBlock(\"h!\", blocks.get(4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testBlaExampleWithFullArrayAvailableForCompression",
  "sourceCode" : "@Test\r\nvoid testBlaExampleWithFullArrayAvailableForCompression() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(128), BLA);\r\n    assertSize(4, blocks);\r\n    assertLiteralBlock(\"Blah b\", blocks.get(0));\r\n    assertBackReference(5, 18, blocks.get(1));\r\n    assertLiteralBlock(\"!\", blocks.get(2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testBlaExampleWithPrefill",
  "sourceCode" : "@Test\r\nvoid testBlaExampleWithPrefill() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = new ArrayList<>();\r\n    final LZ77Compressor c = new LZ77Compressor(newParameters(128), block -> {\r\n        // System.err.println(block);\r\n        if (block instanceof LZ77Compressor.LiteralBlock) {\r\n            // replace with a real copy of data so tests\r\n            // can see the results as they've been when\r\n            // the callback has been called\r\n            final LZ77Compressor.LiteralBlock b = (LZ77Compressor.LiteralBlock) block;\r\n            final int len = b.getLength();\r\n            block = new LZ77Compressor.LiteralBlock(Arrays.copyOfRange(b.getData(), b.getOffset(), b.getOffset() + len), 0, len);\r\n        }\r\n        blocks.add(block);\r\n    });\r\n    c.prefill(Arrays.copyOfRange(BLA, 0, 6));\r\n    c.compress(Arrays.copyOfRange(BLA, 6, BLA.length));\r\n    c.finish();\r\n    assertSize(3, blocks);\r\n    assertBackReference(5, 18, blocks.get(0));\r\n    assertLiteralBlock(\"!\", blocks.get(1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testBlaExampleWithPrefillBiggerThanWindowSize",
  "sourceCode" : "@Test\r\nvoid testBlaExampleWithPrefillBiggerThanWindowSize() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = new ArrayList<>();\r\n    final LZ77Compressor c = new LZ77Compressor(newParameters(4), block -> {\r\n        // System.err.println(block);\r\n        if (block instanceof LZ77Compressor.LiteralBlock) {\r\n            // replace with a real copy of data so tests\r\n            // can see the results as they've been when\r\n            // the callback has been called\r\n            final LZ77Compressor.LiteralBlock b = (LZ77Compressor.LiteralBlock) block;\r\n            final int len = b.getLength();\r\n            block = new LZ77Compressor.LiteralBlock(Arrays.copyOfRange(b.getData(), b.getOffset(), b.getOffset() + len), 0, len);\r\n        }\r\n        blocks.add(block);\r\n    });\r\n    c.prefill(Arrays.copyOfRange(BLA, 0, 6));\r\n    c.compress(Arrays.copyOfRange(BLA, 6, BLA.length));\r\n    c.finish();\r\n    assertSize(6, blocks);\r\n    assertLiteralBlock(\"lah \", blocks.get(0));\r\n    assertLiteralBlock(\"blah\", blocks.get(1));\r\n    assertLiteralBlock(\" bla\", blocks.get(2));\r\n    assertLiteralBlock(\"h bl\", blocks.get(3));\r\n    assertLiteralBlock(\"ah!\", blocks.get(4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testBlaExampleWithShorterBackReferenceLength",
  "sourceCode" : "@Test\r\nvoid testBlaExampleWithShorterBackReferenceLength() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(128, 3, 5, 0, 0), BLA);\r\n    assertSize(7, blocks);\r\n    assertLiteralBlock(\"Blah b\", blocks.get(0));\r\n    assertBackReference(5, 5, blocks.get(1));\r\n    assertBackReference(5, 5, blocks.get(2));\r\n    assertBackReference(5, 5, blocks.get(3));\r\n    assertBackReference(5, 3, blocks.get(4));\r\n    assertLiteralBlock(\"!\", blocks.get(5));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testBlaExampleWithShortPrefill",
  "sourceCode" : "@Test\r\nvoid testBlaExampleWithShortPrefill() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = new ArrayList<>();\r\n    final LZ77Compressor c = new LZ77Compressor(newParameters(128), block -> {\r\n        // System.err.println(block);\r\n        if (block instanceof LZ77Compressor.LiteralBlock) {\r\n            // replace with a real copy of data so tests\r\n            // can see the results as they've been when\r\n            // the callback has been called\r\n            final LZ77Compressor.LiteralBlock b = (LZ77Compressor.LiteralBlock) block;\r\n            final int len = b.getLength();\r\n            block = new LZ77Compressor.LiteralBlock(Arrays.copyOfRange(b.getData(), b.getOffset(), b.getOffset() + len), 0, len);\r\n        }\r\n        blocks.add(block);\r\n    });\r\n    c.prefill(Arrays.copyOfRange(BLA, 0, 2));\r\n    c.compress(Arrays.copyOfRange(BLA, 2, BLA.length));\r\n    c.finish();\r\n    assertSize(4, blocks);\r\n    assertLiteralBlock(\"ah b\", blocks.get(0));\r\n    assertBackReference(5, 18, blocks.get(1));\r\n    assertLiteralBlock(\"!\", blocks.get(2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testBlaExampleWithSingleByteWrites",
  "sourceCode" : "@Test\r\nvoid testBlaExampleWithSingleByteWrites() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(128), stagger(BLA));\r\n    assertEquals(9, blocks.size());\r\n    assertLiteralBlock(\"Blah b\", blocks.get(0));\r\n    assertBackReference(5, 3, blocks.get(1));\r\n    assertBackReference(5, 3, blocks.get(2));\r\n    assertBackReference(5, 3, blocks.get(3));\r\n    assertBackReference(5, 3, blocks.get(4));\r\n    assertBackReference(5, 3, blocks.get(5));\r\n    assertBackReference(5, 3, blocks.get(6));\r\n    assertLiteralBlock(\"!\", blocks.get(7));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testCantPrefillAfterCompress",
  "sourceCode" : "@Test\r\nvoid testCantPrefillAfterCompress() throws IOException {\r\n    final LZ77Compressor c = new LZ77Compressor(newParameters(128), block -> {\r\n    });\r\n    c.compress(Arrays.copyOfRange(BLA, 0, 2));\r\n    assertThrows(IllegalStateException.class, () -> c.prefill(Arrays.copyOfRange(BLA, 2, 4)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testCantPrefillTwice",
  "sourceCode" : "@Test\r\nvoid testCantPrefillTwice() {\r\n    final LZ77Compressor c = new LZ77Compressor(newParameters(128), block -> {\r\n    });\r\n    c.prefill(Arrays.copyOfRange(BLA, 0, 2));\r\n    assertThrows(IllegalStateException.class, () -> c.prefill(Arrays.copyOfRange(BLA, 2, 4)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testNonCompressableSentAsSingleBytes",
  "sourceCode" : "@Test\r\nvoid testNonCompressableSentAsSingleBytes() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(8), stagger(ONE_TO_TEN));\r\n    assertSize(3, blocks);\r\n    assertLiteralBlock(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, blocks.get(0));\r\n    assertLiteralBlock(new byte[] { 9, 10 }, blocks.get(1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testNonCompressableWithLengthGreaterThanLiteralMaxButLessThanTwiceWindowSize",
  "sourceCode" : "@Test\r\nvoid testNonCompressableWithLengthGreaterThanLiteralMaxButLessThanTwiceWindowSize() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(8), ONE_TO_TEN);\r\n    assertSize(3, blocks);\r\n    assertLiteralBlock(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, blocks.get(0));\r\n    assertLiteralBlock(new byte[] { 9, 10 }, blocks.get(1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testNonCompressableWithLengthSmallerThanLiteralMax",
  "sourceCode" : "@Test\r\nvoid testNonCompressableWithLengthSmallerThanLiteralMax() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(128), ONE_TO_TEN);\r\n    assertSize(2, blocks);\r\n    assertLiteralBlock(ONE_TO_TEN, blocks.get(0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testNonCompressableWithLengthThatForcesWindowSlide",
  "sourceCode" : "@Test\r\nvoid testNonCompressableWithLengthThatForcesWindowSlide() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(4), ONE_TO_TEN);\r\n    assertSize(4, blocks);\r\n    assertLiteralBlock(new byte[] { 1, 2, 3, 4 }, blocks.get(0));\r\n    assertLiteralBlock(new byte[] { 5, 6, 7, 8 }, blocks.get(1));\r\n    assertLiteralBlock(new byte[] { 9, 10 }, blocks.get(2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\LZ77CompressorTest.java",
  "methodName" : "testSamIAmExampleWithFullArrayAvailableForCompression",
  "sourceCode" : "@Test\r\nvoid testSamIAmExampleWithFullArrayAvailableForCompression() throws IOException {\r\n    final List<LZ77Compressor.Block> blocks = compress(newParameters(1024), SAM);\r\n    assertEquals(21, blocks.size());\r\n    assertLiteralBlock(\"I am Sam\\n\\n\", blocks.get(0));\r\n    assertBackReference(5, 3, blocks.get(1));\r\n    assertLiteralBlock(\" \", blocks.get(2));\r\n    assertBackReference(14, 4, blocks.get(3));\r\n    assertLiteralBlock(\"\\n\\nThat\", blocks.get(4));\r\n    assertBackReference(20, 4, blocks.get(5));\r\n    assertLiteralBlock(\"-I-am!\", blocks.get(6));\r\n    assertBackReference(15, 16, blocks.get(7));\r\n    assertLiteralBlock(\"I do not like\\nt\", blocks.get(8));\r\n    assertBackReference(29, 14, blocks.get(9));\r\n    assertLiteralBlock(\"\\nDo you\", blocks.get(10));\r\n    assertBackReference(28, 5, blocks.get(11));\r\n    assertLiteralBlock(\" green eggs and ham?\\n\", blocks.get(12));\r\n    assertBackReference(63, 14, blocks.get(13));\r\n    assertLiteralBlock(\" them,\", blocks.get(14));\r\n    assertBackReference(64, 9, blocks.get(15));\r\n    assertLiteralBlock(\".\", blocks.get(16));\r\n    assertBackReference(30, 15, blocks.get(17));\r\n    assertBackReference(65, 18, blocks.get(18));\r\n    assertLiteralBlock(\".\", blocks.get(19));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testAllParametersUsuallyTakeTheirSpecifiedValues",
  "sourceCode" : "@Test\r\nvoid testAllParametersUsuallyTakeTheirSpecifiedValues() {\r\n    final Parameters p = newParameters(256, 4, 5, 6, 7);\r\n    assertEquals(256, p.getWindowSize());\r\n    assertEquals(4, p.getMinBackReferenceLength());\r\n    assertEquals(5, p.getMaxBackReferenceLength());\r\n    assertEquals(6, p.getMaxOffset());\r\n    assertEquals(7, p.getMaxLiteralLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testDefaultConstructor",
  "sourceCode" : "@Test\r\nvoid testDefaultConstructor() {\r\n    final Parameters p = newParameters(128);\r\n    assertEquals(128, p.getWindowSize());\r\n    assertEquals(3, p.getMinBackReferenceLength());\r\n    assertEquals(127, p.getMaxBackReferenceLength());\r\n    assertEquals(127, p.getMaxOffset());\r\n    assertEquals(128, p.getMaxLiteralLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxBackReferenceLengthIsMinBackReferenceLengthIfBothAreEqual",
  "sourceCode" : "@Test\r\nvoid testMaxBackReferenceLengthIsMinBackReferenceLengthIfBothAreEqual() {\r\n    final Parameters p = newParameters(128, 2, 3, 4, 5);\r\n    assertEquals(3, p.getMaxBackReferenceLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxBackReferenceLengthIsMinBackReferenceLengthWhenSmallerThanMinBackReferenceLength",
  "sourceCode" : "@Test\r\nvoid testMaxBackReferenceLengthIsMinBackReferenceLengthWhenSmallerThanMinBackReferenceLength() {\r\n    final Parameters p = newParameters(128, 2, 2, 4, 5);\r\n    assertEquals(3, p.getMaxBackReferenceLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxBackReferenceLengthIsMinBackReferenceLengthWhenSmallerThanMinBackReferenceLengthReversedInvocationOrder",
  "sourceCode" : "@Test\r\nvoid testMaxBackReferenceLengthIsMinBackReferenceLengthWhenSmallerThanMinBackReferenceLengthReversedInvocationOrder() {\r\n    final Parameters p = Parameters.builder(128).withMaxBackReferenceLength(2).withMinBackReferenceLength(2).withMaxOffset(4).withMaxLiteralLength(5).build();\r\n    assertEquals(3, p.getMaxBackReferenceLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxLiteralLengthIsWindowSizeIfSetTo0",
  "sourceCode" : "@Test\r\nvoid testMaxLiteralLengthIsWindowSizeIfSetTo0() {\r\n    final Parameters p = newParameters(128, 2, 3, 4, 0);\r\n    assertEquals(128, p.getMaxLiteralLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxLiteralLengthIsWindowSizeIfSetToANegativeValue",
  "sourceCode" : "@Test\r\nvoid testMaxLiteralLengthIsWindowSizeIfSetToANegativeValue() {\r\n    final Parameters p = newParameters(128, 2, 3, 0, -1);\r\n    assertEquals(128, p.getMaxLiteralLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxLiteralLengthIsWindowSizeIfSetToAValueTooBigToHoldInSlidingWindow",
  "sourceCode" : "@Test\r\nvoid testMaxLiteralLengthIsWindowSizeIfSetToAValueTooBigToHoldInSlidingWindow() {\r\n    final Parameters p = newParameters(128, 2, 3, 0, 259);\r\n    assertEquals(128, p.getMaxLiteralLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxOffsetIsWindowSizeMinus1IfBiggerThanWindowSize",
  "sourceCode" : "@Test\r\nvoid testMaxOffsetIsWindowSizeMinus1IfBiggerThanWindowSize() {\r\n    final Parameters p = newParameters(128, 2, 3, 129, 5);\r\n    assertEquals(127, p.getMaxOffset());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxOffsetIsWindowSizeMinus1IfSetTo0",
  "sourceCode" : "@Test\r\nvoid testMaxOffsetIsWindowSizeMinus1IfSetTo0() {\r\n    final Parameters p = newParameters(128, 2, 3, 0, 5);\r\n    assertEquals(127, p.getMaxOffset());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMaxOffsetIsWindowSizeMinus1IfSetToANegativeValue",
  "sourceCode" : "@Test\r\nvoid testMaxOffsetIsWindowSizeMinus1IfSetToANegativeValue() {\r\n    final Parameters p = newParameters(128, 2, 3, -1, 5);\r\n    assertEquals(127, p.getMaxOffset());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testMinBackReferenceLengthIsAtLeastThree",
  "sourceCode" : "@Test\r\nvoid testMinBackReferenceLengthIsAtLeastThree() {\r\n    final Parameters p = newParameters(128, 2, 3, 4, 5);\r\n    assertEquals(3, p.getMinBackReferenceLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testWindowSizeMustBeAPowerOfTwo",
  "sourceCode" : "@Test\r\nvoid testWindowSizeMustBeAPowerOfTwo() {\r\n    assertThrows(IllegalArgumentException.class, () -> newParameters(100, 200, 300, 400, 500));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lz77support\\ParametersTest.java",
  "methodName" : "testWindowSizeMustNotBeSmallerThanMinBackReferenceLength",
  "sourceCode" : "@Test\r\nvoid testWindowSizeMustNotBeSmallerThanMinBackReferenceLength() {\r\n    assertThrows(IllegalArgumentException.class, () -> newParameters(128, 200, 300, 400, 500));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMACompressorOutputStreamTest.java",
  "methodName" : "testBuilderOptionsAll",
  "sourceCode" : "@Test\r\nvoid testBuilderOptionsAll() throws IOException {\r\n    final int dictSize = LZMA2Options.DICT_SIZE_MIN;\r\n    final int lc = LZMA2Options.LC_LP_MAX - 4;\r\n    final int lp = LZMA2Options.LC_LP_MAX - 4;\r\n    final int pb = LZMA2Options.PB_MAX;\r\n    final int mode = LZMA2Options.MODE_NORMAL;\r\n    final int niceLen = LZMA2Options.NICE_LEN_MIN;\r\n    final int mf = LZMA2Options.MF_BT4;\r\n    final int depthLimit = 50;\r\n    roundtrip(tempDir.resolve(\"out.lzma\"), new LZMA2Options(dictSize, lc, lp, pb, mode, niceLen, mf, depthLimit));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMACompressorOutputStreamTest.java",
  "methodName" : "testBuilderOptionsDefault",
  "sourceCode" : "@Test\r\nvoid testBuilderOptionsDefault() throws IOException {\r\n    roundtrip(tempDir.resolve(\"out.lzma\"), new LZMA2Options());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMACompressorOutputStreamTest.java",
  "methodName" : "testBuilderOptionsPreset",
  "sourceCode" : "@Test\r\nvoid testBuilderOptionsPreset() throws IOException {\r\n    roundtrip(tempDir.resolve(\"out.lzma\"), new LZMA2Options(LZMA2Options.PRESET_MAX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMACompressorOutputStreamTest.java",
  "methodName" : "testBuilderPath",
  "sourceCode" : "@Test\r\nvoid testBuilderPath() throws IOException {\r\n    // This test does not use LZMA2Options\r\n    final Path outPath = tempDir.resolve(\"out.lzma\");\r\n    try (LZMACompressorOutputStream out = LZMACompressorOutputStream.builder().setPath(outPath).get()) {\r\n        out.writeUtf8(\"Hello World!\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMAUtilsTest.java",
  "methodName" : "testCachingIsEnabledByDefaultAndLZMAIsPresent",
  "sourceCode" : "@Test\r\nvoid testCachingIsEnabledByDefaultAndLZMAIsPresent() {\r\n    assertEquals(LZMAUtils.CachedAvailability.CACHED_AVAILABLE, LZMAUtils.getCachedLZMAAvailability());\r\n    assertTrue(LZMAUtils.isLZMACompressionAvailable());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMAUtilsTest.java",
  "methodName" : "testCanTurnOffCaching",
  "sourceCode" : "@Test\r\nvoid testCanTurnOffCaching() {\r\n    try {\r\n        LZMAUtils.setCacheLZMAAvailablity(false);\r\n        assertEquals(LZMAUtils.CachedAvailability.DONT_CACHE, LZMAUtils.getCachedLZMAAvailability());\r\n        assertTrue(LZMAUtils.isLZMACompressionAvailable());\r\n    } finally {\r\n        LZMAUtils.setCacheLZMAAvailablity(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMAUtilsTest.java",
  "methodName" : "testGetCompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testGetCompressedFilename() {\r\n    assertEquals(\".lzma\", LZMAUtils.getCompressedFilename(\"\"));\r\n    assertEquals(\".lzma\", LZMAUtils.getCompressedFileName(\"\"));\r\n    assertEquals(\"x.lzma\", LZMAUtils.getCompressedFilename(\"x\"));\r\n    assertEquals(\"x.lzma\", LZMAUtils.getCompressedFileName(\"x\"));\r\n    assertEquals(\"x.wmf .lzma\", LZMAUtils.getCompressedFilename(\"x.wmf \"));\r\n    assertEquals(\"x.wmf .lzma\", LZMAUtils.getCompressedFileName(\"x.wmf \"));\r\n    assertEquals(\"x.wmf\\n.lzma\", LZMAUtils.getCompressedFilename(\"x.wmf\\n\"));\r\n    assertEquals(\"x.wmf\\n.lzma\", LZMAUtils.getCompressedFileName(\"x.wmf\\n\"));\r\n    assertEquals(\"x.wmf.y.lzma\", LZMAUtils.getCompressedFilename(\"x.wmf.y\"));\r\n    assertEquals(\"x.wmf.y.lzma\", LZMAUtils.getCompressedFileName(\"x.wmf.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMAUtilsTest.java",
  "methodName" : "testGetUncompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testGetUncompressedFilename() {\r\n    assertEquals(\"\", LZMAUtils.getUncompressedFilename(\"\"));\r\n    assertEquals(\"\", LZMAUtils.getUncompressedFileName(\"\"));\r\n    assertEquals(\".lzma\", LZMAUtils.getUncompressedFilename(\".lzma\"));\r\n    assertEquals(\".lzma\", LZMAUtils.getUncompressedFileName(\".lzma\"));\r\n    assertEquals(\"x\", LZMAUtils.getUncompressedFilename(\"x.lzma\"));\r\n    assertEquals(\"x\", LZMAUtils.getUncompressedFileName(\"x.lzma\"));\r\n    assertEquals(\"x\", LZMAUtils.getUncompressedFilename(\"x-lzma\"));\r\n    assertEquals(\"x\", LZMAUtils.getUncompressedFileName(\"x-lzma\"));\r\n    assertEquals(\"x.lzma \", LZMAUtils.getUncompressedFilename(\"x.lzma \"));\r\n    assertEquals(\"x.lzma \", LZMAUtils.getUncompressedFileName(\"x.lzma \"));\r\n    assertEquals(\"x.lzma\\n\", LZMAUtils.getUncompressedFilename(\"x.lzma\\n\"));\r\n    assertEquals(\"x.lzma\\n\", LZMAUtils.getUncompressedFileName(\"x.lzma\\n\"));\r\n    assertEquals(\"x.lzma.y\", LZMAUtils.getUncompressedFilename(\"x.lzma.y\"));\r\n    assertEquals(\"x.lzma.y\", LZMAUtils.getUncompressedFileName(\"x.lzma.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMAUtilsTest.java",
  "methodName" : "testIsCompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testIsCompressedFilename() {\r\n    assertFalse(LZMAUtils.isCompressedFilename(\"\"));\r\n    assertFalse(LZMAUtils.isCompressedFileName(\"\"));\r\n    assertFalse(LZMAUtils.isCompressedFilename(\".lzma\"));\r\n    assertFalse(LZMAUtils.isCompressedFileName(\".lzma\"));\r\n    assertTrue(LZMAUtils.isCompressedFilename(\"x.lzma\"));\r\n    assertTrue(LZMAUtils.isCompressedFileName(\"x.lzma\"));\r\n    assertTrue(LZMAUtils.isCompressedFilename(\"x-lzma\"));\r\n    assertTrue(LZMAUtils.isCompressedFileName(\"x-lzma\"));\r\n    assertFalse(LZMAUtils.isCompressedFilename(\"xxgz\"));\r\n    assertFalse(LZMAUtils.isCompressedFileName(\"xxgz\"));\r\n    assertFalse(LZMAUtils.isCompressedFilename(\"lzmaz\"));\r\n    assertFalse(LZMAUtils.isCompressedFileName(\"lzmaz\"));\r\n    assertFalse(LZMAUtils.isCompressedFilename(\"xaz\"));\r\n    assertFalse(LZMAUtils.isCompressedFileName(\"xaz\"));\r\n    assertFalse(LZMAUtils.isCompressedFilename(\"x.lzma \"));\r\n    assertFalse(LZMAUtils.isCompressedFileName(\"x.lzma \"));\r\n    assertFalse(LZMAUtils.isCompressedFilename(\"x.lzma\\n\"));\r\n    assertFalse(LZMAUtils.isCompressedFileName(\"x.lzma\\n\"));\r\n    assertFalse(LZMAUtils.isCompressedFilename(\"x.lzma.y\"));\r\n    assertFalse(LZMAUtils.isCompressedFileName(\"x.lzma.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMAUtilsTest.java",
  "methodName" : "testMatches",
  "sourceCode" : "@Test\r\nvoid testMatches() {\r\n    final byte[] data = { (byte) 0x5D, 0, 0 };\r\n    assertFalse(LZMAUtils.matches(data, 2));\r\n    assertTrue(LZMAUtils.matches(data, 3));\r\n    assertTrue(LZMAUtils.matches(data, 4));\r\n    data[2] = '0';\r\n    assertFalse(LZMAUtils.matches(data, 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\lzma\\LZMAUtilsTest.java",
  "methodName" : "testTurningOnCachingReEvaluatesAvailability",
  "sourceCode" : "@Test\r\nvoid testTurningOnCachingReEvaluatesAvailability() {\r\n    try {\r\n        LZMAUtils.setCacheLZMAAvailablity(false);\r\n        assertEquals(LZMAUtils.CachedAvailability.DONT_CACHE, LZMAUtils.getCachedLZMAAvailability());\r\n        LZMAUtils.setCacheLZMAAvailablity(true);\r\n        assertEquals(LZMAUtils.CachedAvailability.CACHED_AVAILABLE, LZMAUtils.getCachedLZMAAvailability());\r\n    } finally {\r\n        LZMAUtils.setCacheLZMAAvailablity(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\LZMATest.java",
  "methodName" : "testLzmaRoundtrip",
  "sourceCode" : "@Test\r\nvoid testLzmaRoundtrip() throws Exception {\r\n    final Path input = getPath(\"test1.xml\");\r\n    final File compressed = newTempFile(\"test1.xml.xz\");\r\n    try (OutputStream out = Files.newOutputStream(compressed.toPath())) {\r\n        try (CompressorOutputStream<?> cos = new CompressorStreamFactory().createCompressorOutputStream(\"lzma\", out)) {\r\n            cos.write(input);\r\n        }\r\n    }\r\n    final byte[] orig = Files.readAllBytes(input);\r\n    final byte[] uncompressed;\r\n    try (InputStream is = Files.newInputStream(compressed.toPath());\r\n        CompressorInputStream in = new LZMACompressorInputStream(is)) {\r\n        uncompressed = IOUtils.toByteArray(in);\r\n    }\r\n    assertArrayEquals(orig, uncompressed);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\LZMATest.java",
  "methodName" : "testLZMAUnarchive",
  "sourceCode" : "@Test\r\nvoid testLZMAUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.tar.lzma\");\r\n    final File output = newTempFile(\"bla.tar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new LZMACompressorInputStream(is)) {\r\n            Files.copy(in, output.toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\LZMATest.java",
  "methodName" : "testLZMAUnarchiveWithAutodetection",
  "sourceCode" : "@Test\r\nvoid testLZMAUnarchiveWithAutodetection() throws Exception {\r\n    final File input = getFile(\"bla.tar.lzma\");\r\n    final File output = newTempFile(\"bla.tar\");\r\n    try (InputStream is = new BufferedInputStream(Files.newInputStream(input.toPath()))) {\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(is)) {\r\n            Files.copy(in, output.toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\LZMATest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tar.lzma\");\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (LZMACompressorInputStream in = new LZMACompressorInputStream(is)) {\r\n            IOUtils.toByteArray(in);\r\n            assertEquals(-1, in.read(buf));\r\n            assertEquals(-1, in.read(buf));\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\LZMATest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tar.lzma\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (LZMACompressorInputStream in = new LZMACompressorInputStream(is)) {\r\n            IOUtils.toByteArray(in);\r\n            assertEquals(-1, in.read());\r\n            assertEquals(-1, in.read());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Compress687Test.java",
  "methodName" : "testTransferTo",
  "sourceCode" : "@Test\r\nvoid testTransferTo() throws Exception {\r\n    try (InputStream inputStream = Compress687Test.class.getClassLoader().getResourceAsStream(FIXTURE);\r\n        Pack200CompressorInputStream compressInputStream = new Pack200CompressorInputStream(inputStream)) {\r\n        transferTo(compressInputStream, NullOutputStream.INSTANCE);\r\n    }\r\n    try (InputStream inputStream = Compress687Test.class.getClassLoader().getResourceAsStream(FIXTURE);\r\n        Pack200CompressorInputStream compressInputStream = new Pack200CompressorInputStream(inputStream)) {\r\n        IOUtils.copy(compressInputStream, NullOutputStream.INSTANCE);\r\n    }\r\n    if (Boolean.getBoolean(\"Compress687Test.sysout\")) {\r\n        System.out.println(\"Done.\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testBandSet_decodeBandInt",
  "sourceCode" : "/**\r\n * Tests bad input detected in org.apache.commons.compress.harmony.unpack200.CpBands.parseCpUtf8(InputStream).\r\n *\r\n * An {@link IOException} wraps an {@link ArrayIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testBandSet_decodeBandInt() {\r\n    assertThrowsIOException(\"yv7QDQeWZxAEDXNJEBAuEBAQAQAAAABDAIAQEC8Q7RAQEPYAAAD/////ARAQCgoKCgo0CgoKCgoKCgoKCgoKJwAAAAoKLf4\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAcQQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAPD+/v7+/v7+/v7+\" + \"/v7+/v7+/////wEAAAAAAAAAAAAAAAAQ//7+JZAoDQc=\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testBandSet_getReferences",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.unpack200.BandSet.getReferences(int[], String[])}.\r\n *\r\n * An {@link IOException} wraps an {@link ArrayIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testBandSet_getReferences() {\r\n    assertThrowsIOException(\"yv7QDQeWAgICAgMCAgICAv////8CAgAAAAINAAAAAAAAAAAAAAAAAAAAAAAAAAAAgBAC\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testBandSet_parseCPUTF8References",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.unpack200.CpBands.cpUTF8Value(int)}.\r\n *\r\n * An {@link IOException} wraps an {@link ArrayIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testBandSet_parseCPUTF8References() {\r\n    assertThrowsIOException(\"yv7QDQeWEBAQEBAQEBAQEBAAAQAABhAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAJSxkAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACUsZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAEAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8WAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASwAAAIAA\" + \"AAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAO3t7e3t7e3t7e3tAAAAAAAQ5xAQBhAQEBAQEBAQECgNBxcXFxc=\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testClassBands_getCallCount",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.unpack200.ClassBands.getCallCount(int[][], long[][], int)}.\r\n *\r\n * An {@link IOException} wraps an {@link NullPointerException}.\r\n */\r\n@Test\r\npublic void testClassBands_getCallCount() {\r\n    assertThrowsIOException(\"yv7QDQeWEBAQEBAQEBAQEBAAAAAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////////////////////////////////EBAQEBAQKA0H\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testClassBands_parseClassAttrBands",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.unpack200.ClassBands.parseClassAttrBands(InputStream)}.\r\n *\r\n * An {@link IOException} wraps an {@link ArrayIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testClassBands_parseClassAttrBands() {\r\n    assertThrowsIOException(\"yv7QDQeWEBAQEBAQEBAQEBAQEBAQEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADLAAAAAAAAWiAAAAAAAAAlLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAADYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABDnEBAQEBAQ\" + \"EBAQEBAoDQc=\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testCpBands_cpUTF8Value",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.unpack200.CpBands.cpUTF8Value(int)}.\r\n *\r\n * An {@link IOException} wraps an {@link ArrayIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testCpBands_cpUTF8Value() {\r\n    assertThrowsIOException(\"yv7QDQeWEBgQEBAQEBAQEBAQEBAQEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAQAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAMcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAlLGQAAAAAAAAAAAAAAADj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+PjAAAAAACRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACUsAA\" + \"AAAAAAAAAAAAAAAGVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWU0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0RzQ0NDQ0NDQ0\" + \"NDQ0NAAAAAAAAAAAAAAAAAAAoKCgoKCgoKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAEAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAZS5jb21tb25zLmNvbXByZXNzLmhhcm1vbnk+dW5wYWNrMzcwLlBhY2syMDBVbnBhY2tlckFkYQAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKCgoKCgoKCgAAAAAAAlLGQAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAvAAAAEOcQEBAQEBAQEBAQECgNBw==\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testCpBands_parseCpUtf8",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.unpack200.CpBands.parseCpUtf8(InputStream)}.\r\n *\r\n * An {@link IOException} wraps an {@link StringIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testCpBands_parseCpUtf8() {\r\n    assertThrowsIOException(\"yv7QDQeWEAMDAwMDAxAAAAAQKhAQEBAQKAYGBgYGBgYAECoQEBAQECj//5j/\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testMetadataBandGroup_getNextValue",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.unpack200.MetadataBandGroup.getNextValue(int)}.\r\n *\r\n * An {@link IOException} wraps an {@link NegativeArraySizeException}.\r\n */\r\n@Test\r\npublic void testMetadataBandGroup_getNextValue() {\r\n    assertThrowsIOException(\"yv7QDQeWEBAQEBAQEBAQEBAQEBAQEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAEAAAYACQAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAxwAAAAAAAAAAAAAAAAAAAAAAAAAA4+Pj4+Pj4+Pj4+NbW1tbW1tbW1tbW1tbW1tbW1tbW1tbqltbW1tb\" + \"W1tbW1tbW1tbW1tbW1tbW1tbBQUFBQUKBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ\" + \"UFBQUFBQUFBQUFBQUFBVtbW1tbWwBbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1vj4+Pj4wAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAIAAAAAAAAAAAAAAAD5////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJUVlZWVldZQAAAAAAAAAAAAA=\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testMetadataBandGroup_getNextValue2",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.unpack200.MetadataBandGroup.getNextValue(int)}.\r\n *\r\n * An {@link IOException} wraps an {@link ArrayIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testMetadataBandGroup_getNextValue2() {\r\n    assertThrowsIOException(\"yv7QDQeWEBAQEBAQEBAQEBAQEBAQEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAEAAAYAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAxwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACUsZAAAAAAAAAAAAAAA\" + \"AOPj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+MAAAAAAJEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXQAAAAAA4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+\" + \"NbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sjW1tbWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAD/////////\" + \"////////////////AAb//////////////////////////////////////////////////////////////////////wAF//////////////////////////////////8AAAAAAAAAAA\" + \"AAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAACgAAAAA\" + \"AAAAAAAAAAAA\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testPopulationCodec_decodeInts",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.pack200.PopulationCodec.decodeInts(int, InputStream)}.\r\n *\r\n * An {@link IOException} wraps an {@link ArrayIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testPopulationCodec_decodeInts() {\r\n    assertThrowsIOException(\"yv7QDQeWgYGBgYGBgYGBgYGBhYUwhYWFhYV6enp6enp6hYWFhYWFhYWFhYWFhYWFhY2FhYWFhYWFh4WFhYWFhYVAhYWFhX2F\" + \"hYWFhYWFjoWFhY2FhYWFhYWFhYWFhYqFhYUHlmcQEBArEBAQLhAQEBAQEBCTATeTk5OTk5OTk5N1fJMrEBAQEBD2AAAAzQAAAAEAAgAA+wAHlmcQEBAAACsAJQAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAP7///+AAAAAAAAAAAAAAAAAAAAAAAAAAAAA/v///xAQLhAQEBAQEAAAsw==\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200CompressorInputStreamTest.java",
  "methodName" : "testRunCodec_decodeInts",
  "sourceCode" : "/**\r\n * Tests bad input detected in {@code org.apache.commons.compress.harmony.pack200.PopulationCodec.decodeInts(int, InputStream)}.\r\n *\r\n * An {@link IOException} wraps an {@link ArrayIndexOutOfBoundsException}.\r\n */\r\n@Test\r\npublic void testRunCodec_decodeInts() {\r\n    assertThrowsIOException(\"yv7QDQeWgYGBgYGBgYGBgYGBhYUwhYWFhYV6enp6enp6hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFh4WFhYWFhYWFhYWFhYWF\" + \"hYWFhYWFjoWFjYWFhYWFhYWFhYWFhYWFhYUHlmcQEBArEBAQLhAQEBAQEBCTATeTk5OTk5OTk5N1fJMrEBAQEBD2AAAA/////wEAAgAA+wBaB9ANB5ZnEBAQKxAQEC4QEBAQEB\" + \"AQkwE3k5OTk5OTk5OTdXyTk3qKbP0AAAAAALM=\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200UtilsTest.java",
  "methodName" : "testCompress675",
  "sourceCode" : "/**\r\n * Tests https://issues.apache.org/jira/browse/COMPRESS-675\r\n *\r\n * Put 2 pack files inside an archive and then try to unpack them.\r\n * @throws Exception Test failure.\r\n */\r\n@Test\r\nvoid testCompress675() throws Exception {\r\n    // put 2 pack files inside an archive and then try to unpack them.\r\n    final File pack = getFile(\"bla.pack\");\r\n    final File archiveFile = createTempFile();\r\n    final long expectedCount;\r\n    try (UnsynchronizedByteArrayOutputStream bos = UnsynchronizedByteArrayOutputStream.builder().get();\r\n        Pack200CompressorInputStream inputStream = new Pack200CompressorInputStream(new FileInputStream(pack))) {\r\n        IOUtils.copy(inputStream, bos);\r\n        expectedCount = bos.size() * 2;\r\n    }\r\n    try (OutputStream os = new FileOutputStream(archiveFile);\r\n        TarArchiveOutputStream taos = new TarArchiveOutputStream(os)) {\r\n        final TarArchiveEntry ae = taos.createArchiveEntry(pack, \"./bla.pack\");\r\n        taos.putArchiveEntry(ae);\r\n        try (FileInputStream in = new FileInputStream(pack)) {\r\n            IOUtils.copy(in, taos);\r\n        }\r\n        taos.closeArchiveEntry();\r\n        final TarArchiveEntry ae2 = taos.createArchiveEntry(pack, \"./bla2.pack\");\r\n        taos.putArchiveEntry(ae2);\r\n        try (FileInputStream in = new FileInputStream(pack)) {\r\n            IOUtils.copy(in, taos);\r\n        }\r\n        taos.closeArchiveEntry();\r\n        taos.finish();\r\n        taos.flush();\r\n    }\r\n    // The underlying ChannelInputStream is what causes the problem\r\n    // FileInputStream doesn't show the bug\r\n    //\r\n    // If you use a zip archive instead of a tar archive you\r\n    // get a different number of bytes read, but still not the expected\r\n    try (TarArchiveInputStream in = TarArchiveInputStream.builder().setFile(archiveFile).get()) {\r\n        ArchiveEntry entry = in.getNextEntry();\r\n        int entries = 0;\r\n        long count = 0;\r\n        while (entry != null) {\r\n            if (in.canReadEntryData(entry)) {\r\n                @SuppressWarnings(\"resource\")\r\n                final CloseShieldInputStream wrap = CloseShieldInputStream.wrap(in);\r\n                count += parseEntry(wrap);\r\n                entries++;\r\n            }\r\n            entry = in.getNextEntry();\r\n        }\r\n        assertEquals(2, entries);\r\n        assertEquals(expectedCount, count);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200UtilsTest.java",
  "methodName" : "testNormalize",
  "sourceCode" : "@Test\r\nvoid testNormalize() throws Throwable {\r\n    final File input = getFile(\"bla.jar\");\r\n    final File output = createTempFile();\r\n    Pack200Utils.normalize(input, output, new HashMap<>());\r\n    try (InputStream is = Files.newInputStream(output.toPath());\r\n        ArchiveInputStream<?> in = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"jar\", is)) {\r\n        in.forEach(entry -> {\r\n            final File archiveEntry = newTempFile(entry.getName());\r\n            archiveEntry.getParentFile().mkdirs();\r\n            if (entry.isDirectory()) {\r\n                archiveEntry.mkdir();\r\n            } else {\r\n                Files.copy(in, archiveEntry.toPath());\r\n            }\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\pack200\\Pack200UtilsTest.java",
  "methodName" : "testNormalizeInPlace",
  "sourceCode" : "@Test\r\nvoid testNormalizeInPlace() throws Throwable {\r\n    final File input = getFile(\"bla.jar\");\r\n    final File output = createTempFile();\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        Files.copy(is, output.toPath(), StandardCopyOption.REPLACE_EXISTING);\r\n    }\r\n    Pack200Utils.normalize(output);\r\n    try (InputStream is = Files.newInputStream(output.toPath());\r\n        ArchiveInputStream<?> in = ArchiveStreamFactory.DEFAULT.createArchiveInputStream(\"jar\", is)) {\r\n        in.forEach(entry -> {\r\n            final File archiveEntry = newTempFile(entry.getName());\r\n            archiveEntry.getParentFile().mkdirs();\r\n            if (entry.isDirectory()) {\r\n                archiveEntry.mkdir();\r\n            } else {\r\n                Files.copy(in, archiveEntry.toPath());\r\n            }\r\n        });\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testBadSignature",
  "sourceCode" : "@Test\r\nvoid testBadSignature() throws Exception {\r\n    try (InputStream is = newInputStream(\"bla.jar\")) {\r\n        final byte[] sig = new byte[4];\r\n        is.read(sig);\r\n        assertFalse(Pack200CompressorInputStream.matches(sig, 4));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testGoodSignature",
  "sourceCode" : "@Test\r\nvoid testGoodSignature() throws Exception {\r\n    try (InputStream is = newInputStream(\"bla.pack\")) {\r\n        final byte[] sig = new byte[4];\r\n        is.read(sig);\r\n        assertTrue(Pack200CompressorInputStream.matches(sig, 4));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testInputStreamMethods",
  "sourceCode" : "@Test\r\nvoid testInputStreamMethods() throws Exception {\r\n    final Map<String, String> m = new HashMap<>();\r\n    m.put(\"foo\", \"bar\");\r\n    try (InputStream is = new Pack200CompressorInputStream(newInputStream(\"bla.jar\"), m)) {\r\n        // packed file is a jar, which is a ZIP, so it starts with\r\n        // a local file header\r\n        assertTrue(is.markSupported());\r\n        is.mark(5);\r\n        assertEquals(0x50, is.read());\r\n        final byte[] rest = new byte[3];\r\n        assertEquals(3, is.read(rest));\r\n        assertEquals(0x4b, rest[0]);\r\n        assertEquals(3, rest[1]);\r\n        assertEquals(4, rest[2]);\r\n        assertEquals(1, is.skip(1));\r\n        is.reset();\r\n        assertEquals(0x50, is.read());\r\n        assertTrue(is.available() > 0);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testJarArchiveCreationInMemory",
  "sourceCode" : "@Test\r\nvoid testJarArchiveCreationInMemory() throws Exception {\r\n    jarArchiveCreation(Pack200Strategy.IN_MEMORY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testJarArchiveCreationTempFile",
  "sourceCode" : "@Test\r\nvoid testJarArchiveCreationTempFile() throws Exception {\r\n    jarArchiveCreation(Pack200Strategy.TEMP_FILE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testJarUnarchiveAllFileArgInMemory",
  "sourceCode" : "@Test\r\nvoid testJarUnarchiveAllFileArgInMemory() throws Exception {\r\n    jarUnarchiveAll(true, Pack200Strategy.IN_MEMORY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testJarUnarchiveAllFileTempFile",
  "sourceCode" : "@Test\r\nvoid testJarUnarchiveAllFileTempFile() throws Exception {\r\n    jarUnarchiveAll(true, Pack200Strategy.TEMP_FILE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testJarUnarchiveAllInMemory",
  "sourceCode" : "@Test\r\nvoid testJarUnarchiveAllInMemory() throws Exception {\r\n    jarUnarchiveAll(false, Pack200Strategy.IN_MEMORY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testJarUnarchiveAllTempFile",
  "sourceCode" : "@Test\r\nvoid testJarUnarchiveAllTempFile() throws Exception {\r\n    jarUnarchiveAll(false, Pack200Strategy.TEMP_FILE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testMultiByteReadFromMemoryConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadFromMemoryConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(Pack200Strategy.IN_MEMORY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testMultiByteReadFromTempFileConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadFromTempFileConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(Pack200Strategy.TEMP_FILE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testOutputStreamMethods",
  "sourceCode" : "@Test\r\nvoid testOutputStreamMethods() throws Exception {\r\n    final File output = newTempFile(\"bla.pack\");\r\n    final Map<String, String> m = new HashMap<>();\r\n    m.put(\"foo\", \"bar\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath());\r\n        Pack200CompressorOutputStream os = new Pack200CompressorOutputStream(out, m)) {\r\n        os.write(1);\r\n        os.write(new byte[] { 2, 3 });\r\n        os.close();\r\n        assertTrue(os.isClosed());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testShortSignature",
  "sourceCode" : "@Test\r\nvoid testShortSignature() throws Exception {\r\n    try (InputStream is = newInputStream(\"bla.pack\")) {\r\n        final byte[] sig = new byte[2];\r\n        is.read(sig);\r\n        assertFalse(Pack200CompressorInputStream.matches(sig, 2));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testSingleByteReadFromMemoryConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadFromMemoryConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(Pack200Strategy.IN_MEMORY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\Pack200Test.java",
  "methodName" : "testSingleByteReadFromTempFileConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadFromTempFileConsistentlyReturnsMinusOneAtEof() throws Exception {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(Pack200Strategy.TEMP_FILE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testAvailable",
  "sourceCode" : "@Test\r\nvoid testAvailable() throws Exception {\r\n    try (InputStream isSz = newInputStream(\"mixed.txt.sz\");\r\n        FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(isSz)) {\r\n        // no chunk read so far\r\n        assertEquals(0, in.available());\r\n        assertEquals('1', in.read());\r\n        // remainder of first uncompressed block\r\n        assertEquals(3, in.available());\r\n        assertEquals(3, in.read(new byte[5], 0, 3));\r\n        assertEquals('5', in.read());\r\n        // end of chunk, must read next one\r\n        assertEquals(0, in.available());\r\n        assertEquals(4, in.read(new byte[5], 0, 4));\r\n        assertEquals('5', in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testChecksumUnmasking",
  "sourceCode" : "@Test\r\nvoid testChecksumUnmasking() {\r\n    testChecksumUnmasking(0xc757L);\r\n    testChecksumUnmasking(0xffffc757L);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testFinishWithNoWrite",
  "sourceCode" : "@Test\r\nvoid testFinishWithNoWrite() throws IOException {\r\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    try (FramedSnappyCompressorOutputStream compressor = new FramedSnappyCompressorOutputStream(buffer)) {\r\n        // do nothing here. this will test that flush on close doesn't throw any exceptions if no data is written.\r\n    }\r\n    assertTrue(buffer.size() == 10, \"Only the signature gets written.\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testLoremIpsum",
  "sourceCode" : "/**\r\n * Something big enough to make buffers slide.\r\n */\r\n@Test\r\nvoid testLoremIpsum() throws Exception {\r\n    final Path outputSz = newTempPath(\"lorem-ipsum.1\");\r\n    final Path outputGz = newTempPath(\"lorem-ipsum.2\");\r\n    try (InputStream isSz = newInputStream(\"lorem-ipsum.txt.sz\")) {\r\n        try (InputStream in = new FramedSnappyCompressorInputStream(isSz)) {\r\n            Files.copy(in, outputSz);\r\n        }\r\n        try (InputStream isGz = newInputStream(\"lorem-ipsum.txt.gz\");\r\n            InputStream in = new GzipCompressorInputStream(isGz)) {\r\n            Files.copy(in, outputGz);\r\n        }\r\n    }\r\n    assertArrayEquals(Files.readAllBytes(outputSz), Files.readAllBytes(outputGz));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testMatches",
  "sourceCode" : "@Test\r\nvoid testMatches() throws IOException {\r\n    assertFalse(FramedSnappyCompressorInputStream.matches(new byte[10], 10));\r\n    final byte[] expected = readAllBytes(\"bla.tar.sz\");\r\n    assertFalse(FramedSnappyCompressorInputStream.matches(expected, 9));\r\n    assertTrue(FramedSnappyCompressorInputStream.matches(expected, 10));\r\n    assertTrue(FramedSnappyCompressorInputStream.matches(expected, 12));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tar.sz\");\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testReadIWAFile",
  "sourceCode" : "@Test\r\nvoid testReadIWAFile() throws Exception {\r\n    try (ZipFile zip = ZipFile.builder().setFile(getFile(\"testNumbersNew.numbers\")).get()) {\r\n        try (InputStream is = zip.getInputStream(zip.getEntry(\"Index/Document.iwa\"))) {\r\n            try (FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(is, FramedSnappyDialect.IWORK_ARCHIVE)) {\r\n                Files.copy(in, newTempFile(\"snappyIWATest.raw\").toPath());\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testReadIWAFileWithBiggerOffset",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-358\"\r\n */\r\n@Test\r\nvoid testReadIWAFileWithBiggerOffset() throws Exception {\r\n    final File o = newTempFile(\"COMPRESS-358.raw\");\r\n    try (InputStream is = newInputStream(\"COMPRESS-358.iwa\");\r\n        FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(is, 1 << 16, FramedSnappyDialect.IWORK_ARCHIVE)) {\r\n        Files.copy(in, o.toPath());\r\n    }\r\n    try (InputStream a = Files.newInputStream(o.toPath());\r\n        InputStream e = newInputStream(\"COMPRESS-358.uncompressed\")) {\r\n        final byte[] expected = IOUtils.toByteArray(e);\r\n        final byte[] actual = IOUtils.toByteArray(a);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testRemainingChunkTypes",
  "sourceCode" : "@Test\r\nvoid testRemainingChunkTypes() throws Exception {\r\n    try (ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n        InputStream isSz = newInputStream(\"mixed.txt.sz\");\r\n        FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(isSz)) {\r\n        IOUtils.copy(in, out);\r\n        assertArrayEquals(new byte[] { '1', '2', '3', '4', '5', '6', '7', '8', '9', '5', '6', '7', '8', '9', '5', '6', '7', '8', '9', '5', '6', '7', '8', '9', '5', '6', '7', '8', '9', 10, '1', '2', '3', '4', '1', '2', '3', '4' }, out.toByteArray());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"bla.tar.sz\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testUnskippableChunk",
  "sourceCode" : "@Test\r\nvoid testUnskippableChunk() {\r\n    final byte[] input = { (byte) 0xff, 6, 0, 0, 's', 'N', 'a', 'P', 'p', 'Y', 2, 2, 0, 0, 1, 1 };\r\n    try (FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(new ByteArrayInputStream(input))) {\r\n        final IOException exception = assertThrows(CompressorException.class, () -> in.read());\r\n        assertTrue(exception.getMessage().contains(\"Unskippable chunk\"));\r\n    } catch (final IOException ex) {\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testWriteByteArrayVsWriteByte",
  "sourceCode" : "@Test\r\nvoid testWriteByteArrayVsWriteByte() throws IOException {\r\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    final byte[] bytes = \"abcdefghijklmnop\".getBytes();\r\n    try (FramedSnappyCompressorOutputStream compressor = new FramedSnappyCompressorOutputStream(buffer)) {\r\n        compressor.write(bytes);\r\n        compressor.finish();\r\n        compressor.close();\r\n        assertTrue(compressor.isClosed());\r\n    }\r\n    final byte[] bulkOutput = buffer.toByteArray();\r\n    buffer = new ByteArrayOutputStream();\r\n    try (FramedSnappyCompressorOutputStream compressor = new FramedSnappyCompressorOutputStream(buffer)) {\r\n        for (final byte element : bytes) {\r\n            compressor.write(element);\r\n        }\r\n        compressor.finish();\r\n        compressor.close();\r\n        assertTrue(compressor.isClosed());\r\n    }\r\n    assertArrayEquals(bulkOutput, buffer.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\FramedSnappyCompressorInputStreamTest.java",
  "methodName" : "testWriteDataLargerThanBufferOneCall",
  "sourceCode" : "@Test\r\nvoid testWriteDataLargerThanBufferOneCall() throws IOException {\r\n    final int inputSize = 500_000;\r\n    final byte[] data = generateTestData(inputSize);\r\n    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\r\n    try (FramedSnappyCompressorOutputStream compressor = new FramedSnappyCompressorOutputStream(outputStream)) {\r\n        compressor.write(data, 0, data.length);\r\n        compressor.finish();\r\n    }\r\n    final byte[] compressed = outputStream.toByteArray();\r\n    byte[] decompressed = {};\r\n    try (ByteArrayInputStream bytesIn = new ByteArrayInputStream(compressed, 0, compressed.length);\r\n        FramedSnappyCompressorInputStream decompressor = new FramedSnappyCompressorInputStream(bytesIn)) {\r\n        int i;\r\n        final ByteArrayOutputStream decompressedOutputStream = new ByteArrayOutputStream();\r\n        while (-1 != (i = decompressor.read())) {\r\n            decompressedOutputStream.write(i);\r\n        }\r\n        decompressed = decompressedOutputStream.toByteArray();\r\n    }\r\n    assertArrayEquals(data, decompressed);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\SnappyRoundtripTest.java",
  "methodName" : "testBiggerFileRoundtrip",
  "sourceCode" : "// yields no compression at all\r\n@Test\r\nvoid testBiggerFileRoundtrip() throws IOException {\r\n    roundTripTest(\"COMPRESS-256.7z\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\SnappyRoundtripTest.java",
  "methodName" : "testBlaTarRoundtrip",
  "sourceCode" : "// should yield decent compression\r\n@Test\r\nvoid testBlaTarRoundtrip() throws IOException {\r\n    // System.err.println(\"Configuration: default\");\r\n    roundTripTest(\"bla.tar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\SnappyRoundtripTest.java",
  "methodName" : "testBlaTarRoundtripTunedForCompressionRatio",
  "sourceCode" : "@Test\r\nvoid testBlaTarRoundtripTunedForCompressionRatio() throws IOException {\r\n    // System.err.println(\"Configuration: tuned for compression ratio\");\r\n    roundTripTest(getPath(\"bla.tar\"), SnappyCompressorOutputStream.createParameterBuilder(SnappyCompressorInputStream.DEFAULT_BLOCK_SIZE).tunedForCompressionRatio().build());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\SnappyRoundtripTest.java",
  "methodName" : "testBlaTarRoundtripTunedForSpeed",
  "sourceCode" : "@Test\r\nvoid testBlaTarRoundtripTunedForSpeed() throws IOException {\r\n    // System.err.println(\"Configuration: tuned for speed\");\r\n    roundTripTest(getPath(\"bla.tar\"), SnappyCompressorOutputStream.createParameterBuilder(SnappyCompressorInputStream.DEFAULT_BLOCK_SIZE).tunedForSpeed().build());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\SnappyRoundtripTest.java",
  "methodName" : "testGzippedLoremIpsumRoundtrip",
  "sourceCode" : "// yields no compression at all\r\n@Test\r\nvoid testGzippedLoremIpsumRoundtrip() throws IOException {\r\n    roundTripTest(\"lorem-ipsum.txt.gz\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\SnappyRoundtripTest.java",
  "methodName" : "testTryReallyBigOffset",
  "sourceCode" : "@Test\r\nvoid testTryReallyBigOffset() throws IOException {\r\n    // \"normal\" Snappy files will never reach offsets beyond\r\n    // 16bits (i.e. those using four bytes to encode the length)\r\n    // as the block size is only 32k. This means we never execute\r\n    // the code for four-byte length copies in either stream class\r\n    // using real-world Snappy files.\r\n    // This is an artificial stream using a bigger block size that\r\n    // may not even be expandable by other Snappy implementations.\r\n    // Start with the four byte sequence 0000 after that add > 64k\r\n    // of random noise that doesn't contain any 0000 at all, then\r\n    // add 0000.\r\n    final ByteArrayOutputStream fs = new ByteArrayOutputStream((1 << 16) + 1024);\r\n    fs.write(0);\r\n    fs.write(0);\r\n    fs.write(0);\r\n    fs.write(0);\r\n    final int cnt = 1 << 16 + 5;\r\n    final Random r = new Random();\r\n    for (int i = 0; i < cnt; i++) {\r\n        fs.write(r.nextInt(255) + 1);\r\n    }\r\n    fs.write(0);\r\n    fs.write(0);\r\n    fs.write(0);\r\n    fs.write(0);\r\n    roundTripTest(fs.toByteArray(), newParameters(1 << 17, 4, 64, 1 << 17 - 1, 1 << 17 - 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\snappy\\SnappyRoundtripTest.java",
  "methodName" : "testTryReallyLongLiterals",
  "sourceCode" : "@Test\r\nvoid testTryReallyLongLiterals() throws IOException {\r\n    // \"normal\" Snappy files will never reach literal blocks with\r\n    // length beyond 16bits (i.e. those using three or four bytes\r\n    // to encode the length) as the block size is only 32k. This\r\n    // means we never execute the code for the three/four byte\r\n    // length literals in either stream class using real-world\r\n    // Snappy files.\r\n    // What we'd need would be a sequence of bytes with no four\r\n    // byte subsequence repeated that is longer than 64k, we try\r\n    // our best with random, but will probably only hit the three byte\r\n    // methods in a few lucky cases.\r\n    // The four byte methods would require even more luck and a\r\n    // buffer (and a file written to disk) that was 2^5 bigger\r\n    // than the buffer used here.\r\n    final Path path = newTempPath(\"reallyBigLiteralTest\");\r\n    try (OutputStream outputStream = Files.newOutputStream(path)) {\r\n        final int cnt = 1 << 19;\r\n        final Random r = new Random();\r\n        for (int i = 0; i < cnt; i++) {\r\n            outputStream.write(r.nextInt(256));\r\n        }\r\n    }\r\n    roundTripTest(path, newParameters(1 << 18, 4, 64, 1 << 16 - 1, 1 << 18 - 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofDecompressConcatenated",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofDecompressConcatenated() throws IOException {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEofNoDecompressConcatenated",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEofNoDecompressConcatenated() throws IOException {\r\n    multiByteReadConsistentlyReturnsMinusOneAtEof(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorInputStreamTest.java",
  "methodName" : "testRedundantTestOfAlmostDeprecatedMatchesMethod",
  "sourceCode" : "@Test\r\nvoid testRedundantTestOfAlmostDeprecatedMatchesMethod() {\r\n    final byte[] data = { (byte) 0xFD, '7', 'z', 'X', 'Z', '\\0' };\r\n    assertFalse(XZCompressorInputStream.matches(data, 5));\r\n    assertTrue(XZCompressorInputStream.matches(data, 6));\r\n    assertTrue(XZCompressorInputStream.matches(data, 7));\r\n    data[5] = '0';\r\n    assertFalse(XZCompressorInputStream.matches(data, 6));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofDecompressConcatenated",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofDecompressConcatenated() throws IOException {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEofNoDecompressConcatenated",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEofNoDecompressConcatenated() throws IOException {\r\n    singleByteReadConsistentlyReturnsMinusOneAtEof(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorOutputStreamTest.java",
  "methodName" : "testWrite",
  "sourceCode" : "@Test\r\nvoid testWrite() throws IOException {\r\n    final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(4590);\r\n    try (XZCompressorOutputStream xZCompressorOutputStream = new XZCompressorOutputStream(byteArrayOutputStream)) {\r\n        xZCompressorOutputStream.write(4590);\r\n        xZCompressorOutputStream.close();\r\n        assertTrue(xZCompressorOutputStream.isClosed());\r\n    }\r\n    try (XZCompressorInputStream xZCompressorInputStream = new XZCompressorInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()))) {\r\n        assertEquals(4590 % 256, xZCompressorInputStream.read());\r\n        assertEquals(-1, xZCompressorInputStream.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorRoundtripTest.java",
  "methodName" : "testBuilderOptions",
  "sourceCode" : "@CartesianTest\r\nvoid testBuilderOptions(@Values(ints = { LZMA2Options.PRESET_MAX, LZMA2Options.PRESET_MIN, LZMA2Options.PRESET_DEFAULT }) final int preset, @Values(booleans = { false, true }) final boolean decompressConcatenated, @Values(ints = { -1, 100_000 }) final int memoryLimitKiB) throws IOException {\r\n    roundtrip(tempDir.resolve(\"out.xz\"), new LZMA2Options(preset), false, -1);\r\n}",
  "annotations" : [ "CartesianTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorRoundtripTest.java",
  "methodName" : "testBuilderOptionsAll",
  "sourceCode" : "@Test\r\nvoid testBuilderOptionsAll() throws IOException {\r\n    final int dictSize = LZMA2Options.DICT_SIZE_MIN;\r\n    final int lc = LZMA2Options.LC_LP_MAX - 4;\r\n    final int lp = LZMA2Options.LC_LP_MAX - 4;\r\n    final int pb = LZMA2Options.PB_MAX;\r\n    final int mode = LZMA2Options.MODE_NORMAL;\r\n    final int niceLen = LZMA2Options.NICE_LEN_MIN;\r\n    final int mf = LZMA2Options.MF_BT4;\r\n    final int depthLimit = 50;\r\n    roundtrip(tempDir.resolve(\"out.xz\"), new LZMA2Options(dictSize, lc, lp, pb, mode, niceLen, mf, depthLimit), false, -1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorRoundtripTest.java",
  "methodName" : "testBuilderOptionsDefgault",
  "sourceCode" : "@CartesianTest\r\nvoid testBuilderOptionsDefgault(@Values(booleans = { false, true }) final boolean decompressConcatenated, @Values(ints = { -1, 100_000 }) final int memoryLimitKiB) throws IOException {\r\n    roundtrip(tempDir.resolve(\"out.xz\"), new LZMA2Options(), decompressConcatenated, memoryLimitKiB);\r\n}",
  "annotations" : [ "CartesianTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZCompressorRoundtripTest.java",
  "methodName" : "testBuilderPath",
  "sourceCode" : "@Test\r\nvoid testBuilderPath() throws IOException {\r\n    // This test does not use LZMA2Options\r\n    final String data = \"Hello World!\";\r\n    final Path outPath = tempDir.resolve(\"out.xz\");\r\n    try (XZCompressorOutputStream out = XZCompressorOutputStream.builder().setPath(outPath).get()) {\r\n        out.writeUtf8(data);\r\n    }\r\n    // deprecated\r\n    try (XZCompressorInputStream out = new XZCompressorInputStream(Files.newInputStream(outPath), false)) {\r\n        assertEquals(data, IOUtils.toString(out, StandardCharsets.UTF_8));\r\n    }\r\n    // deprecated\r\n    try (XZCompressorInputStream out = new XZCompressorInputStream(Files.newInputStream(outPath), false, -1)) {\r\n        assertEquals(data, IOUtils.toString(out, StandardCharsets.UTF_8));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZUtilsTest.java",
  "methodName" : "testCachingIsEnabledByDefaultAndXZIsPresent",
  "sourceCode" : "@Test\r\nvoid testCachingIsEnabledByDefaultAndXZIsPresent() {\r\n    assertEquals(XZUtils.CachedAvailability.CACHED_AVAILABLE, XZUtils.getCachedXZAvailability());\r\n    assertTrue(XZUtils.isXZCompressionAvailable());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZUtilsTest.java",
  "methodName" : "testCanTurnOffCaching",
  "sourceCode" : "@Test\r\nvoid testCanTurnOffCaching() {\r\n    try {\r\n        XZUtils.setCacheXZAvailablity(false);\r\n        assertEquals(XZUtils.CachedAvailability.DONT_CACHE, XZUtils.getCachedXZAvailability());\r\n        assertTrue(XZUtils.isXZCompressionAvailable());\r\n    } finally {\r\n        XZUtils.setCacheXZAvailablity(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZUtilsTest.java",
  "methodName" : "testGetCompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testGetCompressedFilename() {\r\n    assertEquals(\".xz\", XZUtils.getCompressedFilename(\"\"));\r\n    assertEquals(\".xz\", XZUtils.getCompressedFileName(\"\"));\r\n    assertEquals(\"x.xz\", XZUtils.getCompressedFilename(\"x\"));\r\n    assertEquals(\"x.xz\", XZUtils.getCompressedFileName(\"x\"));\r\n    assertEquals(\"x.txz\", XZUtils.getCompressedFilename(\"x.tar\"));\r\n    assertEquals(\"x.txz\", XZUtils.getCompressedFileName(\"x.tar\"));\r\n    assertEquals(\"x.wmf .xz\", XZUtils.getCompressedFilename(\"x.wmf \"));\r\n    assertEquals(\"x.wmf .xz\", XZUtils.getCompressedFileName(\"x.wmf \"));\r\n    assertEquals(\"x.wmf\\n.xz\", XZUtils.getCompressedFilename(\"x.wmf\\n\"));\r\n    assertEquals(\"x.wmf\\n.xz\", XZUtils.getCompressedFileName(\"x.wmf\\n\"));\r\n    assertEquals(\"x.wmf.y.xz\", XZUtils.getCompressedFilename(\"x.wmf.y\"));\r\n    assertEquals(\"x.wmf.y.xz\", XZUtils.getCompressedFileName(\"x.wmf.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZUtilsTest.java",
  "methodName" : "testGetUncompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testGetUncompressedFilename() {\r\n    assertEquals(\"\", XZUtils.getUncompressedFilename(\"\"));\r\n    assertEquals(\"\", XZUtils.getUncompressedFileName(\"\"));\r\n    assertEquals(\".xz\", XZUtils.getUncompressedFilename(\".xz\"));\r\n    assertEquals(\"x.tar\", XZUtils.getUncompressedFilename(\"x.txz\"));\r\n    assertEquals(\"x.tar\", XZUtils.getUncompressedFileName(\"x.txz\"));\r\n    assertEquals(\"x\", XZUtils.getUncompressedFilename(\"x.xz\"));\r\n    assertEquals(\"x\", XZUtils.getUncompressedFileName(\"x.xz\"));\r\n    assertEquals(\"x\", XZUtils.getUncompressedFilename(\"x-xz\"));\r\n    assertEquals(\"x\", XZUtils.getUncompressedFileName(\"x-xz\"));\r\n    assertEquals(\"x.txz \", XZUtils.getUncompressedFilename(\"x.txz \"));\r\n    assertEquals(\"x.txz \", XZUtils.getUncompressedFileName(\"x.txz \"));\r\n    assertEquals(\"x.txz\\n\", XZUtils.getUncompressedFilename(\"x.txz\\n\"));\r\n    assertEquals(\"x.txz\\n\", XZUtils.getUncompressedFileName(\"x.txz\\n\"));\r\n    assertEquals(\"x.txz.y\", XZUtils.getUncompressedFilename(\"x.txz.y\"));\r\n    assertEquals(\"x.txz.y\", XZUtils.getUncompressedFileName(\"x.txz.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZUtilsTest.java",
  "methodName" : "testIsCompressedFilename",
  "sourceCode" : "@SuppressWarnings(\"deprecation\")\r\n@Test\r\nvoid testIsCompressedFilename() {\r\n    assertFalse(XZUtils.isCompressedFilename(\"\"));\r\n    assertFalse(XZUtils.isCompressedFileName(\"\"));\r\n    assertFalse(XZUtils.isCompressedFilename(\".xz\"));\r\n    assertFalse(XZUtils.isCompressedFileName(\".xz\"));\r\n    assertTrue(XZUtils.isCompressedFilename(\"x.txz\"));\r\n    assertTrue(XZUtils.isCompressedFileName(\"x.txz\"));\r\n    assertTrue(XZUtils.isCompressedFilename(\"x.xz\"));\r\n    assertTrue(XZUtils.isCompressedFileName(\"x.xz\"));\r\n    assertTrue(XZUtils.isCompressedFilename(\"x-xz\"));\r\n    assertTrue(XZUtils.isCompressedFileName(\"x-xz\"));\r\n    assertFalse(XZUtils.isCompressedFilename(\"xxgz\"));\r\n    assertFalse(XZUtils.isCompressedFileName(\"xxgz\"));\r\n    assertFalse(XZUtils.isCompressedFilename(\"xzz\"));\r\n    assertFalse(XZUtils.isCompressedFileName(\"xzz\"));\r\n    assertFalse(XZUtils.isCompressedFilename(\"xaz\"));\r\n    assertFalse(XZUtils.isCompressedFileName(\"xaz\"));\r\n    assertFalse(XZUtils.isCompressedFilename(\"x.txz \"));\r\n    assertFalse(XZUtils.isCompressedFileName(\"x.txz \"));\r\n    assertFalse(XZUtils.isCompressedFilename(\"x.txz\\n\"));\r\n    assertFalse(XZUtils.isCompressedFileName(\"x.txz\\n\"));\r\n    assertFalse(XZUtils.isCompressedFilename(\"x.txz.y\"));\r\n    assertFalse(XZUtils.isCompressedFileName(\"x.txz.y\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZUtilsTest.java",
  "methodName" : "testMatches",
  "sourceCode" : "@Test\r\nvoid testMatches() {\r\n    final byte[] data = { (byte) 0xFD, '7', 'z', 'X', 'Z', '\\0' };\r\n    assertFalse(XZUtils.matches(data, 5));\r\n    assertTrue(XZUtils.matches(data, 6));\r\n    assertTrue(XZUtils.matches(data, 7));\r\n    data[5] = '0';\r\n    assertFalse(XZUtils.matches(data, 6));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\xz\\XZUtilsTest.java",
  "methodName" : "testTurningOnCachingReEvaluatesAvailability",
  "sourceCode" : "@Test\r\nvoid testTurningOnCachingReEvaluatesAvailability() {\r\n    try {\r\n        XZUtils.setCacheXZAvailablity(false);\r\n        assertEquals(XZUtils.CachedAvailability.DONT_CACHE, XZUtils.getCachedXZAvailability());\r\n        XZUtils.setCacheXZAvailablity(true);\r\n        assertEquals(XZUtils.CachedAvailability.CACHED_AVAILABLE, XZUtils.getCachedXZAvailability());\r\n    } finally {\r\n        XZUtils.setCacheXZAvailablity(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\XZTest.java",
  "methodName" : "testConcatenatedStreamsReadFirstOnly",
  "sourceCode" : "@Test\r\nvoid testConcatenatedStreamsReadFirstOnly() throws Exception {\r\n    final File input = getFile(\"multiple.xz\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"xz\", is)) {\r\n            assertEquals('a', in.read());\r\n            assertEquals(-1, in.read());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\XZTest.java",
  "methodName" : "testConcatenatedStreamsReadFully",
  "sourceCode" : "@Test\r\nvoid testConcatenatedStreamsReadFully() throws Exception {\r\n    final File input = getFile(\"multiple.xz\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new XZCompressorInputStream(is, true)) {\r\n            assertEquals('a', in.read());\r\n            assertEquals('b', in.read());\r\n            assertEquals(0, in.available());\r\n            assertEquals(-1, in.read());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\XZTest.java",
  "methodName" : "testXZCreation",
  "sourceCode" : "@Test\r\nvoid testXZCreation() throws Exception {\r\n    final long max = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getMax();\r\n    System.out.println(\"XZTestCase: HeapMax=\" + max + \" bytes \" + (double) max / (1024 * 1024) + \" MB\");\r\n    final File input = getFile(\"test1.xml\");\r\n    final File output = newTempFile(\"test1.xml.xz\");\r\n    try (OutputStream out = Files.newOutputStream(output.toPath())) {\r\n        try (CompressorOutputStream<?> cos = new CompressorStreamFactory().createCompressorOutputStream(\"xz\", out)) {\r\n            cos.write(input);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\XZTest.java",
  "methodName" : "testXZUnarchive",
  "sourceCode" : "@Test\r\nvoid testXZUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.tar.xz\");\r\n    final File output = newTempFile(\"bla.tar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"xz\", is)) {\r\n            Files.copy(in, output.toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\z\\ZCompressorInputStreamTest.java",
  "methodName" : "testFailsToCreateZCompressorInputStreamAndThrowsIOException",
  "sourceCode" : "@Test\r\nvoid testFailsToCreateZCompressorInputStreamAndThrowsIOException() throws IOException {\r\n    try (SequenceInputStream sequenceInputStream = new SequenceInputStream(Collections.emptyEnumeration())) {\r\n        assertThrows(CompressorException.class, () -> new ZCompressorInputStream(sequenceInputStream));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\z\\ZCompressorInputStreamTest.java",
  "methodName" : "testInvalidMaxCodeSize",
  "sourceCode" : "@Test\r\nvoid testInvalidMaxCodeSize() throws IOException {\r\n    final byte[] bytes = AbstractTest.readAllBytes(\"bla.tar.Z\");\r\n    // @formatter:off\r\n    final IntStream[] invalid = { IntStream.range(Byte.MIN_VALUE, -120), IntStream.range(-97, -88), IntStream.range(-65, -56), IntStream.range(-33, -24), IntStream.range(-1, 8), IntStream.range(31, 40), IntStream.range(63, 72), IntStream.range(95, 104), IntStream.range(127, 127) };\r\n    // @formatter:on\r\n    Stream.of(invalid).forEach(ints -> ints.forEach(i -> {\r\n        bytes[2] = (byte) i;\r\n        assertThrows(IllegalArgumentException.class, () -> new ZCompressorInputStream(new ByteArrayInputStream(bytes), 1024 * 1024), () -> \"value=\" + i);\r\n    }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\z\\ZCompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = AbstractTest.getFile(\"bla.tar.Z\");\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ZCompressorInputStream in = new ZCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\z\\ZCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = AbstractTest.getFile(\"bla.tar.Z\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ZCompressorInputStream in = new ZCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testCachingIsEnabledByDefaultAndZstdUtilsPresent",
  "sourceCode" : "@Test\r\nvoid testCachingIsEnabledByDefaultAndZstdUtilsPresent() {\r\n    assertEquals(ZstdUtils.CachedAvailability.CACHED_AVAILABLE, ZstdUtils.getCachedZstdAvailability());\r\n    assertTrue(ZstdUtils.isZstdCompressionAvailable());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testCanTurnOffCaching",
  "sourceCode" : "@Test\r\nvoid testCanTurnOffCaching() {\r\n    try {\r\n        ZstdUtils.setCacheZstdAvailablity(false);\r\n        assertEquals(ZstdUtils.CachedAvailability.DONT_CACHE, ZstdUtils.getCachedZstdAvailability());\r\n        assertTrue(ZstdUtils.isZstdCompressionAvailable());\r\n    } finally {\r\n        ZstdUtils.setCacheZstdAvailablity(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testMultiByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testMultiByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"zstandard.testdata.zst\");\r\n    final byte[] buf = new byte[2];\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ZstdCompressorInputStream in = new ZstdCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read(buf));\r\n        assertEquals(-1, in.read(buf));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testShouldBeAbleToSkipAByte",
  "sourceCode" : "@Test\r\nvoid testShouldBeAbleToSkipAByte() throws IOException {\r\n    final File input = getFile(\"zstandard.testdata.zst\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ZstdCompressorInputStream in = new ZstdCompressorInputStream(is)) {\r\n        assertEquals(1, in.skip(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadConsistentlyReturnsMinusOneAtEof",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadConsistentlyReturnsMinusOneAtEof() throws IOException {\r\n    final File input = getFile(\"zstandard.testdata.zst\");\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ZstdCompressorInputStream in = new ZstdCompressorInputStream(is)) {\r\n        IOUtils.toByteArray(in);\r\n        assertEquals(-1, in.read());\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testSingleByteReadWorksAsExpected",
  "sourceCode" : "@Test\r\nvoid testSingleByteReadWorksAsExpected() throws IOException {\r\n    final File input = getFile(\"zstandard.testdata.zst\");\r\n    final File original = getFile(\"zstandard.testdata\");\r\n    final long originalFileLength = original.length();\r\n    final byte[] originalFileContent = new byte[(int) originalFileLength];\r\n    try (InputStream ois = Files.newInputStream(original.toPath())) {\r\n        ois.read(originalFileContent);\r\n    }\r\n    try (InputStream is = Files.newInputStream(input.toPath());\r\n        ZstdCompressorInputStream in = new ZstdCompressorInputStream(is)) {\r\n        assertEquals(originalFileContent[0], in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testTurningOnCachingReEvaluatesAvailability",
  "sourceCode" : "@Test\r\nvoid testTurningOnCachingReEvaluatesAvailability() {\r\n    try {\r\n        ZstdUtils.setCacheZstdAvailablity(false);\r\n        assertEquals(ZstdUtils.CachedAvailability.DONT_CACHE, ZstdUtils.getCachedZstdAvailability());\r\n        ZstdUtils.setCacheZstdAvailablity(true);\r\n        assertEquals(ZstdUtils.CachedAvailability.CACHED_AVAILABLE, ZstdUtils.getCachedZstdAvailability());\r\n    } finally {\r\n        ZstdUtils.setCacheZstdAvailablity(true);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testZstandardUnarchive",
  "sourceCode" : "@Test\r\nvoid testZstandardUnarchive() throws Exception {\r\n    final File input = getFile(\"bla.tar.zst\");\r\n    final File output = newTempFile(\"bla.tar\");\r\n    try (InputStream is = Files.newInputStream(input.toPath())) {\r\n        try (CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"zstd\", is)) {\r\n            Files.copy(in, output.toPath());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testZstdDecode",
  "sourceCode" : "/**\r\n * Test bridge works fine.\r\n *\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testZstdDecode() throws IOException {\r\n    final File input = getFile(\"zstandard.testdata.zst\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ZstdCompressorInputStream zstdInputStream = new ZstdCompressorInputStream(inputStream)) {\r\n        final byte[] expected = readAllBytes(\"zstandard.testdata\");\r\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        IOUtils.copy(zstdInputStream, bos);\r\n        assertArrayEquals(expected, bos.toByteArray());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testZstdDecodeWithNoPool",
  "sourceCode" : "@Test\r\nvoid testZstdDecodeWithNoPool() throws IOException {\r\n    final File input = getFile(\"zstandard.testdata.zst\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ZstdCompressorInputStream zstdInputStream = new ZstdCompressorInputStream(inputStream, NoPool.INSTANCE)) {\r\n        final byte[] expected = readAllBytes(\"zstandard.testdata\");\r\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        IOUtils.copy(zstdInputStream, bos);\r\n        assertArrayEquals(expected, bos.toByteArray());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdCompressorInputStreamTest.java",
  "methodName" : "testZstdDecodeWithRecyclingBufferPool",
  "sourceCode" : "@Test\r\nvoid testZstdDecodeWithRecyclingBufferPool() throws IOException {\r\n    final File input = getFile(\"zstandard.testdata.zst\");\r\n    try (InputStream inputStream = Files.newInputStream(input.toPath());\r\n        ZstdCompressorInputStream zstdInputStream = new ZstdCompressorInputStream(inputStream, RecyclingBufferPool.INSTANCE)) {\r\n        final byte[] expected = readAllBytes(\"zstandard.testdata\");\r\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        IOUtils.copy(zstdInputStream, bos);\r\n        assertArrayEquals(expected, bos.toByteArray());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testDirectRoundtrip",
  "sourceCode" : "@Test\r\nvoid testDirectRoundtrip() throws Exception {\r\n    roundtrip(ZstdCompressorOutputStream::new);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testFactoryRoundtrip",
  "sourceCode" : "@Test\r\nvoid testFactoryRoundtrip() throws Exception {\r\n    final Path input = getPath(\"bla.tar\");\r\n    final File output = newTempFile(input.getFileName() + \".zstd\");\r\n    try (OutputStream os = Files.newOutputStream(output.toPath());\r\n        CompressorOutputStream<?> zos = new CompressorStreamFactory().createCompressorOutputStream(\"zstd\", os)) {\r\n        zos.write(input);\r\n    }\r\n    try (InputStream inputStream = Files.newInputStream(output.toPath());\r\n        CompressorInputStream zis = new CompressorStreamFactory().createCompressorInputStream(\"zstd\", inputStream)) {\r\n        final byte[] expected = Files.readAllBytes(input);\r\n        final byte[] actual = IOUtils.toByteArray(zis);\r\n        assertArrayEquals(expected, actual);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetChainLogNonDefaultMax",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetChainLogNonDefaultMax() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setChainLog(ZstdConstants.ZSTD_CHAINLOG_MAX).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetChainLogNonDefaultMin",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetChainLogNonDefaultMin() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setChainLog(ZstdConstants.ZSTD_CHAINLOG_MIN).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetChecksumNonDefault",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetChecksumNonDefault() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setChecksum(true).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetCloseFrameOnFlushNonDefault",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetCloseFrameOnFlushNonDefault() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setCloseFrameOnFlush(true).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetHashLogNonDefaultMax",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetHashLogNonDefaultMax() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setHashLog(ZstdConstants.ZSTD_HASHLOG_MAX).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetHashLogNonDefaultMin",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetHashLogNonDefaultMin() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setHashLog(ZstdConstants.ZSTD_HASHLOG_MIN).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetJobSizeNonDefault",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetJobSizeNonDefault() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setJobSize(1).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetLevelNonDefault",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetLevelNonDefault() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setLevel(1).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetMinMatchNonDefaultMax",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetMinMatchNonDefaultMax() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setMinMatch(ZstdConstants.ZSTD_MINMATCH_MAX).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetMinMatchNonDefaultMin",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetMinMatchNonDefaultMin() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setMinMatch(ZstdConstants.ZSTD_MINMATCH_MIN).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetOverlapLogNonDefault",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetOverlapLogNonDefault() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setOverlapLog(1).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetSearchLogNonDefault",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetSearchLogNonDefault() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setSearchLog(1).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetStrategyNonDefault",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetStrategyNonDefault() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setStrategy(1).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetWindowLogNonDefaultMax",
  "sourceCode" : "@Test\r\n@Disabled(\"com.github.luben.zstd.ZstdIOException: Frame requires too much memory for decoding\")\r\nvoid testRoundtripSetWindowLogNonDefaultMax() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setWindowLog(ZstdConstants.ZSTD_WINDOWLOG_MAX).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetWindowLogNonDefaultMin",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetWindowLogNonDefaultMin() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setWindowLog(ZstdConstants.ZSTD_WINDOWLOG_MIN).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetWorkersNonDefault",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetWorkersNonDefault() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setWorkers(1).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripSetZstdDict",
  "sourceCode" : "@Test\r\nvoid testRoundtripSetZstdDict() throws Exception {\r\n    // Avoid JVM segmentation fault in zstd-jni 1.5.7-2\r\n    // TODO Remove ternary expression in the ctor if/when https://github.com/luben/zstd-jni/pull/356 is fixed.\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setDict(null).get());\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setDict(ArrayUtils.EMPTY_BYTE_ARRAY).get());\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setDict(new byte[512]).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripWithAll",
  "sourceCode" : "@CartesianTest\r\n// @formatter:off\r\nvoid testRoundtripWithAll(// see zstd.h\r\n@Values(ints = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }) final int level, @Values(booleans = { false, true }) final boolean checksum, @Values(booleans = { false, true }) final boolean closeFrameOnFlush, // see zstd.h\r\n@Values(ints = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }) final int strategy, // see zstd.h\r\n@Values(ints = { 0, 6, 9 }) final int overlapLog) throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setChainLog(0).setChecksum(checksum).setCloseFrameOnFlush(closeFrameOnFlush).setDict(null).setHashLog(0).setJobSize(0).setLevel(level).setMinMatch(0).setOutputStream(os).setOverlapLog(overlapLog).setSearchLog(0).setStrategy(strategy).setWindowLog(0).setWorkers(0).get());\r\n}",
  "annotations" : [ "CartesianTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripWithChecksum",
  "sourceCode" : "// @formatter:on\r\n@Test\r\nvoid testRoundtripWithChecksum() throws Exception {\r\n    roundtrip(os -> new ZstdCompressorOutputStream(os, 3, false, true));\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setLevel(3).setCloseFrameOnFlush(true).setChecksum(true).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripWithCloseFrameOnFlush",
  "sourceCode" : "@Test\r\nvoid testRoundtripWithCloseFrameOnFlush() throws Exception {\r\n    roundtrip(os -> new ZstdCompressorOutputStream(os, 3, true));\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setLevel(3).setCloseFrameOnFlush(true).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripWithCustomLevel",
  "sourceCode" : "@Test\r\nvoid testRoundtripWithCustomLevel() throws Exception {\r\n    roundtrip(os -> new ZstdCompressorOutputStream(os, 1));\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(os).setLevel(1).get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdRoundtripTest.java",
  "methodName" : "testRoundtripWithZstdOutputStream",
  "sourceCode" : "@Test\r\nvoid testRoundtripWithZstdOutputStream() throws Exception {\r\n    roundtrip(os -> ZstdCompressorOutputStream.builder().setOutputStream(new ZstdOutputStream(os)).get());\r\n    roundtrip(os -> new ZstdCompressorOutputStream(new ZstdOutputStream(os)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdUtilsTest.java",
  "methodName" : "testMatchesSkippableFrame",
  "sourceCode" : "@Test\r\nvoid testMatchesSkippableFrame() {\r\n    final byte[] data = { 0, (byte) 0x2A, (byte) 0x4D, (byte) 0x18 };\r\n    assertFalse(ZstdUtils.matches(data, 4));\r\n    for (byte b = (byte) 0x50; b < 0x60; b++) {\r\n        data[0] = b;\r\n        assertTrue(ZstdUtils.matches(data, 4));\r\n    }\r\n    assertFalse(ZstdUtils.matches(data, 3));\r\n    assertTrue(ZstdUtils.matches(data, 5));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\zstandard\\ZstdUtilsTest.java",
  "methodName" : "testMatchesZstandardFrame",
  "sourceCode" : "@Test\r\nvoid testMatchesZstandardFrame() {\r\n    final byte[] data = { (byte) 0x28, (byte) 0xB5, (byte) 0x2F, (byte) 0xFD };\r\n    assertFalse(ZstdUtils.matches(data, 3));\r\n    assertTrue(ZstdUtils.matches(data, 4));\r\n    assertTrue(ZstdUtils.matches(data, 5));\r\n    data[3] = '0';\r\n    assertFalse(ZstdUtils.matches(data, 4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\ZTest.java",
  "methodName" : "testMatches",
  "sourceCode" : "@Test\r\nvoid testMatches() {\r\n    assertFalse(ZCompressorInputStream.matches(new byte[] { 1, 2, 3, 4 }, 4));\r\n    assertFalse(ZCompressorInputStream.matches(new byte[] { 0x1f, 2, 3, 4 }, 4));\r\n    assertFalse(ZCompressorInputStream.matches(new byte[] { 1, (byte) 0x9d, 3, 4 }, 4));\r\n    assertFalse(ZCompressorInputStream.matches(new byte[] { 0x1f, (byte) 0x9d, 3, 4 }, 3));\r\n    assertTrue(ZCompressorInputStream.matches(new byte[] { 0x1f, (byte) 0x9d, 3, 4 }, 4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\ZTest.java",
  "methodName" : "testZUnarchive",
  "sourceCode" : "@Test\r\nvoid testZUnarchive() throws Exception {\r\n    testUnarchive(ZCompressorInputStream::new);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\ZTest.java",
  "methodName" : "testZUnarchiveViaAutoDetection",
  "sourceCode" : "@Test\r\nvoid testZUnarchiveViaAutoDetection() throws Exception {\r\n    testUnarchive(is -> new CompressorStreamFactory().createCompressorInputStream(new BufferedInputStream(is)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\compressors\\ZTest.java",
  "methodName" : "testZUnarchiveViaFactory",
  "sourceCode" : "@Test\r\nvoid testZUnarchiveViaFactory() throws Exception {\r\n    testUnarchive(is -> new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.Z, is));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testCOMPRESS_117",
  "sourceCode" : "@Test\r\nvoid testCOMPRESS_117() throws Exception {\r\n    try (ArchiveInputStream<?> tar = createArchiveInputStream(\"COMPRESS-117.tar\")) {\r\n        assertNotNull(tar);\r\n        assertInstanceOf(TarArchiveInputStream.class, tar);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testCOMPRESS_335",
  "sourceCode" : "@Test\r\nvoid testCOMPRESS_335() throws Exception {\r\n    try (ArchiveInputStream<?> tar = createArchiveInputStream(\"COMPRESS-335.tar\")) {\r\n        assertNotNull(tar);\r\n        assertInstanceOf(TarArchiveInputStream.class, tar);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testDetection",
  "sourceCode" : "@Test\r\nvoid testDetection() throws Exception {\r\n    try (ArchiveInputStream<?> ar = createArchiveInputStream(\"bla.ar\")) {\r\n        assertNotNull(ar);\r\n        assertInstanceOf(ArArchiveInputStream.class, ar);\r\n    }\r\n    try (ArchiveInputStream<?> tar = createArchiveInputStream(\"bla.tar\")) {\r\n        assertNotNull(tar);\r\n        assertInstanceOf(TarArchiveInputStream.class, tar);\r\n    }\r\n    try (ArchiveInputStream<?> zip = createArchiveInputStream(\"bla.zip\")) {\r\n        assertNotNull(zip);\r\n        assertInstanceOf(ZipArchiveInputStream.class, zip);\r\n    }\r\n    try (ArchiveInputStream<?> jar = createArchiveInputStream(\"bla.jar\")) {\r\n        assertNotNull(jar);\r\n        assertInstanceOf(ZipArchiveInputStream.class, jar);\r\n    }\r\n    try (ArchiveInputStream<?> cpio = createArchiveInputStream(\"bla.cpio\")) {\r\n        assertNotNull(cpio);\r\n        assertInstanceOf(CpioArchiveInputStream.class, cpio);\r\n    }\r\n    try (ArchiveInputStream<?> arj = createArchiveInputStream(\"bla.arj\")) {\r\n        assertNotNull(arj);\r\n        assertInstanceOf(ArjArchiveInputStream.class, arj);\r\n    }\r\n    // Not yet implemented\r\n    //        final ArchiveInputStream<?> tgz = getStreamFor(\"bla.tgz\");\r\n    //        assertNotNull(tgz);\r\n    //        assertInstanceOf(TarArchiveInputStream.class, tgz);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testDetectionNotArchive",
  "sourceCode" : "// Check that the empty archives created by the code are readable\r\n// Not possible to detect empty \"ar\" archive as it is completely empty\r\n//    void testEmptyArArchive() throws Exception {\r\n//        emptyArchive(\"ar\");\r\n//    }\r\n@Test\r\nvoid testDetectionNotArchive() {\r\n    assertThrows(ArchiveException.class, () -> createArchiveInputStream(\"test.txt\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testDetectOldTarFormatArchive",
  "sourceCode" : "@Test\r\nvoid testDetectOldTarFormatArchive() throws Exception {\r\n    try (ArchiveInputStream<?> tar = createArchiveInputStream(\"COMPRESS-612/test-times-star-folder.tar\")) {\r\n        assertNotNull(tar);\r\n        assertInstanceOf(TarArchiveInputStream.class, tar);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testEmptyCpioArchive",
  "sourceCode" : "@Test\r\nvoid testEmptyCpioArchive() throws Exception {\r\n    checkEmptyArchive(\"cpio\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testEmptyJarArchive",
  "sourceCode" : "@Test\r\nvoid testEmptyJarArchive() throws Exception {\r\n    checkEmptyArchive(\"jar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testEmptyTarArchive",
  "sourceCode" : "@Test\r\nvoid testEmptyTarArchive() throws Exception {\r\n    // Can't detect empty tar archive from its contents.\r\n    // will be deleted by tearDown()\r\n    final Path path = createEmptyArchive(\"tar\");\r\n    assertThrows(ArchiveException.class, () -> checkDetectedType(\"tar\", path));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testEmptyZipArchive",
  "sourceCode" : "@Test\r\nvoid testEmptyZipArchive() throws Exception {\r\n    checkEmptyArchive(\"zip\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testIcoFile",
  "sourceCode" : "/**\r\n * Tests COMPRESS-644.\r\n */\r\n@Test\r\nvoid testIcoFile() {\r\n    assertThrows(ArchiveException.class, () -> {\r\n        try (InputStream in = createBufferedInputStream(\"org/apache/commons/compress/COMPRESS-644/ARW05UP.ICO\")) {\r\n            assertNull(ArchiveStreamFactory.detect(in));\r\n        }\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\DetectArchiverTest.java",
  "methodName" : "testIcoFileFirstTarArchiveEntry",
  "sourceCode" : "@Test\r\nvoid testIcoFileFirstTarArchiveEntry() throws Exception {\r\n    try (TarArchiveInputStream inputStream = TarArchiveInputStream.builder().setURI(getURI(\"org/apache/commons/compress/COMPRESS-644/ARW05UP.ICO\")).get()) {\r\n        final TarArchiveEntry entry = inputStream.getNextEntry();\r\n        // Find hints that the file is not a TAR file.\r\n        assertNull(entry.getCreationTime());\r\n        assertEquals(-1, entry.getDataOffset());\r\n        assertEquals(0, entry.getDevMajor());\r\n        assertEquals(0, entry.getDevMinor());\r\n        assertEquals(Collections.emptyMap(), entry.getExtraPaxHeaders());\r\n        assertEquals(0, entry.getGroupId());\r\n        // hint\r\n        assertFalse(isValidName(entry.getGroupName()), entry::getGroupName);\r\n        assertNull(entry.getLastAccessTime());\r\n        // hint\r\n        assertEquals(0, entry.getLastModifiedDate().getTime());\r\n        // hint\r\n        assertEquals(FileTime.from(Instant.EPOCH), entry.getLastModifiedTime());\r\n        // NUL (not really a hint)\r\n        assertEquals(0, entry.getLinkFlag());\r\n        assertEquals(\"\", entry.getLinkName());\r\n        assertEquals(0, entry.getLongGroupId());\r\n        // hint?\r\n        assertEquals(16777215, entry.getLongUserId());\r\n        // hint?\r\n        assertEquals(0, entry.getMode());\r\n        // hint?\r\n        assertEquals(0, entry.getModTime().getTime());\r\n        // hint\r\n        assertFalse(isValidName(entry.getName()), entry::getName);\r\n        assertNull(entry.getPath());\r\n        assertEquals(0, entry.getRealSize());\r\n        assertEquals(0, entry.getSize());\r\n        assertNull(entry.getStatusChangeTime());\r\n        // hint?\r\n        assertEquals(16777215, entry.getUserId());\r\n        // hint\r\n        assertFalse(isValidName(entry.getUserName()), entry::getUserName);\r\n        assertTrue(entry.isFile());\r\n        assertFalse(entry.isBlockDevice());\r\n        assertFalse(entry.isCharacterDevice());\r\n        assertTrue(entry.isCheckSumOK());\r\n        assertFalse(entry.isDirectory());\r\n        assertFalse(entry.isExtended());\r\n        assertFalse(entry.isFIFO());\r\n        assertFalse(entry.isGlobalPaxHeader());\r\n        assertFalse(entry.isGNULongLinkEntry());\r\n        assertFalse(entry.isGNULongNameEntry());\r\n        assertFalse(entry.isGNUSparse());\r\n        assertFalse(entry.isLink());\r\n        assertFalse(entry.isOldGNUSparse());\r\n        assertFalse(entry.isPaxGNU1XSparse());\r\n        assertFalse(entry.isPaxGNUSparse());\r\n        assertFalse(entry.isPaxHeader());\r\n        assertFalse(entry.isSparse());\r\n        assertFalse(entry.isStarSparse());\r\n        assertTrue(entry.isStreamContiguous());\r\n        assertFalse(entry.isSymbolicLink());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testAlternativeConstructor",
  "sourceCode" : "@Test\r\nvoid testAlternativeConstructor() throws IOException, URISyntaxException, Pack200Exception {\r\n    final File file = createTempFile(\"sql\", \".pack.gz\");\r\n    try (JarInputStream inStream = new JarInputStream(new FileInputStream(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI())));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        new Archive(inStream, out, null).pack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testAnnotations",
  "sourceCode" : "@Test\r\nvoid testAnnotations() throws IOException, Pack200Exception, URISyntaxException {\r\n    final File file = createTempFile(\"annotations\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/annotationsUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // now unpack\r\n    final File file2 = createTempFile(\"annotationsout\", \".jar\");\r\n    try (InputStream in2 = new FileInputStream(file);\r\n        JarOutputStream out2 = new JarOutputStream(new FileOutputStream(file2))) {\r\n        final org.apache.commons.compress.harmony.unpack200.Archive archive = new org.apache.commons.compress.harmony.unpack200.Archive(in2, out2);\r\n        archive.unpack();\r\n    }\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(new File(Archive.class.getResource(\"/pack200/annotationsUnpacked.jar\").toURI()))) {\r\n        compareFiles(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testAnnotations2",
  "sourceCode" : "@Test\r\nvoid testAnnotations2() throws IOException, Pack200Exception, URISyntaxException {\r\n    final File file = createTempFile(\"annotations\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/annotations.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // now unpack\r\n    final File file2 = createTempFile(\"annotationsout\", \".jar\");\r\n    try (InputStream in2 = new FileInputStream(file);\r\n        JarOutputStream out2 = new JarOutputStream(new FileOutputStream(file2))) {\r\n        final org.apache.commons.compress.harmony.unpack200.Archive archive = new org.apache.commons.compress.harmony.unpack200.Archive(in2, out2);\r\n        archive.unpack();\r\n    }\r\n    // TODO: This isn't quite right - to fix\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(new File(Archive.class.getResource(\"/pack200/annotationsRI.jar\").toURI()))) {\r\n        compareFiles(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testHelloWorld",
  "sourceCode" : "@Test\r\nvoid testHelloWorld() throws IOException, Pack200Exception, URISyntaxException {\r\n    final File file = createTempFile(\"helloworld\", \".pack.gz\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/hw.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        new Archive(in, out, null).pack();\r\n    }\r\n    // now unpack\r\n    final File file2 = createTempFile(\"helloworld\", \".jar\");\r\n    try (InputStream in2 = new FileInputStream(file);\r\n        JarOutputStream out2 = new JarOutputStream(new FileOutputStream(file2))) {\r\n        final org.apache.commons.compress.harmony.unpack200.Archive archive = new org.apache.commons.compress.harmony.unpack200.Archive(in2, out2);\r\n        archive.unpack();\r\n    }\r\n    try (JarFile jarFile = new JarFile(file2)) {\r\n        final JarEntry entry = jarFile.getJarEntry(\"org/apache/harmony/archive/tests/internal/pack200/HelloWorld.class\");\r\n        assertNotNull(entry);\r\n        try (InputStream ours = jarFile.getInputStream(entry)) {\r\n            try (JarFile jarFile2 = new JarFile(new File(Segment.class.getResource(\"/pack200/hw.jar\").toURI()))) {\r\n                final JarEntry entry2 = jarFile2.getJarEntry(\"org/apache/harmony/archive/tests/internal/pack200/HelloWorld.class\");\r\n                assertNotNull(entry2);\r\n                final InputStream expected = jarFile2.getInputStream(entry2);\r\n                try (BufferedReader reader1 = new BufferedReader(new InputStreamReader(ours));\r\n                    BufferedReader reader2 = new BufferedReader(new InputStreamReader(expected))) {\r\n                    String line1 = reader1.readLine();\r\n                    String line2 = reader2.readLine();\r\n                    int i = 1;\r\n                    while (line1 != null || line2 != null) {\r\n                        assertEquals(line2, line1, \"Unpacked class files differ, i = \" + i);\r\n                        line1 = reader1.readLine();\r\n                        line2 = reader2.readLine();\r\n                        i++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testJNDI",
  "sourceCode" : "@Test\r\nvoid testJNDI() throws IOException, Pack200Exception, URISyntaxException {\r\n    final File file = createTempFile(\"jndi\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/jndi.jar\").toURI()))) {\r\n        try (FileOutputStream out = new FileOutputStream(file)) {\r\n            final PackingOptions options = new PackingOptions();\r\n            options.setGzip(false);\r\n            new Archive(in, out, options).pack();\r\n        }\r\n    }\r\n    // now unpack\r\n    final File file2 = createTempFile(\"jndiout\", \".jar\");\r\n    try (InputStream in2 = new FileInputStream(file);\r\n        JarOutputStream out2 = new JarOutputStream(new FileOutputStream(file2))) {\r\n        final org.apache.commons.compress.harmony.unpack200.Archive archive = new org.apache.commons.compress.harmony.unpack200.Archive(in2, out2);\r\n        archive.unpack();\r\n    }\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(new File(Archive.class.getResource(\"/pack200/jndiUnpacked.jar\").toURI()))) {\r\n        compareFiles(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testLargeClass",
  "sourceCode" : "@Test\r\nvoid testLargeClass() throws IOException, Pack200Exception, URISyntaxException {\r\n    final File file = createTempFile(\"largeClass\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/largeClassUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // now unpack\r\n    final File file2 = createTempFile(\"largeClassOut\", \".jar\");\r\n    try (InputStream in2 = new FileInputStream(file);\r\n        JarOutputStream out2 = new JarOutputStream(new FileOutputStream(file2))) {\r\n        final org.apache.commons.compress.harmony.unpack200.Archive archive = new org.apache.commons.compress.harmony.unpack200.Archive(in2, out2);\r\n        archive.unpack();\r\n    }\r\n    final File compareFile = new File(Archive.class.getResource(\"/pack200/largeClassUnpacked.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        assertEquals(jarFile2.size(), jarFile.size());\r\n        compareFiles(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testMultipleJars",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"loadMultipleJars\")\r\nvoid testMultipleJars(final Path path) throws IOException, Pack200Exception {\r\n    final File file = createTempFile(\"temp\", \".pack.gz\");\r\n    final File inputFile = path.toFile();\r\n    try (JarFile in = new JarFile(inputFile);\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        // System.out.println(\"packing \" + children[i]);\r\n        new Archive(in, out, null).pack();\r\n    }\r\n    // unpack and compare\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testSQL",
  "sourceCode" : "@Test\r\nvoid testSQL() throws IOException, Pack200Exception, URISyntaxException {\r\n    final File file = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // now unpack\r\n    final File file2 = createTempFile(\"sqlout\", \".jar\");\r\n    try (InputStream in2 = new FileInputStream(file);\r\n        JarOutputStream out2 = new JarOutputStream(new FileOutputStream(file2))) {\r\n        final org.apache.commons.compress.harmony.unpack200.Archive archive = new org.apache.commons.compress.harmony.unpack200.Archive(in2, out2);\r\n        archive.unpack();\r\n    }\r\n    final File compareFile = new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        assertEquals(jarFile2.size(), jarFile.size());\r\n        compareFiles(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\ArchiveTest.java",
  "methodName" : "testWithAnnotations2",
  "sourceCode" : "// Test with an archive containing Annotations\r\n@Test\r\nvoid testWithAnnotations2() throws Exception {\r\n    final File file = createTempFile(\"annotations\", \".jar\");\r\n    try (InputStream input = Archive.class.getResourceAsStream(\"/pack200/annotationsRI.pack.gz\");\r\n        JarOutputStream jout = new JarOutputStream(new FileOutputStream(file))) {\r\n        final org.apache.commons.compress.harmony.unpack200.Archive archive = new org.apache.commons.compress.harmony.unpack200.Archive(input, jout);\r\n        archive.unpack();\r\n    }\r\n    try (JarFile jarFile = new JarFile(file);\r\n        JarFile jarFile2 = new JarFile(new File(Archive.class.getResource(\"/pack200/annotationsRI.jar\").toURI()))) {\r\n        compareFiles(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\BHSDCodecTest.java",
  "methodName" : "testDeltaEncodings",
  "sourceCode" : "@Test\r\nvoid testDeltaEncodings() throws IOException, Pack200Exception {\r\n    final Codec c = Codec.UDELTA5;\r\n    final int[] sequence = { 0, 2, 4, 2, 2, 4 };\r\n    final byte[] encoded = c.encode(sequence);\r\n    final int[] decoded = c.decodeInts(6, new ByteArrayInputStream(encoded));\r\n    for (int i = 0; i < decoded.length; i++) {\r\n        assertEquals(sequence[i], decoded[i]);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\BHSDCodecTest.java",
  "methodName" : "testEncodeDecode",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"encodeDecodeRange\")\r\nvoid testEncodeDecode(final int i) throws IOException, Pack200Exception {\r\n    final BHSDCodec codec = (BHSDCodec) CodecEncoding.getCodec(i, null, null);\r\n    if (!codec.isDelta()) {\r\n        // Test encode-decode with a selection of numbers within the\r\n        // range of the codec\r\n        final long largest = codec.largest();\r\n        long smallest = codec.isSigned() ? codec.smallest() : 0;\r\n        if (smallest < Integer.MIN_VALUE) {\r\n            smallest = Integer.MIN_VALUE;\r\n        }\r\n        final long difference = (largest - smallest) / 4;\r\n        for (long j = smallest; j <= largest; j += difference) {\r\n            if (j > Integer.MAX_VALUE) {\r\n                break;\r\n            }\r\n            final byte[] encoded = codec.encode((int) j, 0);\r\n            long decoded = 0;\r\n            try {\r\n                decoded = codec.decode(new ByteArrayInputStream(encoded), 0);\r\n            } catch (final EOFException e) {\r\n                System.out.println(e);\r\n            }\r\n            if (j != decoded) {\r\n                fail(\"Failed with codec: \" + i + \", \" + codec + \" expected: \" + j + \", got: \" + decoded);\r\n            }\r\n        }\r\n    }\r\n    // Test encode-decode with 0\r\n    assertEquals(0, codec.decode(new ByteArrayInputStream(codec.encode(0, 0)), 0));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecEncodingTest.java",
  "methodName" : "testArbitraryCodec",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"arbitraryCodec\")\r\nvoid testArbitraryCodec(final String expected, final byte[] bytes) throws IOException, Pack200Exception {\r\n    assertEquals(expected, CodecEncoding.getCodec(116, new ByteArrayInputStream(bytes), null).toString());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecEncodingTest.java",
  "methodName" : "testCanonicalEncodings",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"canonicalEncodings\")\r\nvoid testCanonicalEncodings(final int i, final String expectedCodec) throws IOException, Pack200Exception {\r\n    assertEquals(expectedCodec, CodecEncoding.getCodec(i, null, null).toString());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecEncodingTest.java",
  "methodName" : "testCanonicalGetSpecifier",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"canonicalGetSpecifier\")\r\nvoid testCanonicalGetSpecifier(final int i) throws Pack200Exception, IOException {\r\n    assertEquals(i, CodecEncoding.getSpecifier(CodecEncoding.getCodec(i, null, null), null)[0]);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecEncodingTest.java",
  "methodName" : "testDefaultCodec",
  "sourceCode" : "@Test\r\nvoid testDefaultCodec() throws Pack200Exception, IOException {\r\n    final Codec defaultCodec = new BHSDCodec(2, 16, 0, 0);\r\n    assertEquals(defaultCodec, CodecEncoding.getCodec(0, null, defaultCodec));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecEncodingTest.java",
  "methodName" : "testGetSpeciferForPopulationCodec",
  "sourceCode" : "@Test\r\nvoid testGetSpeciferForPopulationCodec() throws IOException, Pack200Exception {\r\n    final PopulationCodec populationCodec = new PopulationCodec(Codec.BYTE1, Codec.CHAR3, Codec.UNSIGNED5);\r\n    final int[] specifiers = CodecEncoding.getSpecifier(populationCodec, null);\r\n    assertTrue(specifiers[0] > 140);\r\n    assertTrue(specifiers[0] < 189);\r\n    final byte[] bytes = new byte[specifiers.length - 1];\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        bytes[i] = (byte) specifiers[i + 1];\r\n    }\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    final PopulationCodec populationCodec2 = (PopulationCodec) CodecEncoding.getCodec(specifiers[0], in, null);\r\n    assertEquals(populationCodec.getFavouredCodec(), populationCodec2.getFavouredCodec());\r\n    assertEquals(populationCodec.getTokenCodec(), populationCodec2.getTokenCodec());\r\n    assertEquals(populationCodec.getUnfavouredCodec(), populationCodec2.getUnfavouredCodec());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecEncodingTest.java",
  "methodName" : "testGetSpeciferForRunCodec",
  "sourceCode" : "@Test\r\nvoid testGetSpeciferForRunCodec() throws Pack200Exception, IOException {\r\n    RunCodec runCodec = new RunCodec(25, Codec.DELTA5, Codec.BYTE1);\r\n    int[] specifiers = CodecEncoding.getSpecifier(runCodec, null);\r\n    assertTrue(specifiers[0] > 116);\r\n    assertTrue(specifiers[0] < 141);\r\n    byte[] bytes = new byte[specifiers.length - 1];\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        bytes[i] = (byte) specifiers[i + 1];\r\n    }\r\n    InputStream in = new ByteArrayInputStream(bytes);\r\n    RunCodec runCodec2 = (RunCodec) CodecEncoding.getCodec(specifiers[0], in, null);\r\n    assertEquals(runCodec.getK(), runCodec2.getK());\r\n    assertEquals(runCodec.getACodec(), runCodec2.getACodec());\r\n    assertEquals(runCodec.getBCodec(), runCodec2.getBCodec());\r\n    // One codec is the same as the default\r\n    runCodec = new RunCodec(4096, Codec.DELTA5, Codec.BYTE1);\r\n    specifiers = CodecEncoding.getSpecifier(runCodec, Codec.DELTA5);\r\n    assertTrue(specifiers[0] > 116);\r\n    assertTrue(specifiers[0] < 141);\r\n    bytes = new byte[specifiers.length - 1];\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        bytes[i] = (byte) specifiers[i + 1];\r\n    }\r\n    in = new ByteArrayInputStream(bytes);\r\n    runCodec2 = (RunCodec) CodecEncoding.getCodec(specifiers[0], in, Codec.DELTA5);\r\n    assertEquals(runCodec.getK(), runCodec2.getK());\r\n    assertEquals(runCodec.getACodec(), runCodec2.getACodec());\r\n    assertEquals(runCodec.getBCodec(), runCodec2.getBCodec());\r\n    // Nested run codecs\r\n    runCodec = new RunCodec(64, Codec.SIGNED5, new RunCodec(25, Codec.UDELTA5, Codec.DELTA5));\r\n    specifiers = CodecEncoding.getSpecifier(runCodec, null);\r\n    assertTrue(specifiers[0] > 116);\r\n    assertTrue(specifiers[0] < 141);\r\n    bytes = new byte[specifiers.length - 1];\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        bytes[i] = (byte) specifiers[i + 1];\r\n    }\r\n    in = new ByteArrayInputStream(bytes);\r\n    runCodec2 = (RunCodec) CodecEncoding.getCodec(specifiers[0], in, null);\r\n    assertEquals(runCodec.getK(), runCodec2.getK());\r\n    assertEquals(runCodec.getACodec(), runCodec2.getACodec());\r\n    RunCodec bCodec = (RunCodec) runCodec.getBCodec();\r\n    RunCodec bCodec2 = (RunCodec) runCodec2.getBCodec();\r\n    assertEquals(bCodec.getK(), bCodec2.getK());\r\n    assertEquals(bCodec.getACodec(), bCodec2.getACodec());\r\n    assertEquals(bCodec.getBCodec(), bCodec2.getBCodec());\r\n    // Nested with one the same as the default\r\n    runCodec = new RunCodec(64, Codec.SIGNED5, new RunCodec(25, Codec.UDELTA5, Codec.DELTA5));\r\n    specifiers = CodecEncoding.getSpecifier(runCodec, Codec.UDELTA5);\r\n    assertTrue(specifiers[0] > 116);\r\n    assertTrue(specifiers[0] < 141);\r\n    bytes = new byte[specifiers.length - 1];\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        bytes[i] = (byte) specifiers[i + 1];\r\n    }\r\n    in = new ByteArrayInputStream(bytes);\r\n    runCodec2 = (RunCodec) CodecEncoding.getCodec(specifiers[0], in, Codec.UDELTA5);\r\n    assertEquals(runCodec.getK(), runCodec2.getK());\r\n    assertEquals(runCodec.getACodec(), runCodec2.getACodec());\r\n    bCodec = (RunCodec) runCodec.getBCodec();\r\n    bCodec2 = (RunCodec) runCodec2.getBCodec();\r\n    assertEquals(bCodec.getK(), bCodec2.getK());\r\n    assertEquals(bCodec.getACodec(), bCodec2.getACodec());\r\n    assertEquals(bCodec.getBCodec(), bCodec2.getBCodec());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecEncodingTest.java",
  "methodName" : "testGetSpecifier",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"specifier\")\r\nvoid testGetSpecifier(final Codec c1) throws IOException, Pack200Exception {\r\n    final int[] specifiers = CodecEncoding.getSpecifier(c1, null);\r\n    assertEquals(3, specifiers.length);\r\n    assertEquals(116, specifiers[0]);\r\n    final byte[] bytes = { (byte) specifiers[1], (byte) specifiers[2] };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    assertEquals(c1, CodecEncoding.getCodec(116, in, null));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testBCodings",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"bCodings\")\r\nvoid testBCodings(final int i) {\r\n    if (i == 5) {\r\n        assertThrows(IllegalArgumentException.class, () -> new BHSDCodec(i, 256));\r\n    } else {\r\n        assertDoesNotThrow(() -> new BHSDCodec(i, 256));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testByte1",
  "sourceCode" : "@Test\r\nvoid testByte1() throws Exception {\r\n    for (int i = 0; i < 255; i++) {\r\n        decode(Codec.BYTE1, new byte[] { (byte) i }, i, 0);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testByte1Delta",
  "sourceCode" : "@Test\r\nvoid testByte1Delta() throws Exception {\r\n    final Codec BYTE1D = new BHSDCodec(1, 256, 0, 1);\r\n    long last = 0;\r\n    for (int i = 1; i < 255; i++) {\r\n        last = decode(BYTE1D, new byte[] { (byte) 1 }, i, last);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testByte1DeltaException",
  "sourceCode" : "@Test\r\nvoid testByte1DeltaException() throws Exception {\r\n    final Codec BYTE1D = new BHSDCodec(1, 256, 0, 1);\r\n    assertThrows(Pack200Exception.class, () -> BYTE1D.decode(new ByteArrayInputStream(new byte[] { (byte) 1 })), \"Decoding with a delta stream and not passing a last value should throw an exception\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testByte1Signed",
  "sourceCode" : "@Test\r\nvoid testByte1Signed() throws Exception {\r\n    final Codec BYTE1S2 = new BHSDCodec(1, 256, 2);\r\n    decode(BYTE1S2, new byte[] { 0 }, 0, 0);\r\n    decode(BYTE1S2, new byte[] { 1 }, 1, 0);\r\n    decode(BYTE1S2, new byte[] { 2 }, 2, 0);\r\n    decode(BYTE1S2, new byte[] { 3 }, -1, 0);\r\n    decode(BYTE1S2, new byte[] { 4 }, 3, 0);\r\n    decode(BYTE1S2, new byte[] { 5 }, 4, 0);\r\n    decode(BYTE1S2, new byte[] { 6 }, 5, 0);\r\n    decode(BYTE1S2, new byte[] { 7 }, -2, 0);\r\n    decode(BYTE1S2, new byte[] { 8 }, 6, 0);\r\n    decode(BYTE1S2, new byte[] { 9 }, 7, 0);\r\n    decode(BYTE1S2, new byte[] { 10 }, 8, 0);\r\n    decode(BYTE1S2, new byte[] { 11 }, -3, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testCardinality",
  "sourceCode" : "@Test\r\nvoid testCardinality() {\r\n    final BHSDCodec byte1 = Codec.BYTE1;\r\n    assertEquals(256, byte1.cardinality());\r\n    assertEquals(0, byte1.smallest());\r\n    assertEquals(255, byte1.largest());\r\n    assertFalse(byte1.encodes(-257));\r\n    assertFalse(byte1.encodes(-256));\r\n    assertFalse(byte1.encodes(-255));\r\n    assertFalse(byte1.encodes(-129));\r\n    assertFalse(byte1.encodes(-128));\r\n    assertFalse(byte1.encodes(-127));\r\n    assertFalse(byte1.encodes(-1));\r\n    assertTrue(byte1.encodes(0));\r\n    assertTrue(byte1.encodes(1));\r\n    assertTrue(byte1.encodes(255));\r\n    assertFalse(byte1.encodes(256));\r\n    final BHSDCodec byte1s = new BHSDCodec(1, 256, 1);\r\n    assertEquals(256, byte1s.cardinality());\r\n    assertEquals(-128, byte1s.smallest());\r\n    assertEquals(127, byte1s.largest());\r\n    assertFalse(byte1s.encodes(-257));\r\n    assertFalse(byte1s.encodes(-256));\r\n    assertFalse(byte1s.encodes(-255));\r\n    assertFalse(byte1s.encodes(-129));\r\n    assertTrue(byte1s.encodes(-128));\r\n    assertTrue(byte1s.encodes(-127));\r\n    assertTrue(byte1s.encodes(-1));\r\n    assertTrue(byte1s.encodes(0));\r\n    assertTrue(byte1s.encodes(1));\r\n    assertTrue(byte1s.encodes(127));\r\n    assertFalse(byte1s.encodes(128));\r\n    assertFalse(byte1s.encodes(129));\r\n    assertFalse(byte1s.encodes(255));\r\n    assertFalse(byte1s.encodes(256));\r\n    final BHSDCodec byte2s = new BHSDCodec(1, 256, 2);\r\n    assertEquals(256, byte2s.cardinality());\r\n    assertEquals(-64, byte2s.smallest());\r\n    assertEquals(191, byte2s.largest());\r\n    assertFalse(byte2s.encodes(-257));\r\n    assertFalse(byte2s.encodes(-256));\r\n    assertFalse(byte2s.encodes(-255));\r\n    assertFalse(byte2s.encodes(-129));\r\n    assertFalse(byte2s.encodes(-128));\r\n    assertFalse(byte2s.encodes(-127));\r\n    assertFalse(byte2s.encodes(-65));\r\n    assertTrue(byte2s.encodes(-64));\r\n    assertTrue(byte2s.encodes(-64));\r\n    assertTrue(byte2s.encodes(-1));\r\n    assertTrue(byte2s.encodes(0));\r\n    assertTrue(byte2s.encodes(1));\r\n    assertTrue(byte2s.encodes(127));\r\n    assertTrue(byte2s.encodes(128));\r\n    assertTrue(byte2s.encodes(191));\r\n    assertFalse(byte2s.encodes(192));\r\n    assertFalse(byte2s.encodes(256));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testCodecFamilies",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"codecFamily\")\r\nvoid testCodecFamilies(final BHSDCodec[] family) {\r\n    for (int i = 1; i < family.length; i++) {\r\n        final BHSDCodec previous = family[i - 1];\r\n        final BHSDCodec codec = family[i];\r\n        assertTrue(codec.largest() >= previous.largest());\r\n        assertTrue(codec.smallest() <= previous.smallest());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testCodecToString",
  "sourceCode" : "@Test\r\nvoid testCodecToString() {\r\n    assertEquals(\"(1,256)\", Codec.BYTE1.toString());\r\n    assertEquals(\"(3,128)\", Codec.CHAR3.toString());\r\n    assertEquals(\"(5,4)\", Codec.BCI5.toString());\r\n    assertEquals(\"(5,4,2)\", Codec.BRANCH5.toString());\r\n    assertEquals(\"(5,64)\", Codec.UNSIGNED5.toString());\r\n    assertEquals(\"(5,64,1)\", Codec.SIGNED5.toString());\r\n    assertEquals(\"(5,64,0,1)\", Codec.UDELTA5.toString());\r\n    assertEquals(\"(5,64,1,1)\", Codec.DELTA5.toString());\r\n    assertEquals(\"(5,64,2,1)\", Codec.MDELTA5.toString());\r\n    assertEquals(\"(5,64)\", Codec.UNSIGNED5.toString());\r\n    assertEquals(\"(5,64,1)\", Codec.SIGNED5.toString());\r\n    assertEquals(\"(5,64,1,1)\", Codec.DELTA5.toString());\r\n    assertEquals(\"(5,64,2,1)\", Codec.MDELTA5.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testInvalidHCodings",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"hCodings\")\r\nvoid testInvalidHCodings(final int i) {\r\n    assertThrows(IllegalArgumentException.class, () -> new BHSDCodec(1, i), \"b=1 -> h=256\");\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\CodecTest.java",
  "methodName" : "testUnsigned5",
  "sourceCode" : "@Test\r\nvoid testUnsigned5() throws Exception {\r\n    decode(Codec.UNSIGNED5, new byte[] { 1 }, 1, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 191 }, 191, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 192, 0 }, 192, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 193, 0 }, 193, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 255, 0 }, 255, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 192, 1 }, 256, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 192, 5 }, 512, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 192, 13 }, 1024, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 192, 29 }, 2048, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 255, (byte) 191 }, 12479, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 192, (byte) 192, 0 }, 12480, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 255, (byte) 255, (byte) 191 }, 798911, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 192, (byte) 192, (byte) 192, 0 }, 798912, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 191 }, 51130559, 0);\r\n    decode(Codec.UNSIGNED5, new byte[] { (byte) 192, (byte) 192, (byte) 192, (byte) 192, 0 }, 51130560, 0);\r\n    decodeFail(Codec.UNSIGNED5, new byte[] { (byte) 192 });\r\n    decodeFail(Codec.UNSIGNED5, new byte[] { (byte) 192, (byte) 192 });\r\n    decodeFail(Codec.UNSIGNED5, new byte[] { (byte) 192, (byte) 192, (byte) 192 });\r\n    decodeFail(Codec.UNSIGNED5, new byte[] { (byte) 192, (byte) 192, (byte) 192, (byte) 192 });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\Compress626Test.java",
  "methodName" : "test",
  "sourceCode" : "@Test\r\nvoid test() throws Exception {\r\n    final CPUTF8 name = new CPUTF8(\"\");\r\n    final CPUTF8 layout = new CPUTF8(\"[\");\r\n    assertDoesNotThrow(() -> new NewAttributeBands(1, null, null, new AttributeDefinitionBands.AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\Compress626Test.java",
  "methodName" : "testJar",
  "sourceCode" : "@Test\r\nvoid testJar() throws IOException {\r\n    try (InputStream inputStream = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/commons/compress/COMPRESS-626/compress-626-pack200.jar\"));\r\n        JarOutputStream out = new JarOutputStream(NullOutputStream.INSTANCE)) {\r\n        Pack200.newUnpacker().unpack(inputStream, out);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\Compress628Test.java",
  "methodName" : "test",
  "sourceCode" : "@Test\r\nvoid test() throws Exception {\r\n    final CPUTF8 name = new CPUTF8(\"\");\r\n    final CPUTF8 layout = new CPUTF8(\"Re\\\\T\");\r\n    assertDoesNotThrow(() -> new NewAttributeBands(1, null, null, new AttributeDefinitionBands.AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testAddAttributes",
  "sourceCode" : "@Test\r\nvoid testAddAttributes() throws IOException, Pack200Exception {\r\n    final CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    final CPUTF8 layout = new CPUTF8(\"B\");\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    newAttributeBands.addAttribute(new NewAttribute(null, \"TestAttribute\", \"B\", new byte[] { 27 }, null, 0, null));\r\n    newAttributeBands.addAttribute(new NewAttribute(null, \"TestAttribute\", \"B\", new byte[] { 56 }, null, 0, null));\r\n    newAttributeBands.addAttribute(new NewAttribute(null, \"TestAttribute\", \"B\", new byte[] { 3 }, null, 0, null));\r\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    newAttributeBands.pack(out);\r\n    // BYTE1 is used for B layouts, so we don't need to unpack to test the\r\n    // results\r\n    final byte[] bytes = out.toByteArray();\r\n    assertEquals(3, bytes.length);\r\n    assertEquals(27, bytes[0]);\r\n    assertEquals(56, bytes[1]);\r\n    assertEquals(3, bytes[2]);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testAddAttributesWithReplicationLayout",
  "sourceCode" : "@Test\r\nvoid testAddAttributesWithReplicationLayout() throws IOException, Pack200Exception {\r\n    final CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    final CPUTF8 layout = new CPUTF8(\"NB[SH]\");\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    newAttributeBands.addAttribute(new NewAttribute(null, \"TestAttribute\", \"B\", new byte[] { 1, 0, 100 }, null, 0, null));\r\n    final short s = -50;\r\n    final byte b1 = (byte) (s >>> 8);\r\n    final byte b2 = (byte) s;\r\n    newAttributeBands.addAttribute(new NewAttribute(null, \"TestAttribute\", \"B\", new byte[] { 3, 0, 5, 0, 25, b1, b2 }, null, 0, null));\r\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    newAttributeBands.pack(out);\r\n    final byte[] bytes = out.toByteArray();\r\n    assertEquals(1, bytes[0]);\r\n    assertEquals(3, bytes[1]);\r\n    final byte[] band = new byte[bytes.length - 2];\r\n    System.arraycopy(bytes, 2, band, 0, band.length);\r\n    final int[] decoded = Codec.SIGNED5.decodeInts(4, new ByteArrayInputStream(band));\r\n    assertEquals(4, decoded.length);\r\n    assertEquals(100, decoded[0]);\r\n    assertEquals(5, decoded[1]);\r\n    assertEquals(25, decoded[2]);\r\n    assertEquals(-50, decoded[3]);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testEmptyLayout",
  "sourceCode" : "@Test\r\nvoid testEmptyLayout() throws IOException {\r\n    final CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    final CPUTF8 layout = new CPUTF8(\"\");\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    final List<AttributeLayoutElement> layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(0, layoutElements.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testIntegralLayouts",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { \"B\", \"FB\", \"SB\", \"H\", \"FH\", \"SH\", \"I\", \"FI\", \"SI\", \"PB\", \"OB\", \"OSB\", \"POB\", \"PH\", \"OH\", \"OSH\", \"POH\", \"PI\", \"OI\", \"OSI\", \"POI\" })\r\nvoid testIntegralLayouts(final String layoutStr) throws IOException {\r\n    final CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    final CPUTF8 layout = new CPUTF8(layoutStr);\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    final List<AttributeLayoutElement> layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(1, layoutElements.size());\r\n    final Integral element = (Integral) layoutElements.get(0);\r\n    assertEquals(layoutStr, element.getTag());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testLayoutWithBackwardsCalls",
  "sourceCode" : "@Test\r\nvoid testLayoutWithBackwardsCalls() throws Exception {\r\n    CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    CPUTF8 layout = new CPUTF8(\"[NH[(1)]][KIH][(-1)]\");\r\n    MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    List<AttributeLayoutElement> layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(3, layoutElements.size());\r\n    Callable firstCallable = (Callable) layoutElements.get(0);\r\n    Callable secondCallable = (Callable) layoutElements.get(1);\r\n    Callable thirdCallable = (Callable) layoutElements.get(2);\r\n    List<LayoutElement> thirdBody = thirdCallable.getBody();\r\n    assertEquals(1, thirdBody.size());\r\n    Call call = (Call) thirdBody.get(0);\r\n    assertEquals(secondCallable, call.getCallable());\r\n    assertTrue(secondCallable.isBackwardsCallable());\r\n    assertFalse(firstCallable.isBackwardsCallable());\r\n    assertFalse(thirdCallable.isBackwardsCallable());\r\n    name = new CPUTF8(\"TestAttribute\");\r\n    layout = new CPUTF8(\"[NH[(1)]][KIH][(-2)]\");\r\n    newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(3, layoutElements.size());\r\n    firstCallable = (Callable) layoutElements.get(0);\r\n    secondCallable = (Callable) layoutElements.get(1);\r\n    thirdCallable = (Callable) layoutElements.get(2);\r\n    thirdBody = thirdCallable.getBody();\r\n    assertEquals(1, thirdBody.size());\r\n    call = (Call) thirdBody.get(0);\r\n    assertEquals(firstCallable, call.getCallable());\r\n    assertTrue(firstCallable.isBackwardsCallable());\r\n    assertFalse(secondCallable.isBackwardsCallable());\r\n    assertFalse(thirdCallable.isBackwardsCallable());\r\n    name = new CPUTF8(\"TestAttribute\");\r\n    layout = new CPUTF8(\"[NH[(1)]][KIH][(0)]\");\r\n    newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(3, layoutElements.size());\r\n    firstCallable = (Callable) layoutElements.get(0);\r\n    secondCallable = (Callable) layoutElements.get(1);\r\n    thirdCallable = (Callable) layoutElements.get(2);\r\n    thirdBody = thirdCallable.getBody();\r\n    assertEquals(1, thirdBody.size());\r\n    call = (Call) thirdBody.get(0);\r\n    assertEquals(thirdCallable, call.getCallable());\r\n    assertTrue(thirdCallable.isBackwardsCallable());\r\n    assertFalse(firstCallable.isBackwardsCallable());\r\n    assertFalse(secondCallable.isBackwardsCallable());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testLayoutWithCalls",
  "sourceCode" : "@Test\r\nvoid testLayoutWithCalls() throws IOException {\r\n    final CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    // @formatter:off\r\n    final CPUTF8 layout = new CPUTF8(\"[NH[(1)]][RSH NH[RUH(1)]][TB(66,67,73,83,90)[KIH](68)[KDH](70)[KFH](74)[KJH](99)[RSH](101)[RSH RUH](115)[RUH](91)[NH[(0)]](64)[RSH[RUH(0)]]()[]]\");\r\n    // @formatter:on\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    final List<AttributeLayoutElement> layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(3, layoutElements.size());\r\n    final Callable firstCallable = (Callable) layoutElements.get(0);\r\n    final Callable secondCallable = (Callable) layoutElements.get(1);\r\n    final Callable thirdCallable = (Callable) layoutElements.get(2);\r\n    final List<LayoutElement> firstBody = firstCallable.getBody();\r\n    assertEquals(1, firstBody.size());\r\n    final Replication rep = (Replication) firstBody.get(0);\r\n    final List<LayoutElement> repBody = rep.getLayoutElements();\r\n    assertEquals(1, repBody.size());\r\n    final Call call = (Call) repBody.get(0);\r\n    assertEquals(1, call.getCallableIndex());\r\n    assertEquals(secondCallable, call.getCallable());\r\n    assertFalse(firstCallable.isBackwardsCallable());\r\n    assertFalse(secondCallable.isBackwardsCallable());\r\n    assertFalse(thirdCallable.isBackwardsCallable());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testReferenceLayouts",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { \"KIB\", \"KIH\", \"KII\", \"KINH\", \"KJH\", \"KDH\", \"KSH\", \"KQH\", \"RCH\", \"RSH\", \"RDH\", \"RFH\", \"RMH\", \"RIH\", \"RUH\", \"RQH\", \"RQNH\", \"RQNI\" })\r\nvoid testReferenceLayouts(final String layoutStr) throws IOException {\r\n    final CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    final CPUTF8 layout = new CPUTF8(layoutStr);\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    final List<AttributeLayoutElement> layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(1, layoutElements.size());\r\n    final Reference element = (Reference) layoutElements.get(0);\r\n    assertEquals(layoutStr, element.getTag());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testReplicationLayouts",
  "sourceCode" : "@Test\r\nvoid testReplicationLayouts() throws IOException {\r\n    final CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    final CPUTF8 layout = new CPUTF8(\"NH[PHOHRUHRSHH]\");\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    final List<AttributeLayoutElement> layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(1, layoutElements.size());\r\n    final Replication element = (Replication) layoutElements.get(0);\r\n    final Integral countElement = element.getCountElement();\r\n    assertEquals(\"H\", countElement.getTag());\r\n    final List<LayoutElement> replicatedElements = element.getLayoutElements();\r\n    assertEquals(5, replicatedElements.size());\r\n    final Integral firstElement = (Integral) replicatedElements.get(0);\r\n    assertEquals(\"PH\", firstElement.getTag());\r\n    final Integral secondElement = (Integral) replicatedElements.get(1);\r\n    assertEquals(\"OH\", secondElement.getTag());\r\n    final Reference thirdElement = (Reference) replicatedElements.get(2);\r\n    assertEquals(\"RUH\", thirdElement.getTag());\r\n    final Reference fourthElement = (Reference) replicatedElements.get(3);\r\n    assertEquals(\"RSH\", fourthElement.getTag());\r\n    final Integral fifthElement = (Integral) replicatedElements.get(4);\r\n    assertEquals(\"H\", fifthElement.getTag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\NewAttributeBandsTest.java",
  "methodName" : "testUnionLayout",
  "sourceCode" : "@Test\r\nvoid testUnionLayout() throws IOException {\r\n    final CPUTF8 name = new CPUTF8(\"TestAttribute\");\r\n    final CPUTF8 layout = new CPUTF8(\"TB(55)[FH](23)[]()[RSH]\");\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(1, null, null, new AttributeDefinition(35, AttributeDefinitionBands.CONTEXT_CLASS, name, layout));\r\n    final List<AttributeLayoutElement> layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(1, layoutElements.size());\r\n    final Union element = (Union) layoutElements.get(0);\r\n    final Integral tag = element.getUnionTag();\r\n    assertEquals(\"B\", tag.getTag());\r\n    final List<UnionCase> unionCases = element.getUnionCases();\r\n    assertEquals(2, unionCases.size());\r\n    final UnionCase firstCase = unionCases.get(0);\r\n    assertTrue(firstCase.hasTag(55));\r\n    assertFalse(firstCase.hasTag(23));\r\n    List<LayoutElement> body = firstCase.getBody();\r\n    assertEquals(1, body.size());\r\n    final Integral bodyElement = (Integral) body.get(0);\r\n    assertEquals(\"FH\", bodyElement.getTag());\r\n    final UnionCase secondCase = unionCases.get(1);\r\n    assertTrue(secondCase.hasTag(23));\r\n    assertFalse(secondCase.hasTag(55));\r\n    body = secondCase.getBody();\r\n    assertEquals(0, body.size());\r\n    final List<LayoutElement> defaultBody = element.getDefaultCaseBody();\r\n    assertEquals(1, defaultBody.size());\r\n    final Reference ref = (Reference) defaultBody.get(0);\r\n    assertEquals(\"RSH\", ref.getTag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testDeflateHint",
  "sourceCode" : "@Test\r\nvoid testDeflateHint() {\r\n    // Test default first\r\n    final PackingOptions options = new PackingOptions();\r\n    assertEquals(\"keep\", options.getDeflateHint());\r\n    options.setDeflateHint(\"true\");\r\n    assertEquals(\"true\", options.getDeflateHint());\r\n    options.setDeflateHint(\"false\");\r\n    assertEquals(\"false\", options.getDeflateHint());\r\n    assertThrows(IllegalArgumentException.class, () -> options.setDeflateHint(\"hello\"), \"Should throw IllegalArgumentException for incorrect deflate hint\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testErrorAttributes",
  "sourceCode" : "@Test\r\nvoid testErrorAttributes() throws Exception {\r\n    final File file = createTempFile(\"unknown\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/jndiWithUnknownAttributes.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.addClassAttributeAction(\"Pack200\", \"error\");\r\n        final Archive ar = new Archive(in, out, options);\r\n        final IllegalStateException error = assertThrows(IllegalStateException.class, () -> {\r\n            ar.pack();\r\n            in.close();\r\n            out.close();\r\n        });\r\n        assertEquals(\"Attribute Pack200 was found\", error.getMessage());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testKeepFileOrder",
  "sourceCode" : "@Test\r\nvoid testKeepFileOrder() throws Exception {\r\n    // Test default first\r\n    PackingOptions options = new PackingOptions();\r\n    assertTrue(options.isKeepFileOrder());\r\n    options.setKeepFileOrder(false);\r\n    assertFalse(options.isKeepFileOrder());\r\n    // Test option works correctly. Test 'True'.\r\n    File file = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile jarFile = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream outputStream = new FileOutputStream(file)) {\r\n        options = new PackingOptions();\r\n        options.setGzip(false);\r\n        new Archive(jarFile, outputStream, options).pack();\r\n    }\r\n    File file2 = createTempFile(\"sql\", \".jar\");\r\n    unpackJar(file, file2);\r\n    File compareFile = new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        // Check that both jars have the same entries in the same order\r\n        final Enumeration<JarEntry> entries = jarFile.entries();\r\n        final Enumeration<JarEntry> entries2 = jarFile2.entries();\r\n        while (entries.hasMoreElements()) {\r\n            final JarEntry entry = entries.nextElement();\r\n            assertNotNull(entry);\r\n            final JarEntry entry2 = entries2.nextElement();\r\n            final String name = entry.getName();\r\n            final String name2 = entry2.getName();\r\n            assertEquals(name, name2);\r\n        }\r\n    }\r\n    // Test 'false'\r\n    file = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile jarFile = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream outputStream = new FileOutputStream(file)) {\r\n        options = new PackingOptions();\r\n        options.setKeepFileOrder(false);\r\n        options.setGzip(false);\r\n        new Archive(jarFile, outputStream, options).pack();\r\n    }\r\n    file2 = createTempFile(\"sql\", \".jar\");\r\n    unpackJar(file, file2);\r\n    compareFile = new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        // Check that both jars have the same entries (may be in a different order)\r\n        compareJarEntries(jarFile, jarFile2);\r\n        // Check files are not in order this time\r\n        final Enumeration<JarEntry> entries = jarFile.entries();\r\n        final Enumeration<JarEntry> entries2 = jarFile2.entries();\r\n        boolean inOrder = true;\r\n        while (entries.hasMoreElements()) {\r\n            final JarEntry entry = entries.nextElement();\r\n            assertNotNull(entry);\r\n            final JarEntry entry2 = entries2.nextElement();\r\n            final String name = entry.getName();\r\n            final String name2 = entry2.getName();\r\n            if (!name.equals(name2)) {\r\n                inOrder = false;\r\n                break;\r\n            }\r\n        }\r\n        assertFalse(inOrder, \"Files are not expected to be in order\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testLoggingOptions",
  "sourceCode" : "// Test verbose, quiet and log file options.\r\n@Test\r\nvoid testLoggingOptions() throws Exception {\r\n    // Test defaults\r\n    final PackingOptions options = new PackingOptions();\r\n    assertFalse(options.isVerbose());\r\n    assertNull(options.getLogFile());\r\n    options.setVerbose(true);\r\n    assertTrue(options.isVerbose());\r\n    options.setQuiet(true);\r\n    assertFalse(options.isVerbose());\r\n    final File logFile = createTempFile(\"logfile\", \".txt\");\r\n    options.setLogFile(logFile.getPath());\r\n    assertEquals(logFile.getPath(), options.getLogFile());\r\n    File file = createTempFile(\"helloworld\", \".pack.gz\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/hw.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // log file should be empty\r\n    try (FileReader reader = new FileReader(logFile)) {\r\n        assertFalse(reader.ready());\r\n    }\r\n    options.setVerbose(true);\r\n    file = createTempFile(\"helloworld\", \".pack.gz\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/hw.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // log file should not be empty\r\n    try (FileReader reader = new FileReader(logFile)) {\r\n        assertTrue(reader.ready());\r\n    }\r\n    PackingUtils.config(null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testModificationTime",
  "sourceCode" : "@Test\r\nvoid testModificationTime() throws Exception {\r\n    // Test default first\r\n    PackingOptions options = new PackingOptions();\r\n    assertEquals(\"keep\", options.getModificationTime());\r\n    options.setModificationTime(\"latest\");\r\n    assertEquals(\"latest\", options.getModificationTime());\r\n    assertThrows(IllegalArgumentException.class, () -> {\r\n        final PackingOptions illegalOption = new PackingOptions();\r\n        illegalOption.setModificationTime(\"true\");\r\n    }, \"Should throw IllegalArgumentException for incorrect mod time\");\r\n    // Test option works correctly. Test 'keep'.\r\n    File file = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        options = new PackingOptions();\r\n        options.setGzip(false);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    File file2 = createTempFile(\"sql\", \".jar\");\r\n    unpackJar(file, file2);\r\n    File compareFile = new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        // Check that both jars have the same entries in the same order\r\n        final Enumeration<JarEntry> entries = jarFile.entries();\r\n        final Enumeration<JarEntry> entries2 = jarFile2.entries();\r\n        while (entries.hasMoreElements()) {\r\n            final JarEntry entry = entries.nextElement();\r\n            assertNotNull(entry);\r\n            final JarEntry entry2 = entries2.nextElement();\r\n            final String name = entry.getName();\r\n            final String name2 = entry2.getName();\r\n            assertEquals(name, name2);\r\n            assertEquals(entry.getTime(), entry2.getTime());\r\n        }\r\n    }\r\n    // Test option works correctly. Test 'latest'.\r\n    file = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        options = new PackingOptions();\r\n        options.setGzip(false);\r\n        options.setModificationTime(\"latest\");\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    file2 = createTempFile(\"sql\", \".jar\");\r\n    unpackJar(file, file2);\r\n    compareFile = new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        // Check that all mod times are the same and some are not the same as the original\r\n        final Enumeration<JarEntry> entries = jarFile.entries();\r\n        final Enumeration<JarEntry> entries2 = jarFile2.entries();\r\n        long modtime = -1;\r\n        boolean sameAsOriginal = true;\r\n        while (entries.hasMoreElements()) {\r\n            final JarEntry entry = entries.nextElement();\r\n            assertNotNull(entry);\r\n            final JarEntry entry2 = entries2.nextElement();\r\n            final String name = entry.getName();\r\n            if (!name.startsWith(\"META-INF\")) {\r\n                if (modtime == -1) {\r\n                    modtime = entry.getTime();\r\n                } else {\r\n                    assertEquals(modtime, entry.getTime());\r\n                }\r\n            }\r\n            if (entry2.getTime() != entry.getTime()) {\r\n                sameAsOriginal = false;\r\n            }\r\n        }\r\n        assertFalse(sameAsOriginal, \"Some modtimes should have changed\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testNewAttributes",
  "sourceCode" : "@Test\r\nvoid testNewAttributes() throws Exception {\r\n    final File file = createTempFile(\"unknown\", \".pack\");\r\n    try (FileOutputStream out = new FileOutputStream(file);\r\n        JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/jndiWithUnknownAttributes.jar\").toURI()))) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.addClassAttributeAction(\"Pack200\", \"I\");\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // unpack and check this was done right\r\n    final File file2 = createTempFile(\"unknown\", \".jar\");\r\n    unpackJar(file, file2);\r\n    // compare with original\r\n    final File compareFile = new File(Archive.class.getResource(\"/pack200/jndiWithUnknownAttributes.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        assertEquals(jarFile2.size(), jarFile.size());\r\n        compareJarEntries(jarFile, jarFile2);\r\n        //        compareFiles(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testNewAttributes2",
  "sourceCode" : "@Test\r\nvoid testNewAttributes2() throws Exception {\r\n    final File file = createTempFile(\"unknown\", \".pack\");\r\n    try (FileOutputStream out = new FileOutputStream(file);\r\n        JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/p200WithUnknownAttributes.jar\").toURI()))) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.addFieldAttributeAction(\"Pack200\", \"I\");\r\n        options.addMethodAttributeAction(\"Pack200\", \"I\");\r\n        options.addCodeAttributeAction(\"Pack200\", \"I\");\r\n        final Archive ar = new Archive(in, out, options);\r\n        ar.pack();\r\n    }\r\n    // unpack and check this was done right\r\n    final File file2 = createTempFile(\"unknown\", \".jar\");\r\n    unpackJar(file, file2);\r\n    // compare with original\r\n    final File compareFile = new File(Archive.class.getResource(\"/pack200/p200WithUnknownAttributes.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        assertEquals(jarFile2.size(), jarFile.size());\r\n        compareJarEntries(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testPackEffort0",
  "sourceCode" : "@Test\r\nvoid testPackEffort0() throws Pack200Exception, IOException, URISyntaxException {\r\n    final File f1 = new File(Archive.class.getResource(\"/pack200/jndi.jar\").toURI());\r\n    final File file = createTempFile(\"jndiE0\", \".pack\");\r\n    try (JarFile in = new JarFile(f1);\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        options.setEffort(0);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    try (JarFile jf1 = new JarFile(f1);\r\n        JarFile jf2 = new JarFile(file)) {\r\n        compareFiles(jf1, jf2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testPassAttributes",
  "sourceCode" : "@Test\r\nvoid testPassAttributes() throws Exception {\r\n    final File file = createTempFile(\"unknown\", \".pack\");\r\n    try (FileOutputStream out = new FileOutputStream(file);\r\n        JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/jndiWithUnknownAttributes.jar\").toURI()))) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.addClassAttributeAction(\"Pack200\", \"pass\");\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // now unpack\r\n    final File file2 = createTempFile(\"unknown\", \".jar\");\r\n    unpackJar(file, file2);\r\n    // compare with original\r\n    final File compareFile = new File(Archive.class.getResource(\"/pack200/jndiWithUnknownAttributes.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        assertEquals(jarFile2.size(), jarFile.size());\r\n        compareJarEntries(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testPassFiles",
  "sourceCode" : "@Test\r\nvoid testPassFiles() throws IOException, URISyntaxException, Pack200Exception {\r\n    // Don't pass any\r\n    final File file0 = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file0)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // Pass one file\r\n    final File file = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        options.addPassFile(\"bin/test/org/apache/harmony/sql/tests/java/sql/DatabaseMetaDataTest.class\");\r\n        assertTrue(options.isPassFile(\"bin/test/org/apache/harmony/sql/tests/java/sql/DatabaseMetaDataTest.class\"));\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    // Pass a whole directory\r\n    final File file2 = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file2)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        options.addPassFile(\"bin/test/org/apache/harmony/sql/tests/java/sql\");\r\n        assertTrue(options.isPassFile(\"bin/test/org/apache/harmony/sql/tests/java/sql/DatabaseMetaDataTest.class\"));\r\n        assertFalse(options.isPassFile(\"bin/test/org/apache/harmony/sql/tests/java/sqldata/SqlData.class\"));\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    assertTrue(file.length() > file0.length(), \"If files are passed then the pack file should be larger\");\r\n    assertTrue(file2.length() > file.length(), \"If more files are passed then the pack file should be larger\");\r\n    // now unpack\r\n    final File file3 = createTempFile(\"sql\", \".jar\");\r\n    unpackJar(file, file3);\r\n    final File compareFile = new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file3);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        // Check that both jars have the same entries\r\n        compareJarEntries(jarFile, jarFile2);\r\n    }\r\n    // now unpack the file with lots of passed files\r\n    final File file4 = createTempFile(\"sql\", \".jar\");\r\n    unpackJar(file2, file4);\r\n    try (JarFile jarFile = new JarFile(file4);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        compareJarEntries(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testSegmentLimits",
  "sourceCode" : "@Test\r\nvoid testSegmentLimits() throws IOException, Pack200Exception, URISyntaxException {\r\n    File file = createTempFile(\"helloworld\", \".pack.gz\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/hw.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setSegmentLimit(0);\r\n        final Archive archive = new Archive(in, out, options);\r\n        archive.pack();\r\n    }\r\n    file = createTempFile(\"helloworld\", \".pack.gz\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/hw.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setSegmentLimit(-1);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n    file = createTempFile(\"helloworld\", \".pack.gz\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/hw.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setSegmentLimit(5000);\r\n        new Archive(in, out, options).pack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PackingOptionsTest.java",
  "methodName" : "testStripDebug",
  "sourceCode" : "@Test\r\nvoid testStripDebug() throws IOException, Pack200Exception, URISyntaxException {\r\n    final File file = createTempFile(\"sql\", \".pack\");\r\n    try (JarFile in = new JarFile(new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI()));\r\n        FileOutputStream out = new FileOutputStream(file)) {\r\n        final PackingOptions options = new PackingOptions();\r\n        options.setGzip(false);\r\n        options.setStripDebug(true);\r\n        final Archive archive = new Archive(in, out, options);\r\n        archive.pack();\r\n    }\r\n    // now unpack\r\n    final File file2 = createTempFile(\"sqloutNoDebug\", \".jar\");\r\n    unpackJar(file, file2);\r\n    final File compareFile = new File(Archive.class.getResource(\"/pack200/sqlUnpackedNoDebug.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file2);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        assertTrue(file2.length() < 250000);\r\n        compareFiles(jarFile, jarFile2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PopulationCodecTest.java",
  "methodName" : "testEncodeSingleValue",
  "sourceCode" : "@Test\r\nvoid testEncodeSingleValue() {\r\n    assertThrows(Pack200Exception.class, () -> new PopulationCodec(Codec.SIGNED5, Codec.SIGNED5, Codec.UDELTA5).encode(5), \"Should not allow a single value to be encoded as we don't know which codec to use\");\r\n    assertThrows(Pack200Exception.class, () -> new PopulationCodec(Codec.SIGNED5, Codec.SIGNED5, Codec.UDELTA5).encode(5, 8), \"Should not allow a single value to be encoded as we don't know which codec to use\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\PopulationCodecTest.java",
  "methodName" : "testPopulationCodec",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"populationCodec\")\r\nvoid testPopulationCodec(final byte[] data, final long[] expectedResult, final Codec codec) throws IOException, Pack200Exception {\r\n    try (InputStream in = new ByteArrayInputStream(data)) {\r\n        final int[] result = new PopulationCodec(codec, codec, codec).decodeInts(expectedResult.length, in);\r\n        assertEquals(expectedResult.length, result.length);\r\n        for (int i = 0; i < expectedResult.length; i++) {\r\n            assertEquals(expectedResult[i], result[i]);\r\n        }\r\n        assertEquals(0, in.available());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testDecode",
  "sourceCode" : "@Test\r\nvoid testDecode() throws Exception {\r\n    RunCodec runCodec = new RunCodec(1, Codec.UNSIGNED5, Codec.BYTE1);\r\n    ByteArrayInputStream bais = new ByteArrayInputStream(new byte[] { (byte) 192, 0, (byte) 192, 0 });\r\n    assertEquals(192, runCodec.decode(bais));\r\n    assertEquals(192, runCodec.decode(bais));\r\n    assertEquals(0, runCodec.decode(bais));\r\n    assertEquals(0, bais.available());\r\n    runCodec = new RunCodec(1, Codec.BYTE1, Codec.UNSIGNED5);\r\n    bais = new ByteArrayInputStream(new byte[] { (byte) 192, 0, (byte) 192, 0 });\r\n    assertEquals(192, runCodec.decode(bais));\r\n    assertEquals(0, runCodec.decode(bais));\r\n    assertEquals(192, runCodec.decode(bais));\r\n    assertEquals(0, bais.available());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testDecodeInts",
  "sourceCode" : "@Test\r\nvoid testDecodeInts() throws Exception {\r\n    final int[] band = { 1, -2, -3, 1000, 55, 5, 10, 20 };\r\n    // first 5 of band to be encoded with DELTA5\r\n    final byte[] bytes1 = Codec.DELTA5.encode(new int[] { 1, -2, -3, 1000, 55 });\r\n    // rest of band to be encoded with UNSIGNED5\r\n    final byte[] bytes2 = Codec.UNSIGNED5.encode(new int[] { 5, 10, 20 });\r\n    final byte[] bandEncoded = new byte[bytes1.length + bytes2.length];\r\n    System.arraycopy(bytes1, 0, bandEncoded, 0, bytes1.length);\r\n    System.arraycopy(bytes2, 0, bandEncoded, bytes1.length, bytes2.length);\r\n    final RunCodec runCodec = new RunCodec(5, Codec.DELTA5, Codec.UNSIGNED5);\r\n    final int[] bandDecoded = runCodec.decodeInts(8, new ByteArrayInputStream(bandEncoded));\r\n    assertEquals(band.length, bandDecoded.length);\r\n    for (int i = 0; i < band.length; i++) {\r\n        assertEquals(band[i], bandDecoded[i]);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testEncodeSingleValue",
  "sourceCode" : "@Test\r\nvoid testEncodeSingleValue() {\r\n    assertThrows(Pack200Exception.class, () -> new RunCodec(10, Codec.SIGNED5, Codec.UDELTA5).encode(5), \"Should not allow a single value to be encoded as we don't know which codec to use\");\r\n    assertThrows(Pack200Exception.class, () -> new RunCodec(10, Codec.SIGNED5, Codec.UDELTA5).encode(5, 8), \"Should not allow a single value to be encoded as we don't know which codec to use\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testNestedPopulationCodec",
  "sourceCode" : "@Test\r\nvoid testNestedPopulationCodec() throws Exception {\r\n    final int[] band = { 11, 12, 33, 4000, -555, 5, 10, 20, 10, 3, 20, 20, 20, 10, 10, 999, 20, 789, 10, 10, 355, 12345 };\r\n    // first 5 of band to be encoded with DELTA5\r\n    final byte[] bytes1 = Codec.DELTA5.encode(new int[] { 11, 12, 33, 4000, -555 });\r\n    // rest of band to be encoded with a PopulationCodec\r\n    final PopulationCodec popCodec = new PopulationCodec(Codec.UNSIGNED5, Codec.BYTE1, Codec.UNSIGNED5);\r\n    final byte[] bytes2 = popCodec.encode(new int[] { 10, 20 }, new int[] { 0, 1, 2, 1, 0, 2, 2, 2, 1, 1, 0, 2, 0, 1, 1, 0, 0 }, new int[] { 5, 3, 999, 789, 355, 12345 });\r\n    final byte[] bandEncoded = new byte[bytes1.length + bytes2.length];\r\n    System.arraycopy(bytes1, 0, bandEncoded, 0, bytes1.length);\r\n    System.arraycopy(bytes2, 0, bandEncoded, bytes1.length, bytes2.length);\r\n    final RunCodec runCodec = new RunCodec(5, Codec.DELTA5, new PopulationCodec(Codec.UNSIGNED5, Codec.BYTE1, Codec.UNSIGNED5));\r\n    final int[] bandDecoded = runCodec.decodeInts(band.length, new ByteArrayInputStream(bandEncoded));\r\n    assertEquals(band.length, bandDecoded.length);\r\n    for (int i = 0; i < band.length; i++) {\r\n        assertEquals(band[i], bandDecoded[i]);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testNestedRunCodec",
  "sourceCode" : "@Test\r\nvoid testNestedRunCodec() throws Exception {\r\n    final int[] band = { 1, 2, 3, 10, 20, 30, 100, 200, 300 };\r\n    // first 3 of band to be encoded with UDELTA5\r\n    final byte[] bytes1 = Codec.UDELTA5.encode(new int[] { 1, 2, 3 });\r\n    // rest of band to be encoded with a RunCodec\r\n    final byte[] bytes2 = Codec.BYTE1.encode(new int[] { 10, 20, 30 });\r\n    final byte[] bytes3 = Codec.UNSIGNED5.encode(new int[] { 100, 200, 300 });\r\n    final byte[] bandEncoded = new byte[bytes1.length + bytes2.length + bytes3.length];\r\n    System.arraycopy(bytes1, 0, bandEncoded, 0, bytes1.length);\r\n    System.arraycopy(bytes2, 0, bandEncoded, bytes1.length, bytes2.length);\r\n    System.arraycopy(bytes3, 0, bandEncoded, bytes1.length + bytes2.length, bytes3.length);\r\n    final RunCodec runCodec = new RunCodec(3, Codec.UDELTA5, new RunCodec(3, Codec.BYTE1, Codec.UNSIGNED5));\r\n    final int[] bandDecoded = runCodec.decodeInts(9, new ByteArrayInputStream(bandEncoded));\r\n    assertEquals(band.length, bandDecoded.length);\r\n    for (int i = 0; i < band.length; i++) {\r\n        assertEquals(band[i], bandDecoded[i]);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testPopulationCodecDecodeIntsOverflow",
  "sourceCode" : "@Disabled\r\n@Test\r\nvoid testPopulationCodecDecodeIntsOverflow() throws Exception {\r\n    final byte[] bytes1 = Codec.DELTA5.encode(new int[] { 11, 12, 33, 4000, -555 });\r\n    final PopulationCodec popCodec = new PopulationCodec(Codec.UNSIGNED5, Codec.BYTE1, Codec.UNSIGNED5);\r\n    final byte[] bytes2 = popCodec.encode(new int[] { 10, 20 }, new int[] { 0, 1, 2, 1, 0, 2, 2, 2, 1, 1, 0, 2, 0, 1, 1, 0, 0 }, new int[] { 5, 3, 999, 789, 355, 12345 });\r\n    final byte[] bandEncoded = new byte[bytes1.length + bytes2.length];\r\n    // Should only throw an IOException and not an OutOfMemoryError\r\n    assertThrows(IOException.class, () -> popCodec.decodeInts(Integer.MAX_VALUE - 1, new ByteArrayInputStream(bandEncoded)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testRunCodec",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"runCodec\")\r\nvoid testRunCodec(final int k, final Codec aCodec, final Codec bCodec, final String failureMessage) {\r\n    assertThrows(Pack200Exception.class, () -> new RunCodec(k, aCodec, bCodec), failureMessage);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testRunCodecDecodeIntsOverflow",
  "sourceCode" : "@Disabled\r\n@Test\r\nvoid testRunCodecDecodeIntsOverflow() throws Exception {\r\n    final byte[] bytes1 = Codec.DELTA5.encode(new int[] { 1, -2, -3, 1000, 55 });\r\n    final byte[] bytes2 = Codec.UNSIGNED5.encode(new int[] { 5, 10, 20 });\r\n    final byte[] bandEncoded = new byte[bytes1.length + bytes2.length];\r\n    System.arraycopy(bytes1, 0, bandEncoded, 0, bytes1.length);\r\n    System.arraycopy(bytes2, 0, bandEncoded, bytes1.length, bytes2.length);\r\n    final RunCodec runCodec = new RunCodec(5, Codec.DELTA5, Codec.UNSIGNED5);\r\n    // Should only throw an IOException and not an OutOfMemoryError\r\n    assertThrows(IOException.class, () -> runCodec.decodeInts(Integer.MAX_VALUE - 1, new ByteArrayInputStream(bandEncoded)));\r\n    assertThrows(IOException.class, () -> runCodec.decodeInts(Integer.MAX_VALUE - 1, new ByteArrayInputStream(bandEncoded), 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\pack200\\RunCodecTest.java",
  "methodName" : "testToString",
  "sourceCode" : "@Test\r\nvoid testToString() throws Pack200Exception {\r\n    final RunCodec runCodec = new RunCodec(3, Codec.UNSIGNED5, Codec.BYTE1);\r\n    assertEquals(\"RunCodec[k=\" + 3 + \";aCodec=\" + Codec.UNSIGNED5 + \"bCodec=\" + Codec.BYTE1 + \"]\", runCodec.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testAlternativeConstructor",
  "sourceCode" : "@Test\r\nvoid testAlternativeConstructor() throws Exception {\r\n    final String inputFile = new File(Archive.class.getResource(\"/pack200/sql.pack.gz\").toURI()).getPath();\r\n    final File file = createTempFile(\"sql\", \".jar\");\r\n    final String outputFile = file.getPath();\r\n    new Archive(inputFile, outputFile).unpack();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testDeflateHint",
  "sourceCode" : "@Test\r\nvoid testDeflateHint() throws Exception {\r\n    File file = createTempFile(\"sql\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.setDeflateHint(true);\r\n        archive.unpack();\r\n    }\r\n    try (JarFile jarFile = new JarFile(file)) {\r\n        assertEquals(ZipEntry.DEFLATED, jarFile.getEntry(\"bin/test/org/apache/harmony/sql/tests/internal/rowset/CachedRowSetImplTest.class\").getMethod());\r\n        try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql.pack.gz\")) {\r\n            file = createTempFile(\"sql\", \".jar\");\r\n            try (JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n                final Archive archive = new Archive(in, out);\r\n                archive.setDeflateHint(false);\r\n                archive.unpack();\r\n            }\r\n        }\r\n    }\r\n    try (JarFile jarFile = new JarFile(file)) {\r\n        assertEquals(ZipEntry.STORED, jarFile.getEntry(\"bin/test/org/apache/harmony/sql/tests/internal/rowset/CachedRowSetImplTest.class\").getMethod());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testJustResourcesGZip",
  "sourceCode" : "@Test\r\nvoid testJustResourcesGZip() throws Exception {\r\n    final File file = createTempFile(\"Just\", \"ResourcesGz.jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/JustResources.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        new Archive(in, out).unpack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testLoggingOptions",
  "sourceCode" : "// Test verbose, quiet and log file options.\r\n@Test\r\nvoid testLoggingOptions() throws Exception {\r\n    // test default option, which is quiet (no output at all)\r\n    File file = createTempFile(\"logtest\", \".jar\");\r\n    File logFile = createTempFile(\"logfile\", \".txt\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.setLogFile(logFile.getPath());\r\n        archive.unpack();\r\n    }\r\n    // log file should be empty\r\n    assertEquals(0, logFile.length());\r\n    // test verbose\r\n    file = createTempFile(\"logtest\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        logFile = createTempFile(\"logfile\", \".txt\");\r\n        archive.setLogFile(logFile.getPath());\r\n        archive.setVerbose(true);\r\n        archive.unpack();\r\n    }\r\n    // log file should not be empty\r\n    assertTrue(logFile.length() > 0);\r\n    // test append option\r\n    final long length = logFile.length();\r\n    file = createTempFile(\"logtest\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.setLogFile(logFile.getPath(), true);\r\n        archive.setVerbose(true);\r\n        archive.unpack();\r\n    }\r\n    assertTrue(logFile.length() > length);\r\n    file = createTempFile(\"logtest\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.setLogFile(logFile.getPath(), false);\r\n        archive.setVerbose(true);\r\n        archive.unpack();\r\n    }\r\n    assertEquals(logFile.length(), length);\r\n    // test setting quiet explicitly\r\n    file = createTempFile(\"logtest\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        logFile = createTempFile(\"logfile\", \".txt\");\r\n        archive.setLogFile(logFile.getPath());\r\n        archive.setQuiet(true);\r\n        archive.unpack();\r\n    }\r\n    // log file should be empty\r\n    assertEquals(0, logFile.length());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testParsingOOMBounded",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { // @formatter:off\r\n\"bandint_oom.pack\", \"cpfloat_oom.pack\", \"cputf8_oom.pack\", \"favoured_oom.pack\", \"filebits_oom.pack\", \"flags_oom.pack\", \"references_oom.pack\", \"segment_header_oom.pack\", \"signatures_oom.pack\" // @formatter:on\r\n})\r\n// Tests of various files that can cause out of memory errors\r\nvoid testParsingOOMBounded(final String testFileName) throws Exception {\r\n    final URL url = Segment.class.getResource(\"/org/apache/commons/compress/pack/\" + testFileName);\r\n    try (BoundedInputStream in = Pack200UnpackerAdapter.newBoundedInputStream(url);\r\n        JarOutputStream out = new JarOutputStream(NullOutputStream.INSTANCE)) {\r\n        assertThrows(IOException.class, () -> new Archive(in, out).unpack());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testParsingOOMUnbounded",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { // @formatter:off\r\n\"bandint_oom.pack\", \"cpfloat_oom.pack\", \"cputf8_oom.pack\", \"favoured_oom.pack\", \"filebits_oom.pack\", \"flags_oom.pack\", \"references_oom.pack\", \"segment_header_oom.pack\", \"signatures_oom.pack\" // @formatter:on\r\n})\r\n// Tests of various files that can cause out of memory errors\r\nvoid testParsingOOMUnbounded(final String testFileName) throws Exception {\r\n    try (InputStream is = Segment.class.getResourceAsStream(\"/org/apache/commons/compress/pack/\" + testFileName);\r\n        JarOutputStream out = new JarOutputStream(NullOutputStream.INSTANCE)) {\r\n        assertThrows(IOException.class, () -> new Archive(is, out).unpack());\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testRemovePackFile",
  "sourceCode" : "@Test\r\nvoid testRemovePackFile() throws Exception {\r\n    final File copy = createTempFile(\"sqlcopy\", \".pack.gz\");\r\n    final File original = new File(Archive.class.getResource(\"/pack200/sql.pack.gz\").toURI());\r\n    try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(original));\r\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(copy))) {\r\n        final byte[] bytes = new byte[256];\r\n        int read = inputStream.read(bytes);\r\n        while (read > 0) {\r\n            outputStream.write(bytes, 0, read);\r\n            read = inputStream.read(bytes);\r\n        }\r\n    }\r\n    final String inputFileName = copy.getPath();\r\n    final File file = createTempFile(\"sqlout\", \".jar\");\r\n    final String outputFileName = file.getPath();\r\n    final Archive archive = new Archive(inputFileName, outputFileName);\r\n    archive.setRemovePackFile(true);\r\n    archive.unpack();\r\n    assertFalse(copy.exists());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testWithAnnotations",
  "sourceCode" : "// Test with an archive containing Annotations\r\n@Test\r\nvoid testWithAnnotations() throws Exception {\r\n    final File file = createTempFile(\"annotations\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/annotations.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.unpack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testWithE0",
  "sourceCode" : "// Test with an archive packed with the -E0 option\r\n@Test\r\nvoid testWithE0() throws Exception {\r\n    final File file = createTempFile(\"simple-e0\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/simple-E0.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.unpack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testWithJNDIE1",
  "sourceCode" : "// Test with an archive containing Harmony's JNDI module\r\n@Test\r\nvoid testWithJNDIE1() throws Exception {\r\n    final File file = createTempFile(\"jndi-e1\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/jndi-e1.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.unpack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testWithLargeClass",
  "sourceCode" : "// Test with a class containing lots of local variables (regression test for\r\n// HARMONY-5470)\r\n@Test\r\nvoid testWithLargeClass() throws Exception {\r\n    final File file = createTempFile(\"largeClass\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/LargeClass.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.unpack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testWithPack200",
  "sourceCode" : "// Test with an archive containing Harmony's Pack200 module\r\n@Test\r\nvoid testWithPack200() throws Exception {\r\n    final File file = createTempFile(\"p200\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/pack200.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.unpack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testWithPack200E1",
  "sourceCode" : "// Test with an archive containing Harmony's Pack200 module, packed with -E1\r\n@Test\r\nvoid testWithPack200E1() throws Exception {\r\n    final File file = createTempFile(\"p200-e1\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/pack200-e1.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.unpack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testWithSql",
  "sourceCode" : "// Test with an archive containing Harmony's SQL module\r\n@Test\r\nvoid testWithSql() throws Exception {\r\n    final File file = createTempFile(\"sql\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        new Archive(in, out).unpack();\r\n    }\r\n    final File compareFile = new File(Archive.class.getResource(\"/pack200/sqlUnpacked.jar\").toURI());\r\n    try (JarFile jarFile = new JarFile(file);\r\n        JarFile jarFile2 = new JarFile(compareFile)) {\r\n        final long differenceInJarSizes = Math.abs(compareFile.length() - file.length());\r\n        assertTrue(differenceInJarSizes < 100, \"Expected jar files to be a similar size, difference was \" + differenceInJarSizes + \" bytes\");\r\n        final Enumeration<JarEntry> entries = jarFile.entries();\r\n        final Enumeration<JarEntry> entries2 = jarFile2.entries();\r\n        while (entries.hasMoreElements() && entries2.hasMoreElements()) {\r\n            final JarEntry entry = entries.nextElement();\r\n            assertNotNull(entry);\r\n            final String name = entry.getName();\r\n            final JarEntry entry2 = entries2.nextElement();\r\n            assertNotNull(entry2);\r\n            final String name2 = entry2.getName();\r\n            assertEquals(name, name2);\r\n            try (InputStream ours = jarFile.getInputStream(entry);\r\n                InputStream expected = jarFile2.getInputStream(entry2);\r\n                BufferedReader reader1 = new BufferedReader(new InputStreamReader(ours));\r\n                BufferedReader reader2 = new BufferedReader(new InputStreamReader(expected))) {\r\n                String line1 = reader1.readLine();\r\n                String line2 = reader2.readLine();\r\n                int i = 1;\r\n                while (line1 != null || line2 != null) {\r\n                    assertEquals(line2, line1, \"Unpacked class files differ for \" + name);\r\n                    line1 = reader1.readLine();\r\n                    line2 = reader2.readLine();\r\n                    i++;\r\n                }\r\n                assertTrue(i > 0);\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ArchiveTest.java",
  "methodName" : "testWithSqlE1",
  "sourceCode" : "// Test with an archive containing Harmony's SQL module, packed with -E1\r\n@Test\r\nvoid testWithSqlE1() throws Exception {\r\n    final File file = createTempFile(\"sql-e1\", \".jar\");\r\n    try (InputStream in = Archive.class.getResourceAsStream(\"/pack200/sql-e1.pack.gz\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        final Archive archive = new Archive(in, out);\r\n        archive.unpack();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\AttributeLayoutMapTest.java",
  "methodName" : "testRepeatable",
  "sourceCode" : "@Test\r\nvoid testRepeatable() throws Pack200Exception {\r\n    // Check we can retrieve a default layout\r\n    final AttributeLayoutMap a = new AttributeLayoutMap();\r\n    AttributeLayout layout = a.getAttributeLayout(\"SourceFile\", AttributeLayout.CONTEXT_CLASS);\r\n    assertNotNull(layout);\r\n    assertEquals(\"RUNH\", layout.getLayout());\r\n    assertEquals(17, layout.getIndex());\r\n    // and that we can change it\r\n    a.add(new AttributeLayout(\"SourceFile\", AttributeLayout.CONTEXT_CLASS, \"FROG\", 17));\r\n    layout = a.getAttributeLayout(\"SourceFile\", AttributeLayout.CONTEXT_CLASS);\r\n    assertNotNull(layout);\r\n    assertEquals(\"FROG\", layout.getLayout());\r\n    assertTrue(layout.matches(1 << 17));\r\n    assertFalse(layout.matches(1 << 16));\r\n    assertTrue(layout.matches(-1));\r\n    assertFalse(layout.matches(0));\r\n    // and that changes don't affect subsequent defaults\r\n    final AttributeLayoutMap b = new AttributeLayoutMap();\r\n    layout = b.getAttributeLayout(\"SourceFile\", AttributeLayout.CONTEXT_CLASS);\r\n    assertNotNull(layout);\r\n    assertEquals(\"RUNH\", layout.getLayout());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\AttributeLayoutTest.java",
  "methodName" : "testBadData",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"badData\")\r\nvoid testBadData(final String name, final int context, final String layout) {\r\n    assertThrows(Pack200Exception.class, () -> new AttributeLayout(name, context, layout, -1));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\AttributeLayoutTest.java",
  "methodName" : "testGetCodec",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"codec\")\r\nvoid testGetCodec(final String name, final int context, final String layout, final Codec expectedCodec) throws Pack200Exception {\r\n    final AttributeLayout attributeLayout = new AttributeLayout(name, context, layout, 1);\r\n    assertEquals(expectedCodec, attributeLayout.getCodec());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\AttributeLayoutTest.java",
  "methodName" : "testLayoutRS",
  "sourceCode" : "@Test\r\nvoid testLayoutRS() throws Pack200Exception {\r\n    final AttributeLayout layout = new AttributeLayout(\"RS\", AttributeLayout.CONTEXT_CLASS, \"RS\", 1);\r\n    final Segment segment = new TestSegment();\r\n    assertNull(layout.getValue(-1, segment.getConstantPool()));\r\n    assertEquals(\"Eins\", ((CPUTF8) layout.getValue(0, segment.getConstantPool())).underlyingString());\r\n    assertEquals(\"Zwei\", ((CPUTF8) layout.getValue(1, segment.getConstantPool())).underlyingString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\AttributeLayoutTest.java",
  "methodName" : "testLayoutRSN",
  "sourceCode" : "@Test\r\nvoid testLayoutRSN() throws Pack200Exception {\r\n    final AttributeLayout layout = new AttributeLayout(\"RSN\", AttributeLayout.CONTEXT_CLASS, \"RSN\", 1);\r\n    final Segment segment = new TestSegment();\r\n    assertNull(layout.getValue(0, segment.getConstantPool()));\r\n    assertEquals(\"Eins\", ((CPUTF8) layout.getValue(1, segment.getConstantPool())).underlyingString());\r\n    assertEquals(\"Zwei\", ((CPUTF8) layout.getValue(2, segment.getConstantPool())).underlyingString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\AttributeLayoutTest.java",
  "methodName" : "testLayoutRU",
  "sourceCode" : "@Test\r\nvoid testLayoutRU() throws Pack200Exception {\r\n    final AttributeLayout layout = new AttributeLayout(\"RU\", AttributeLayout.CONTEXT_CLASS, \"RU\", 1);\r\n    final Segment segment = new TestSegment();\r\n    assertNull(layout.getValue(-1, segment.getConstantPool()));\r\n    assertEquals(\"Zero\", ((CPUTF8) layout.getValue(0, segment.getConstantPool())).underlyingString());\r\n    assertEquals(\"One\", ((CPUTF8) layout.getValue(1, segment.getConstantPool())).underlyingString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\AttributeLayoutTest.java",
  "methodName" : "testLayoutRUN",
  "sourceCode" : "@Test\r\nvoid testLayoutRUN() throws Pack200Exception {\r\n    final AttributeLayout layout = new AttributeLayout(\"RUN\", AttributeLayout.CONTEXT_CLASS, \"RUN\", 1);\r\n    final Segment segment = new TestSegment();\r\n    assertNull(layout.getValue(0, segment.getConstantPool()));\r\n    assertEquals(\"Zero\", ((CPUTF8) layout.getValue(1, segment.getConstantPool())).underlyingString());\r\n    assertEquals(\"One\", ((CPUTF8) layout.getValue(2, segment.getConstantPool())).underlyingString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\AttributeLayoutTest.java",
  "methodName" : "testOkData",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"okData\")\r\nvoid testOkData(final String name, final int context, final String layout) {\r\n    assertDoesNotThrow(() -> new AttributeLayout(name, context, layout, -1));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BandSetTest.java",
  "methodName" : "testDecodeBandInt",
  "sourceCode" : "@Test\r\nvoid testDecodeBandInt() throws IOException, Pack200Exception {\r\n    final BHSDCodec codec = Codec.BYTE1;\r\n    final byte[] bytes = { (byte) 3, (byte) 56, (byte) 122, (byte) 78 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    final int[] ints = bandSet.decodeBandInt(\"Test Band\", in, codec, 4);\r\n    for (int i = 0; i < ints.length; i++) {\r\n        assertEquals(ints[i], bytes[i], \"Wrong value in position \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BandSetTest.java",
  "methodName" : "testParseFlags1",
  "sourceCode" : "@Test\r\n@Disabled(\"TODO: Implement\")\r\nvoid testParseFlags1() {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BandSetTest.java",
  "methodName" : "testParseFlags2",
  "sourceCode" : "@Test\r\n@Disabled(\"TODO: Implement\")\r\nvoid testParseFlags2() {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BandSetTest.java",
  "methodName" : "testParseFlags3",
  "sourceCode" : "@Test\r\n@Disabled(\"TODO: Implement\")\r\nvoid testParseFlags3() {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BandSetTest.java",
  "methodName" : "testParseReferences1",
  "sourceCode" : "@Test\r\n@Disabled(\"TODO: Implement\")\r\nvoid testParseReferences1() {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BandSetTest.java",
  "methodName" : "testParseReferences2",
  "sourceCode" : "@Test\r\n@Disabled(\"TODO: Implement\")\r\nvoid testParseReferences2() {\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcByteBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_byte band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcByteBand() throws IOException, Pack200Exception {\r\n    final byte[] bytes = { // bc_byte band\r\n    16, // bc_byte band\r\n    (byte) 132, // bc_byte band\r\n    (byte) 188, // bc_byte band\r\n    (byte) 197, // bc_byte band\r\n    (byte) 255, // bc_byte band\r\n    8, // bc_byte band\r\n    8, // bc_byte band\r\n    8, // bc_byte band\r\n    8, // bc_locals band (required by iinc (132))\r\n    8, // bc_class band (required by multianewarray (197))\r\n    8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(4, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_byte = bcBands.getBcByte();\r\n    assertEquals(4, bc_byte.length);\r\n    for (final int element : bc_byte) {\r\n        assertEquals(8, element);\r\n    }\r\n    assertEquals(1, bcBands.getBcLocal().length);\r\n    assertEquals(1, bcBands.getBcClassRef().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcCaseBands",
  "sourceCode" : "/**\r\n * Test with codes that require entries in the bc_case_count and bc_case_value bands\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcCaseBands() throws IOException, Pack200Exception {\r\n    final byte[] bytes = { // bc_case_count\r\n    (byte) 170, // bc_case_count\r\n    (byte) 171, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    0, // bc_case_count\r\n    (byte) 255, // bc_case_count\r\n    2, // bc_case_count\r\n    5, // bc_case_value\r\n    0, // bc_case_value\r\n    0, // bc_case_value\r\n    0, // bc_case_value\r\n    0, // bc_case_value\r\n    0, // bc_case_value\r\n    0, // bc_case_value\r\n    0, 0, 0, 0, 0, 0, 0, 0, 0, // bc_label\r\n    0 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(18, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_case_count = bcBands.getBcCaseCount();\r\n    assertEquals(2, bc_case_count.length);\r\n    assertEquals(2, bc_case_count[0]);\r\n    assertEquals(5, bc_case_count[1]);\r\n    final int[] bc_case_value = bcBands.getBcCaseValue();\r\n    assertEquals(0, bc_case_value[0]);\r\n    assertEquals(0, bc_case_value[1]);\r\n    assertEquals(9, bcBands.getBcLabel().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcClassRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_classref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcClassRefBand() throws IOException, Pack200Exception {\r\n    // bc_classref\r\n    final byte[] bytes = { (byte) 233, (byte) 236, (byte) 255, 8, 8 };\r\n    // band\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(2, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_classref = bcBands.getBcClassRef();\r\n    assertEquals(2, bc_classref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcDoubleRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_doubleref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcDoubleRefBand() throws IOException, Pack200Exception {\r\n    // bc_doubleref\r\n    final byte[] bytes = { (byte) 239, (byte) 255, 8 };\r\n    // band\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(1, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_doubleref = bcBands.getBcDoubleRef();\r\n    assertEquals(1, bc_doubleref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcEscBands",
  "sourceCode" : "@Test\r\n@Disabled(\"TODO: Implement\")\r\nvoid testBcEscBands() {\r\n    // TODO\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcEscRefBands",
  "sourceCode" : "@Test\r\n@Disabled(\"TODO: Implement\")\r\nvoid testBcEscRefBands() {\r\n    // TODO\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcFieldRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_fieldref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcFieldRefBand() throws IOException, Pack200Exception {\r\n    // bc_fieldref band\r\n    final byte[] bytes = { (byte) 178, (byte) 179, (byte) 180, (byte) 181, (byte) 255, 8, 8, 8, 8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(4, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_fieldref = bcBands.getBcFieldRef();\r\n    assertEquals(4, bc_fieldref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcFloatRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_floatref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcFloatRefBand() throws IOException, Pack200Exception {\r\n    // bc_floatref\r\n    final byte[] bytes = { (byte) 235, (byte) 238, (byte) 255, 8, 8 };\r\n    // band\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(2, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_floatref = bcBands.getBcFloatRef();\r\n    assertEquals(2, bc_floatref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcIMethodRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_imethodref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcIMethodRefBand() throws IOException, Pack200Exception {\r\n    // bc_imethodref\r\n    final byte[] bytes = { (byte) 185, (byte) 255, 8 };\r\n    // band\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(1, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_imethodref = bcBands.getBcIMethodRef();\r\n    assertEquals(1, bc_imethodref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcInitRefRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_initrefref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\n@Disabled(\"TODO: Need to fix this test so it has enough data to pass.\")\r\nvoid testBcInitRefRefBand() throws IOException, Pack200Exception {\r\n    // bc_initrefref band\r\n    final byte[] bytes = { (byte) 230, (byte) 231, (byte) 232, (byte) 255, 8, 8, 8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(3, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_initrefref = bcBands.getBcInitRef();\r\n    assertEquals(3, bc_initrefref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcIntRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_intref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcIntRefBand() throws IOException, Pack200Exception {\r\n    // bc_intref\r\n    final byte[] bytes = { (byte) 234, (byte) 237, (byte) 255, 8, 8 };\r\n    // band\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(2, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_intref = bcBands.getBcIntRef();\r\n    assertEquals(2, bc_intref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcLabelBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_label band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcLabelBand() throws IOException, Pack200Exception {\r\n    final byte[] bytes = { (byte) 159, (byte) 160, (byte) 161, (byte) 162, (byte) 163, (byte) 164, (byte) 165, (byte) 166, (byte) 167, (byte) 168, (byte) 170, (byte) 171, (byte) 198, (byte) 199, (byte) 200, (byte) 201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 255, // bc_case_count\r\n    2, // bc_case_count\r\n    2, // (required\r\n    // by\r\n    // tableswitch\r\n    // (170) and\r\n    // lookupswitch\r\n    // (171))\r\n    // bc_case_value\r\n    0, // bc_case_value\r\n    0, // bc_case_value\r\n    0, // bc_case_value\r\n    0, // Now that we're actually doing real label lookup, need valid\r\n    // labels\r\n    // 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 }; // bc_label\r\n    // band\r\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // bc_label\r\n    0 };\r\n    // band\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(36, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    assertEquals(20, bcBands.getBcLabel().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcLocalBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_local band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcLocalBand() throws IOException, Pack200Exception {\r\n    // bc_local\r\n    final byte[] bytes = { 21, 22, 23, 24, 25, 54, 55, 56, 57, 58, (byte) 169, (byte) 255, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };\r\n    // band\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(11, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    assertEquals(11, bcBands.getBcLocal().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcLongRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_longref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcLongRefBand() throws IOException, Pack200Exception {\r\n    // bc_longref band\r\n    final byte[] bytes = { 20, (byte) 255, 8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(1, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_longref = bcBands.getBcLongRef();\r\n    assertEquals(1, bc_longref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcMethodRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_methodref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcMethodRefBand() throws IOException, Pack200Exception {\r\n    // bc_methodref band\r\n    final byte[] bytes = { (byte) 182, (byte) 183, (byte) 184, (byte) 255, 8, 8, 8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(3, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_methodref = bcBands.getBcMethodRef();\r\n    assertEquals(3, bc_methodref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcShortBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_short band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcShortBand() throws IOException, Pack200Exception {\r\n    // TODO: Need to fix this test so it has enough data to pass.\r\n    final byte[] bytes = { // bc_short band\r\n    17, // bc_short band\r\n    (byte) 196, // bc_short band\r\n    (byte) 132, // bc_short band\r\n    (byte) 255, // bc_short band\r\n    8, // bc_short band\r\n    8, // bc_locals band (required by wide iinc (196, 132))\r\n    8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(3, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    assertEquals(2, bcBands.getBcShort().length);\r\n    assertEquals(1, bcBands.getBcLocal().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcStringRefBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_stringref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcStringRefBand() throws IOException, Pack200Exception {\r\n    // bc_stringref\r\n    final byte[] bytes = { 18, 19, (byte) 255, 8, 8 };\r\n    // band\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(2, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_stringref = bcBands.getBcStringRef();\r\n    assertEquals(2, bc_stringref.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcSuperFieldBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_superfield band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcSuperFieldBand() throws IOException, Pack200Exception {\r\n    final byte[] bytes = { (byte) 216, (byte) 217, (byte) 218, (byte) 219, (byte) 223, (byte) 224, (byte) 225, (byte) 226, (byte) 255, 8, 8, 8, 8, 8, 8, 8, // bc_superfield band\r\n    8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(8, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_superfield = bcBands.getBcSuperField();\r\n    assertEquals(8, bc_superfield.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcSuperMethodBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_supermethod band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\n@Disabled(\"TODO: Need to fix this test so it has enough data to pass.\")\r\nvoid testBcSuperMethodBand() throws IOException, Pack200Exception {\r\n    // bc_supermethod band\r\n    final byte[] bytes = { (byte) 220, (byte) 221, (byte) 222, (byte) 227, (byte) 228, (byte) 229, (byte) 255, 8, 8, 8, 8, 8, 8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(6, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_supermethod = bcBands.getBcSuperMethod();\r\n    assertEquals(6, bc_supermethod.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcThisFieldBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_thisfieldref band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcThisFieldBand() throws IOException, Pack200Exception {\r\n    final byte[] bytes = { (byte) 202, (byte) 203, (byte) 204, (byte) 205, (byte) 209, (byte) 210, (byte) 211, (byte) 212, (byte) 255, 8, 8, 8, 8, 8, 8, 8, // bc_thisfieldref band\r\n    8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(8, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_thisfield = bcBands.getBcThisField();\r\n    assertEquals(8, bc_thisfield.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testBcThisMethodBand",
  "sourceCode" : "/**\r\n * Test with codes that should require entries in the bc_thismethod band\r\n *\r\n * @throws Pack200Exception\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n@Test\r\nvoid testBcThisMethodBand() throws IOException, Pack200Exception {\r\n    // bc_thismethod band\r\n    final byte[] bytes = { (byte) 206, (byte) 207, (byte) 208, (byte) 213, (byte) 214, (byte) 215, (byte) 255, 8, 8, 8, 8, 8, 8 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(6, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    final int[] bc_thismethod = bcBands.getBcThisMethod();\r\n    assertEquals(6, bc_thismethod.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testMultipleClassesSimple",
  "sourceCode" : "/**\r\n * Test with multiple classes but single byte instructions\r\n *\r\n * @throws IOException if an I/O error occurs.\r\n * @throws Pack200Exception\r\n */\r\n@Test\r\nvoid testMultipleClassesSimple() throws IOException, Pack200Exception {\r\n    numClasses = 2;\r\n    numMethods = new int[] { 1, 1 };\r\n    final byte[] bytes = { 50, 50, (byte) 255, 50, 50, (byte) 255 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(2, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    assertEquals(2, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    numClasses = 1;\r\n    numMethods = new int[] { 1 };\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testMultipleMethodsSimple",
  "sourceCode" : "/**\r\n * Test with multiple classes and multiple methods but single byte instructions\r\n *\r\n * @throws IOException if an I/O error occurs.\r\n * @throws Pack200Exception\r\n */\r\n@Test\r\nvoid testMultipleMethodsSimple() throws IOException, Pack200Exception {\r\n    numClasses = 2;\r\n    numMethods = new int[] { 3, 1 };\r\n    final byte[] bytes = { 50, 50, (byte) 255, 50, 50, (byte) 255, 50, 50, (byte) 255, 50, 50, (byte) 255 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(2, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    assertEquals(2, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    numClasses = 1;\r\n    numMethods = new int[] { 1 };\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testSimple",
  "sourceCode" : "/**\r\n * Test with single byte instructions that mean all other bands apart from bc_codes will be empty.\r\n *\r\n * @throws IOException if an I/O error occurs.\r\n * @throws Pack200Exception\r\n */\r\n@Test\r\nvoid testSimple() throws IOException, Pack200Exception {\r\n    final byte[] bytes = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, (byte) 128, (byte) 129, (byte) 130, (byte) 131, (byte) 133, (byte) 134, (byte) 135, (byte) 136, (byte) 137, (byte) 138, (byte) 139, (byte) 140, (byte) 141, (byte) 142, (byte) 143, (byte) 144, (byte) 145, (byte) 146, (byte) 147, (byte) 148, (byte) 149, (byte) 150, (byte) 151, (byte) 172, (byte) 173, (byte) 174, (byte) 175, (byte) 176, (byte) 177, (byte) 190, (byte) 191, (byte) 194, (byte) 195, (byte) 255 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(bytes.length - 1, bcBands.getMethodByteCodePacked()[0][0].length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\BcBandsTest.java",
  "methodName" : "testWideForms",
  "sourceCode" : "@Test\r\nvoid testWideForms() throws IOException, Pack200Exception {\r\n    final byte[] bytes = { // wide istore\r\n    (byte) 196, // wide istore\r\n    (byte) 54, // wide iinc\r\n    (byte) 196, // wide iinc\r\n    (byte) 132, // bc_short band\r\n    (byte) 255, // bc_short band\r\n    0, 0, // bc_locals band\r\n    1 };\r\n    final InputStream in = new ByteArrayInputStream(bytes);\r\n    bcBands.unpack(in);\r\n    assertEquals(4, bcBands.getMethodByteCodePacked()[0][0].length);\r\n    assertEquals(2, bcBands.getBcLocal().length);\r\n    assertEquals(1, bcBands.getBcShort().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ByteCodeTest.java",
  "methodName" : "testByteCode",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"byteCode\")\r\nvoid testByteCode(final int opCode, final String expectedName) {\r\n    assertEquals(expectedName, ByteCode.getByteCode(opCode).getName());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ClassFileEntryTest.java",
  "methodName" : "testCPDouble",
  "sourceCode" : "@Test\r\nvoid testCPDouble() {\r\n    final CPDouble cp1 = new CPDouble(Double.valueOf(3), 3);\r\n    final CPDouble cp2 = new CPDouble(Double.valueOf(3), 3);\r\n    final CPDouble cp3 = new CPDouble(Double.valueOf(5), 5);\r\n    //$NON-NLS-1$\r\n    checkEquality(cp1, cp2, \"3\", cp3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ClassFileEntryTest.java",
  "methodName" : "testCPField",
  "sourceCode" : "@Test\r\nvoid testCPField() {\r\n    final CPMember cp1 = new CPMember(new CPUTF8(\"Name\", 3), new CPUTF8(\"I\", 4), 0, null);\r\n    final CPMember cp2 = new CPMember(new CPUTF8(\"Name\", 3), new CPUTF8(\"I\", 4), 0, null);\r\n    final CPMember cp3 = new CPMember(new CPUTF8(\"Name\", 3), new CPUTF8(\"Z\", 5), 0, null);\r\n    final CPMember cp4 = new CPMember(new CPUTF8(\"GName\", 6), new CPUTF8(\"I\", 4), 0, null);\r\n    //$NON-NLS-1$\r\n    checkEquality(cp1, cp2, \"Name\", cp3);\r\n    //$NON-NLS-1$\r\n    checkEquality(cp1, cp2, \"I\", cp4);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ClassFileEntryTest.java",
  "methodName" : "testCPFloat",
  "sourceCode" : "@Test\r\nvoid testCPFloat() {\r\n    final CPFloat cp1 = new CPFloat(Float.valueOf(3), 3);\r\n    final CPFloat cp2 = new CPFloat(Float.valueOf(3), 3);\r\n    final CPFloat cp3 = new CPFloat(Float.valueOf(5), 5);\r\n    //$NON-NLS-1$\r\n    checkEquality(cp1, cp2, \"3\", cp3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ClassFileEntryTest.java",
  "methodName" : "testCPInteger",
  "sourceCode" : "@Test\r\nvoid testCPInteger() {\r\n    final CPInteger cp1 = new CPInteger(Integer.valueOf(3), 3);\r\n    final CPInteger cp2 = new CPInteger(Integer.valueOf(3), 3);\r\n    final CPInteger cp3 = new CPInteger(Integer.valueOf(5), 5);\r\n    //$NON-NLS-1$\r\n    checkEquality(cp1, cp2, \"3\", cp3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ClassFileEntryTest.java",
  "methodName" : "testCPLong",
  "sourceCode" : "@Test\r\nvoid testCPLong() {\r\n    final CPLong cp1 = new CPLong(Long.valueOf(3), 3);\r\n    final CPLong cp2 = new CPLong(Long.valueOf(3), 3);\r\n    final CPLong cp3 = new CPLong(Long.valueOf(5), 5);\r\n    //$NON-NLS-1$\r\n    checkEquality(cp1, cp2, \"3\", cp3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ClassFileEntryTest.java",
  "methodName" : "testCPString",
  "sourceCode" : "@Test\r\nvoid testCPString() {\r\n    final CPString cp1 = new CPString(new CPUTF8(\"3\", 3), 3);\r\n    final CPString cp2 = new CPString(new CPUTF8(\"3\", 3), 3);\r\n    final CPString cp3 = new CPString(new CPUTF8(\"5\", 5), 5);\r\n    //$NON-NLS-1$\r\n    checkEquality(cp1, cp2, \"3\", cp3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ClassFileEntryTest.java",
  "methodName" : "testSourceAttribute",
  "sourceCode" : "@Test\r\nvoid testSourceAttribute() {\r\n    //$NON-NLS-1$\r\n    final SourceFileAttribute sfa1 = new SourceFileAttribute(new CPUTF8(\"Thing.java\", 1));\r\n    //$NON-NLS-1$\r\n    final SourceFileAttribute sfa2 = new SourceFileAttribute(new CPUTF8(\"Thing.java\", 1));\r\n    //$NON-NLS-1$\r\n    final SourceFileAttribute sfa3 = new SourceFileAttribute(new CPUTF8(\"OtherThing.java\", 2));\r\n    //$NON-NLS-1$\r\n    checkEquality(sfa1, sfa2, \"Thing.java\", sfa3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ClassFileEntryTest.java",
  "methodName" : "testUTF8",
  "sourceCode" : "@Test\r\nvoid testUTF8() {\r\n    //$NON-NLS-1$\r\n    final CPUTF8 u1 = new CPUTF8(\"thing\", 1);\r\n    //$NON-NLS-1$\r\n    final CPUTF8 u2 = new CPUTF8(\"thing\", 1);\r\n    //$NON-NLS-1$\r\n    final CPUTF8 u3 = new CPUTF8(\"otherthing\", 2);\r\n    checkEquality(u1, u2, \"thing\", u3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ConstantPoolTest.java",
  "methodName" : "testDuplicateField",
  "sourceCode" : "@Test\r\nvoid testDuplicateField() {\r\n    final CPMember cp1 = new CPMember(new CPUTF8(\"name\", 1), new CPUTF8(\"I\", 2), 0, null);\r\n    pool.add(cp1);\r\n    pool.addNestedEntries();\r\n    assertEquals(2, pool.size());\r\n    final CPMember cp2 = new CPMember(new CPUTF8(\"name\", 1), new CPUTF8(\"I\", 2), 0, null);\r\n    pool.add(cp2);\r\n    pool.addNestedEntries();\r\n    assertEquals(2, pool.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ConstantPoolTest.java",
  "methodName" : "testDuplicateUTF8",
  "sourceCode" : "@Test\r\nvoid testDuplicateUTF8() {\r\n    final CPUTF8 u1 = new CPUTF8(\"thing\", 1);\r\n    final CPUTF8 u2 = new CPUTF8(\"thing\", 1);\r\n    pool.add(u1);\r\n    pool.add(u2);\r\n    assertEquals(1, pool.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ConstantPoolTest.java",
  "methodName" : "testEntries",
  "sourceCode" : "@Test\r\nvoid testEntries() {\r\n    pool.add(new CPClass(new CPUTF8(\"RandomClass\", 1), 10));\r\n    pool.add(new CPClass(new CPUTF8(\"RandomClass2\", 2), 20));\r\n    assertEquals(2, pool.entries().size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\bytecode\\ConstantPoolTest.java",
  "methodName" : "testIndex",
  "sourceCode" : "@Test\r\nvoid testIndex() {\r\n    pool.add(new CPUTF8(\"OtherThing\", 1));\r\n    final CPUTF8 u1 = new CPUTF8(\"thing\", 2);\r\n    pool.add(u1);\r\n    pool.resolve(new Segment());\r\n    assertTrue(pool.indexOf(u1) > 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ClassBandsTest.java",
  "methodName" : "testSimple",
  "sourceCode" : "@Test\r\nvoid testSimple() throws IOException, Pack200Exception {\r\n    cpClasses = new String[] { \"Class1\", \"Class2\", \"Class3\", \"Interface1\", \"Interface2\" };\r\n    cpDescriptor = new String[0];\r\n    cpUTF8 = new String[0];\r\n    final byte[] classThis = Codec.DELTA5.encode(1, 0);\r\n    final byte[] classSuper = Codec.DELTA5.encode(2, 0);\r\n    final byte[] classInterfaceCount = Codec.DELTA5.encode(2, 0);\r\n    final byte[] classInterfaceRef1 = encodeBandInt(new int[] { 3, 4 }, Codec.DELTA5);\r\n    final byte[] classFieldCount = Codec.DELTA5.encode(0, 0);\r\n    final byte[] classMethodCount = Codec.DELTA5.encode(0, 0);\r\n    final byte[] classFlags = Codec.UNSIGNED5.encode(0, 0);\r\n    final byte[][] allArrays = { classThis, classSuper, classInterfaceCount, classInterfaceRef1, classFieldCount, classMethodCount, classFlags };\r\n    final int total = classThis.length + classSuper.length + classInterfaceCount.length + classInterfaceRef1.length + classFieldCount.length + classMethodCount.length + classFlags.length;\r\n    final byte[] bytes = new byte[total];\r\n    int index = 0;\r\n    for (final byte[] array : allArrays) {\r\n        for (final byte element : array) {\r\n            bytes[index] = element;\r\n            index++;\r\n        }\r\n    }\r\n    final ByteArrayInputStream in = new ByteArrayInputStream(bytes);\r\n    classBands.unpack(in);\r\n    assertEquals(1, classBands.getClassThisInts()[0]);\r\n    assertEquals(2, classBands.getClassSuperInts()[0]);\r\n    assertEquals(1, classBands.getClassInterfacesInts().length);\r\n    assertEquals(2, classBands.getClassInterfacesInts()[0].length);\r\n    assertEquals(3, classBands.getClassInterfacesInts()[0][0]);\r\n    assertEquals(4, classBands.getClassInterfacesInts()[0][1]);\r\n    cpClasses = null;\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ClassBandsTest.java",
  "methodName" : "testWithMethods",
  "sourceCode" : "@Test\r\nvoid testWithMethods() throws Pack200Exception, IOException {\r\n    cpClasses = new String[] { \"Class1\", \"Class2\", \"Class3\" };\r\n    cpDescriptor = new String[] { \"method1\", \"method2\", \"method3\" };\r\n    cpUTF8 = new String[0];\r\n    final byte[] classThis = Codec.DELTA5.encode(1, 0);\r\n    final byte[] classSuper = Codec.DELTA5.encode(2, 0);\r\n    final byte[] classInterfaceCount = Codec.DELTA5.encode(0, 0);\r\n    final byte[] classFieldCount = Codec.DELTA5.encode(0, 0);\r\n    final byte[] classMethodCount = Codec.DELTA5.encode(3, 0);\r\n    final byte[] methodDescr = encodeBandInt(new int[] { 0, 1, 2 }, Codec.MDELTA5);\r\n    final byte[] methodFlagsLo = encodeBandInt(new int[] { 0, 0, 0 }, Codec.UNSIGNED5);\r\n    final byte[] classFlags = Codec.UNSIGNED5.encode(0, 0);\r\n    final byte[][] allArrays = { classThis, classSuper, classInterfaceCount, classFieldCount, classMethodCount, methodDescr, methodFlagsLo, classFlags };\r\n    int total = 0;\r\n    for (final byte[] array : allArrays) {\r\n        total += array.length;\r\n    }\r\n    final byte[] bytes = new byte[total];\r\n    int index = 0;\r\n    for (final byte[] array : allArrays) {\r\n        for (final byte element : array) {\r\n            bytes[index] = element;\r\n            index++;\r\n        }\r\n    }\r\n    final ByteArrayInputStream in = new ByteArrayInputStream(bytes);\r\n    classBands.unpack(in);\r\n    assertEquals(1, classBands.getClassThisInts()[0]);\r\n    assertEquals(2, classBands.getClassSuperInts()[0]);\r\n    assertEquals(1, classBands.getMethodDescr().length);\r\n    assertEquals(3, classBands.getMethodDescr()[0].length);\r\n    assertEquals(cpDescriptor[0], classBands.getMethodDescr()[0][0]);\r\n    assertEquals(cpDescriptor[1], classBands.getMethodDescr()[0][1]);\r\n    assertEquals(cpDescriptor[2], classBands.getMethodDescr()[0][2]);\r\n    cpClasses = null;\r\n    cpDescriptor = null;\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\CodeAttributeTest.java",
  "methodName" : "testLength",
  "sourceCode" : "@Test\r\nvoid testLength() throws Pack200Exception {\r\n    final OperandManager operandManager = new MockOperandManager();\r\n    operandManager.setSegment(segment);\r\n    operandManager.setCurrentClass(\"java/lang/Foo\");\r\n    final MockCodeAttribute attribute = new // maxStack\r\n    MockCodeAttribute(// maxStack\r\n    3, // maxLocals\r\n    2, // codePacked\r\n    mixedByteArray, // segment\r\n    segment, // operandManager\r\n    operandManager, new ArrayList<>());\r\n    assertEquals(29, attribute.getLength());\r\n    attribute.attributes.add(new LocalVariableTableAttribute(0, null, null, null, null, null));\r\n    assertEquals(37, attribute.getLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\CodeAttributeTest.java",
  "methodName" : "testMixedByteCodes",
  "sourceCode" : "@Test\r\nvoid testMixedByteCodes() throws Pack200Exception {\r\n    final OperandManager operandManager = new MockOperandManager();\r\n    operandManager.setSegment(segment);\r\n    operandManager.setCurrentClass(\"java/lang/Foo\");\r\n    final CodeAttribute attribute = new // maxStack\r\n    CodeAttribute(// maxStack\r\n    3, // maxLocals\r\n    2, // codePacked\r\n    mixedByteArray, // segment\r\n    segment, // operandManager\r\n    operandManager, new ArrayList<>());\r\n    assertEquals(2, attribute.maxLocals);\r\n    assertEquals(3, attribute.maxStack);\r\n    assertEquals(\"aload_0_putfield_this\", attribute.byteCodes.get(4).toString());\r\n    final int[] expectedLabels = { 0, 1, 4, 5, 8, 9, 10, 13, 14 };\r\n    for (int index = 0; index < expectedLabels.length; index++) {\r\n        assertEquals(expectedLabels[index], attribute.byteCodeOffsets.get(index).intValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\CodeAttributeTest.java",
  "methodName" : "testSingleByteCodes",
  "sourceCode" : "@Test\r\nvoid testSingleByteCodes() throws Pack200Exception {\r\n    final OperandManager operandManager = new MockOperandManager();\r\n    operandManager.setSegment(segment);\r\n    operandManager.setCurrentClass(\"java/lang/Foo\");\r\n    final CodeAttribute attribute = new // maxStack\r\n    CodeAttribute(// maxStack\r\n    4, // maxLocals\r\n    3, // codePacked\r\n    singleByteArray, // segment\r\n    segment, // operandManager\r\n    operandManager, new ArrayList<>());\r\n    assertEquals(3, attribute.maxLocals);\r\n    assertEquals(4, attribute.maxStack);\r\n    assertEquals(\"invokespecial_this\", attribute.byteCodes.get(3).toString());\r\n    final int[] expectedLabels = { 0, 1, 2, 4 };\r\n    for (int index = 0; index < expectedLabels.length; index++) {\r\n        assertEquals(expectedLabels[index], attribute.byteCodeOffsets.get(index).intValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\Codec_decodeInts_OutOfMemoryErrorTest.java",
  "methodName" : "test",
  "sourceCode" : "// @formatter:on\r\n@Test\r\nvoid test() throws IOException {\r\n    final byte[] input = Base64.getDecoder().decode(BASE64_BYTES);\r\n    try (InputStream is = new Pack200CompressorInputStream(new ByteArrayInputStream(input), Pack200Strategy.TEMP_FILE)) {\r\n        // do nothing\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\CPUTF8Test.java",
  "methodName" : "testEquality",
  "sourceCode" : "@Test\r\nvoid testEquality() {\r\n    final CPUTF8 one = new CPUTF8(\"(III)V\", 1);\r\n    final CPUTF8 two = new CPUTF8(\"((I[II)V\", 2);\r\n    final CPUTF8 three = new CPUTF8(\"([III)V\", 3);\r\n    assertNotEquals(one, two);\r\n    assertNotEquals(one, three);\r\n    assertNotEquals(two, three);\r\n    assertNotEquals(two, one);\r\n    assertNotEquals(three, one);\r\n    assertNotEquals(three, two);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ICTupleTest.java",
  "methodName" : "testExplicitClassTupleParsing",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"explicit\")\r\nvoid testExplicitClassTupleParsing(final String c, final String c2, final String n, final String expectedSimpleClassName, final String expectedOuterClass) {\r\n    final IcTuple tuple = new IcTuple(c, IcTuple.NESTED_CLASS_FLAG, c2, n, -1, -1, -1, -1);\r\n    assertEquals(expectedSimpleClassName, tuple.simpleClassName());\r\n    assertEquals(expectedOuterClass, tuple.outerClassString());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\ICTupleTest.java",
  "methodName" : "testPredictedClassTupleParsing",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"predicted\")\r\nvoid testPredictedClassTupleParsing(final String c, final String expectedSimpleClass, final String expectedOuterClass) {\r\n    final IcTuple tuple = new IcTuple(c, 0, null, null, -1, -1, -1, -1);\r\n    assertEquals(expectedSimpleClass, tuple.simpleClassName());\r\n    assertEquals(expectedOuterClass, tuple.outerClassString());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\LookupSwitchFormTest.java",
  "methodName" : "test",
  "sourceCode" : "/**\r\n * Run with {@copde -Xmx64m} too get a Pack200Exception(MemoryLimitException).\r\n *\r\n * @throws Pack200Exception\r\n */\r\n@Test\r\nvoid test() throws Pack200Exception {\r\n    final int large = 1_000_000_000;\r\n    final int[] caseCount = { large };\r\n    // Provide a dummy label for the defaultPc branch taken before the allocation.\r\n    final int[] labels = { 0 };\r\n    final int[] empty = {};\r\n    // The OperandManager requires all 21 band arrays.\r\n    // Most can be empty for this test.\r\n    final OperandManager om = new OperandManager(caseCount, empty, empty, empty, empty, labels, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty);\r\n    // lookupswitch\r\n    final ByteCode bc = ByteCode.getByteCode(171);\r\n    // Run with -Xmx64m too get a Pack200Exception(MemoryLimitException).\r\n    assertThrows(Exception.class, () -> new LookupSwitchForm(171, \"lookupswitch\").setByteCodeOperands(bc, om, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\NewAttributeBandsTest.java",
  "methodName" : "testEmptyLayout",
  "sourceCode" : "@Test\r\nvoid testEmptyLayout() throws IOException, Pack200Exception {\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_CLASS, \"\", 25));\r\n    final List<?> layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(0, layoutElements.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\NewAttributeBandsTest.java",
  "methodName" : "testIntegralLayout",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { \"B\", \"FB\", \"SB\", \"H\", \"FH\", \"SH\", \"I\", \"FI\", \"SI\", \"PB\", \"OB\", \"OSB\", \"POB\", \"PH\", \"OH\", \"OSH\", \"POH\", \"PI\", \"OI\", \"OSI\", \"POI\" })\r\nvoid testIntegralLayout(final String layoutStr) throws IOException, Pack200Exception {\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_CLASS, layoutStr, 25));\r\n    final List layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(1, layoutElements.size());\r\n    final Integral element = (Integral) layoutElements.get(0);\r\n    assertEquals(layoutStr, element.getTag());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\NewAttributeBandsTest.java",
  "methodName" : "testLayoutWithBackwardsCall",
  "sourceCode" : "@Test\r\nvoid testLayoutWithBackwardsCall() throws IOException, Pack200Exception {\r\n    MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_METHOD, \"[NH[(1)]][KIH][(-1)]\", 20));\r\n    List layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(3, layoutElements.size());\r\n    Callable firstCallable = (Callable) layoutElements.get(0);\r\n    Callable secondCallable = (Callable) layoutElements.get(1);\r\n    Callable thirdCallable = (Callable) layoutElements.get(2);\r\n    List thirdBody = thirdCallable.getBody();\r\n    assertEquals(1, thirdBody.size());\r\n    Call call = (Call) thirdBody.get(0);\r\n    assertEquals(secondCallable, call.getCallable());\r\n    assertTrue(secondCallable.isBackwardsCallable());\r\n    assertFalse(firstCallable.isBackwardsCallable());\r\n    assertFalse(thirdCallable.isBackwardsCallable());\r\n    newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_METHOD, \"[NH[(1)]][KIH][(-2)]\", 20));\r\n    layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(3, layoutElements.size());\r\n    firstCallable = (Callable) layoutElements.get(0);\r\n    secondCallable = (Callable) layoutElements.get(1);\r\n    thirdCallable = (Callable) layoutElements.get(2);\r\n    thirdBody = thirdCallable.getBody();\r\n    assertEquals(1, thirdBody.size());\r\n    call = (Call) thirdBody.get(0);\r\n    assertEquals(firstCallable, call.getCallable());\r\n    assertTrue(firstCallable.isBackwardsCallable());\r\n    assertFalse(secondCallable.isBackwardsCallable());\r\n    assertFalse(thirdCallable.isBackwardsCallable());\r\n    newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_METHOD, \"[NH[(1)]][KIH][(0)]\", 20));\r\n    layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(3, layoutElements.size());\r\n    firstCallable = (Callable) layoutElements.get(0);\r\n    secondCallable = (Callable) layoutElements.get(1);\r\n    thirdCallable = (Callable) layoutElements.get(2);\r\n    thirdBody = thirdCallable.getBody();\r\n    assertEquals(1, thirdBody.size());\r\n    call = (Call) thirdBody.get(0);\r\n    assertEquals(thirdCallable, call.getCallable());\r\n    assertTrue(thirdCallable.isBackwardsCallable());\r\n    assertFalse(firstCallable.isBackwardsCallable());\r\n    assertFalse(secondCallable.isBackwardsCallable());\r\n    assertFalse(firstCallable.isBackwardsCallable());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\NewAttributeBandsTest.java",
  "methodName" : "testLayoutWithCalls",
  "sourceCode" : "@Test\r\nvoid testLayoutWithCalls() throws IOException, Pack200Exception {\r\n    // @formatter:off\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_FIELD, \"[NH[(1)]][RSH NH[RUH(1)]][TB(66,67,73,83,90)[KIH](68)[KDH](70)[KFH](74)[KJH](99)[RSH](101)[RSH RUH](115)[RUH](91)[NH[(0)]](64)[RSH[RUH(0)]]()[]]\", 26));\r\n    // @formatter:on\r\n    final List layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(3, layoutElements.size());\r\n    final Callable firstCallable = (Callable) layoutElements.get(0);\r\n    final Callable secondCallable = (Callable) layoutElements.get(1);\r\n    final Callable thirdCallable = (Callable) layoutElements.get(2);\r\n    final List firstBody = firstCallable.getBody();\r\n    assertEquals(1, firstBody.size());\r\n    final Replication rep = (Replication) firstBody.get(0);\r\n    final List repBody = rep.getLayoutElements();\r\n    assertEquals(1, repBody.size());\r\n    final Call call = (Call) repBody.get(0);\r\n    assertEquals(1, call.getCallableIndex());\r\n    assertEquals(secondCallable, call.getCallable());\r\n    assertFalse(firstCallable.isBackwardsCallable());\r\n    assertFalse(secondCallable.isBackwardsCallable());\r\n    assertFalse(thirdCallable.isBackwardsCallable());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\NewAttributeBandsTest.java",
  "methodName" : "testReferenceLayouts",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { \"KIB\", \"KIH\", \"KII\", \"KINH\", \"KJH\", \"KDH\", \"KSH\", \"KQH\", \"RCH\", \"RSH\", \"RDH\", \"RFH\", \"RMH\", \"RIH\", \"RUH\", \"RQH\", \"RQNH\", \"RQNI\" })\r\nvoid testReferenceLayouts(final String layout) throws IOException, Pack200Exception {\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_CODE, layout, 26));\r\n    final List layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(1, layoutElements.size());\r\n    final Reference element = (Reference) layoutElements.get(0);\r\n    assertEquals(layout, element.getTag());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\NewAttributeBandsTest.java",
  "methodName" : "testReplicationLayout",
  "sourceCode" : "@Test\r\nvoid testReplicationLayout() throws IOException, Pack200Exception {\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_CLASS, \"NH[PHOHRUHRSHH]\", 25));\r\n    final List layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(1, layoutElements.size());\r\n    final Replication element = (Replication) layoutElements.get(0);\r\n    final Integral countElement = element.getCountElement();\r\n    assertEquals(\"H\", countElement.getTag());\r\n    final List replicatedElements = element.getLayoutElements();\r\n    assertEquals(5, replicatedElements.size());\r\n    final Integral firstElement = (Integral) replicatedElements.get(0);\r\n    assertEquals(\"PH\", firstElement.getTag());\r\n    final Integral secondElement = (Integral) replicatedElements.get(1);\r\n    assertEquals(\"OH\", secondElement.getTag());\r\n    final Reference thirdElement = (Reference) replicatedElements.get(2);\r\n    assertEquals(\"RUH\", thirdElement.getTag());\r\n    final Reference fourthElement = (Reference) replicatedElements.get(3);\r\n    assertEquals(\"RSH\", fourthElement.getTag());\r\n    final Integral fifthElement = (Integral) replicatedElements.get(4);\r\n    assertEquals(\"H\", fifthElement.getTag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\NewAttributeBandsTest.java",
  "methodName" : "testUnionLayout",
  "sourceCode" : "@Test\r\nvoid testUnionLayout() throws IOException, Pack200Exception {\r\n    final MockNewAttributeBands newAttributeBands = new MockNewAttributeBands(new MockSegment(), new AttributeLayout(\"test\", AttributeLayout.CONTEXT_CODE, \"TB(55)[FH](23)[]()[RSH]\", 26));\r\n    final List layoutElements = newAttributeBands.getLayoutElements();\r\n    assertEquals(1, layoutElements.size());\r\n    final Union element = (Union) layoutElements.get(0);\r\n    final Integral tag = element.getUnionTag();\r\n    assertEquals(\"B\", tag.getTag());\r\n    final List unionCases = element.getUnionCases();\r\n    assertEquals(2, unionCases.size());\r\n    final UnionCase firstCase = (UnionCase) unionCases.get(0);\r\n    assertTrue(firstCase.hasTag(55));\r\n    assertFalse(firstCase.hasTag(23));\r\n    List body = firstCase.getBody();\r\n    assertEquals(1, body.size());\r\n    final Integral bodyElement = (Integral) body.get(0);\r\n    assertEquals(\"FH\", bodyElement.getTag());\r\n    final UnionCase secondCase = (UnionCase) unionCases.get(1);\r\n    assertTrue(secondCase.hasTag(23));\r\n    assertFalse(secondCase.hasTag(55));\r\n    body = secondCase.getBody();\r\n    assertEquals(0, body.size());\r\n    final List defaultBody = element.getDefaultCaseBody();\r\n    assertEquals(1, defaultBody.size());\r\n    final Reference ref = (Reference) defaultBody.get(0);\r\n    assertEquals(\"RSH\", ref.getTag());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentConstantPoolArrayCacheTest.java",
  "methodName" : "testMultipleArrayMultipleHit",
  "sourceCode" : "@Test\r\nvoid testMultipleArrayMultipleHit() {\r\n    final SegmentConstantPoolArrayCache arrayCache = new SegmentConstantPoolArrayCache();\r\n    final String[] arrayOne = { \"Zero\", \"Shared\", \"Two\", \"Shared\", \"Shared\" };\r\n    final String[] arrayTwo = { \"Shared\", \"One\", \"Shared\", \"Shared\", \"Shared\" };\r\n    List<Integer> listOne = arrayCache.indexesForArrayKey(arrayOne, \"Shared\");\r\n    List<Integer> listTwo = arrayCache.indexesForArrayKey(arrayTwo, \"Shared\");\r\n    // Make sure we're using the cached values. First trip\r\n    // through builds the cache.\r\n    listOne = arrayCache.indexesForArrayKey(arrayOne, \"Two\");\r\n    listTwo = arrayCache.indexesForArrayKey(arrayTwo, \"Shared\");\r\n    assertEquals(1, listOne.size());\r\n    assertEquals(2, listOne.get(0).intValue());\r\n    // Now look for a different element in list one\r\n    listOne = arrayCache.indexesForArrayKey(arrayOne, \"Shared\");\r\n    assertEquals(3, listOne.size());\r\n    assertEquals(1, listOne.get(0).intValue());\r\n    assertEquals(3, listOne.get(1).intValue());\r\n    assertEquals(4, listOne.get(2).intValue());\r\n    assertEquals(4, listTwo.size());\r\n    assertEquals(0, listTwo.get(0).intValue());\r\n    assertEquals(2, listTwo.get(1).intValue());\r\n    assertEquals(3, listTwo.get(2).intValue());\r\n    assertEquals(4, listTwo.get(3).intValue());\r\n    final List<Integer> listThree = arrayCache.indexesForArrayKey(arrayOne, \"Not found\");\r\n    assertEquals(0, listThree.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentConstantPoolArrayCacheTest.java",
  "methodName" : "testSingleMultipleHitArray",
  "sourceCode" : "@Test\r\nvoid testSingleMultipleHitArray() {\r\n    final SegmentConstantPoolArrayCache arrayCache = new SegmentConstantPoolArrayCache();\r\n    final String[] array = { \"Zero\", \"OneThreeFour\", \"Two\", \"OneThreeFour\", \"OneThreeFour\" };\r\n    final List<Integer> list = arrayCache.indexesForArrayKey(array, \"OneThreeFour\");\r\n    assertEquals(3, list.size());\r\n    assertEquals(1, list.get(0).intValue());\r\n    assertEquals(3, list.get(1).intValue());\r\n    assertEquals(4, list.get(2).intValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentConstantPoolArrayCacheTest.java",
  "methodName" : "testSingleSimpleArray",
  "sourceCode" : "@Test\r\nvoid testSingleSimpleArray() {\r\n    final SegmentConstantPoolArrayCache arrayCache = new SegmentConstantPoolArrayCache();\r\n    final String[] array = { \"Zero\", \"One\", \"Two\", \"Three\", \"Four\" };\r\n    final List<Integer> list = arrayCache.indexesForArrayKey(array, \"Three\");\r\n    assertEquals(1, list.size());\r\n    assertEquals(3, list.get(0).intValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentConstantPoolTest.java",
  "methodName" : "testMatchSpecificPoolEntryIndex_DoubleArray",
  "sourceCode" : "@Test\r\nvoid testMatchSpecificPoolEntryIndex_DoubleArray() {\r\n    final MockSegmentConstantPool mockInstance = new MockSegmentConstantPool();\r\n    // Elements should be found at the proper position.\r\n    assertEquals(0, mockInstance.matchSpecificPoolEntryIndex(testClassArray, testMethodArray, \"Object\", \"^<init>.*\", 0));\r\n    assertEquals(2, mockInstance.matchSpecificPoolEntryIndex(testClassArray, testMethodArray, \"java/lang/String\", \".*\", 0));\r\n    assertEquals(3, mockInstance.matchSpecificPoolEntryIndex(testClassArray, testMethodArray, \"java/lang/String\", \"^<init>.*\", 0));\r\n    assertEquals(5, mockInstance.matchSpecificPoolEntryIndex(testClassArray, testMethodArray, \"Other\", \".*\", 0));\r\n    // Elements that don't exist shouldn't be found\r\n    assertEquals(-1, mockInstance.matchSpecificPoolEntryIndex(testClassArray, testMethodArray, \"NotThere\", \"^<init>.*\", 0));\r\n    // Elements that exist but don't have the requisite number\r\n    // of hits shouldn't be found.\r\n    assertEquals(-1, mockInstance.matchSpecificPoolEntryIndex(testClassArray, testMethodArray, \"java/lang/String\", \"^<init>.*\", 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentConstantPoolTest.java",
  "methodName" : "testMatchSpecificPoolEntryIndex_SingleArray",
  "sourceCode" : "@Test\r\nvoid testMatchSpecificPoolEntryIndex_SingleArray() {\r\n    final MockSegmentConstantPool mockInstance = new MockSegmentConstantPool();\r\n    // Elements should be found at the proper position.\r\n    assertEquals(0, mockInstance.matchSpecificPoolEntryIndex(testClassArray, \"Object\", 0));\r\n    assertEquals(1, mockInstance.matchSpecificPoolEntryIndex(testClassArray, \"Object\", 1));\r\n    assertEquals(2, mockInstance.matchSpecificPoolEntryIndex(testClassArray, \"java/lang/String\", 0));\r\n    assertEquals(3, mockInstance.matchSpecificPoolEntryIndex(testClassArray, \"java/lang/String\", 1));\r\n    assertEquals(4, mockInstance.matchSpecificPoolEntryIndex(testClassArray, \"Object\", 2));\r\n    assertEquals(5, mockInstance.matchSpecificPoolEntryIndex(testClassArray, \"Other\", 0));\r\n    // Elements that don't exist shouldn't be found\r\n    assertEquals(-1, mockInstance.matchSpecificPoolEntryIndex(testClassArray, \"NotThere\", 0));\r\n    // Elements that exist but don't have the requisite number\r\n    // of hits shouldn't be found.\r\n    assertEquals(-1, mockInstance.matchSpecificPoolEntryIndex(testClassArray, \"java/lang/String\", 2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentConstantPoolTest.java",
  "methodName" : "testRegexReplacement",
  "sourceCode" : "@Test\r\nvoid testRegexReplacement() {\r\n    final MockSegmentConstantPool mockPool = new MockSegmentConstantPool();\r\n    assertTrue(mockPool.regexMatchesVisible(\".*\", \"anything\"));\r\n    assertTrue(mockPool.regexMatchesVisible(\".*\", \"\"));\r\n    assertTrue(mockPool.regexMatchesVisible(\"^<init>.*\", \"<init>\"));\r\n    assertTrue(mockPool.regexMatchesVisible(\"^<init>.*\", \"<init>stuff\"));\r\n    assertFalse(mockPool.regexMatchesVisible(\"^<init>.*\", \"init>stuff\"));\r\n    assertFalse(mockPool.regexMatchesVisible(\"^<init>.*\", \"<init\"));\r\n    assertFalse(mockPool.regexMatchesVisible(\"^<init>.*\", \"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentOptionsTest.java",
  "methodName" : "testUnused",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 3, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 })\r\nvoid testUnused(final int element) {\r\n    assertThrows(Pack200Exception.class, () -> new SegmentOptions(1 << element));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentTest.java",
  "methodName" : "testHelloWorld",
  "sourceCode" : "@Test\r\nvoid testHelloWorld() throws Exception {\r\n    final File file = createTempFile(\"hello\", \"world.jar\");\r\n    try (InputStream in = Segment.class.getResourceAsStream(\"/pack200/HelloWorld.pack\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        new Segment().unpack(in, out);\r\n    }\r\n    try (JarFile jarFile = new JarFile(file)) {\r\n        final JarEntry entry = jarFile.getJarEntry(\"org/apache/harmony/archive/tests/internal/pack200/HelloWorld.class\");\r\n        assertNotNull(entry);\r\n        final InputStream ours = jarFile.getInputStream(entry);\r\n        try (JarFile jarFile2 = new JarFile(new File(Segment.class.getResource(\"/pack200/hw.jar\").toURI()))) {\r\n            final JarEntry entry2 = jarFile2.getJarEntry(\"org/apache/harmony/archive/tests/internal/pack200/HelloWorld.class\");\r\n            assertNotNull(entry2);\r\n            final InputStream expected = jarFile2.getInputStream(entry2);\r\n            try (BufferedReader reader1 = new BufferedReader(new InputStreamReader(ours));\r\n                BufferedReader reader2 = new BufferedReader(new InputStreamReader(expected))) {\r\n                String line1 = reader1.readLine();\r\n                String line2 = reader2.readLine();\r\n                int i = 1;\r\n                while (line1 != null || line2 != null) {\r\n                    assertEquals(line2, line1, \"Unpacked class files differ ar line \" + i);\r\n                    line1 = reader1.readLine();\r\n                    line2 = reader2.readLine();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentTest.java",
  "methodName" : "testInterfaceOnly",
  "sourceCode" : "@Test\r\nvoid testInterfaceOnly() throws Exception {\r\n    final File file = createTempFile(\"Interface\", \"Only.jar\");\r\n    try (InputStream in = Segment.class.getResourceAsStream(\"/pack200/InterfaceOnly.pack\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        new Segment().unpack(in, out);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentTest.java",
  "methodName" : "testJustResources",
  "sourceCode" : "@Test\r\nvoid testJustResources() throws Exception {\r\n    final File file = createTempFile(\"just\", \"resources.jar\");\r\n    try (InputStream in = Segment.class.getResourceAsStream(\"/pack200/JustResources.pack\");\r\n        JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {\r\n        new Segment().unpack(in, out);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentTest.java",
  "methodName" : "testParsingOOMBounded",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { // @formatter:off\r\n\"bandint_oom.pack\", \"cpfloat_oom.pack\", \"cputf8_oom.pack\", \"favoured_oom.pack\", \"filebits_oom.pack\", \"flags_oom.pack\", \"references_oom.pack\", \"segment_header_oom.pack\", \"signatures_oom.pack\" // @formatter:on\r\n})\r\n// Tests of various files that can cause out of memory errors\r\nvoid testParsingOOMBounded(final String testFileName) throws Exception {\r\n    final URL url = Segment.class.getResource(\"/org/apache/commons/compress/pack/\" + testFileName);\r\n    try (BoundedInputStream in = Pack200UnpackerAdapter.newBoundedInputStream(url);\r\n        JarOutputStream out = new JarOutputStream(NullOutputStream.INSTANCE)) {\r\n        assertThrows(IOException.class, () -> new Segment().unpack(in, out));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentTest.java",
  "methodName" : "testParsingOOMUnounded",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { // @formatter:off\r\n\"bandint_oom.pack\", \"cpfloat_oom.pack\", \"cputf8_oom.pack\", \"favoured_oom.pack\", \"filebits_oom.pack\", \"flags_oom.pack\", \"references_oom.pack\", \"segment_header_oom.pack\", \"signatures_oom.pack\" // @formatter:on\r\n})\r\n// Tests of various files that can cause out of memory errors\r\nvoid testParsingOOMUnounded(final String testFileName) throws Exception {\r\n    try (InputStream in = Segment.class.getResourceAsStream(\"/org/apache/commons/compress/pack/\" + testFileName);\r\n        JarOutputStream out = new JarOutputStream(NullOutputStream.INSTANCE)) {\r\n        assertThrows(IOException.class, () -> new Segment().unpack(in, out));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentUtilsTest.java",
  "methodName" : "testCountArgs",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"countArgs\")\r\nvoid testCountArgs(final String descriptor, final int expectedArgsCount) {\r\n    assertEquals(expectedArgsCount, SegmentUtils.countArgs(descriptor));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentUtilsTest.java",
  "methodName" : "testCountInvokeInterfaceArgs",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"countInvokeInterfaceArgs\")\r\nvoid testCountInvokeInterfaceArgs(final String descriptor, final int expectedCountInvokeInterfaceArgs) {\r\n    assertEquals(expectedCountInvokeInterfaceArgs, SegmentUtils.countInvokeInterfaceArgs(descriptor));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\SegmentUtilsTest.java",
  "methodName" : "testMatches",
  "sourceCode" : "@Test\r\nvoid testMatches() {\r\n    final long[] oneToTen = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n    assertEquals(6, SegmentUtils.countMatches(new long[][] { oneToTen, new long[] { 5, 6, 7 } }, even));\r\n    assertEquals(5, SegmentUtils.countMatches(new long[][] { oneToTen }, even));\r\n    assertEquals(5, SegmentUtils.countMatches(oneToTen, even));\r\n    assertEquals(3, SegmentUtils.countMatches(new long[][] { oneToTen, new long[] { 5, 6, 7 } }, five));\r\n    assertEquals(2, SegmentUtils.countMatches(new long[][] { oneToTen }, five));\r\n    assertEquals(2, SegmentUtils.countMatches(oneToTen, five));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\harmony\\unpack200\\TableSwitchFormTest.java",
  "methodName" : "test",
  "sourceCode" : "/**\r\n * Run with {@code -Xmx64m} to get a Pack200Exception(MemoryLimitException).\r\n *\r\n * @throws Pack200Exception\r\n */\r\n@Test\r\nvoid test() throws Pack200Exception {\r\n    final int large = 1_000_000_000;\r\n    final int[] caseCount = { large };\r\n    // Provide a dummy label for the defaultPc branch taken before the allocation.\r\n    final int[] labels = { 0 };\r\n    // TableSwitch needs at least one case value.\r\n    final int[] caseValues = { 0 };\r\n    final int[] empty = {};\r\n    // The OperandManager requires all 21 band arrays.\r\n    // Most can be empty for this test.\r\n    final OperandManager om = new OperandManager(caseCount, caseValues, empty, empty, empty, labels, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty);\r\n    // tableswitch\r\n    final ByteCode bc = ByteCode.getByteCode(170);\r\n    // Run with -Xmx64m to get a Pack200Exception(MemoryLimitException).\r\n    assertThrows(Exception.class, () -> new TableSwitchForm(170, \"tableswitch\").setByteCodeOperands(bc, om, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testReadAr",
  "sourceCode" : "@Test\r\nvoid testReadAr() throws Exception {\r\n    compareReads(\"ar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testReadCpio",
  "sourceCode" : "@Test\r\nvoid testReadCpio() throws Exception {\r\n    compareReads(\"cpio\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testReadJar",
  "sourceCode" : "@Test\r\nvoid testReadJar() throws Exception {\r\n    compareReads(\"jar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testReadTar",
  "sourceCode" : "@Test\r\nvoid testReadTar() throws Exception {\r\n    compareReads(\"tar\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testReadZip",
  "sourceCode" : "@Test\r\nvoid testReadZip() throws Exception {\r\n    compareReads(\"zip\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testWriteAr",
  "sourceCode" : "@Test\r\nvoid testWriteAr() throws Exception {\r\n    compareWrites(\"ar\", new ArArchiveEntry(\"dummy\", bytesToTest));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testWriteCpio",
  "sourceCode" : "@Test\r\nvoid testWriteCpio() throws Exception {\r\n    final ArchiveEntry entry = new CpioArchiveEntry(\"dummy\", bytesToTest);\r\n    compareWrites(\"cpio\", entry);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testWriteJar",
  "sourceCode" : "@Test\r\nvoid testWriteJar() throws Exception {\r\n    final ArchiveEntry entry = new JarArchiveEntry(\"dummy\");\r\n    compareWrites(\"jar\", entry);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testWriteTar",
  "sourceCode" : "@Test\r\nvoid testWriteTar() throws Exception {\r\n    final TarArchiveEntry entry = new TarArchiveEntry(\"dummy\");\r\n    entry.setSize(bytesToTest);\r\n    compareWrites(\"tar\", entry);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\IOMethodsTest.java",
  "methodName" : "testWriteZip",
  "sourceCode" : "@Test\r\nvoid testWriteZip() throws Exception {\r\n    final ArchiveEntry entry = new ZipArchiveEntry(\"dummy\");\r\n    compareWrites(\"zip\", entry);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\java\\util\\jar\\Pack200Test.java",
  "methodName" : "testPacker",
  "sourceCode" : "@Test\r\nvoid testPacker() {\r\n    final Pack200.Packer packer = Pack200.newPacker();\r\n    assertEquals(\"org.apache.commons.compress.harmony.pack200.Pack200PackerAdapter\", packer.getClass().getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\java\\util\\jar\\Pack200Test.java",
  "methodName" : "testUnpacker",
  "sourceCode" : "@Test\r\nvoid testUnpacker() {\r\n    final Pack200.Unpacker unpacker = Pack200.newUnpacker();\r\n    assertEquals(\"org.apache.commons.compress.harmony.unpack200.Pack200UnpackerAdapter\", unpacker.getClass().getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\LegacyConstructorsTest.java",
  "methodName" : "testArjConstructor",
  "sourceCode" : "@Test\r\nvoid testArjConstructor() throws Exception {\r\n    try (InputStream inputStream = Files.newInputStream(getPath(\"bla.arj\"));\r\n        ArjArchiveInputStream archiveInputStream = new ArjArchiveInputStream(inputStream, \"US-ASCII\")) {\r\n        // Arj wraps the input stream in a DataInputStream\r\n        assertEquals(inputStream, getNestedInputStream(getNestedInputStream(archiveInputStream)));\r\n        assertEquals(US_ASCII, archiveInputStream.getCharset());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\LegacyConstructorsTest.java",
  "methodName" : "testCpioConstructors",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource\r\nvoid testCpioConstructors(final CpioArchiveInputStream archiveStream, final InputStream expectedInput, final String expectedEncoding, final int expectedBlockSize) throws Exception {\r\n    assertEquals(expectedInput, getNestedInputStream(archiveStream));\r\n    assertEquals(Charset.forName(expectedEncoding), archiveStream.getCharset());\r\n    assertEquals(expectedBlockSize, readDeclaredField(archiveStream, \"blockSize\", true));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\LegacyConstructorsTest.java",
  "methodName" : "testDumpConstructor",
  "sourceCode" : "@Test\r\nvoid testDumpConstructor() throws Exception {\r\n    final String otherEncoding = \"UTF-8\".equals(Charset.defaultCharset().name()) ? \"US-ASCII\" : \"UTF-8\";\r\n    try (InputStream inputStream = Files.newInputStream(getPath(\"bla.dump\"));\r\n        DumpArchiveInputStream archiveStream = new DumpArchiveInputStream(inputStream, otherEncoding)) {\r\n        assertEquals(inputStream, getNestedInputStream(archiveStream));\r\n        assertEquals(Charset.forName(otherEncoding), archiveStream.getCharset());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\LegacyConstructorsTest.java",
  "methodName" : "testJarConstructor",
  "sourceCode" : "@Test\r\nvoid testJarConstructor() throws Exception {\r\n    final InputStream inputStream = mock(InputStream.class);\r\n    try (JarArchiveInputStream archiveInputStream = new JarArchiveInputStream(inputStream, \"US-ASCII\")) {\r\n        assertEquals(US_ASCII, archiveInputStream.getCharset());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\LegacyConstructorsTest.java",
  "methodName" : "testTarConstructors",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource\r\nvoid testTarConstructors(final TarArchiveInputStream archiveStream, final InputStream expectedInput, final int expectedBlockSize, final int expectedRecordSize, final String expectedEncoding, final boolean expectedLenient) throws Exception {\r\n    assertEquals(expectedInput, getNestedInputStream(archiveStream));\r\n    assertEquals(expectedBlockSize, readDeclaredField(archiveStream, \"blockSize\", true));\r\n    final byte[] recordBuffer = (byte[]) readField(archiveStream, \"recordBuffer\", true);\r\n    assertEquals(expectedRecordSize, recordBuffer.length);\r\n    assertEquals(Charset.forName(expectedEncoding), archiveStream.getCharset());\r\n    assertEquals(expectedLenient, readField(archiveStream, \"lenient\", true));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\LegacyConstructorsTest.java",
  "methodName" : "testZipConstructors",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource\r\nvoid testZipConstructors(final ZipArchiveInputStream archiveStream, final InputStream expectedInput, final String expectedEncoding, final boolean expectedUseUnicodeExtraFields, final boolean expectedSupportStoredEntryDataDescriptor, final boolean expectedSkipSplitSignature) throws Exception {\r\n    // Zip wraps the input stream in a PushbackInputStream\r\n    assertEquals(expectedInput, getNestedInputStream(getNestedInputStream(archiveStream)));\r\n    assertEquals(Charset.forName(expectedEncoding), archiveStream.getCharset());\r\n    assertEquals(expectedUseUnicodeExtraFields, readDeclaredField(archiveStream, \"useUnicodeExtraFields\", true));\r\n    assertEquals(expectedSupportStoredEntryDataDescriptor, readDeclaredField(archiveStream, \"supportStoredEntryDataDescriptor\", true));\r\n    assertEquals(expectedSkipSplitSignature, readDeclaredField(archiveStream, \"skipSplitSignature\", true));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\MemoryLimitExceptionTest.java",
  "methodName" : "testAccessorsCause",
  "sourceCode" : "@Test\r\nvoid testAccessorsCause() {\r\n    final IOException ioe = new IOException();\r\n    final MemoryLimitException e = new MemoryLimitException(1, 2, (Throwable) ioe);\r\n    assertEquals(1, e.getMemoryNeededInKb());\r\n    assertEquals(2, e.getMemoryLimitInKb());\r\n    assertSame(ioe, e.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\MemoryLimitExceptionTest.java",
  "methodName" : "testAccessorsCauseDepreacted",
  "sourceCode" : "@Test\r\nvoid testAccessorsCauseDepreacted() {\r\n    final IOException ioe = new IOException();\r\n    @SuppressWarnings(\"deprecation\")\r\n    final MemoryLimitException e = new MemoryLimitException(1, 2, ioe);\r\n    assertEquals(1, e.getMemoryNeededInKb());\r\n    assertEquals(2, e.getMemoryLimitInKb());\r\n    assertSame(ioe, e.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\MemoryLimitExceptionTest.java",
  "methodName" : "testAccessorsLimitInt",
  "sourceCode" : "@Test\r\nvoid testAccessorsLimitInt() {\r\n    final MemoryLimitException e = new MemoryLimitException(1, 2);\r\n    assertEquals(1, e.getMemoryNeededInKb());\r\n    assertEquals(2, e.getMemoryLimitInKb());\r\n    assertEquals(2, e.getMemoryLimitInKiBLong());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\MemoryLimitExceptionTest.java",
  "methodName" : "testAccessorsLimitLong",
  "sourceCode" : "@Test\r\nvoid testAccessorsLimitLong() {\r\n    final MemoryLimitException e = new MemoryLimitException(1, 2L);\r\n    assertEquals(1, e.getMemoryNeededInKb());\r\n    assertEquals(2, e.getMemoryLimitInKb());\r\n    assertEquals(2, e.getMemoryLimitInKiBLong());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\osgi\\AbstractOsgiITest.java",
  "methodName" : "testCanLoadBundle",
  "sourceCode" : "@Test\r\nvoid testCanLoadBundle() {\r\n    assertNotNull(\"Expected to find bundle \" + EXPECTED_BUNDLE_NAME, loadBundle());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\osgi\\AbstractOsgiITest.java",
  "methodName" : "testProperlyDetectsRunningInsideOsgiEnv",
  "sourceCode" : "@Test\r\nvoid testProperlyDetectsRunningInsideOsgiEnv() throws Exception {\r\n    final String className = \"org.apache.commons.compress.utils.OsgiUtils\";\r\n    final Class<?> osgiUtils = loadBundle().loadClass(className);\r\n    assertNotNull(\"Can't load \" + className + \" via bundle\", osgiUtils);\r\n    final Method method = osgiUtils.getMethod(\"isRunningInOsgiEnvironment\");\r\n    assertNotNull(\"Can't access isRunningInOsgiEnvironment method\", method);\r\n    assertTrue(\"Compress can't detect OSGi environment\", (Boolean) method.invoke(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testAlignWithByteBoundaryWhenAtBoundary",
  "sourceCode" : "@Test\r\nvoid testAlignWithByteBoundaryWhenAtBoundary() throws Exception {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0xF8, bis.readBits(8));\r\n        bis.alignWithByteBoundary();\r\n        assertEquals(0, bis.readBits(4));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testAlignWithByteBoundaryWhenNotAtBoundary",
  "sourceCode" : "@Test\r\nvoid testAlignWithByteBoundaryWhenNotAtBoundary() throws Exception {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0x08, bis.readBits(4));\r\n        assertEquals(4, bis.bitsCached());\r\n        bis.alignWithByteBoundary();\r\n        assertEquals(0, bis.bitsCached());\r\n        assertEquals(0, bis.readBits(4));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testAvailableWithCache",
  "sourceCode" : "@Test\r\nvoid testAvailableWithCache() throws Exception {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0x08, bis.readBits(4));\r\n        assertEquals(28, bis.bitsAvailable());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testAvailableWithoutCache",
  "sourceCode" : "@Test\r\nvoid testAvailableWithoutCache() throws Exception {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(32, bis.bitsAvailable());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testBigEndianWithOverflow",
  "sourceCode" : "@Test\r\nvoid testBigEndianWithOverflow() throws Exception {\r\n    final ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { // 01010111\r\n    87, // 00101101\r\n    45, // 01000010\r\n    66, // 00001111\r\n    15, // 01011010\r\n    90, // 00011101\r\n    29, // 01011000\r\n    88, // 00111101\r\n    61, // 00100001\r\n    33, // 01001010\r\n    74 });\r\n    try (BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN)) {\r\n        // 01010\r\n        assertEquals(// 01010\r\n        10, bin.readBits(5));\r\n        // 111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\r\n        assertEquals(// 111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\r\n        8274274654740644818L, bin.readBits(63));\r\n        // 0001-01001010\r\n        assertEquals(// 0001-01001010\r\n        330, bin.readBits(12));\r\n        assertEquals(-1, bin.readBits(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testClearBitCache",
  "sourceCode" : "@Test\r\nvoid testClearBitCache() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0x08, bis.readBits(4));\r\n        bis.clearBitCache();\r\n        assertEquals(0, bis.readBits(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testEOF",
  "sourceCode" : "@Test\r\nvoid testEOF() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0x2f0140f8, bis.readBits(30));\r\n        assertEquals(-1, bis.readBits(3));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testLittleEndianWithOverflow",
  "sourceCode" : "/**\r\n * @see \"https://issues.apache.org/jira/browse/COMPRESS-363\"\r\n */\r\n@Test\r\nvoid testLittleEndianWithOverflow() throws Exception {\r\n    final ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { // 01010111\r\n    87, // 00101101\r\n    45, // 01000010\r\n    66, // 00001111\r\n    15, // 01011010\r\n    90, // 00011101\r\n    29, // 01011000\r\n    88, // 00111101\r\n    61, // 00100001\r\n    33, // 01001010\r\n    74 });\r\n    try (BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN)) {\r\n        // 10111\r\n        assertEquals(// 10111\r\n        23, bin.readBits(5));\r\n        // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\r\n        assertEquals(// 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\r\n        714595605644185962L, bin.readBits(63));\r\n        // 01001010-0010\r\n        assertEquals(// 01001010-0010\r\n        1186, bin.readBits(12));\r\n        assertEquals(-1, bin.readBits(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReading17BitsInBigEndian",
  "sourceCode" : "@Test\r\nvoid testReading17BitsInBigEndian() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN)) {\r\n        // 1-11110000-10000000\r\n        assertEquals(0x0001f080, bis.readBits(17));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReading17BitsInLittleEndian",
  "sourceCode" : "@Test\r\nvoid testReading17BitsInLittleEndian() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0x000140f8, bis.readBits(17));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReading24BitsInBigEndian",
  "sourceCode" : "@Test\r\nvoid testReading24BitsInBigEndian() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN)) {\r\n        assertEquals(0x00f84001, bis.readBits(24));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReading24BitsInLittleEndian",
  "sourceCode" : "@Test\r\nvoid testReading24BitsInLittleEndian() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0x000140f8, bis.readBits(24));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReading30BitsInBigEndian",
  "sourceCode" : "@Test\r\nvoid testReading30BitsInBigEndian() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN)) {\r\n        // 111110-00010000-00000000-01001011\r\n        assertEquals(0x3e10004b, bis.readBits(30));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReading30BitsInLittleEndian",
  "sourceCode" : "@Test\r\nvoid testReading30BitsInLittleEndian() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0x2f0140f8, bis.readBits(30));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReading31BitsInBigEndian",
  "sourceCode" : "@Test\r\nvoid testReading31BitsInBigEndian() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN)) {\r\n        // 1111100-00100000-00000000-10010111\r\n        assertEquals(0x7c200097, bis.readBits(31));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReading31BitsInLittleEndian",
  "sourceCode" : "@Test\r\nvoid testReading31BitsInLittleEndian() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0x2f0140f8, bis.readBits(31));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReadingOneBitFromEmptyStream",
  "sourceCode" : "@Test\r\nvoid testReadingOneBitFromEmptyStream() throws Exception {\r\n    try (BitInputStream bis = new BitInputStream(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(-1, bis.readBit(), \"next bit\");\r\n        assertEquals(-1, bis.readBit(), \"next bit\");\r\n        assertEquals(-1, bis.readBit(), \"next bit\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReadingOneBitInBigEndian",
  "sourceCode" : "@Test\r\nvoid testReadingOneBitInBigEndian() throws Exception {\r\n    try (BitInputStream bis = new BitInputStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x03 }), ByteOrder.BIG_ENDIAN)) {\r\n        assertEquals(1, bis.readBit(), \"bit 0\");\r\n        assertEquals(1, bis.readBit(), \"bit 1\");\r\n        assertEquals(1, bis.readBit(), \"bit 2\");\r\n        assertEquals(0, bis.readBit(), \"bit 3\");\r\n        assertEquals(1, bis.readBit(), \"bit 4\");\r\n        assertEquals(0, bis.readBit(), \"bit 5\");\r\n        assertEquals(1, bis.readBit(), \"bit 6\");\r\n        assertEquals(0, bis.readBit(), \"bit 7\");\r\n        assertEquals(0, bis.readBit(), \"bit 8\");\r\n        assertEquals(0, bis.readBit(), \"bit 9\");\r\n        assertEquals(0, bis.readBit(), \"bit 10\");\r\n        assertEquals(0, bis.readBit(), \"bit 11\");\r\n        assertEquals(0, bis.readBit(), \"bit 12\");\r\n        assertEquals(0, bis.readBit(), \"bit 13\");\r\n        assertEquals(1, bis.readBit(), \"bit 14\");\r\n        assertEquals(1, bis.readBit(), \"bit 15\");\r\n        assertEquals(-1, bis.readBit(), \"next bit\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testReadingOneBitInLittleEndian",
  "sourceCode" : "@Test\r\nvoid testReadingOneBitInLittleEndian() throws Exception {\r\n    try (BitInputStream bis = new BitInputStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x03 }), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertEquals(0, bis.readBit(), \"bit 0\");\r\n        assertEquals(1, bis.readBit(), \"bit 1\");\r\n        assertEquals(0, bis.readBit(), \"bit 2\");\r\n        assertEquals(1, bis.readBit(), \"bit 3\");\r\n        assertEquals(0, bis.readBit(), \"bit 4\");\r\n        assertEquals(1, bis.readBit(), \"bit 5\");\r\n        assertEquals(1, bis.readBit(), \"bit 6\");\r\n        assertEquals(1, bis.readBit(), \"bit 7\");\r\n        assertEquals(1, bis.readBit(), \"bit 8\");\r\n        assertEquals(1, bis.readBit(), \"bit 9\");\r\n        assertEquals(0, bis.readBit(), \"bit 10\");\r\n        assertEquals(0, bis.readBit(), \"bit 11\");\r\n        assertEquals(0, bis.readBit(), \"bit 12\");\r\n        assertEquals(0, bis.readBit(), \"bit 13\");\r\n        assertEquals(0, bis.readBit(), \"bit 14\");\r\n        assertEquals(0, bis.readBit(), \"bit 15\");\r\n        assertEquals(-1, bis.readBit(), \"next bit\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testShouldNotAllowReadingOfANegativeAmountOfBits",
  "sourceCode" : "@Test\r\nvoid testShouldNotAllowReadingOfANegativeAmountOfBits() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertThrows(IOException.class, () -> bis.readBits(-1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BitInputStreamTest.java",
  "methodName" : "testShouldNotAllowReadingOfMoreThan63BitsAtATime",
  "sourceCode" : "@Test\r\nvoid testShouldNotAllowReadingOfMoreThan63BitsAtATime() throws IOException {\r\n    try (BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN)) {\r\n        assertThrows(IOException.class, () -> bis.readBits(64));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\BoundedSeekableByteChannelInputStreamTest.java",
  "methodName" : "testCheckRestrictedRead",
  "sourceCode" : "@Test\r\nvoid testCheckRestrictedRead() throws IOException {\r\n    final byte[] readContent;\r\n    try (SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(\"Hello World!\".getBytes(UTF_8));\r\n        BoundedSeekableByteChannelInputStream input = new BoundedSeekableByteChannelInputStream(0, 5, channel)) {\r\n        readContent = IOUtils.toByteArray(input);\r\n    }\r\n    assertEquals(5, readContent.length);\r\n    assertArrayEquals(\"Hello\".getBytes(UTF_8), readContent);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromArray",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromArray() {\r\n    final byte[] b = { 1, 2, 3, 4, 5 };\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(b, 1, 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromArrayOneArg",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromArrayOneArg() {\r\n    final byte[] b = { 2, 3, 4 };\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(b));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromArrayOneArgThrowsForLengthTooBig",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromArrayOneArgThrowsForLengthTooBig() {\r\n    assertThrows(IllegalArgumentException.class, () -> fromLittleEndian(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromArrayOneArgUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromArrayOneArgUnsignedInt32() {\r\n    final byte[] b = { 2, 3, 4, (byte) 128 };\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, fromLittleEndian(b));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromArrayThrowsForLengthTooBig",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromArrayThrowsForLengthTooBig() {\r\n    assertThrows(IllegalArgumentException.class, () -> fromLittleEndian(ArrayUtils.EMPTY_BYTE_ARRAY, 0, 9));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromArrayUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromArrayUnsignedInt32() {\r\n    final byte[] b = { 1, 2, 3, 4, (byte) 128 };\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, fromLittleEndian(b, 1, 4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromDataInput",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromDataInput() throws IOException {\r\n    final DataInput din = new DataInputStream(new ByteArrayInputStream(new byte[] { 2, 3, 4, 5 }));\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(din, 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromDataInputThrowsForLengthTooBig",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromDataInputThrowsForLengthTooBig() {\r\n    final DataInput din = new DataInputStream(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY));\r\n    assertThrows(IllegalArgumentException.class, () -> fromLittleEndian(din, 9));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromDataInputThrowsForPrematureEnd",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromDataInputThrowsForPrematureEnd() {\r\n    final DataInput din = new DataInputStream(new ByteArrayInputStream(new byte[] { 2, 3 }));\r\n    assertThrows(EOFException.class, () -> fromLittleEndian(din, 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromDataInputUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromDataInputUnsignedInt32() throws IOException {\r\n    final DataInput din = new DataInputStream(new ByteArrayInputStream(new byte[] { 2, 3, 4, (byte) 128 }));\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, fromLittleEndian(din, 4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromStream",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromStream() throws IOException {\r\n    final ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3, 4, 5 });\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(bin, 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromStreamThrowsForLengthTooBig",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromStreamThrowsForLengthTooBig() {\r\n    assertThrows(IllegalArgumentException.class, () -> fromLittleEndian(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY), 9));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromStreamThrowsForPrematureEnd",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromStreamThrowsForPrematureEnd() {\r\n    final ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3 });\r\n    assertThrows(IOException.class, () -> fromLittleEndian(bin, 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromStreamUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromStreamUnsignedInt32() throws IOException {\r\n    final ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3, 4, (byte) 128 });\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, fromLittleEndian(bin, 4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromSupplier",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromSupplier() throws IOException {\r\n    final ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3, 4, 5 });\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(new InputStreamByteSupplier(bin), 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromSupplierThrowsForLengthTooBig",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromSupplierThrowsForLengthTooBig() {\r\n    assertThrows(IllegalArgumentException.class, () -> fromLittleEndian(new InputStreamByteSupplier(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY)), 9));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromSupplierThrowsForPrematureEnd",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromSupplierThrowsForPrematureEnd() {\r\n    final ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3 });\r\n    assertThrows(IOException.class, () -> fromLittleEndian(new InputStreamByteSupplier(bin), 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testFromLittleEndianFromSupplierUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testFromLittleEndianFromSupplierUnsignedInt32() throws IOException {\r\n    final ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3, 4, (byte) 128 });\r\n    assertEquals(2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, fromLittleEndian(new InputStreamByteSupplier(bin), 4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testToLittleEndianToByteArray",
  "sourceCode" : "@Test\r\nvoid testToLittleEndianToByteArray() {\r\n    final byte[] b = new byte[4];\r\n    toLittleEndian(b, 2 + 3 * 256 + 4 * 256 * 256, 1, 3);\r\n    assertArrayEquals(new byte[] { 2, 3, 4 }, Arrays.copyOfRange(b, 1, 4));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testToLittleEndianToByteArrayUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testToLittleEndianToByteArrayUnsignedInt32() {\r\n    final byte[] b = new byte[4];\r\n    toLittleEndian(b, 2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, 0, 4);\r\n    assertArrayEquals(new byte[] { 2, 3, 4, (byte) 128 }, b);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testToLittleEndianToConsumer",
  "sourceCode" : "@Test\r\nvoid testToLittleEndianToConsumer() throws IOException {\r\n    final byte[] byteArray;\r\n    final byte[] expected = { 2, 3, 4 };\r\n    try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\r\n        toLittleEndian(new OutputStreamByteConsumer(bos), 2 + 3 * 256 + 4 * 256 * 256, 3);\r\n        byteArray = bos.toByteArray();\r\n        assertArrayEquals(expected, byteArray);\r\n    }\r\n    assertArrayEquals(expected, byteArray);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testToLittleEndianToConsumerUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testToLittleEndianToConsumerUnsignedInt32() throws IOException {\r\n    final byte[] byteArray;\r\n    final byte[] expected = { 2, 3, 4, (byte) 128 };\r\n    try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\r\n        toLittleEndian(new OutputStreamByteConsumer(bos), 2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, 4);\r\n        byteArray = bos.toByteArray();\r\n        assertArrayEquals(expected, byteArray);\r\n    }\r\n    assertArrayEquals(expected, byteArray);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testToLittleEndianToDataOutput",
  "sourceCode" : "@Test\r\nvoid testToLittleEndianToDataOutput() throws IOException {\r\n    final byte[] byteArray;\r\n    final byte[] expected = { 2, 3, 4 };\r\n    try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\r\n        final DataOutput dos = new DataOutputStream(bos);\r\n        toLittleEndian(dos, 2 + 3 * 256 + 4 * 256 * 256, 3);\r\n        byteArray = bos.toByteArray();\r\n        assertArrayEquals(expected, byteArray);\r\n    }\r\n    assertArrayEquals(expected, byteArray);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testToLittleEndianToDataOutputUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testToLittleEndianToDataOutputUnsignedInt32() throws IOException {\r\n    final byte[] byteArray;\r\n    final byte[] expected = { 2, 3, 4, (byte) 128 };\r\n    try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\r\n        final DataOutput dos = new DataOutputStream(bos);\r\n        toLittleEndian(dos, 2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, 4);\r\n        byteArray = bos.toByteArray();\r\n        assertArrayEquals(expected, byteArray);\r\n    }\r\n    assertArrayEquals(expected, byteArray);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testToLittleEndianToStream",
  "sourceCode" : "@Test\r\nvoid testToLittleEndianToStream() throws IOException {\r\n    final byte[] byteArray;\r\n    final byte[] expected = { 2, 3, 4 };\r\n    try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\r\n        toLittleEndian(bos, 2 + 3 * 256 + 4 * 256 * 256, 3);\r\n        byteArray = bos.toByteArray();\r\n        assertArrayEquals(expected, byteArray);\r\n    }\r\n    assertArrayEquals(expected, byteArray);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ByteUtilsTest.java",
  "methodName" : "testToLittleEndianToStreamUnsignedInt32",
  "sourceCode" : "@Test\r\nvoid testToLittleEndianToStreamUnsignedInt32() throws IOException {\r\n    final byte[] byteArray;\r\n    final byte[] expected = { 2, 3, 4, (byte) 128 };\r\n    try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\r\n        toLittleEndian(bos, 2 + 3 * 256 + 4 * 256 * 256 + 128L * 256 * 256 * 256, 4);\r\n        byteArray = bos.toByteArray();\r\n        assertArrayEquals(expected, byteArray);\r\n    }\r\n    assertArrayEquals(expected, byteArray);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\CharsetNamesTest.java",
  "methodName" : "testConstants",
  "sourceCode" : "@Test\r\nvoid testConstants() {\r\n    assertEquals(StandardCharsets.ISO_8859_1.name(), CharsetNames.ISO_8859_1);\r\n    assertEquals(StandardCharsets.US_ASCII.name(), CharsetNames.US_ASCII);\r\n    assertEquals(StandardCharsets.UTF_16.name(), CharsetNames.UTF_16);\r\n    assertEquals(StandardCharsets.UTF_16BE.name(), CharsetNames.UTF_16BE);\r\n    assertEquals(StandardCharsets.UTF_16LE.name(), CharsetNames.UTF_16LE);\r\n    assertEquals(StandardCharsets.UTF_8.name(), CharsetNames.UTF_8);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\CharsetsTest.java",
  "methodName" : "testToCharset",
  "sourceCode" : "@Test\r\nvoid testToCharset() {\r\n    assertEquals(Charset.defaultCharset(), Charsets.toCharset((String) null));\r\n    assertEquals(Charset.defaultCharset(), Charsets.toCharset((Charset) null));\r\n    assertEquals(Charset.defaultCharset(), Charsets.toCharset(Charset.defaultCharset()));\r\n    assertEquals(StandardCharsets.UTF_8, Charsets.toCharset(StandardCharsets.UTF_8));\r\n    assertEquals(StandardCharsets.UTF_8, StandardCharsets.UTF_8);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
  "sourceCode" : "@Test\r\nvoid testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne() {\r\n    assertThrows(NullPointerException.class, () -> new ChecksumCalculatingInputStream(null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree",
  "sourceCode" : "@Test\r\nvoid testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree() {\r\n    assertThrows(NullPointerException.class, () -> new ChecksumCalculatingInputStream(new CRC32(), null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
  "sourceCode" : "@Test\r\nvoid testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo() {\r\n    assertThrows(NullPointerException.class, () -> new ChecksumCalculatingInputStream(null, new ByteArrayInputStream(new byte[1])));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testReadTakingByteArray",
  "sourceCode" : "@Test\r\nvoid testReadTakingByteArray() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final byte[] byteArray = new byte[6];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    try (ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(adler32, byteArrayInputStream)) {\r\n        final int readResult = checksumCalculatingInputStream.read(byteArray);\r\n        assertEquals(6, readResult);\r\n        assertEquals(0, byteArrayInputStream.available());\r\n        assertEquals(393217L, checksumCalculatingInputStream.getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testReadTakingByteArraySanityCheck",
  "sourceCode" : "@Test\r\nvoid testReadTakingByteArraySanityCheck() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final byte[] byteArray = new byte[6];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    try (CheckedInputStream checksumCalculatingInputStream = new CheckedInputStream(byteArrayInputStream, adler32)) {\r\n        final int readResult = checksumCalculatingInputStream.read(byteArray);\r\n        assertEquals(6, readResult);\r\n        assertEquals(0, byteArrayInputStream.available());\r\n        assertEquals(393217L, checksumCalculatingInputStream.getChecksum().getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testReadTakingNoArguments",
  "sourceCode" : "@Test\r\nvoid testReadTakingNoArguments() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final byte[] byteArray = new byte[6];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    final ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(adler32, byteArrayInputStream);\r\n    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(checksumCalculatingInputStream)) {\r\n        final int inputStreamReadResult = bufferedInputStream.read(byteArray, 0, 1);\r\n        final int checkSumCalculationReadResult = checksumCalculatingInputStream.read();\r\n        assertNotEquals(checkSumCalculationReadResult, inputStreamReadResult);\r\n        assertEquals(-1, checkSumCalculationReadResult);\r\n        assertEquals(0, byteArrayInputStream.available());\r\n        assertEquals(393217L, checksumCalculatingInputStream.getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testReadTakingNoArgumentsSanityCheck",
  "sourceCode" : "@Test\r\nvoid testReadTakingNoArgumentsSanityCheck() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final byte[] byteArray = new byte[6];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    final CheckedInputStream checksumCalculatingInputStream = new CheckedInputStream(byteArrayInputStream, adler32);\r\n    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(checksumCalculatingInputStream)) {\r\n        final int inputStreamReadResult = bufferedInputStream.read(byteArray, 0, 1);\r\n        final int checkSumCalculationReadResult = checksumCalculatingInputStream.read();\r\n        assertNotEquals(checkSumCalculationReadResult, inputStreamReadResult);\r\n        assertEquals(-1, checkSumCalculationReadResult);\r\n        assertEquals(0, byteArrayInputStream.available());\r\n        assertEquals(393217L, checksumCalculatingInputStream.getChecksum().getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testSkipReturningPositive",
  "sourceCode" : "@Test\r\nvoid testSkipReturningPositive() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final byte[] byteArray = new byte[6];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    try (ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(adler32, byteArrayInputStream)) {\r\n        final long skipResult = checksumCalculatingInputStream.skip((byte) 0);\r\n        assertEquals(0, skipResult);\r\n        assertEquals(1, checksumCalculatingInputStream.getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testSkipReturningPositiveSanityCheck",
  "sourceCode" : "@Test\r\nvoid testSkipReturningPositiveSanityCheck() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final byte[] byteArray = new byte[6];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    try (CheckedInputStream checksumCalculatingInputStream = new CheckedInputStream(byteArrayInputStream, adler32)) {\r\n        final long skipResult = checksumCalculatingInputStream.skip((byte) 0);\r\n        assertEquals(0, skipResult);\r\n        assertEquals(1, checksumCalculatingInputStream.getChecksum().getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testSkipReturningZero",
  "sourceCode" : "@Test\r\nvoid testSkipReturningZero() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY);\r\n    try (ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(adler32, byteArrayInputStream)) {\r\n        final long skipResult = checksumCalculatingInputStream.skip(60L);\r\n        assertEquals(0L, skipResult);\r\n        assertEquals(1L, checksumCalculatingInputStream.getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumCalculatingInputStreamTest.java",
  "methodName" : "testSkipReturningZeroSanityCheck",
  "sourceCode" : "@Test\r\nvoid testSkipReturningZeroSanityCheck() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY);\r\n    try (CheckedInputStream checksumCalculatingInputStream = new CheckedInputStream(byteArrayInputStream, adler32)) {\r\n        final long skipResult = checksumCalculatingInputStream.skip(60L);\r\n        assertEquals(0L, skipResult);\r\n        assertEquals(1L, checksumCalculatingInputStream.getChecksum().getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumVerifyingInputStreamTest.java",
  "methodName" : "testReadTakingByteArrayThrowsIOException",
  "sourceCode" : "@Test\r\nvoid testReadTakingByteArrayThrowsIOException() throws IOException {\r\n    final Adler32 adler32 = new Adler32();\r\n    final byte[] byteArray = new byte[3];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    try (ChecksumVerifyingInputStream checksumVerifyingInputStream = new ChecksumVerifyingInputStream(adler32, byteArrayInputStream, -1859L, (byte) -68)) {\r\n        assertThrows(IOException.class, () -> checksumVerifyingInputStream.read(byteArray));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumVerifyingInputStreamTest.java",
  "methodName" : "testReadTakingNoArgumentsThrowsIOException",
  "sourceCode" : "@Test\r\nvoid testReadTakingNoArgumentsThrowsIOException() throws IOException {\r\n    final CRC32 crc32 = new CRC32();\r\n    final byte[] byteArray = new byte[9];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    try (ChecksumVerifyingInputStream checksumVerifyingInputStream = new ChecksumVerifyingInputStream(crc32, byteArrayInputStream, (byte) 1, (byte) 1)) {\r\n        assertThrows(IOException.class, () -> checksumVerifyingInputStream.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ChecksumVerifyingInputStreamTest.java",
  "methodName" : "testSkip",
  "sourceCode" : "@Test\r\nvoid testSkip() throws IOException {\r\n    final CRC32 crc32 = new CRC32();\r\n    final byte[] byteArray = new byte[4];\r\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\r\n    try (ChecksumVerifyingInputStream checksumVerifyingInputStream = new ChecksumVerifyingInputStream(crc32, byteArrayInputStream, (byte) 33, 2303L)) {\r\n        @SuppressWarnings(\"unused\")\r\n        final int intOne = checksumVerifyingInputStream.read(byteArray);\r\n        final long skipReturnValue = checksumVerifyingInputStream.skip((byte) 1);\r\n        assertEquals(558161692L, crc32.getValue());\r\n        assertEquals(0, byteArrayInputStream.available());\r\n        assertArrayEquals(new byte[4], byteArray);\r\n        assertEquals(0L, skipReturnValue);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\CountingStreamTest.java",
  "methodName" : "testInput",
  "sourceCode" : "@Test\r\nvoid testInput() throws Exception {\r\n    // I don't like \"test all at once\" tests either, but the class\r\n    // is so trivial\r\n    final ByteArrayInputStream bis = new ByteArrayInputStream(new byte[] { 1, 2, 3, 4 });\r\n    try (CountingInputStream i = new CountingInputStream(bis)) {\r\n        assertEquals(1, i.read());\r\n        assertEquals(1, i.getBytesRead());\r\n        byte[] b = new byte[2];\r\n        i.read(b);\r\n        assertEquals(3, i.getBytesRead());\r\n        assertArrayEquals(new byte[] { 2, 3 }, b);\r\n        b = new byte[3];\r\n        i.read(b, 1, 1);\r\n        assertArrayEquals(new byte[] { 0, 4, 0 }, b);\r\n        assertEquals(4, i.getBytesRead());\r\n        i.count(-1);\r\n        assertEquals(4, i.getBytesRead());\r\n        i.count(-2);\r\n        assertEquals(2, i.getBytesRead());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\CountingStreamTest.java",
  "methodName" : "testOutput",
  "sourceCode" : "@Test\r\nvoid testOutput() throws Exception {\r\n    // I don't like \"test all at once\" tests either, but the class\r\n    // is so trivial\r\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    try (CountingOutputStream o = new CountingOutputStream(bos)) {\r\n        o.write(1);\r\n        assertEquals(1, o.getBytesWritten());\r\n        o.write(new byte[] { 2, 3 });\r\n        assertEquals(3, o.getBytesWritten());\r\n        o.write(new byte[] { 2, 3, 4, 5 }, 2, 1);\r\n        assertEquals(4, o.getBytesWritten());\r\n        o.count(-1);\r\n        assertEquals(4, o.getBytesWritten());\r\n        o.count(-2);\r\n        assertEquals(2, o.getBytesWritten());\r\n    }\r\n    assertArrayEquals(new byte[] { 1, 2, 3, 4 }, bos.toByteArray());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ExactMathTest.java",
  "methodName" : "testOverflow",
  "sourceCode" : "@Test\r\nvoid testOverflow() {\r\n    assertThrows(IllegalArgumentException.class, () -> ExactMath.add(1, Long.MAX_VALUE / 1000));\r\n    assertThrows(IllegalArgumentException.class, () -> ExactMath.add(Integer.MAX_VALUE, Integer.MAX_VALUE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FileNameUtilsTest.java",
  "methodName" : "testGetBaseNamePathBaseCases",
  "sourceCode" : "@Test\r\nvoid testGetBaseNamePathBaseCases() {\r\n    assertEquals(\"bar\", FileNameUtils.getBaseName(Paths.get(\"a/b/c/bar.foo\")));\r\n    assertEquals(\"foo\", FileNameUtils.getBaseName(Paths.get(\"foo\")));\r\n    assertEquals(\"\", FileNameUtils.getBaseName(Paths.get(\"\")));\r\n    assertEquals(\"\", FileNameUtils.getBaseName(Paths.get(\".\")));\r\n    for (final File f : File.listRoots()) {\r\n        assertNull(FileNameUtils.getBaseName(f.toPath()));\r\n    }\r\n    if (SystemUtils.IS_OS_WINDOWS) {\r\n        assertNull(FileNameUtils.getBaseName(Paths.get(\"C:\\\\\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FileNameUtilsTest.java",
  "methodName" : "testGetBaseNamePathCornerCases",
  "sourceCode" : "@Test\r\nvoid testGetBaseNamePathCornerCases() {\r\n    assertNull(FileNameUtils.getBaseName((Path) null));\r\n    assertEquals(\"foo\", FileNameUtils.getBaseName(Paths.get(\"foo.\")));\r\n    assertEquals(\"\", FileNameUtils.getBaseName(Paths.get(\"bar/.foo\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FileNameUtilsTest.java",
  "methodName" : "testGetBaseNameStringBaseCases",
  "sourceCode" : "@Test\r\nvoid testGetBaseNameStringBaseCases() {\r\n    assertEquals(\"bar\", FileNameUtils.getBaseName(\"a/b/c/bar.foo\"));\r\n    assertEquals(\"foo\", FileNameUtils.getBaseName(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FileNameUtilsTest.java",
  "methodName" : "testGetBaseNameStringCornerCases",
  "sourceCode" : "@Test\r\nvoid testGetBaseNameStringCornerCases() {\r\n    assertNull(FileNameUtils.getBaseName((String) null));\r\n    assertEquals(\"foo\", FileNameUtils.getBaseName(\"foo.\"));\r\n    assertEquals(\"\", FileNameUtils.getBaseName(\"bar/.foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FileNameUtilsTest.java",
  "methodName" : "testGetExtensionPathBaseCases",
  "sourceCode" : "@Test\r\nvoid testGetExtensionPathBaseCases() {\r\n    assertEquals(\"foo\", FileNameUtils.getExtension(Paths.get(\"a/b/c/bar.foo\")));\r\n    assertEquals(\"\", FileNameUtils.getExtension(Paths.get(\"foo\")));\r\n    assertEquals(\"\", FileNameUtils.getExtension(Paths.get(\"\")));\r\n    assertEquals(\"\", FileNameUtils.getExtension(Paths.get(\".\")));\r\n    for (final File f : File.listRoots()) {\r\n        assertNull(FileNameUtils.getExtension(f.toPath()));\r\n    }\r\n    if (SystemUtils.IS_OS_WINDOWS) {\r\n        assertNull(FileNameUtils.getExtension(Paths.get(\"C:\\\\\")));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FileNameUtilsTest.java",
  "methodName" : "testGetExtensionPathCornerCases",
  "sourceCode" : "@Test\r\nvoid testGetExtensionPathCornerCases() {\r\n    assertNull(FileNameUtils.getExtension((String) null));\r\n    assertEquals(\"\", FileNameUtils.getExtension(Paths.get(\"foo.\")));\r\n    assertEquals(\"foo\", FileNameUtils.getExtension(Paths.get(\"bar/.foo\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FileNameUtilsTest.java",
  "methodName" : "testGetExtensionStringBaseCases",
  "sourceCode" : "@Test\r\nvoid testGetExtensionStringBaseCases() {\r\n    assertEquals(\"foo\", FileNameUtils.getExtension(\"a/b/c/bar.foo\"));\r\n    assertEquals(\"\", FileNameUtils.getExtension(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FileNameUtilsTest.java",
  "methodName" : "testGetExtensionStringCornerCases",
  "sourceCode" : "@Test\r\nvoid testGetExtensionStringCornerCases() {\r\n    assertNull(FileNameUtils.getExtension((String) null));\r\n    assertEquals(\"\", FileNameUtils.getExtension(\"foo.\"));\r\n    assertEquals(\"foo\", FileNameUtils.getExtension(\"bar/.foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testMultiWriteBuf",
  "sourceCode" : "@Test\r\nvoid testMultiWriteBuf() throws IOException {\r\n    final int blockSize = 13;\r\n    try (MockWritableByteChannel mock = new MockWritableByteChannel(blockSize, false)) {\r\n        final String testString = \"hello world\";\r\n        final byte[] msg = testString.getBytes();\r\n        final int reps = 17;\r\n        try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(mock, blockSize)) {\r\n            for (int i = 0; i < reps; i++) {\r\n                final ByteBuffer buf = getByteBuffer(msg);\r\n                out.write(buf);\r\n            }\r\n        }\r\n        final ByteArrayOutputStream bos = mock.bos;\r\n        final double v = Math.ceil(reps * msg.length / (double) blockSize) * blockSize;\r\n        assertEquals((long) v, bos.size(), \"wrong size\");\r\n        final int strLen = msg.length * reps;\r\n        final byte[] output = bos.toByteArray();\r\n        final String l = new String(output, 0, strLen);\r\n        final StringBuilder buf = new StringBuilder(strLen);\r\n        for (int i = 0; i < reps; i++) {\r\n            buf.append(testString);\r\n        }\r\n        assertEquals(buf.toString(), l);\r\n        for (int i = strLen; i < output.length; i++) {\r\n            assertEquals(0, output[i]);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testPartialWritingThrowsException",
  "sourceCode" : "@Test\r\nvoid testPartialWritingThrowsException() {\r\n    final IOException e = assertThrows(IOException.class, () -> testWriteAndPad(512, \"hello world!\\n\", true), \"Exception for partial write not thrown\");\r\n    final String msg = e.getMessage();\r\n    assertEquals(\"Failed to write 512 bytes atomically. Only wrote  511\", msg, \"exception message\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testSmallWrite",
  "sourceCode" : "@Test\r\nvoid testSmallWrite() throws IOException {\r\n    testWriteAndPad(10240, \"hello world!\\n\", false);\r\n    testWriteAndPad(512, \"hello world!\\n\", false);\r\n    testWriteAndPad(11, \"hello world!\\n\", false);\r\n    testWriteAndPad(3, \"hello world!\\n\", false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testSmallWriteToStream",
  "sourceCode" : "@Test\r\nvoid testSmallWriteToStream() throws IOException {\r\n    testWriteAndPadToStream(10240, \"hello world!\\n\", false);\r\n    testWriteAndPadToStream(512, \"hello world!\\n\", false);\r\n    testWriteAndPadToStream(11, \"hello world!\\n\", false);\r\n    testWriteAndPadToStream(3, \"hello     world!\\n\", false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testWithFileOutputStream",
  "sourceCode" : "@Test\r\nvoid testWithFileOutputStream() throws IOException {\r\n    final Path tempFile = Files.createTempFile(\"xxx\", \"yyy\");\r\n    Runtime.getRuntime().addShutdownHook(new Thread(() -> {\r\n        try {\r\n            Files.deleteIfExists(tempFile);\r\n        } catch (final IOException ignored) {\r\n            // ignored\r\n        }\r\n    }));\r\n    final int blockSize = 512;\r\n    final int reps = 1000;\r\n    try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(Files.newOutputStream(tempFile.toFile().toPath()), blockSize)) {\r\n        final DataOutputStream dos = new DataOutputStream(out);\r\n        for (int i = 0; i < reps; i++) {\r\n            dos.writeInt(i);\r\n        }\r\n    }\r\n    final long expectedDataSize = reps * 4L;\r\n    final long expectedFileSize = (long) Math.ceil(expectedDataSize / (double) blockSize) * blockSize;\r\n    assertEquals(expectedFileSize, Files.size(tempFile), \"file size\");\r\n    final DataInputStream din = new DataInputStream(Files.newInputStream(tempFile));\r\n    for (int i = 0; i < reps; i++) {\r\n        assertEquals(i, din.readInt(), \"file int\");\r\n    }\r\n    for (int i = 0; i < expectedFileSize - expectedDataSize; i++) {\r\n        assertEquals(0, din.read());\r\n    }\r\n    assertEquals(-1, din.read());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testWriteBuf",
  "sourceCode" : "@Test\r\nvoid testWriteBuf() throws IOException {\r\n    final String hwa = \"hello world avengers\";\r\n    testBuf(4, hwa);\r\n    testBuf(512, hwa);\r\n    testBuf(10240, hwa);\r\n    testBuf(11, hwa + hwa + hwa);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testWriteFailsAfterDestClosedThrowsException",
  "sourceCode" : "@Test\r\nvoid testWriteFailsAfterDestClosedThrowsException() throws IOException {\r\n    final int blockSize = 2;\r\n    try (MockOutputStream mock = new MockOutputStream(blockSize, false);\r\n        FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(mock, blockSize)) {\r\n        assertThrows(IOException.class, () -> {\r\n            out.write(1);\r\n            assertTrue(out.isOpen());\r\n            mock.close();\r\n            out.write(1);\r\n        }, \"expected IO Exception\");\r\n        assertFalse(out.isOpen());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testWriteFailsAfterFLClosedThrowsException",
  "sourceCode" : "@Test\r\nvoid testWriteFailsAfterFLClosedThrowsException() {\r\n    assertThrowsExactly(ClosedChannelException.class, () -> {\r\n        try (FixedLengthBlockOutputStream out = newClosedFLBOS()) {\r\n            out.write(1);\r\n        }\r\n    }, \"expected Closed Channel Exception\");\r\n    assertThrowsExactly(ClosedChannelException.class, () -> {\r\n        try (FixedLengthBlockOutputStream out = newClosedFLBOS()) {\r\n            out.write(new byte[] { 0, 1, 2, 3 });\r\n        }\r\n    }, \"expected Closed Channel Exception\");\r\n    assertThrowsExactly(ClosedChannelException.class, () -> {\r\n        try (FixedLengthBlockOutputStream out = newClosedFLBOS()) {\r\n            out.write(ByteBuffer.wrap(new byte[] { 0, 1, 2, 3 }));\r\n        }\r\n    }, \"expected Closed Channel Exception\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\FixedLengthBlockOutputStreamTest.java",
  "methodName" : "testWriteSingleBytes",
  "sourceCode" : "@Test\r\nvoid testWriteSingleBytes() throws IOException {\r\n    final int blockSize = 4;\r\n    try (MockWritableByteChannel mock = new MockWritableByteChannel(blockSize, false)) {\r\n        final ByteArrayOutputStream bos = mock.bos;\r\n        final String text = \"hello world avengers\";\r\n        final byte[] msg = text.getBytes();\r\n        final int len = msg.length;\r\n        try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(mock, blockSize)) {\r\n            for (int i = 0; i < len; i++) {\r\n                out.write(msg[i]);\r\n            }\r\n        }\r\n        final byte[] output = bos.toByteArray();\r\n        validate(blockSize, msg, output);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testCopy_inputStreamToOutputStream_IO84",
  "sourceCode" : "@Test\r\nvoid testCopy_inputStreamToOutputStream_IO84() throws Exception {\r\n    final long size = (long) Integer.MAX_VALUE + (long) 1;\r\n    final InputStream in = new NullInputStream(size);\r\n    final OutputStream out = NullOutputStream.INSTANCE;\r\n    // Test copy() method\r\n    assertEquals(-1, IOUtils.copy(in, out));\r\n    // reset the input\r\n    in.close();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testCopy_inputStreamToOutputStream_nullIn",
  "sourceCode" : "@Test\r\nvoid testCopy_inputStreamToOutputStream_nullIn() {\r\n    final OutputStream out = new ByteArrayOutputStream();\r\n    assertThrows(NullPointerException.class, () -> IOUtils.copy((InputStream) null, out));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testCopy_inputStreamToOutputStream_nullOut",
  "sourceCode" : "@Test\r\nvoid testCopy_inputStreamToOutputStream_nullOut() {\r\n    final InputStream in = new ByteArrayInputStream(new byte[] { 1, 2, 3, 4 });\r\n    assertThrows(NullPointerException.class, () -> IOUtils.copy(in, (OutputStream) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testCopyOnZeroBufferSize",
  "sourceCode" : "@Test\r\nvoid testCopyOnZeroBufferSize() throws IOException {\r\n    assertEquals(0, IOUtils.copy(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY), new ByteArrayOutputStream(), 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testCopyRangeDoesntCopyMoreThanAskedFor",
  "sourceCode" : "@Test\r\nvoid testCopyRangeDoesntCopyMoreThanAskedFor() throws IOException {\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 1, 2, 3, 4, 5 });\r\n        ByteArrayOutputStream out = new ByteArrayOutputStream()) {\r\n        assertEquals(3, IOUtils.copyRange(in, 3, out));\r\n        out.close();\r\n        assertArrayEquals(new byte[] { 1, 2, 3 }, out.toByteArray());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testCopyRangeStopsIfThereIsNothingToCopyAnymore",
  "sourceCode" : "@Test\r\nvoid testCopyRangeStopsIfThereIsNothingToCopyAnymore() throws IOException {\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 1, 2, 3, 4, 5 });\r\n        ByteArrayOutputStream out = new ByteArrayOutputStream()) {\r\n        assertEquals(5, IOUtils.copyRange(in, 10, out));\r\n        out.close();\r\n        assertArrayEquals(new byte[] { 1, 2, 3, 4, 5 }, out.toByteArray());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testCopyRangeThrowsOnZeroBufferSize",
  "sourceCode" : "@Test\r\nvoid testCopyRangeThrowsOnZeroBufferSize() throws IOException {\r\n    assertThrows(IllegalArgumentException.class, () -> IOUtils.copyRange(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY), 5, new ByteArrayOutputStream(), 0));\r\n    assertEquals(0, IOUtils.copyRange(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY), 5, new ByteArrayOutputStream(), 1));\r\n    assertEquals(0, IOUtils.copyRange(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY), 5, null, 1));\r\n    assertEquals(1, IOUtils.copyRange(new ByteArrayInputStream(new byte[1]), 5, null, 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testReadFullyOnChannelReadsFully",
  "sourceCode" : "@Test\r\nvoid testReadFullyOnChannelReadsFully() throws IOException {\r\n    final ByteBuffer b = ByteBuffer.allocate(20);\r\n    final byte[] source = new byte[20];\r\n    for (byte i = 0; i < 20; i++) {\r\n        source[i] = i;\r\n    }\r\n    readFully(source, b);\r\n    assertArrayEquals(source, b.array());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testReadFullyOnChannelThrowsEof",
  "sourceCode" : "@Test\r\nvoid testReadFullyOnChannelThrowsEof() {\r\n    final ByteBuffer b = ByteBuffer.allocate(21);\r\n    final byte[] source = new byte[20];\r\n    for (byte i = 0; i < 20; i++) {\r\n        source[i] = i;\r\n    }\r\n    assertThrows(EOFException.class, () -> readFully(source, b));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testReadRangeFromChannelDoesntReadMoreThanAskedFor",
  "sourceCode" : "@Test\r\nvoid testReadRangeFromChannelDoesntReadMoreThanAskedFor() throws IOException {\r\n    try (ReadableByteChannel in = new SeekableInMemoryByteChannel(new byte[] { 1, 2, 3, 4, 5 })) {\r\n        final byte[] read = IOUtils.readRange(in, 3);\r\n        assertArrayEquals(new byte[] { 1, 2, 3 }, read);\r\n        final ByteBuffer b = ByteBuffer.allocate(1);\r\n        assertEquals(1, in.read(b));\r\n        assertArrayEquals(new byte[] { 4 }, b.array());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testReadRangeFromChannelDoesntReadMoreThanAskedForWhenItGotLessInFirstReadCall",
  "sourceCode" : "@Test\r\nvoid testReadRangeFromChannelDoesntReadMoreThanAskedForWhenItGotLessInFirstReadCall() throws IOException {\r\n    try (ReadableByteChannel in = new SeekableInMemoryByteChannel(new byte[] { 1, 2, 3, 4, 5, 6, 7 }) {\r\n\r\n        @Override\r\n        public int read(ByteBuffer buf) throws IOException {\r\n            // Trickle max 2 bytes at a time to trigger COMPRESS-584\r\n            final ByteBuffer temp = ByteBuffer.allocate(Math.min(2, buf.remaining()));\r\n            final int read = super.read(temp);\r\n            if (read > 0) {\r\n                buf.put(temp.array(), 0, read);\r\n            }\r\n            return read;\r\n        }\r\n    }) {\r\n        final byte[] read = IOUtils.readRange(in, 5);\r\n        assertArrayEquals(new byte[] { 1, 2, 3, 4, 5 }, read);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testReadRangeFromChannelStopsIfThereIsNothingToReadAnymore",
  "sourceCode" : "@Test\r\nvoid testReadRangeFromChannelStopsIfThereIsNothingToReadAnymore() throws IOException {\r\n    try (ReadableByteChannel in = new SeekableInMemoryByteChannel(new byte[] { 1, 2, 3, 4, 5 })) {\r\n        final byte[] read = IOUtils.readRange(in, 10);\r\n        assertArrayEquals(new byte[] { 1, 2, 3, 4, 5 }, read);\r\n        final ByteBuffer b = ByteBuffer.allocate(1);\r\n        assertEquals(-1, in.read(b));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testReadRangeFromStreamDoesntReadMoreThanAskedFor",
  "sourceCode" : "@Test\r\nvoid testReadRangeFromStreamDoesntReadMoreThanAskedFor() throws IOException {\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 1, 2, 3, 4, 5 })) {\r\n        final byte[] read = IOUtils.readRange(in, 3);\r\n        assertArrayEquals(new byte[] { 1, 2, 3 }, read);\r\n        assertEquals(4, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testReadRangeFromStreamStopsIfThereIsNothingToReadAnymore",
  "sourceCode" : "@Test\r\nvoid testReadRangeFromStreamStopsIfThereIsNothingToReadAnymore() throws IOException {\r\n    try (ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 1, 2, 3, 4, 5 })) {\r\n        final byte[] read = IOUtils.readRange(in, 10);\r\n        assertArrayEquals(new byte[] { 1, 2, 3, 4, 5 }, read);\r\n        assertEquals(-1, in.read());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testReadRangeMoreThanCopyBufferSize",
  "sourceCode" : "@Test\r\nvoid testReadRangeMoreThanCopyBufferSize() throws Exception {\r\n    final int copyBufSize = org.apache.commons.io.IOUtils.DEFAULT_BUFFER_SIZE;\r\n    // Make an input that requires two read loops to trigger COMPRESS-585\r\n    final byte[] input = new byte[copyBufSize + 10];\r\n    try (SeekableInMemoryByteChannel in = new SeekableInMemoryByteChannel(input)) {\r\n        // Ask for less than the input length, but more than the buffer size\r\n        final int toRead = copyBufSize + 1;\r\n        final byte[] read = IOUtils.readRange(in, toRead);\r\n        assertEquals(toRead, read.length);\r\n        assertEquals(toRead, in.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testSkipUsingRead",
  "sourceCode" : "@Test\r\nvoid testSkipUsingRead() throws Exception {\r\n    skip(toWrap -> new FilterInputStream(toWrap) {\r\n\r\n        @Override\r\n        public long skip(final long s) {\r\n            return 0;\r\n        }\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testSkipUsingSkip",
  "sourceCode" : "@Test\r\nvoid testSkipUsingSkip() throws Exception {\r\n    skip(toWrap -> toWrap);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testSkipUsingSkipAndRead",
  "sourceCode" : "@Test\r\nvoid testSkipUsingSkipAndRead() throws Exception {\r\n    skip(toWrap -> new FilterInputStream(toWrap) {\r\n\r\n        boolean skipped;\r\n\r\n        @Override\r\n        public long skip(final long s) throws IOException {\r\n            if (!skipped) {\r\n                toWrap.skip(5);\r\n                skipped = true;\r\n                return 5;\r\n            }\r\n            return 0;\r\n        }\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\IOUtilsTest.java",
  "methodName" : "testToByteArray_InputStream",
  "sourceCode" : "@Test\r\nvoid testToByteArray_InputStream() throws Exception {\r\n    final byte[] bytes = \"ABCB\".getBytes(StandardCharsets.UTF_8);\r\n    try (InputStream fin = new ByteArrayInputStream(bytes)) {\r\n        @SuppressWarnings(\"deprecation\")\r\n        final byte[] out = IOUtils.toByteArray(fin);\r\n        assertNotNull(out);\r\n        assertEquals(0, fin.available());\r\n        assertEquals(4, out.length);\r\n        assertArrayEquals(bytes, out);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testCantPositionToANegativePosition",
  "sourceCode" : "@Test\r\nvoid testCantPositionToANegativePosition() throws IOException {\r\n    try (SeekableByteChannel s = MultiReadOnlySeekableByteChannel.forSeekableByteChannels(makeEmpty(), makeEmpty())) {\r\n        assertThrows(IllegalArgumentException.class, () -> s.position(-1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testCantTruncate",
  "sourceCode" : "@Test\r\nvoid testCantTruncate() throws IOException {\r\n    try (SeekableByteChannel s = MultiReadOnlySeekableByteChannel.forSeekableByteChannels(makeEmpty(), makeEmpty())) {\r\n        assertThrows(NonWritableChannelException.class, () -> s.truncate(1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testCantWrite",
  "sourceCode" : "@Test\r\nvoid testCantWrite() throws IOException {\r\n    try (SeekableByteChannel s = MultiReadOnlySeekableByteChannel.forSeekableByteChannels(makeEmpty(), makeEmpty())) {\r\n        assertThrows(NonWritableChannelException.class, () -> s.write(ByteBuffer.allocate(10)));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testCheckForSingleByte",
  "sourceCode" : "@Test\r\nvoid testCheckForSingleByte() throws IOException {\r\n    check(new byte[] { 0 });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testCheckForString",
  "sourceCode" : "@Test\r\nvoid testCheckForString() throws IOException {\r\n    check(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".getBytes(UTF_8));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testCloseIsIdempotent",
  "sourceCode" : "/*\r\n     * <q>If the stream is already closed then invoking this method has no effect.</q>\r\n     */\r\n@Test\r\nvoid testCloseIsIdempotent() throws Exception {\r\n    try (SeekableByteChannel c = testChannel()) {\r\n        c.close();\r\n        assertFalse(c.isOpen());\r\n        c.close();\r\n        assertFalse(c.isOpen());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testClosesAllAndThrowsExceptionIfCloseThrows",
  "sourceCode" : "@Test\r\nvoid testClosesAllAndThrowsExceptionIfCloseThrows() {\r\n    final SeekableByteChannel[] ts = new ThrowingSeekableByteChannel[] { new ThrowingSeekableByteChannel(), new ThrowingSeekableByteChannel() };\r\n    final SeekableByteChannel s = MultiReadOnlySeekableByteChannel.forSeekableByteChannels(ts);\r\n    assertThrows(IOException.class, s::close, \"IOException expected\");\r\n    assertFalse(ts[0].isOpen());\r\n    assertFalse(ts[1].isOpen());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testConstructorThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testConstructorThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> new MultiReadOnlySeekableByteChannel(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForFilesThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testForFilesThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> MultiReadOnlySeekableByteChannel.forFiles((File[]) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForSeekableByteChannelsReturnsIdentityForSingleElement",
  "sourceCode" : "@Test\r\nvoid testForSeekableByteChannelsReturnsIdentityForSingleElement() throws IOException {\r\n    try (SeekableByteChannel e = makeEmpty();\r\n        SeekableByteChannel m = MultiReadOnlySeekableByteChannel.forSeekableByteChannels(e)) {\r\n        assertSame(e, m);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForSeekableByteChannelsThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testForSeekableByteChannelsThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> MultiReadOnlySeekableByteChannel.forSeekableByteChannels((SeekableByteChannel[]) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testReadingFromAPositionAfterEndReturnsEOF",
  "sourceCode" : "/*\r\n     * <q>Setting the position to a value that is greater than the current size is legal but does not change the size of the entity. A later attempt to read\r\n     * bytes at such a position will immediately return an end-of-file indication</q>\r\n     */\r\n@Test\r\nvoid testReadingFromAPositionAfterEndReturnsEOF() throws Exception {\r\n    try (SeekableByteChannel c = testChannel()) {\r\n        c.position(2);\r\n        assertEquals(2, c.position());\r\n        final ByteBuffer readBuffer = ByteBuffer.allocate(5);\r\n        assertEquals(-1, c.read(readBuffer));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testReferenceBehaviorForEmptyChannel",
  "sourceCode" : "// Contract Tests added in response to https://issues.apache.org/jira/browse/COMPRESS-499\r\n@Test\r\nvoid testReferenceBehaviorForEmptyChannel() throws IOException {\r\n    checkEmpty(makeEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel",
  "sourceCode" : "// https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html#close()\r\n/*\r\n     * <q>ClosedChannelException - If this channel is closed</q>\r\n     */\r\n@Test\r\nvoid testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel() throws Exception {\r\n    try (SeekableByteChannel c = testChannel()) {\r\n        c.close();\r\n        assertThrows(ClosedChannelException.class, () -> c.position(0));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testThrowsClosedChannelExceptionWhenSizeIsReadOnClosedChannel",
  "sourceCode" : "// https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position()\r\n/*\r\n     * <q>ClosedChannelException - If this channel is closed</q>\r\n     */\r\n@Test\r\nvoid testThrowsClosedChannelExceptionWhenSizeIsReadOnClosedChannel() throws Exception {\r\n    try (SeekableByteChannel c = testChannel()) {\r\n        c.close();\r\n        assertThrows(ClosedChannelException.class, () -> c.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testThrowsIOExceptionWhenPositionIsSetToANegativeValue",
  "sourceCode" : "// https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#size()\r\n/*\r\n     * <q>IOException - If the new position is negative</q>\r\n     */\r\n@Test\r\nvoid testThrowsIOExceptionWhenPositionIsSetToANegativeValue() throws Exception {\r\n    try (SeekableByteChannel c = testChannel()) {\r\n        assertThrows(IllegalArgumentException.class, () -> c.position(-1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testTwoEmptyChannelsConcatenateAsEmptyChannel",
  "sourceCode" : "// https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position(long)\r\n@Test\r\nvoid testTwoEmptyChannelsConcatenateAsEmptyChannel() throws IOException {\r\n    try (SeekableByteChannel channel = MultiReadOnlySeekableByteChannel.forSeekableByteChannels(makeEmpty(), makeEmpty())) {\r\n        checkEmpty(channel);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "testVerifyGrouped",
  "sourceCode" : "@Test\r\nvoid testVerifyGrouped() {\r\n    assertArrayEquals(new byte[][] { new byte[] { 1, 2, 3 }, new byte[] { 4, 5, 6 }, new byte[] { 7 } }, grouped(new byte[] { 1, 2, 3, 4, 5, 6, 7 }, 3));\r\n    assertArrayEquals(new byte[][] { new byte[] { 1, 2, 3 }, new byte[] { 4, 5, 6 } }, grouped(new byte[] { 1, 2, 3, 4, 5, 6 }, 3));\r\n    assertArrayEquals(new byte[][] { new byte[] { 1, 2, 3 }, new byte[] { 4, 5 } }, grouped(new byte[] { 1, 2, 3, 4, 5 }, 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\MultiReadOnlySeekableByteChannelTest.java",
  "methodName" : "throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel",
  "sourceCode" : "/*\r\n     * <q>ClosedChannelException - If this channel is closed</q>\r\n     */\r\n@Test\r\n@Disabled(\"we deliberately violate the spec\")\r\npublic void throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel() throws Exception {\r\n    try (SeekableByteChannel c = testChannel()) {\r\n        c.close();\r\n        c.position();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\OsgiUtilsTest.java",
  "methodName" : "testDetectsItIsNotRunningInsideOsgiEnv",
  "sourceCode" : "@Test\r\nvoid testDetectsItIsNotRunningInsideOsgiEnv() {\r\n    assertFalse(OsgiUtils.isRunningInOsgiEnvironment());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ParsingUtilsTest.java",
  "methodName" : "testParseIntValueInvalidValues",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { Integer.MIN_VALUE + \"1\", \"x.x\", \"9e999\", \"1.1\", \"one\", Integer.MAX_VALUE + \"1\" })\r\nvoid testParseIntValueInvalidValues(final String value) {\r\n    assertThrows(IOException.class, () -> ParsingUtils.parseIntValue(value, 10));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ParsingUtilsTest.java",
  "methodName" : "testParseIntValueValidValues",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { Integer.MIN_VALUE + \"\", \"-1\", \"1\", \"123456\", Integer.MAX_VALUE + \"\" })\r\nvoid testParseIntValueValidValues(final String value) throws Exception {\r\n    assertEquals(Long.parseLong(value), ParsingUtils.parseIntValue(value, 10));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ParsingUtilsTest.java",
  "methodName" : "testParseLongValueInvalidValues",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { Long.MIN_VALUE + \"1\", \"x.x\", \"9e999\", \"1.1\", \"one\", Long.MAX_VALUE + \"1\" })\r\nvoid testParseLongValueInvalidValues(final String value) {\r\n    assertThrows(IOException.class, () -> ParsingUtils.parseLongValue(value, 10));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ParsingUtilsTest.java",
  "methodName" : "testParseLongValueValidValues",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(strings = { Long.MIN_VALUE + \"\", \"-1\", \"1\", \"12345678901234\", Long.MAX_VALUE + \"\" })\r\nvoid testParseLongValueValidValues(final String value) throws Exception {\r\n    assertEquals(Long.parseLong(value), ParsingUtils.parseLongValue(value, 10));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testCloseIsIdempotent",
  "sourceCode" : "/*\r\n     * <q>If the stream is already closed then invoking this method has no effect.</q>\r\n     */\r\n@Test\r\nvoid testCloseIsIdempotent() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        c.close();\r\n        assertFalse(c.isOpen());\r\n        c.close();\r\n        assertFalse(c.isOpen());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testReadingFromAPositionAfterEndReturnsEOF",
  "sourceCode" : "/*\r\n     * <q>Setting the position to a value that is greater than the current size is legal but does not change the size of the entity. A later attempt to read\r\n     * bytes at such a position will immediately return an end-of-file indication</q>\r\n     */\r\n@ParameterizedTest\r\n@ValueSource(ints = { 0, 1, 2, 3, 4, 5, 6 })\r\nvoid testReadingFromAPositionAfterEndReturnsEOF(final int size) throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel(size)) {\r\n        final int position = 2;\r\n        c.position(position);\r\n        assertEquals(position, c.position());\r\n        final int readSize = 5;\r\n        final ByteBuffer readBuffer = ByteBuffer.allocate(readSize);\r\n        assertEquals(position >= size ? -1 : size - position, c.read(readBuffer));\r\n    }\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldReadContentsProperly",
  "sourceCode" : "@Test\r\nvoid testShouldReadContentsProperly() throws IOException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\r\n        final int readCount = c.read(readBuffer);\r\n        assertEquals(testData.length, readCount);\r\n        assertArrayEquals(testData, readBuffer.array());\r\n        assertEquals(testData.length, c.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldReadContentsWhenBiggerBufferSupplied",
  "sourceCode" : "@Test\r\nvoid testShouldReadContentsWhenBiggerBufferSupplied() throws IOException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length + 1);\r\n        final int readCount = c.read(readBuffer);\r\n        assertEquals(testData.length, readCount);\r\n        assertArrayEquals(testData, Arrays.copyOf(readBuffer.array(), testData.length));\r\n        assertEquals(testData.length, c.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldReadDataFromSetPosition",
  "sourceCode" : "@Test\r\nvoid testShouldReadDataFromSetPosition() throws IOException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        final ByteBuffer readBuffer = ByteBuffer.allocate(4);\r\n        c.position(5L);\r\n        final int readCount = c.read(readBuffer);\r\n        assertEquals(4L, readCount);\r\n        assertEquals(\"data\", new String(readBuffer.array(), StandardCharsets.UTF_8));\r\n        assertEquals(testData.length, c.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldSetProperPosition",
  "sourceCode" : "@Test\r\nvoid testShouldSetProperPosition() throws IOException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        final long posAtFour = c.position(4L).position();\r\n        final long posAtTheEnd = c.position(testData.length).position();\r\n        final long posPastTheEnd = c.position(testData.length + 1L).position();\r\n        assertEquals(4L, posAtFour);\r\n        assertEquals(c.size(), posAtTheEnd);\r\n        assertEquals(testData.length + 1L, posPastTheEnd);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldSetProperPositionOnTruncate",
  "sourceCode" : "@Test\r\nvoid testShouldSetProperPositionOnTruncate() throws IOException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        c.position(testData.length);\r\n        c.truncate(4L);\r\n        assertEquals(4L, c.position());\r\n        assertEquals(4L, c.size());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldSignalEOFWhenPositionAtTheEnd",
  "sourceCode" : "@Test\r\nvoid testShouldSignalEOFWhenPositionAtTheEnd() throws IOException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\r\n        c.position(testData.length + 1);\r\n        final int readCount = c.read(readBuffer);\r\n        assertEquals(0L, readBuffer.position());\r\n        assertEquals(-1, readCount);\r\n        assertEquals(-1, c.read(readBuffer));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldThrowExceptionOnReadingClosedChannel",
  "sourceCode" : "@Test\r\nvoid testShouldThrowExceptionOnReadingClosedChannel() {\r\n    final SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel();\r\n    c.close();\r\n    assertThrows(ClosedChannelException.class, () -> c.read(ByteBuffer.allocate(1)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldThrowExceptionOnWritingToClosedChannel",
  "sourceCode" : "@Test\r\nvoid testShouldThrowExceptionOnWritingToClosedChannel() {\r\n    final SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel();\r\n    c.close();\r\n    assertThrows(ClosedChannelException.class, () -> c.write(ByteBuffer.allocate(1)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldThrowExceptionWhenSettingIncorrectPosition",
  "sourceCode" : "@Test\r\nvoid testShouldThrowExceptionWhenSettingIncorrectPosition() {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        assertThrows(IllegalArgumentException.class, () -> c.position(Integer.MAX_VALUE + 1L));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldThrowExceptionWhenTruncatingToIncorrectSize",
  "sourceCode" : "@Test\r\nvoid testShouldThrowExceptionWhenTruncatingToIncorrectSize() {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        assertThrows(IllegalArgumentException.class, () -> c.truncate(Integer.MAX_VALUE + 1L));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldTruncateContentsProperly",
  "sourceCode" : "@Test\r\nvoid testShouldTruncateContentsProperly() throws ClosedChannelException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        c.truncate(4);\r\n        final byte[] bytes = Arrays.copyOf(c.array(), (int) c.size());\r\n        assertEquals(\"Some\", new String(bytes, StandardCharsets.UTF_8));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldWriteDataProperly",
  "sourceCode" : "// Contract Tests added in response to https://issues.apache.org/jira/browse/COMPRESS-499\r\n// https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html#close()\r\n@Test\r\nvoid testShouldWriteDataProperly() throws IOException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        final ByteBuffer inData = ByteBuffer.wrap(testData);\r\n        final int writeCount = c.write(inData);\r\n        assertEquals(testData.length, writeCount);\r\n        assertEquals(testData.length, c.position());\r\n        assertArrayEquals(testData, Arrays.copyOf(c.array(), (int) c.position()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testShouldWriteDataProperlyAfterPositionSet",
  "sourceCode" : "// https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position()\r\n@Test\r\nvoid testShouldWriteDataProperlyAfterPositionSet() throws IOException {\r\n    try (SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        final ByteBuffer inData = ByteBuffer.wrap(testData);\r\n        final ByteBuffer expectedData = ByteBuffer.allocate(testData.length + 5).put(testData, 0, 5).put(testData);\r\n        c.position(5L);\r\n        final int writeCount = c.write(inData);\r\n        assertEquals(testData.length, writeCount);\r\n        assertArrayEquals(expectedData.array(), Arrays.copyOf(c.array(), (int) c.size()));\r\n        assertEquals(testData.length + 5, c.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel",
  "sourceCode" : "// https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#size()\r\n/*\r\n     * <q>ClosedChannelException - If this channel is closed</q>\r\n     */\r\n@Test\r\nvoid testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        c.close();\r\n        assertThrows(ClosedChannelException.class, () -> c.position(0));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testThrowsIllegalArgumentExceptionWhenTruncatingToANegativeSize",
  "sourceCode" : "// https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position(long)\r\n/*\r\n     * <q>IllegalArgumentException - If the new position is negative</q>\r\n     */\r\n@Test\r\nvoid testThrowsIllegalArgumentExceptionWhenTruncatingToANegativeSize() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        assertThrows(IllegalArgumentException.class, () -> c.truncate(-1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testThrowsIOExceptionWhenPositionIsSetToANegativeValue",
  "sourceCode" : "/*\r\n     * <q>IOException - If the new position is negative</q>\r\n     */\r\n@Test\r\nvoid testThrowsIOExceptionWhenPositionIsSetToANegativeValue() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        assertThrows(IllegalArgumentException.class, () -> c.position(-1));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testTruncateDoesntChangeSmallPosition",
  "sourceCode" : "/*\r\n     * <q> In either case, if the current position is greater than the given size then it is set to that size.</q>\r\n     */\r\n@Test\r\nvoid testTruncateDoesntChangeSmallPosition() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        c.position(1);\r\n        c.truncate(testData.length - 1);\r\n        assertEquals(testData.length - 1, c.size());\r\n        assertEquals(1, c.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger",
  "sourceCode" : "/*\r\n     * <q> In either case, if the current position is greater than the given size then it is set to that size.</q>\r\n     */\r\n@Test\r\nvoid testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        c.position(2 * testData.length);\r\n        c.truncate(testData.length + 1);\r\n        assertEquals(testData.length, c.size());\r\n        assertEquals(testData.length + 1, c.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize",
  "sourceCode" : "// https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#truncate(long)\r\n/*\r\n     * <q> In either case, if the current position is greater than the given size then it is set to that size.</q>\r\n     */\r\n@Test\r\nvoid testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        c.position(2 * testData.length);\r\n        c.truncate(testData.length);\r\n        assertEquals(testData.length, c.size());\r\n        assertEquals(testData.length, c.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testTruncateMovesPositionWhenShrinkingBeyondPosition",
  "sourceCode" : "/*\r\n     * <q> In either case, if the current position is greater than the given size then it is set to that size.</q>\r\n     */\r\n@Test\r\nvoid testTruncateMovesPositionWhenShrinkingBeyondPosition() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        c.position(4);\r\n        c.truncate(3);\r\n        assertEquals(3, c.size());\r\n        assertEquals(3, c.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testTruncateToBiggerSizeDoesntChangeAnything",
  "sourceCode" : "/*\r\n     * <q>If the given size is greater than or equal to the current size then the entity is not modified.</q>\r\n     */\r\n@Test\r\nvoid testTruncateToBiggerSizeDoesntChangeAnything() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        assertEquals(testData.length, c.size());\r\n        c.truncate(testData.length + 1);\r\n        assertEquals(testData.length, c.size());\r\n        final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\r\n        assertEquals(testData.length, c.read(readBuffer));\r\n        assertArrayEquals(testData, Arrays.copyOf(readBuffer.array(), testData.length));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "testTruncateToCurrentSizeDoesntChangeAnything",
  "sourceCode" : "/*\r\n     * <q>If the given size is greater than or equal to the current size then the entity is not modified.</q>\r\n     */\r\n@Test\r\nvoid testTruncateToCurrentSizeDoesntChangeAnything() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel(testData)) {\r\n        assertEquals(testData.length, c.size());\r\n        c.truncate(testData.length);\r\n        assertEquals(testData.length, c.size());\r\n        final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\r\n        assertEquals(testData.length, c.read(readBuffer));\r\n        assertArrayEquals(testData, Arrays.copyOf(readBuffer.array(), testData.length));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel",
  "sourceCode" : "/*\r\n     * <q>ClosedChannelException - If this channel is closed</q>\r\n     */\r\n@Test\r\npublic void throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        c.close();\r\n        assertThrows(ClosedChannelException.class, c::position);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "throwsClosedChannelExceptionWhenSizeIsReadOnClosedChannel",
  "sourceCode" : "/*\r\n     * <q>ClosedChannelException - If this channel is closed</q>\r\n     */\r\n@Test\r\npublic void throwsClosedChannelExceptionWhenSizeIsReadOnClosedChannel() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        c.close();\r\n        assertThrows(ClosedChannelException.class, c::size);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SeekableInMemoryByteChannelTest.java",
  "methodName" : "throwsClosedChannelExceptionWhenTruncateIsCalledOnClosedChannel",
  "sourceCode" : "/*\r\n     * <q>ClosedChannelException - If this channel is closed</q>\r\n     */\r\n@Test\r\npublic void throwsClosedChannelExceptionWhenTruncateIsCalledOnClosedChannel() throws Exception {\r\n    try (SeekableByteChannel c = new SeekableInMemoryByteChannel()) {\r\n        c.close();\r\n        assertThrows(ClosedChannelException.class, () -> c.truncate(0));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ServiceLoaderIteratorTest.java",
  "methodName" : "testHasNextReturnsFalse",
  "sourceCode" : "@Test\r\nvoid testHasNextReturnsFalse() {\r\n    final Class<Object> clasz = Object.class;\r\n    final ServiceLoaderIterator<Object> serviceLoaderIterator = new ServiceLoaderIterator<>(clasz);\r\n    final boolean result = serviceLoaderIterator.hasNext();\r\n    assertFalse(result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ServiceLoaderIteratorTest.java",
  "methodName" : "testNextThrowsNoSuchElementException",
  "sourceCode" : "@Test\r\nvoid testNextThrowsNoSuchElementException() {\r\n    final Class<String> clasz = String.class;\r\n    final ServiceLoaderIterator<String> serviceLoaderIterator = new ServiceLoaderIterator<>(clasz);\r\n    assertThrows(NoSuchElementException.class, () -> serviceLoaderIterator.next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ServiceLoaderIteratorTest.java",
  "methodName" : "testRemoveThrowsUnsupportedOperationException",
  "sourceCode" : "@Test\r\nvoid testRemoveThrowsUnsupportedOperationException() {\r\n    final Class<Integer> clasz = Integer.class;\r\n    final ServiceLoaderIterator<Integer> serviceLoaderIterator = new ServiceLoaderIterator<>(clasz);\r\n    assertThrows(UnsupportedOperationException.class, () -> serviceLoaderIterator.remove());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SetsTest.java",
  "methodName" : "testNewHashSet",
  "sourceCode" : "@Test\r\nvoid testNewHashSet() {\r\n    final HashSet<String> expected = new HashSet<>();\r\n    assertEquals(expected, Sets.newHashSet());\r\n    assertEquals(expected, Sets.newHashSet((String[]) null));\r\n    expected.add(\"1\");\r\n    assertEquals(expected, Sets.newHashSet(\"1\"));\r\n    expected.add(\"2\");\r\n    assertEquals(expected, Sets.newHashSet(\"2\", \"1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SkipShieldingInputStreamTest.java",
  "methodName" : "testSkipDelegatesToRead",
  "sourceCode" : "@Test\r\nvoid testSkipDelegatesToRead() throws IOException {\r\n    try (InputStream i = new SkipShieldingInputStream(new InputStream() {\r\n\r\n        @Override\r\n        public int read() {\r\n            return -1;\r\n        }\r\n\r\n        @Override\r\n        public int read(byte[] b, int off, int len) {\r\n            return len;\r\n        }\r\n\r\n        @Override\r\n        public long skip(long n) {\r\n            fail(\"skip invoked\");\r\n            return -1;\r\n        }\r\n    })) {\r\n        assertEquals(100, i.skip(100));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SkipShieldingInputStreamTest.java",
  "methodName" : "testSkipHasAnUpperBoundOnRead",
  "sourceCode" : "@Test\r\nvoid testSkipHasAnUpperBoundOnRead() throws IOException {\r\n    try (InputStream i = new SkipShieldingInputStream(new InputStream() {\r\n\r\n        @Override\r\n        public int read() {\r\n            return -1;\r\n        }\r\n\r\n        @Override\r\n        public int read(byte[] b, int off, int len) {\r\n            return len;\r\n        }\r\n\r\n        @Override\r\n        public long skip(long n) {\r\n            fail(\"skip invoked\");\r\n            return -1;\r\n        }\r\n    })) {\r\n        assertTrue(Integer.MAX_VALUE > i.skip(Long.MAX_VALUE));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\SkipShieldingInputStreamTest.java",
  "methodName" : "testSkipSwallowsNegativeArguments",
  "sourceCode" : "@Test\r\nvoid testSkipSwallowsNegativeArguments() throws IOException {\r\n    try (InputStream i = new SkipShieldingInputStream(new InputStream() {\r\n\r\n        @Override\r\n        public int read() {\r\n            return -1;\r\n        }\r\n\r\n        @Override\r\n        public int read(byte[] b, int off, int len) {\r\n            fail(\"read invoked\");\r\n            return len;\r\n        }\r\n\r\n        @Override\r\n        public long skip(long n) {\r\n            fail(\"skip invoked\");\r\n            return -1;\r\n        }\r\n    })) {\r\n        assertEquals(0, i.skip(Long.MIN_VALUE));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testIsUnixTime",
  "sourceCode" : "@Test\r\nvoid testIsUnixTime() {\r\n    assertTrue(TimeUtils.isUnixTime(null));\r\n    assertTrue(TimeUtils.isUnixTime(FileTime.from(Instant.parse(\"2022-12-27T12:45:22Z\"))));\r\n    assertTrue(TimeUtils.isUnixTime(FileTime.from(Instant.parse(\"2038-01-19T03:14:07Z\"))));\r\n    assertTrue(TimeUtils.isUnixTime(FileTime.from(Instant.parse(\"1901-12-13T23:14:08Z\"))));\r\n    assertFalse(TimeUtils.isUnixTime(FileTime.from(Instant.parse(\"1901-12-13T03:14:08Z\"))));\r\n    assertFalse(TimeUtils.isUnixTime(FileTime.from(Instant.parse(\"2038-01-19T03:14:08Z\"))));\r\n    assertFalse(TimeUtils.isUnixTime(FileTime.from(Instant.parse(\"2099-06-30T12:31:42Z\"))));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testJavaTimeToNtfsTime",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"dateToNtfsProvider\")\r\nvoid testJavaTimeToNtfsTime(final String instant, final long ntfsTime) {\r\n    final long ntfsMillis = Math.floorDiv(ntfsTime, HUNDRED_NANOS_PER_MILLISECOND) * HUNDRED_NANOS_PER_MILLISECOND;\r\n    final Date parsed = Date.from(Instant.parse(instant));\r\n    final long converted = toNtfsTime(parsed);\r\n    assertEquals(ntfsMillis, converted);\r\n    // ensuring the deprecated method still works\r\n    assertEquals(converted, SevenZArchiveEntry.javaTimeToNtfsTime(parsed));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testNtfsTimeToFileTime",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"fileTimeToNtfsProvider\")\r\nvoid testNtfsTimeToFileTime(final String instant, final long ntfsTime) {\r\n    final FileTime parsed = FileTime.from(Instant.parse(instant));\r\n    assertEquals(parsed, ntfsTimeToFileTime(ntfsTime));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testNtfsTimeToJavaTime",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"dateToNtfsProvider\")\r\nvoid testNtfsTimeToJavaTime(final String instant, final long ntfsTime) {\r\n    final Date converted = ntfsTimeToDate(ntfsTime);\r\n    assertEquals(Instant.parse(instant), converted.toInstant());\r\n    // ensuring the deprecated method still works\r\n    assertEquals(converted, SevenZArchiveEntry.ntfsTimeToJavaTime(ntfsTime));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testToDate",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"fileTimeToNtfsProvider\")\r\nvoid testToDate(final String instant, final long ignored) {\r\n    final Instant parsedInstant = Instant.parse(instant);\r\n    final FileTime parsedFileTime = FileTime.from(parsedInstant);\r\n    final Date parsedDate = Date.from(parsedInstant);\r\n    assertEquals(parsedDate, toDate(parsedFileTime));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testToDateNull",
  "sourceCode" : "@Test\r\nvoid testToDateNull() {\r\n    assertNull(toDate(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testToFileTime",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"dateToNtfsProvider\")\r\nvoid testToFileTime(final String instant, final long ignored) {\r\n    final Instant parsedInstant = Instant.parse(instant);\r\n    final FileTime parsedFileTime = FileTime.from(parsedInstant);\r\n    final Date parsedDate = Date.from(parsedInstant);\r\n    assertEquals(parsedFileTime, toFileTime(parsedDate));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testToFileTimeNull",
  "sourceCode" : "@Test\r\nvoid testToFileTimeNull() {\r\n    assertNull(toFileTime(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testToNtfsTime",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"fileTimeToNtfsProvider\")\r\nvoid testToNtfsTime(final String instant, final long ntfsTime) {\r\n    final FileTime parsed = FileTime.from(Instant.parse(instant));\r\n    assertEquals(ntfsTime, toNtfsTime(parsed));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testToUnixTime",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"fileTimeToUnixTimeArguments\")\r\nvoid testToUnixTime(final long expectedUnixTime, final String instant) {\r\n    assertEquals(expectedUnixTime, FileTimes.toUnixTime(FileTime.from(Instant.parse(instant))));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testTruncateToHundredNanos",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"truncateFileTimeProvider\")\r\nvoid testTruncateToHundredNanos(final String original, final String truncated) {\r\n    final FileTime originalTime = FileTime.from(Instant.parse(original));\r\n    final FileTime truncatedTime = FileTime.from(Instant.parse(truncated));\r\n    assertEquals(truncatedTime, TimeUtils.truncateToHundredNanos(originalTime));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\TimeUtilsTest.java",
  "methodName" : "testUnixTimeToFileTime",
  "sourceCode" : "@ParameterizedTest\r\n@MethodSource(\"fileTimeToUnixTimeArguments\")\r\nvoid testUnixTimeToFileTime(final long unixTime, final String expectedInstant) {\r\n    assertEquals(Instant.parse(expectedInstant), TimeUtils.unixTimeToFileTime(unixTime).toInstant());\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testBuildFromLastSplitSegmentThrowsOnNotZipFile",
  "sourceCode" : "@Test\r\nvoid testBuildFromLastSplitSegmentThrowsOnNotZipFile() throws IOException {\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\r\n    assertThrows(IllegalArgumentException.class, () -> ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testChannelsPositionIsZeroAfterConstructor",
  "sourceCode" : "@Test\r\nvoid testChannelsPositionIsZeroAfterConstructor() throws IOException {\r\n    final List<SeekableByteChannel> channels = getSplitZipChannels();\r\n    try (ZipSplitReadOnlySeekableByteChannel c = new ZipSplitReadOnlySeekableByteChannel(channels)) {\r\n        for (final SeekableByteChannel channel : channels) {\r\n            assertEquals(0, channel.position());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testConstructorThrowsOnNonSplitZipFiles",
  "sourceCode" : "@Test\r\nvoid testConstructorThrowsOnNonSplitZipFiles() throws IOException {\r\n    final List<SeekableByteChannel> channels = new ArrayList<>();\r\n    final File file = getFile(\"COMPRESS-189.zip\");\r\n    try (SeekableByteChannel byteChannel = Files.newByteChannel(file.toPath(), StandardOpenOption.READ)) {\r\n        channels.add(byteChannel);\r\n        assertThrows(IOException.class, () -> new ZipSplitReadOnlySeekableByteChannel(channels));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testConstructorThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testConstructorThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> new ZipSplitReadOnlySeekableByteChannel(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForFilesOfTwoParametersThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testForFilesOfTwoParametersThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forFiles(null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForFilesReturnCorrectClass",
  "sourceCode" : "@Test\r\nvoid testForFilesReturnCorrectClass() throws IOException {\r\n    final File firstFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\r\n    final File secondFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\r\n    final ArrayList<File> list = new ArrayList<>();\r\n    list.add(firstFile);\r\n    list.add(secondFile);\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forFiles(lastFile, list)) {\r\n        assertInstanceOf(ZipSplitReadOnlySeekableByteChannel.class, channel);\r\n    }\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forFiles(firstFile, secondFile, lastFile)) {\r\n        assertInstanceOf(ZipSplitReadOnlySeekableByteChannel.class, channel);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForFilesThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testForFilesThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forFiles((File[]) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForOrderedSeekableByteChannelsOfTwoParametersThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testForOrderedSeekableByteChannelsOfTwoParametersThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForOrderedSeekableByteChannelsReturnCorrectClass",
  "sourceCode" : "@Test\r\nvoid testForOrderedSeekableByteChannelsReturnCorrectClass() throws IOException {\r\n    final File file1 = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\r\n    final File file2 = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\r\n    try (SeekableByteChannel firstChannel = Files.newByteChannel(file1.toPath(), StandardOpenOption.READ);\r\n        SeekableByteChannel secondChannel = Files.newByteChannel(file2.toPath(), StandardOpenOption.READ);\r\n        SeekableByteChannel lastChannel = Files.newByteChannel(lastFile.toPath(), StandardOpenOption.READ)) {\r\n        final List<SeekableByteChannel> channels = new ArrayList<>();\r\n        channels.add(firstChannel);\r\n        channels.add(secondChannel);\r\n        // try-with-resources closes\r\n        @SuppressWarnings(\"resource\")\r\n        final SeekableByteChannel channel1 = ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(lastChannel, channels);\r\n        assertInstanceOf(ZipSplitReadOnlySeekableByteChannel.class, channel1);\r\n        // try-with-resources closes\r\n        @SuppressWarnings(\"resource\")\r\n        final SeekableByteChannel channel2 = ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(firstChannel, secondChannel, lastChannel);\r\n        assertInstanceOf(ZipSplitReadOnlySeekableByteChannel.class, channel2);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForOrderedSeekableByteChannelsReturnsIdentityForSingleElement",
  "sourceCode" : "@Test\r\nvoid testForOrderedSeekableByteChannelsReturnsIdentityForSingleElement() throws IOException {\r\n    try (SeekableByteChannel emptyChannel = new SeekableInMemoryByteChannel(ArrayUtils.EMPTY_BYTE_ARRAY);\r\n        SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(emptyChannel)) {\r\n        assertSame(emptyChannel, channel);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForOrderedSeekableByteChannelsThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testForOrderedSeekableByteChannelsThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels((SeekableByteChannel[]) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForPathsOfTwoParametersThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testForPathsOfTwoParametersThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forPaths((Path) null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForPathsReturnCorrectClass",
  "sourceCode" : "@Test\r\nvoid testForPathsReturnCorrectClass() throws IOException {\r\n    final Path firstFile = getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\r\n    final Path secondFile = getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\r\n    final Path lastFile = getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\r\n    final ArrayList<Path> list = new ArrayList<>();\r\n    list.add(firstFile);\r\n    list.add(secondFile);\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forPaths(lastFile, list)) {\r\n        assertInstanceOf(ZipSplitReadOnlySeekableByteChannel.class, channel);\r\n    }\r\n    try (SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forPaths(firstFile, secondFile, lastFile)) {\r\n        assertInstanceOf(ZipSplitReadOnlySeekableByteChannel.class, channel);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testForPathsThrowsOnNullArg",
  "sourceCode" : "@Test\r\nvoid testForPathsThrowsOnNullArg() {\r\n    assertThrows(NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forPaths((Path[]) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-compress\\src\\test\\java\\org\\apache\\commons\\compress\\utils\\ZipSplitReadOnlySeekableByteChannelTest.java",
  "methodName" : "testPositionToSomeZipSplitSegment",
  "sourceCode" : "@Test\r\nvoid testPositionToSomeZipSplitSegment() throws IOException {\r\n    final File firstFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\r\n    final int firstFileSize = (int) firstFile.length();\r\n    final File secondFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\r\n    final int secondFileSize = (int) secondFile.length();\r\n    final File lastFile = getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\r\n    final int lastFileSize = (int) lastFile.length();\r\n    final Random random = new Random();\r\n    final int randomDiskNumber = random.nextInt(3);\r\n    final int randomOffset = randomDiskNumber < 2 ? random.nextInt(firstFileSize) : random.nextInt(lastFileSize);\r\n    try (ZipSplitReadOnlySeekableByteChannel channel = (ZipSplitReadOnlySeekableByteChannel) ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile)) {\r\n        channel.position(randomDiskNumber, randomOffset);\r\n        long expectedPosition = randomOffset;\r\n        expectedPosition += randomDiskNumber > 0 ? firstFileSize : 0;\r\n        expectedPosition += randomDiskNumber > 1 ? secondFileSize : 0;\r\n        assertEquals(expectedPosition, channel.position());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
} ]