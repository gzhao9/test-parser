[ {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testBoolean",
  "sourceCode" : "@Test\r\nvoid testBoolean() throws Exception {\r\n    nonStringTestHolder.testBoolean();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testBooleanArrayValue",
  "sourceCode" : "@Test\r\nvoid testBooleanArrayValue() throws Exception {\r\n    final boolean booleanValue = conf.getBoolean(\"test.boolean\");\r\n    assertTrue(booleanValue);\r\n    assertEquals(2, conf.getList(\"test.boolean.array\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testBooleanDefaultValue",
  "sourceCode" : "@Test\r\nvoid testBooleanDefaultValue() throws Exception {\r\n    nonStringTestHolder.testBooleanDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testByte",
  "sourceCode" : "@Test\r\nvoid testByte() throws Exception {\r\n    nonStringTestHolder.testByte();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testByteArrayValue",
  "sourceCode" : "@Test\r\nvoid testByteArrayValue() throws Exception {\r\n    final byte testValue = 10;\r\n    final byte byteValue = conf.getByte(\"test.byte\");\r\n    assertEquals(testValue, byteValue);\r\n    assertEquals(2, conf.getList(\"test.byte.array\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testDouble",
  "sourceCode" : "@Test\r\nvoid testDouble() throws Exception {\r\n    nonStringTestHolder.testDouble();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testDoubleArrayValue",
  "sourceCode" : "@Test\r\nvoid testDoubleArrayValue() throws Exception {\r\n    final double testValue = 10.25;\r\n    final double doubleValue = conf.getDouble(\"test.double\");\r\n    assertEquals(testValue, doubleValue, 0.01);\r\n    assertEquals(2, conf.getList(\"test.double.array\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testDoubleDefaultValue",
  "sourceCode" : "@Test\r\nvoid testDoubleDefaultValue() throws Exception {\r\n    nonStringTestHolder.testDoubleDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testFloat",
  "sourceCode" : "@Test\r\nvoid testFloat() throws Exception {\r\n    nonStringTestHolder.testFloat();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testFloatArrayValue",
  "sourceCode" : "@Test\r\nvoid testFloatArrayValue() throws Exception {\r\n    final float testValue = (float) 20.25;\r\n    final float floatValue = conf.getFloat(\"test.float\");\r\n    assertEquals(testValue, floatValue, 0.01);\r\n    assertEquals(2, conf.getList(\"test.float.array\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testFloatDefaultValue",
  "sourceCode" : "@Test\r\nvoid testFloatDefaultValue() throws Exception {\r\n    nonStringTestHolder.testFloatDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testInteger",
  "sourceCode" : "@Test\r\nvoid testInteger() throws Exception {\r\n    nonStringTestHolder.testInteger();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testIntegerArrayValue",
  "sourceCode" : "@Test\r\nvoid testIntegerArrayValue() throws Exception {\r\n    final int intValue = conf.getInt(\"test.integer\");\r\n    assertEquals(10, intValue);\r\n    assertEquals(2, conf.getList(\"test.integer.array\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testIntegerDefaultValue",
  "sourceCode" : "@Test\r\nvoid testIntegerDefaultValue() throws Exception {\r\n    nonStringTestHolder.testIntegerDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testIsEmpty",
  "sourceCode" : "@Test\r\nvoid testIsEmpty() throws Exception {\r\n    nonStringTestHolder.testIsEmpty();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testListMissing",
  "sourceCode" : "@Test\r\nvoid testListMissing() throws Exception {\r\n    nonStringTestHolder.testListMissing();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testLong",
  "sourceCode" : "@Test\r\nvoid testLong() throws Exception {\r\n    nonStringTestHolder.testLong();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testLongArrayValue",
  "sourceCode" : "@Test\r\nvoid testLongArrayValue() throws Exception {\r\n    final long longValue = conf.getLong(\"test.long\");\r\n    assertEquals(1000000, longValue);\r\n    assertEquals(2, conf.getList(\"test.long.array\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testLongDefaultValue",
  "sourceCode" : "@Test\r\nvoid testLongDefaultValue() throws Exception {\r\n    nonStringTestHolder.testLongDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testShort",
  "sourceCode" : "@Test\r\nvoid testShort() throws Exception {\r\n    nonStringTestHolder.testShort();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testShortArrayValue",
  "sourceCode" : "@Test\r\nvoid testShortArrayValue() throws Exception {\r\n    final short shortValue = conf.getShort(\"test.short\");\r\n    assertEquals(1, shortValue);\r\n    assertEquals(2, conf.getList(\"test.short.array\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testShortDefaultValue",
  "sourceCode" : "@Test\r\nvoid testShortDefaultValue() throws Exception {\r\n    nonStringTestHolder.testShortDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\BaseNonStringProperties.java",
  "methodName" : "testSubset",
  "sourceCode" : "@Test\r\nvoid testSubset() throws Exception {\r\n    nonStringTestHolder.testSubset();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCopyProperties",
  "sourceCode" : "/**\r\n * Tests whether properties from one bean to another can be copied.\r\n */\r\n@Test\r\nvoid testCopyProperties() throws Exception {\r\n    final PropertiesConfiguration src = new PropertiesConfiguration();\r\n    src.setHeader(\"TestHeader\");\r\n    src.setFooter(\"TestFooter\");\r\n    final LazyDynaBean dest = new LazyDynaBean();\r\n    BeanHelper.copyProperties(dest, src);\r\n    assertEquals(\"TestFooter\", dest.get(\"footer\"));\r\n    assertEquals(\"TestHeader\", dest.get(\"header\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBean",
  "sourceCode" : "/**\r\n * Tests creating a bean. All necessary information is stored in the bean declaration.\r\n */\r\n@Test\r\nvoid testCreateBean() {\r\n    final TestBeanFactory factory = new TestBeanFactory();\r\n    helper.registerBeanFactory(TEST_FACTORY, factory);\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    data.setBeanClassName(BeanCreationTestBean.class.getName());\r\n    checkBean((BeanCreationTestBean) helper.createBean(data, null));\r\n    assertNull(factory.parameter);\r\n    assertEquals(1, factory.getCreateBeanCount());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithDefaultClass",
  "sourceCode" : "/**\r\n * Tests creating a bean. The bean's class is specified as the default class argument.\r\n */\r\n@Test\r\nvoid testCreateBeanWithDefaultClass() {\r\n    helper.registerBeanFactory(TEST_FACTORY, new TestBeanFactory());\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    checkBean((BeanCreationTestBean) helper.createBean(data, BeanCreationTestBean.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithDefaultFactory",
  "sourceCode" : "/**\r\n * Tests creating a bean using the default bean factory.\r\n */\r\n@Test\r\nvoid testCreateBeanWithDefaultFactory() {\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanClassName(BeanCreationTestBean.class.getName());\r\n    checkBean((BeanCreationTestBean) helper.createBean(data, null));\r\n    final TestBeanFactory factory = (TestBeanFactory) helper.getDefaultBeanFactory();\r\n    assertTrue(factory.getCreateBeanCount() > 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithException",
  "sourceCode" : "/**\r\n * Tests creating a bean when the factory throws an exception.\r\n */\r\n@Test\r\nvoid testCreateBeanWithException() {\r\n    helper.registerBeanFactory(TEST_FACTORY, new TestBeanFactory());\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    data.setBeanClassName(getClass().getName());\r\n    assertThrows(ConfigurationRuntimeException.class, () -> helper.createBean(data, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithFactoryDefaultClass",
  "sourceCode" : "/**\r\n * Tests creating a bean when the bean's class is specified as the default class of the bean factory.\r\n */\r\n@Test\r\nvoid testCreateBeanWithFactoryDefaultClass() {\r\n    final TestBeanFactory factory = new TestBeanFactory();\r\n    factory.supportsDefaultClass = true;\r\n    helper.registerBeanFactory(TEST_FACTORY, factory);\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    checkBean((BeanCreationTestBean) helper.createBean(data, null));\r\n    assertEquals(1, factory.getCreateBeanCount());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithInvalidClass",
  "sourceCode" : "/**\r\n * Tries to create a bean with a non existing class. This should cause an exception.\r\n */\r\n@Test\r\nvoid testCreateBeanWithInvalidClass() {\r\n    helper.registerBeanFactory(TEST_FACTORY, new TestBeanFactory());\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    data.setBeanClassName(\"non.existing.ClassName\");\r\n    assertThrows(ConfigurationRuntimeException.class, () -> helper.createBean(data, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithListChildBean",
  "sourceCode" : "/**\r\n * Tests whether a bean with a property of type collection can be created.\r\n */\r\n@Test\r\nvoid testCreateBeanWithListChildBean() {\r\n    final TestBeanFactory factory = new TestBeanFactory();\r\n    helper.registerBeanFactory(TEST_FACTORY, factory);\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclarationWithListChild();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    data.setBeanClassName(BeanCreationTestBeanWithListChild.class.getName());\r\n    checkBean((BeanCreationTestBeanWithListChild) helper.createBean(data, null));\r\n    assertNull(factory.parameter);\r\n    assertEquals(1, factory.getCreateBeanCount());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithNoClass",
  "sourceCode" : "/**\r\n * Tries to create a bean if no class is provided. This should cause an exception.\r\n */\r\n@Test\r\nvoid testCreateBeanWithNoClass() {\r\n    helper.registerBeanFactory(TEST_FACTORY, new TestBeanFactory());\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    assertThrows(ConfigurationRuntimeException.class, () -> helper.createBean(data, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithNullDeclaration",
  "sourceCode" : "/**\r\n * Tests creating a bean when no bean declaration is provided. This should cause an exception.\r\n */\r\n@Test\r\nvoid testCreateBeanWithNullDeclaration() {\r\n    assertThrows(IllegalArgumentException.class, () -> helper.createBean(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithParameter",
  "sourceCode" : "/**\r\n * Tests if a parameter is correctly passed to the bean factory.\r\n */\r\n@Test\r\nvoid testCreateBeanWithParameter() {\r\n    final Object param = 42;\r\n    final TestBeanFactory factory = new TestBeanFactory();\r\n    helper.registerBeanFactory(TEST_FACTORY, factory);\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    data.setBeanClassName(BeanCreationTestBean.class.getName());\r\n    checkBean((BeanCreationTestBean) helper.createBean(data, null, param));\r\n    assertSame(param, factory.parameter);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateBeanWithUnknownFactory",
  "sourceCode" : "/**\r\n * Tests creating a bean using a non registered factory.\r\n */\r\n@Test\r\nvoid testCreateBeanWithUnknownFactory() {\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.setBeanFactoryName(TEST_FACTORY);\r\n    data.setBeanClassName(BeanCreationTestBean.class.getName());\r\n    assertThrows(ConfigurationRuntimeException.class, () -> helper.createBean(data, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateWrapDynaBean",
  "sourceCode" : "/**\r\n * Tests whether a wrapper DynaBean for a Java bean can be created.\r\n */\r\n@Test\r\nvoid testCreateWrapDynaBean() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final DynaBean bean = BeanHelper.createWrapDynaBean(config);\r\n    final String value = \"TestFooter\";\r\n    bean.set(\"footer\", value);\r\n    assertEquals(value, config.getFooter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testCreateWrapDynaBeanNull",
  "sourceCode" : "/**\r\n * Tries to create a wrapper DynaBean for a null bean.\r\n */\r\n@Test\r\nvoid testCreateWrapDynaBeanNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> BeanHelper.createWrapDynaBean(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testDefaultBeanFactory",
  "sourceCode" : "/**\r\n * Tests whether the correct default bean factory is set.\r\n */\r\n@Test\r\nvoid testDefaultBeanFactory() {\r\n    helper = new BeanHelper();\r\n    assertSame(DefaultBeanFactory.INSTANCE, helper.getDefaultBeanFactory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testDefaultInstance",
  "sourceCode" : "/**\r\n * Tests the default instance of BeanHelper.\r\n */\r\n@Test\r\nvoid testDefaultInstance() {\r\n    assertSame(DefaultBeanFactory.INSTANCE, BeanHelper.INSTANCE.getDefaultBeanFactory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testDeregisterBeanFactory",
  "sourceCode" : "/**\r\n * Tests to deregister a bean factory.\r\n */\r\n@Test\r\nvoid testDeregisterBeanFactory() {\r\n    final BeanFactory factory = new TestBeanFactory();\r\n    helper.registerBeanFactory(TEST_FACTORY, factory);\r\n    assertSame(factory, helper.deregisterBeanFactory(TEST_FACTORY));\r\n    assertEquals(Collections.emptySet(), helper.registeredFactoryNames());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testDeregisterBeanFactoryNonExisting",
  "sourceCode" : "/**\r\n * Tests deregisterBeanFactory() for a non-existing factory name.\r\n */\r\n@Test\r\nvoid testDeregisterBeanFactoryNonExisting() {\r\n    assertNull(helper.deregisterBeanFactory(TEST_FACTORY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testDeregisterBeanFactoryNull",
  "sourceCode" : "/**\r\n * Tests deregisterBeanFactory() for a null factory name.\r\n */\r\n@Test\r\nvoid testDeregisterBeanFactoryNull() {\r\n    assertNull(helper.deregisterBeanFactory(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testInitBean",
  "sourceCode" : "/**\r\n * Tests initializing a bean.\r\n */\r\n@Test\r\nvoid testInitBean() {\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    final BeanCreationTestBean bean = new BeanCreationTestBean();\r\n    helper.initBean(bean, data);\r\n    checkBean(bean);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testInitBeanWithInvalidProperty",
  "sourceCode" : "/**\r\n * Tries to initialize a bean with a bean declaration that contains an invalid property value. This should cause an\r\n * exception.\r\n */\r\n@Test\r\nvoid testInitBeanWithInvalidProperty() {\r\n    final BeanDeclarationTestImpl data = setUpBeanDeclaration();\r\n    data.getBeanProperties().put(\"nonExistingProperty\", Boolean.TRUE);\r\n    final BeanCreationTestBean bean = new BeanCreationTestBean();\r\n    assertThrows(ConfigurationRuntimeException.class, () -> helper.initBean(bean, data));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testInitBeanWithNoData",
  "sourceCode" : "/**\r\n * Tests initializing a bean when the bean declaration does not contain any data.\r\n */\r\n@Test\r\nvoid testInitBeanWithNoData() {\r\n    final BeanDeclarationTestImpl data = new BeanDeclarationTestImpl();\r\n    final BeanCreationTestBean bean = new BeanCreationTestBean();\r\n    helper.initBean(bean, data);\r\n    assertNull(bean.getStringValue());\r\n    assertEquals(0, bean.getIntValue());\r\n    assertNull(bean.getBuddy());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testInitWithBeanFactory",
  "sourceCode" : "/**\r\n * Tests whether a specific default bean factory can be set when constructing an instance.\r\n */\r\n@Test\r\nvoid testInitWithBeanFactory() {\r\n    final BeanFactory factory = mock(BeanFactory.class);\r\n    helper = new BeanHelper(factory);\r\n    assertSame(factory, helper.getDefaultBeanFactory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testRegisterBeanFactory",
  "sourceCode" : "/**\r\n * Tests registering a new bean factory.\r\n */\r\n@Test\r\nvoid testRegisterBeanFactory() {\r\n    helper.registerBeanFactory(TEST_FACTORY, new TestBeanFactory());\r\n    assertEquals(Collections.singleton(TEST_FACTORY), helper.registeredFactoryNames());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testRegisterBeanFactoryNull",
  "sourceCode" : "/**\r\n * Tries to register a null factory. This should cause an exception.\r\n */\r\n@Test\r\nvoid testRegisterBeanFactoryNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> helper.registerBeanFactory(TEST_FACTORY, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testRegisterBeanFactoryNullName",
  "sourceCode" : "/**\r\n * Tries to register a bean factory with a null name. This should cause an exception.\r\n */\r\n@Test\r\nvoid testRegisterBeanFactoryNullName() {\r\n    final BeanFactory beanFactory = new TestBeanFactory();\r\n    assertThrows(IllegalArgumentException.class, () -> helper.registerBeanFactory(null, beanFactory));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestBeanHelper.java",
  "methodName" : "testRegisteredFactoriesEmptyForNewInstance",
  "sourceCode" : "/**\r\n * Tests that a newly created instance does not have any bean factories registered.\r\n */\r\n@Test\r\nvoid testRegisteredFactoriesEmptyForNewInstance() {\r\n    assertEquals(Collections.emptySet(), helper.registeredFactoryNames());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetBeanClassNameDefined",
  "sourceCode" : "/**\r\n * Tests whether the bean class name can be obtained if it is set for one of the child declarations.\r\n */\r\n@Test\r\nvoid testGetBeanClassNameDefined() {\r\n    final CombinedBeanDeclaration cd = createCombinedDeclaration();\r\n    when(decl(0).getBeanClassName()).thenReturn(null);\r\n    when(decl(1).getBeanClassName()).thenReturn(getClass().getName());\r\n    assertEquals(getClass().getName(), cd.getBeanClassName());\r\n    verify(decl(0)).getBeanClassName();\r\n    verify(decl(1)).getBeanClassName();\r\n    verifyNoMoreDeclarationInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetBeanClassNameUndefined",
  "sourceCode" : "/**\r\n * Tests getBeanClassName() if none of the child declarations provide a value.\r\n */\r\n@Test\r\nvoid testGetBeanClassNameUndefined() {\r\n    final CombinedBeanDeclaration cd = new CombinedBeanDeclaration();\r\n    assertNull(cd.getBeanClassName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryNameDefined",
  "sourceCode" : "/**\r\n * Tests whether the bean factory can be obtained if it is set for one child declarations.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryNameDefined() {\r\n    final CombinedBeanDeclaration cd = createCombinedDeclaration();\r\n    final String name = \"someTestBeanFactory\";\r\n    when(decl(0).getBeanFactoryName()).thenReturn(null);\r\n    when(decl(1).getBeanFactoryName()).thenReturn(name);\r\n    assertEquals(name, cd.getBeanFactoryName());\r\n    verify(decl(0)).getBeanFactoryName();\r\n    verify(decl(1)).getBeanFactoryName();\r\n    verifyNoMoreDeclarationInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryNameUndefined",
  "sourceCode" : "/**\r\n * Tests getBeanFactoryName() if none of the child declarations provide a value.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryNameUndefined() {\r\n    final CombinedBeanDeclaration cd = new CombinedBeanDeclaration();\r\n    assertNull(cd.getBeanFactoryName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryParameterDefined",
  "sourceCode" : "/**\r\n * Tests whether the bean factory parameter can be obtained if it is set for one of the child declarations.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryParameterDefined() {\r\n    final CombinedBeanDeclaration cd = createCombinedDeclaration();\r\n    final Object param = new Object();\r\n    when(decl(0).getBeanFactoryParameter()).thenReturn(null);\r\n    when(decl(1).getBeanFactoryParameter()).thenReturn(param);\r\n    assertSame(param, cd.getBeanFactoryParameter());\r\n    verify(decl(0)).getBeanFactoryParameter();\r\n    verify(decl(1)).getBeanFactoryParameter();\r\n    verifyNoMoreDeclarationInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryParameterUndefined",
  "sourceCode" : "/**\r\n * Tests getBeanFactoryParameter() if none of the child declarations provide a value.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryParameterUndefined() {\r\n    final CombinedBeanDeclaration cd = new CombinedBeanDeclaration();\r\n    assertNull(cd.getBeanFactoryParameter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetBeanProperties",
  "sourceCode" : "/**\r\n * Tests whether a combined map of bean properties can be obtained.\r\n */\r\n@Test\r\nvoid testGetBeanProperties() {\r\n    final Map<String, Object> props1 = new HashMap<>();\r\n    final Map<String, Object> props2 = new HashMap<>();\r\n    final Map<String, Object> props3 = new HashMap<>();\r\n    props1.put(\"param1\", \"value1\");\r\n    props1.put(\"param2\", \"value2\");\r\n    props2.put(\"param2\", \"othervalue\");\r\n    props2.put(\"param3\", \"value3\");\r\n    props3.put(\"param1\", \"differentvalue\");\r\n    props3.put(\"param4\", \"value4\");\r\n    final CombinedBeanDeclaration cd = createCombinedDeclaration();\r\n    when(decl(0).getBeanProperties()).thenReturn(props1);\r\n    when(decl(1).getBeanProperties()).thenReturn(props2);\r\n    when(decl(2).getBeanProperties()).thenReturn(props3);\r\n    final Map<String, Object> props = cd.getBeanProperties();\r\n    final Map<String, String> expected = new HashMap<>();\r\n    expected.put(\"param1\", \"value1\");\r\n    expected.put(\"param2\", \"value2\");\r\n    expected.put(\"param3\", \"value3\");\r\n    expected.put(\"param4\", \"value4\");\r\n    assertEquals(expected, props);\r\n    verify(decl(0)).getBeanProperties();\r\n    verify(decl(1)).getBeanProperties();\r\n    verify(decl(2)).getBeanProperties();\r\n    verifyNoMoreDeclarationInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetBeanPropertiesNull",
  "sourceCode" : "/**\r\n * Tests whether null return values of bean property maps are handled correctly.\r\n */\r\n@Test\r\nvoid testGetBeanPropertiesNull() {\r\n    final BeanDeclaration child = mock(BeanDeclaration.class);\r\n    when(child.getBeanProperties()).thenReturn(null);\r\n    final CombinedBeanDeclaration cd = new CombinedBeanDeclaration(child);\r\n    assertEquals(Collections.emptyMap(), cd.getBeanProperties());\r\n    verify(child).getBeanProperties();\r\n    verifyNoMoreInteractions(child);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetConstructorArgsDefined",
  "sourceCode" : "/**\r\n * Tests whether constructor arguments can be obtained if one of the child declarations provide this data.\r\n */\r\n@Test\r\nvoid testGetConstructorArgsDefined() {\r\n    final CombinedBeanDeclaration cd = createCombinedDeclaration();\r\n    final Collection<ConstructorArg> args = Arrays.asList(ConstructorArg.forValue(42));\r\n    when(decl(0).getConstructorArgs()).thenReturn(null);\r\n    when(decl(1).getConstructorArgs()).thenReturn(args);\r\n    assertSame(args, cd.getConstructorArgs());\r\n    verify(decl(0)).getConstructorArgs();\r\n    verify(decl(1)).getConstructorArgs();\r\n    verifyNoMoreDeclarationInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetConstructorArgsUndefined",
  "sourceCode" : "/**\r\n * Tests getConstructorArgs() if none of the child declarations provide a value.\r\n */\r\n@Test\r\nvoid testGetConstructorArgsUndefined() {\r\n    final CombinedBeanDeclaration cd = createCombinedDeclaration();\r\n    when(decl(0).getConstructorArgs()).thenReturn(null);\r\n    when(decl(1).getConstructorArgs()).thenReturn(new ArrayList<>());\r\n    when(decl(2).getConstructorArgs()).thenReturn(null);\r\n    assertEquals(Collections.emptyList(), new ArrayList<>(cd.getConstructorArgs()));\r\n    verify(decl(0)).getConstructorArgs();\r\n    verify(decl(1)).getConstructorArgs();\r\n    verify(decl(2)).getConstructorArgs();\r\n    verifyNoMoreDeclarationInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetNestedBeanDeclarations",
  "sourceCode" : "/**\r\n * Tests whether a combined map of nested bean declarations can be obtained.\r\n */\r\n@Test\r\nvoid testGetNestedBeanDeclarations() {\r\n    final Map<String, Object> decls1 = new HashMap<>();\r\n    final Map<String, Object> decls2 = new HashMap<>();\r\n    final Map<String, Object> decls3 = new HashMap<>();\r\n    decls1.put(\"param1\", \"value1\");\r\n    decls1.put(\"param2\", \"value2\");\r\n    decls2.put(\"param2\", \"othervalue\");\r\n    decls2.put(\"param3\", \"value3\");\r\n    decls3.put(\"param1\", \"differentvalue\");\r\n    decls3.put(\"param4\", \"value4\");\r\n    final CombinedBeanDeclaration cd = createCombinedDeclaration();\r\n    when(decl(0).getNestedBeanDeclarations()).thenReturn(decls1);\r\n    when(decl(1).getNestedBeanDeclarations()).thenReturn(decls2);\r\n    when(decl(2).getNestedBeanDeclarations()).thenReturn(decls3);\r\n    final Map<String, Object> decls = cd.getNestedBeanDeclarations();\r\n    final Map<String, String> expected = new HashMap<>();\r\n    expected.put(\"param1\", \"value1\");\r\n    expected.put(\"param2\", \"value2\");\r\n    expected.put(\"param3\", \"value3\");\r\n    expected.put(\"param4\", \"value4\");\r\n    assertEquals(expected, decls);\r\n    verify(decl(0)).getNestedBeanDeclarations();\r\n    verify(decl(1)).getNestedBeanDeclarations();\r\n    verify(decl(2)).getNestedBeanDeclarations();\r\n    verifyNoMoreDeclarationInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestCombinedBeanDeclaration.java",
  "methodName" : "testGetNestedBeanDeclarationsNull",
  "sourceCode" : "/**\r\n * Tests whether null return values of bean declaration maps are handled correctly.\r\n */\r\n@Test\r\nvoid testGetNestedBeanDeclarationsNull() {\r\n    final BeanDeclaration child = mock(BeanDeclaration.class);\r\n    when(child.getNestedBeanDeclarations()).thenReturn(null);\r\n    final CombinedBeanDeclaration cd = new CombinedBeanDeclaration(child);\r\n    assertEquals(Collections.emptyMap(), cd.getNestedBeanDeclarations());\r\n    verify(child).getNestedBeanDeclarations();\r\n    verifyNoMoreInteractions(child);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testAddNullPropertyValue",
  "sourceCode" : "/**\r\n * Tests set on a null value: should throw NPE.\r\n */\r\n@Test\r\nvoid testAddNullPropertyValue() {\r\n    assertThrows(NullPointerException.class, () -> bean.set(\"nullProperty\", null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorArguments",
  "sourceCode" : "/**\r\n * Corner cases on getDynaProperty invalid arguments.\r\n */\r\n@Test\r\nvoid testGetDescriptorArguments() {\r\n    final DynaProperty descriptor = bean.getDynaClass().getDynaProperty(\"unknown\");\r\n    assertNull(descriptor);\r\n    assertThrows(IllegalArgumentException.class, () -> bean.getDynaClass().getDynaProperty(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorBoolean",
  "sourceCode" : "/**\r\n * Positive getDynaProperty on property {@code booleanProperty}.\r\n */\r\n@Test\r\nvoid testGetDescriptorBoolean() {\r\n    testGetDescriptorBase(\"booleanProperty\", Boolean.TYPE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorDouble",
  "sourceCode" : "/**\r\n * Positive getDynaProperty on property {@code doubleProperty}.\r\n */\r\n@Test\r\nvoid testGetDescriptorDouble() {\r\n    testGetDescriptorBase(\"doubleProperty\", Double.TYPE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorFloat",
  "sourceCode" : "/**\r\n * Positive getDynaProperty on property {@code floatProperty}.\r\n */\r\n@Test\r\nvoid testGetDescriptorFloat() {\r\n    testGetDescriptorBase(\"floatProperty\", Float.TYPE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorInt",
  "sourceCode" : "/**\r\n * Positive getDynaProperty on property {@code intProperty}.\r\n */\r\n@Test\r\nvoid testGetDescriptorInt() {\r\n    testGetDescriptorBase(\"intProperty\", Integer.TYPE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorLong",
  "sourceCode" : "/**\r\n * Positive getDynaProperty on property {@code longProperty}.\r\n */\r\n@Test\r\nvoid testGetDescriptorLong() {\r\n    testGetDescriptorBase(\"longProperty\", Long.TYPE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptors",
  "sourceCode" : "/**\r\n * Positive test for getDynaPropertys(). Each property name listed in {@code properties} should be returned exactly\r\n * once.\r\n */\r\n@Test\r\nvoid testGetDescriptors() {\r\n    final DynaProperty[] pd = bean.getDynaClass().getDynaProperties();\r\n    assertNotNull(pd);\r\n    final int[] count = new int[properties.length];\r\n    for (final DynaProperty element : pd) {\r\n        final String name = element.getName();\r\n        for (int j = 0; j < properties.length; j++) {\r\n            if (name.equals(properties[j])) {\r\n                count[j]++;\r\n            }\r\n        }\r\n    }\r\n    for (int j = 0; j < properties.length; j++) {\r\n        assertFalse(count[j] < 0, \"Missing property \" + properties[j]);\r\n        assertFalse(count[j] > 1, \"Duplicate property \" + properties[j]);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorSecond",
  "sourceCode" : "/**\r\n * Positive getDynaProperty on property {@code booleanSecond} that uses an \"is\" method as the getter.\r\n */\r\n@Test\r\nvoid testGetDescriptorSecond() {\r\n    testGetDescriptorBase(\"booleanSecond\", Boolean.TYPE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorShort",
  "sourceCode" : "/**\r\n * Positive getDynaProperty on property {@code shortProperty}.\r\n */\r\n@Test\r\nvoid testGetDescriptorShort() {\r\n    testGetDescriptorBase(\"shortProperty\", Short.TYPE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetDescriptorString",
  "sourceCode" : "/**\r\n * Positive getDynaProperty on property {@code stringProperty}.\r\n */\r\n@Test\r\nvoid testGetDescriptorString() {\r\n    testGetDescriptorBase(\"stringProperty\", String.class);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetIndexedArguments",
  "sourceCode" : "/**\r\n * Corner cases on getIndexedProperty invalid arguments.\r\n */\r\n@Test\r\nvoid testGetIndexedArguments() {\r\n    assertThrows(IndexOutOfBoundsException.class, () -> bean.get(\"intArray\", -1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetIndexedNonExisting",
  "sourceCode" : "/**\r\n * Tests whether an indexed access to a non-existing property causes an exception.\r\n */\r\n@Test\r\nvoid testGetIndexedNonExisting() {\r\n    assertThrows(IllegalArgumentException.class, () -> bean.get(\"Non existing property\", 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetIndexedString",
  "sourceCode" : "/**\r\n * Tests whether accessing a non-indexed string property using the index get method causes an exception.\r\n */\r\n@Test\r\nvoid testGetIndexedString() {\r\n    bean.set(\"stringProp\", \"value\");\r\n    assertThrows(IllegalArgumentException.class, () -> bean.get(\"stringProp\", 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetIndexedValues",
  "sourceCode" : "/**\r\n * Positive and negative tests on getIndexedProperty valid arguments.\r\n */\r\n@Test\r\nvoid testGetIndexedValues() {\r\n    for (int i = 0; i < 5; i++) {\r\n        Object value = bean.get(\"intArray\", i);\r\n        int intValue = assertInstanceOf(Integer.class, value, \"intArray index \" + i);\r\n        assertEquals(i * 10, intValue, \"intArray \" + i);\r\n        value = bean.get(\"intIndexed\", i);\r\n        intValue = assertInstanceOf(Integer.class, value, \"intIndexed index \" + i);\r\n        assertEquals(i * 10, intValue, \"intIndexed index \" + i);\r\n        value = bean.get(\"listIndexed\", i);\r\n        assertInstanceOf(String.class, value, \"list index \" + i);\r\n        assertEquals(\"String \" + i, value, \"listIndexed index \" + i);\r\n        value = bean.get(\"stringArray\", i);\r\n        assertInstanceOf(String.class, value, \"stringArray index \" + i);\r\n        assertEquals(\"String \" + i, value, \"stringArray index \" + i);\r\n        value = bean.get(\"stringIndexed\", i);\r\n        assertInstanceOf(String.class, value, \"stringIndexed index \" + i);\r\n        assertEquals(\"String \" + i, value, \"stringIndexed index \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetMappedArguments",
  "sourceCode" : "/**\r\n * Corner cases on getMappedProperty invalid arguments.\r\n */\r\n@Test\r\nvoid testGetMappedArguments() {\r\n    final Object value = bean.get(\"mappedProperty\", \"unknown\");\r\n    assertNull(value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetMappedValues",
  "sourceCode" : "/**\r\n * Positive and negative tests on getMappedProperty valid arguments.\r\n */\r\n@Test\r\nvoid testGetMappedValues() {\r\n    Object value = bean.get(\"mappedProperty\", \"key1\");\r\n    assertEquals(\"First Value\", value);\r\n    value = bean.get(\"mappedProperty\", \"key2\");\r\n    assertEquals(\"Second Value\", value);\r\n    value = bean.get(\"mappedProperty\", \"key3\");\r\n    assertNotNull(value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetNonExistentProperty",
  "sourceCode" : "/**\r\n * Test the retrieval of a non-existent property.\r\n */\r\n@Test\r\nvoid testGetNonExistentProperty() {\r\n    assertThrows(IllegalArgumentException.class, () -> bean.get(\"nonexistProperty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetNonIndexedProperties",
  "sourceCode" : "/**\r\n * Tests if reading a non-indexed property using the index get method throws an IllegalArgumentException as it should.\r\n */\r\n@Test\r\nvoid testGetNonIndexedProperties() {\r\n    assertThrows(IllegalArgumentException.class, () -> bean.get(\"booleanProperty\", 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetSimpleArguments",
  "sourceCode" : "/**\r\n * Corner cases on getSimpleProperty invalid arguments.\r\n */\r\n@Test\r\nvoid testGetSimpleArguments() {\r\n    assertThrows(IllegalArgumentException.class, () -> bean.get(\"a non existing property\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetSimpleBoolean",
  "sourceCode" : "/**\r\n * Test getSimpleProperty on a boolean property.\r\n */\r\n@Test\r\nvoid testGetSimpleBoolean() {\r\n    final Object value = bean.get(\"booleanProperty\");\r\n    assertInstanceOf(Boolean.class, value);\r\n    assertEquals(Boolean.TRUE, value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetSimpleDouble",
  "sourceCode" : "/**\r\n * Test getSimpleProperty on a double property.\r\n */\r\n@Test\r\nvoid testGetSimpleDouble() {\r\n    final Object value = bean.get(\"doubleProperty\");\r\n    final double doubleValue = assertInstanceOf(Double.class, value);\r\n    assertEquals(Double.MAX_VALUE, doubleValue, 0.005);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetSimpleFloat",
  "sourceCode" : "/**\r\n * Test getSimpleProperty on a float property.\r\n */\r\n@Test\r\nvoid testGetSimpleFloat() {\r\n    final Object value = bean.get(\"floatProperty\");\r\n    final float floatValue = assertInstanceOf(Float.class, value);\r\n    assertEquals(Float.MAX_VALUE, floatValue, 0.005f);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetSimpleInt",
  "sourceCode" : "/**\r\n * Test getSimpleProperty on a int property.\r\n */\r\n@Test\r\nvoid testGetSimpleInt() {\r\n    final Object value = bean.get(\"intProperty\");\r\n    final int intValue = assertInstanceOf(Integer.class, value);\r\n    assertEquals(Integer.MAX_VALUE, intValue);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetSimpleLong",
  "sourceCode" : "/**\r\n * Test getSimpleProperty on a long property.\r\n */\r\n@Test\r\nvoid testGetSimpleLong() {\r\n    final Object value = bean.get(\"longProperty\");\r\n    final long longValue = assertInstanceOf(Long.class, value);\r\n    assertEquals(Long.MAX_VALUE, longValue);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetSimpleShort",
  "sourceCode" : "/**\r\n * Test getSimpleProperty on a short property.\r\n */\r\n@Test\r\nvoid testGetSimpleShort() {\r\n    final Object value = bean.get(\"shortProperty\");\r\n    final short shortValue = assertInstanceOf(Short.class, value);\r\n    assertEquals(Short.MAX_VALUE, shortValue);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testGetSimpleString",
  "sourceCode" : "/**\r\n * Test getSimpleProperty on a String property.\r\n */\r\n@Test\r\nvoid testGetSimpleString() {\r\n    final Object value = bean.get(\"stringProperty\");\r\n    assertInstanceOf(String.class, value);\r\n    assertEquals(\"This is a string\", value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testMappedContains",
  "sourceCode" : "/**\r\n * Test {@code contains()} method for mapped properties.\r\n */\r\n@Test\r\nvoid testMappedContains() {\r\n    assertTrue(bean.contains(\"mappedProperty\", \"key1\"));\r\n    assertFalse(bean.contains(\"mappedProperty\", \"Unknown Key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testMappedRemove",
  "sourceCode" : "/**\r\n * Test {@code remove()} method for mapped properties.\r\n */\r\n@Test\r\nvoid testMappedRemove() {\r\n    assertTrue(bean.contains(\"mappedProperty\", \"key1\"));\r\n    bean.remove(\"mappedProperty\", \"key1\");\r\n    assertFalse(bean.contains(\"mappedProperty\", \"key1\"));\r\n    assertFalse(bean.contains(\"mappedProperty\", \"key4\"));\r\n    bean.remove(\"mappedProperty\", \"key4\");\r\n    assertFalse(bean.contains(\"mappedProperty\", \"key4\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testNestedPropeties",
  "sourceCode" : "/**\r\n * Tests whether nested properties can be accessed.\r\n */\r\n@Test\r\nvoid testNestedPropeties() {\r\n    final ConfigurationDynaBean nested = (ConfigurationDynaBean) bean.get(\"mappedProperty\");\r\n    final String value = (String) nested.get(\"key1\");\r\n    assertEquals(\"First Value\", value);\r\n    nested.set(\"key1\", \"undefined\");\r\n    assertEquals(\"undefined\", bean.get(\"mappedProperty.key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetArrayValue",
  "sourceCode" : "/**\r\n * Test the modification of a configuration property stored internally as an array.\r\n */\r\n@Test\r\nvoid testSetArrayValue() {\r\n    final MapConfiguration configuration = new MapConfiguration(new HashMap<>());\r\n    configuration.getMap().put(\"objectArray\", new Object[] { \"value1\", \"value2\", \"value3\" });\r\n    final ConfigurationDynaBean bean = new ConfigurationDynaBean(configuration);\r\n    bean.set(\"objectArray\", 1, \"New Value 1\");\r\n    final Object value = bean.get(\"objectArray\", 1);\r\n    assertInstanceOf(String.class, value);\r\n    assertEquals(\"New Value 1\", value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetIndexedArguments",
  "sourceCode" : "/**\r\n * Corner cases on setIndexedProperty invalid arguments.\r\n */\r\n@Test\r\nvoid testSetIndexedArguments() {\r\n    assertThrows(IndexOutOfBoundsException.class, () -> bean.set(\"intArray\", -1, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetIndexedValues",
  "sourceCode" : "/**\r\n * Positive and negative tests on setIndexedProperty valid arguments.\r\n */\r\n@Test\r\nvoid testSetIndexedValues() {\r\n    bean.set(\"intArray\", 0, 1);\r\n    Object value = bean.get(\"intArray\", 0);\r\n    int intValue = assertInstanceOf(Integer.class, value);\r\n    assertEquals(1, intValue);\r\n    bean.set(\"intIndexed\", 1, 11);\r\n    value = bean.get(\"intIndexed\", 1);\r\n    intValue = assertInstanceOf(Integer.class, value);\r\n    assertEquals(11, intValue);\r\n    bean.set(\"listIndexed\", 2, \"New Value 2\");\r\n    value = bean.get(\"listIndexed\", 2);\r\n    assertInstanceOf(String.class, value);\r\n    assertEquals(\"New Value 2\", value);\r\n    bean.set(\"stringArray\", 3, \"New Value 3\");\r\n    value = bean.get(\"stringArray\", 3);\r\n    assertInstanceOf(String.class, value);\r\n    assertEquals(\"New Value 3\", value);\r\n    bean.set(\"stringIndexed\", 4, \"New Value 4\");\r\n    value = bean.get(\"stringIndexed\", 4);\r\n    assertInstanceOf(String.class, value);\r\n    assertEquals(\"New Value 4\", value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetMappedValues",
  "sourceCode" : "/**\r\n * Positive and negative tests on setMappedProperty valid arguments.\r\n */\r\n@Test\r\nvoid testSetMappedValues() {\r\n    bean.set(\"mappedProperty\", \"First Key\", \"New First Value\");\r\n    assertEquals(\"New First Value\", bean.get(\"mappedProperty\", \"First Key\"));\r\n    bean.set(\"mappedProperty\", \"Fourth Key\", \"Fourth Value\");\r\n    assertEquals(\"Fourth Value\", bean.get(\"mappedProperty\", \"Fourth Key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetNonIndexedProperties",
  "sourceCode" : "/**\r\n * Tests if writing a non-indexed property using the index set method with an index &gt; 0 throws an\r\n * IllegalArgumentException as it should.\r\n */\r\n@Test\r\nvoid testSetNonIndexedProperties() {\r\n    assertThrows(IllegalArgumentException.class, () -> bean.set(\"booleanProperty\", 1, Boolean.TRUE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetSimpleBoolean",
  "sourceCode" : "/**\r\n * Test setSimpleProperty on a boolean property.\r\n */\r\n@Test\r\nvoid testSetSimpleBoolean() {\r\n    final boolean oldValue = ((Boolean) bean.get(\"booleanProperty\")).booleanValue();\r\n    final boolean newValue = !oldValue;\r\n    bean.set(\"booleanProperty\", newValue);\r\n    assertEquals(newValue, ((Boolean) bean.get(\"booleanProperty\")).booleanValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetSimpleDouble",
  "sourceCode" : "/**\r\n * Test setSimpleProperty on a double property.\r\n */\r\n@Test\r\nvoid testSetSimpleDouble() {\r\n    final double oldValue = ((Double) bean.get(\"doubleProperty\")).doubleValue();\r\n    final double newValue = oldValue + 1.0;\r\n    bean.set(\"doubleProperty\", newValue);\r\n    assertEquals(newValue, ((Double) bean.get(\"doubleProperty\")).doubleValue(), 0.005);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetSimpleFloat",
  "sourceCode" : "/**\r\n * Test setSimpleProperty on a float property.\r\n */\r\n@Test\r\nvoid testSetSimpleFloat() {\r\n    final float oldValue = ((Float) bean.get(\"floatProperty\")).floatValue();\r\n    final float newValue = oldValue + (float) 1.0;\r\n    bean.set(\"floatProperty\", newValue);\r\n    assertEquals(newValue, ((Float) bean.get(\"floatProperty\")).floatValue(), 0.005f);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetSimpleInt",
  "sourceCode" : "/**\r\n * Test setSimpleProperty on a int property.\r\n */\r\n@Test\r\nvoid testSetSimpleInt() {\r\n    final int oldValue = ((Integer) bean.get(\"intProperty\")).intValue();\r\n    final int newValue = oldValue + 1;\r\n    bean.set(\"intProperty\", newValue);\r\n    assertEquals(newValue, ((Integer) bean.get(\"intProperty\")).intValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetSimpleLong",
  "sourceCode" : "/**\r\n * Test setSimpleProperty on a long property.\r\n */\r\n@Test\r\nvoid testSetSimpleLong() {\r\n    final long oldValue = ((Long) bean.get(\"longProperty\")).longValue();\r\n    final long newValue = oldValue + 1;\r\n    bean.set(\"longProperty\", newValue);\r\n    assertEquals(newValue, ((Long) bean.get(\"longProperty\")).longValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetSimpleShort",
  "sourceCode" : "/**\r\n * Test setSimpleProperty on a short property.\r\n */\r\n@Test\r\nvoid testSetSimpleShort() {\r\n    final short oldValue = ((Short) bean.get(\"shortProperty\")).shortValue();\r\n    final short newValue = (short) (oldValue + 1);\r\n    bean.set(\"shortProperty\", newValue);\r\n    assertEquals(newValue, ((Short) bean.get(\"shortProperty\")).shortValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConfigurationDynaBean.java",
  "methodName" : "testSetSimpleString",
  "sourceCode" : "/**\r\n * Test setSimpleProperty on a String property.\r\n */\r\n@Test\r\nvoid testSetSimpleString() {\r\n    final String oldValue = (String) bean.get(\"stringProperty\");\r\n    final String newValue = oldValue + \" Extra Value\";\r\n    bean.set(\"stringProperty\", newValue);\r\n    assertEquals(newValue, bean.get(\"stringProperty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConstructorArg.java",
  "methodName" : "testForBeanDeclarationNull",
  "sourceCode" : "/**\r\n * Tries to create an instance for a null bean declaration.\r\n */\r\n@Test\r\nvoid testForBeanDeclarationNull() {\r\n    assertThrows(NullPointerException.class, () -> ConstructorArg.forBeanDeclaration(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConstructorArg.java",
  "methodName" : "testIsNestedBeanDeclarationFalse",
  "sourceCode" : "/**\r\n * Tests whether an argument with a simple value is detected.\r\n */\r\n@Test\r\nvoid testIsNestedBeanDeclarationFalse() {\r\n    final ConstructorArg arg = ConstructorArg.forValue(\"test\");\r\n    assertFalse(arg.isNestedBeanDeclaration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConstructorArg.java",
  "methodName" : "testIsNestedBeanDeclarationTrue",
  "sourceCode" : "/**\r\n * Tests whether an argument representing a bean declaration is detected.\r\n */\r\n@Test\r\nvoid testIsNestedBeanDeclarationTrue() {\r\n    final BeanDeclaration decl = mock(BeanDeclaration.class);\r\n    final ConstructorArg arg = ConstructorArg.forBeanDeclaration(decl);\r\n    assertTrue(arg.isNestedBeanDeclaration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConstructorArg.java",
  "methodName" : "testMatchesNoType",
  "sourceCode" : "/**\r\n * Tests matches() if no data type is provided.\r\n */\r\n@Test\r\nvoid testMatchesNoType() {\r\n    final ConstructorArg arg = ConstructorArg.forValue(42);\r\n    assertTrue(arg.matches(String.class));\r\n    assertTrue(arg.matches(getClass()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConstructorArg.java",
  "methodName" : "testMatchesNull",
  "sourceCode" : "/**\r\n * Tests whether matches() deals with a null argument.\r\n */\r\n@Test\r\nvoid testMatchesNull() {\r\n    final ConstructorArg arg = ConstructorArg.forValue(0);\r\n    assertFalse(arg.matches(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestConstructorArg.java",
  "methodName" : "testMatchesWithType",
  "sourceCode" : "/**\r\n * Tests whether a specified data type is evaluated by matches().\r\n */\r\n@Test\r\nvoid testMatchesWithType() {\r\n    final ConstructorArg arg = ConstructorArg.forValue(\"42\", int.class.getName());\r\n    assertTrue(arg.matches(Integer.TYPE));\r\n    assertFalse(arg.matches(Integer.class));\r\n    assertFalse(arg.matches(String.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testCreateBean",
  "sourceCode" : "/**\r\n * Tests creating a bean.\r\n */\r\n@Test\r\nvoid testCreateBean() throws Exception {\r\n    final BeanDeclarationTestImpl decl = new BeanDeclarationTestImpl();\r\n    final Map<String, Object> props = new HashMap<>();\r\n    props.put(\"throwExceptionOnMissing\", Boolean.TRUE);\r\n    decl.setBeanProperties(props);\r\n    final Object bean = factory.createBean(createBcc(PropertiesConfiguration.class, decl));\r\n    assertNotNull(bean);\r\n    assertEquals(PropertiesConfiguration.class, bean.getClass());\r\n    final PropertiesConfiguration config = (PropertiesConfiguration) bean;\r\n    assertTrue(config.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testCreateBeanConstructor",
  "sourceCode" : "/**\r\n * Tests whether a bean can be created by calling its constructor.\r\n */\r\n@Test\r\nvoid testCreateBeanConstructor() throws Exception {\r\n    final BeanDeclarationTestImpl decl = new BeanDeclarationTestImpl();\r\n    final Collection<ConstructorArg> args = new ArrayList<>();\r\n    args.add(ConstructorArg.forValue(\"test\"));\r\n    args.add(ConstructorArg.forValue(\"42\"));\r\n    decl.setConstructorArgs(args);\r\n    final BeanCreationTestCtorBean bean = (BeanCreationTestCtorBean) factory.createBean(createBcc(BeanCreationTestCtorBean.class, decl));\r\n    assertEquals(\"test\", bean.getStringValue());\r\n    assertEquals(42, bean.getIntValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testCreateBeanConstructorNestedBean",
  "sourceCode" : "/**\r\n * Tests whether nested bean declarations in constructor arguments are taken into account.\r\n */\r\n@Test\r\nvoid testCreateBeanConstructorNestedBean() throws Exception {\r\n    final BeanDeclarationTestImpl declNested = new BeanDeclarationTestImpl();\r\n    final Collection<ConstructorArg> args = new ArrayList<>();\r\n    args.add(ConstructorArg.forValue(\"test\", String.class.getName()));\r\n    declNested.setConstructorArgs(args);\r\n    declNested.setBeanClassName(BeanCreationTestCtorBean.class.getName());\r\n    final BeanDeclarationTestImpl decl = new BeanDeclarationTestImpl();\r\n    decl.setConstructorArgs(Collections.singleton(ConstructorArg.forBeanDeclaration(declNested, BeanCreationTestBean.class.getName())));\r\n    final BeanCreationTestCtorBean bean = (BeanCreationTestCtorBean) factory.createBean(createBcc(BeanCreationTestCtorBean.class, decl));\r\n    assertNotNull(bean.getBuddy());\r\n    assertEquals(\"test\", bean.getBuddy().getStringValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testDefaultConversionHandler",
  "sourceCode" : "/**\r\n * Tests whether a correct default conversion handler is set.\r\n */\r\n@Test\r\nvoid testDefaultConversionHandler() {\r\n    assertSame(DefaultConversionHandler.INSTANCE, factory.getConversionHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testFindMatchingConstructorAmbiguous",
  "sourceCode" : "/**\r\n * Tests whether ambiguous constructor arguments are detected.\r\n */\r\n@Test\r\nvoid testFindMatchingConstructorAmbiguous() {\r\n    final BeanDeclarationTestImpl decl = new BeanDeclarationTestImpl();\r\n    final Collection<ConstructorArg> args = new ArrayList<>();\r\n    args.add(ConstructorArg.forValue(TEST_STRING));\r\n    decl.setConstructorArgs(args);\r\n    assertThrows(ConfigurationRuntimeException.class, () -> DefaultBeanFactory.findMatchingConstructor(BeanCreationTestCtorBean.class, decl));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testFindMatchingConstructorArgCount",
  "sourceCode" : "/**\r\n * Tests whether a matching constructor is found if the number of arguments is unique.\r\n */\r\n@Test\r\nvoid testFindMatchingConstructorArgCount() {\r\n    final BeanDeclarationTestImpl decl = new BeanDeclarationTestImpl();\r\n    final Collection<ConstructorArg> args = new ArrayList<>();\r\n    args.add(ConstructorArg.forValue(TEST_STRING));\r\n    args.add(ConstructorArg.forValue(String.valueOf(TEST_INT)));\r\n    decl.setConstructorArgs(args);\r\n    final Constructor<BeanCreationTestCtorBean> ctor = DefaultBeanFactory.findMatchingConstructor(BeanCreationTestCtorBean.class, decl);\r\n    final Class<?>[] paramTypes = ctor.getParameterTypes();\r\n    assertArrayEquals(new Class<?>[] { String.class, Integer.TYPE }, paramTypes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testFindMatchingConstructorExplicitType",
  "sourceCode" : "/**\r\n * Tests whether explicit type declarations are used to resolve ambiguous parameter types.\r\n */\r\n@Test\r\nvoid testFindMatchingConstructorExplicitType() {\r\n    final BeanDeclarationTestImpl decl = new BeanDeclarationTestImpl();\r\n    final Collection<ConstructorArg> args = new ArrayList<>();\r\n    args.add(ConstructorArg.forBeanDeclaration(setUpBeanDeclaration(), BeanCreationTestBean.class.getName()));\r\n    decl.setConstructorArgs(args);\r\n    final Constructor<BeanCreationTestCtorBean> ctor = DefaultBeanFactory.findMatchingConstructor(BeanCreationTestCtorBean.class, decl);\r\n    final Class<?>[] paramTypes = ctor.getParameterTypes();\r\n    assertArrayEquals(new Class<?>[] { BeanCreationTestBean.class }, paramTypes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testFindMatchingConstructorNoArgs",
  "sourceCode" : "/**\r\n * Tests whether the standard constructor can be found.\r\n */\r\n@Test\r\nvoid testFindMatchingConstructorNoArgs() {\r\n    final BeanDeclarationTestImpl decl = new BeanDeclarationTestImpl();\r\n    final Constructor<BeanCreationTestBean> ctor = DefaultBeanFactory.findMatchingConstructor(BeanCreationTestBean.class, decl);\r\n    assertEquals(0, ctor.getParameterTypes().length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testFindMatchingConstructorNoMatch",
  "sourceCode" : "/**\r\n * Tests the case that no matching constructor is found.\r\n */\r\n@Test\r\nvoid testFindMatchingConstructorNoMatch() {\r\n    final BeanDeclarationTestImpl decl = new BeanDeclarationTestImpl();\r\n    final Collection<ConstructorArg> args = new ArrayList<>();\r\n    args.add(ConstructorArg.forValue(TEST_STRING, getClass().getName()));\r\n    decl.setConstructorArgs(args);\r\n    final ConfigurationRuntimeException crex = assertThrows(ConfigurationRuntimeException.class, () -> DefaultBeanFactory.findMatchingConstructor(BeanCreationTestCtorBean.class, decl));\r\n    final String msg = crex.getMessage();\r\n    assertTrue(msg.contains(BeanCreationTestCtorBean.class.getName()));\r\n    assertTrue(msg.contains(TEST_STRING));\r\n    assertTrue(msg.contains(\"(\" + getClass().getName() + ')'));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testGetDefaultBeanClass",
  "sourceCode" : "/**\r\n * Tests obtaining the default class. This should be null.\r\n */\r\n@Test\r\nvoid testGetDefaultBeanClass() {\r\n    assertNull(factory.getDefaultBeanClass());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestDefaultBeanFactory.java",
  "methodName" : "testInitWithConversionHandler",
  "sourceCode" : "/**\r\n * Tests whether a custom conversion handler can be passed to the constructor.\r\n */\r\n@Test\r\nvoid testInitWithConversionHandler() {\r\n    final ConversionHandler handler = mock(ConversionHandler.class);\r\n    factory = new DefaultBeanFactory(handler);\r\n    assertSame(handler, factory.getConversionHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanClassName",
  "sourceCode" : "/**\r\n * Tests fetching the bean's class name.\r\n */\r\n@Test\r\nvoid testGetBeanClassName() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(KEY + \"[@config-class]\", getClass().getName());\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    assertEquals(getClass().getName(), decl.getBeanClassName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanClassNameFromDefault",
  "sourceCode" : "/**\r\n * Tests whether a default bean class name is taken into account.\r\n */\r\n@Test\r\nvoid testGetBeanClassNameFromDefault() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(KEY + \"[@someProperty]\", Boolean.TRUE);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY, false, getClass().getName());\r\n    assertEquals(getClass().getName(), decl.getBeanClassName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanClassNameUndefined",
  "sourceCode" : "/**\r\n * Tests fetching the bean's class name if it is undefined.\r\n */\r\n@Test\r\nvoid testGetBeanClassNameUndefined() {\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(new BaseHierarchicalConfiguration());\r\n    assertNull(decl.getBeanClassName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanClassNameUndefinedWithEx",
  "sourceCode" : "/**\r\n * Tests that a missing bean class name does not cause an exception.\r\n */\r\n@Test\r\nvoid testGetBeanClassNameUndefinedWithEx() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.setThrowExceptionOnMissing(true);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config);\r\n    assertNull(decl.getBeanClassName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryName",
  "sourceCode" : "/**\r\n * Tests fetching the name of the bean factory.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryName() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(KEY + \"[@config-factory]\", \"myFactory\");\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    assertEquals(\"myFactory\", decl.getBeanFactoryName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryNameUndefined",
  "sourceCode" : "/**\r\n * Tests fetching the name of the bean factory if it is undefined.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryNameUndefined() {\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(new BaseHierarchicalConfiguration());\r\n    assertNull(decl.getBeanFactoryName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryNameUndefinedWithEx",
  "sourceCode" : "/**\r\n * Tests that a missing bean factory name does not throw an exception.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryNameUndefinedWithEx() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.setThrowExceptionOnMissing(true);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config);\r\n    assertNull(decl.getBeanFactoryName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryParameter",
  "sourceCode" : "/**\r\n * Tests fetching the parameter for the bean factory.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryParameter() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(KEY + \"[@config-factoryParam]\", \"myFactoryParameter\");\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    assertEquals(\"myFactoryParameter\", decl.getBeanFactoryParameter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryParameterUndefined",
  "sourceCode" : "/**\r\n * Tests fetching the parameter for the bean factory if it is undefined.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryParameterUndefined() {\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(new BaseHierarchicalConfiguration());\r\n    assertNull(decl.getBeanFactoryParameter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanFactoryParameterUndefinedWithEx",
  "sourceCode" : "/**\r\n * Tests that an undefined bean factory parameter does not cause an exception.\r\n */\r\n@Test\r\nvoid testGetBeanFactoryParameterUndefinedWithEx() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.setThrowExceptionOnMissing(true);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config);\r\n    assertNull(decl.getBeanFactoryParameter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanProperties",
  "sourceCode" : "/**\r\n * Tests if the bean's properties are correctly extracted from the configuration object.\r\n */\r\n@Test\r\nvoid testGetBeanProperties() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, TEST_VALUES);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    checkProperties(decl, TEST_PROPS, TEST_VALUES);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanPropertiesEmpty",
  "sourceCode" : "/**\r\n * Tests fetching properties if none are defined.\r\n */\r\n@Test\r\nvoid testGetBeanPropertiesEmpty() {\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(new BaseHierarchicalConfiguration());\r\n    final Map<String, Object> props = decl.getBeanProperties();\r\n    assertTrue(props == null || props.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetBeanPropertiesWithReservedAttributes",
  "sourceCode" : "/**\r\n * Tests obtaining the bean's properties when reserved attributes are involved. These should be ignored.\r\n */\r\n@Test\r\nvoid testGetBeanPropertiesWithReservedAttributes() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, TEST_VALUES);\r\n    config.addProperty(KEY + \"[@config-testattr]\", \"yes\");\r\n    config.addProperty(KEY + \"[@config-anothertest]\", \"this, too\");\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    checkProperties(decl, TEST_PROPS, TEST_VALUES);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetConstructorArgs",
  "sourceCode" : "/**\r\n * Tests whether constructor arguments can be queried.\r\n */\r\n@Test\r\nvoid testGetConstructorArgs() {\r\n    final BaseHierarchicalConfiguration config = prepareNestedBeanDeclarations();\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    final Collection<ConstructorArg> args = decl.getConstructorArgs();\r\n    assertEquals(2, args.size());\r\n    final Iterator<ConstructorArg> it = args.iterator();\r\n    final ConstructorArg arg1 = it.next();\r\n    assertTrue(arg1.isNestedBeanDeclaration());\r\n    checkProperties(arg1.getBeanDeclaration(), CTOR_COMPLEX_ATTRIBUTES, CTOR_COMPLEX_VALUES);\r\n    assertNull(arg1.getTypeName());\r\n    assertEquals(\"TestClass\", arg1.getBeanDeclaration().getBeanClassName());\r\n    final ConstructorArg arg2 = it.next();\r\n    assertFalse(arg2.isNestedBeanDeclaration());\r\n    assertEquals(CTOR_ID, arg2.getValue());\r\n    assertEquals(\"long\", arg2.getTypeName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetConstructorArgsNullArg",
  "sourceCode" : "/**\r\n * Tests whether a constructor argument with a null value can be defined.\r\n */\r\n@Test\r\nvoid testGetConstructorArgsNullArg() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, TEST_VALUES);\r\n    config.addProperty(KEY + \".config-constrarg\", \"\");\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    final Collection<ConstructorArg> args = decl.getConstructorArgs();\r\n    assertEquals(1, args.size());\r\n    final ConstructorArg arg = args.iterator().next();\r\n    assertFalse(arg.isNestedBeanDeclaration());\r\n    assertNull(arg.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetInterpolatedBeanProperties",
  "sourceCode" : "/**\r\n * Tests whether interpolation of bean properties works.\r\n */\r\n@Test\r\nvoid testGetInterpolatedBeanProperties() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    final String[] varValues = new String[TEST_PROPS.length];\r\n    for (int i = 0; i < TEST_PROPS.length; i++) {\r\n        varValues[i] = \"${\" + VARS + TEST_PROPS[i] + \"}\";\r\n        config.addProperty(VARS + TEST_PROPS[i], TEST_VALUES[i]);\r\n    }\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, varValues);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    checkProperties(decl, TEST_PROPS, TEST_VALUES);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetInterpolatedConstructorArgs",
  "sourceCode" : "/**\r\n * Tests whether interpolation is done on constructor arguments.\r\n */\r\n@Test\r\nvoid testGetInterpolatedConstructorArgs() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    final String expectedValue = \"ctorArg\";\r\n    config.addProperty(\"value\", expectedValue);\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, TEST_VALUES);\r\n    config.addProperty(KEY + \".config-constrarg[@config-value]\", \"${value}\");\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    final Collection<ConstructorArg> args = decl.getConstructorArgs();\r\n    final ConstructorArg arg = args.iterator().next();\r\n    assertEquals(expectedValue, arg.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetNestedBeanDeclarations",
  "sourceCode" : "/**\r\n * Tests fetching nested bean declarations.\r\n */\r\n@Test\r\nvoid testGetNestedBeanDeclarations() {\r\n    final BaseHierarchicalConfiguration config = prepareNestedBeanDeclarations();\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    checkProperties(decl, TEST_PROPS, TEST_VALUES);\r\n    final Map<String, Object> nested = decl.getNestedBeanDeclarations();\r\n    assertEquals(COMPLEX_PROPS.length, nested.size());\r\n    for (int i = 0; i < COMPLEX_PROPS.length; i++) {\r\n        final XMLBeanDeclaration d = (XMLBeanDeclaration) nested.get(COMPLEX_PROPS[i]);\r\n        assertNotNull(d, \"No declaration found for \" + COMPLEX_PROPS[i]);\r\n        checkProperties(d, COMPLEX_ATTRIBUTES[i], COMPLEX_VALUES[i]);\r\n        assertEquals(COMPLEX_CLASSES[i], d.getBeanClassName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetNestedBeanDeclarationsEmpty",
  "sourceCode" : "/**\r\n * Tests fetching nested bean declarations if none are defined.\r\n */\r\n@Test\r\nvoid testGetNestedBeanDeclarationsEmpty() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, TEST_VALUES);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    final Map<String, Object> nested = decl.getNestedBeanDeclarations();\r\n    assertTrue(nested == null || nested.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetNestedBeanDeclarationsFactoryMethod",
  "sourceCode" : "/**\r\n * Tests whether the factory method for creating nested bean declarations gets called.\r\n */\r\n@Test\r\nvoid testGetNestedBeanDeclarationsFactoryMethod() {\r\n    final BaseHierarchicalConfiguration config = prepareNestedBeanDeclarations();\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY) {\r\n\r\n        @Override\r\n        BeanDeclaration createBeanDeclaration(final NodeData<?> node) {\r\n            return new XMLBeanDeclarationTestImpl(getConfiguration().configurationAt(node.nodeName()), node);\r\n        }\r\n    };\r\n    final Map<String, Object> nested = decl.getNestedBeanDeclarations();\r\n    for (final String element : COMPLEX_PROPS) {\r\n        final Object d = nested.get(element);\r\n        assertInstanceOf(XMLBeanDeclarationTestImpl.class, d, \"Wrong class for bean declaration: \" + d);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testGetNestedBeanDeclarationsReservedCharacter",
  "sourceCode" : "/**\r\n * Tests whether reserved characters in the node names of nested bean declarations are handled correctly. This is\r\n * related to CONFIGURATION-567.\r\n */\r\n@Test\r\nvoid testGetNestedBeanDeclarationsReservedCharacter() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    final String key = KEY + \".address..private\";\r\n    setupBeanDeclaration(config, key, COMPLEX_ATTRIBUTES[0], COMPLEX_VALUES[0]);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    final Map<String, Object> nested = decl.getNestedBeanDeclarations();\r\n    assertTrue(nested.containsKey(\"address.private\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testInitFromMultiValueKey",
  "sourceCode" : "/**\r\n * Tests constructing a bean declaration from a key with multiple values. This should cause an exception because keys\r\n * must be unique.\r\n */\r\n@Test\r\nvoid testInitFromMultiValueKey() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(KEY, \"myFirstKey\");\r\n    config.addProperty(KEY, \"mySecondKey\");\r\n    assertThrows(ConfigurationRuntimeException.class, () -> new XMLBeanDeclaration(config, KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testInitFromNullConfiguration",
  "sourceCode" : "/**\r\n * Tests creating a declaration from a null configuration. This should cause an exception.\r\n */\r\n@Test\r\nvoid testInitFromNullConfiguration() {\r\n    assertThrows(IllegalArgumentException.class, () -> new XMLBeanDeclaration(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testInitFromNullConfigurationAndKey",
  "sourceCode" : "/**\r\n * Tests creating a declaration from a null configuration with a key. This should cause an exception.\r\n */\r\n@Test\r\nvoid testInitFromNullConfigurationAndKey() {\r\n    assertThrows(IllegalArgumentException.class, () -> new XMLBeanDeclaration(null, KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testInitFromUndefinedKey",
  "sourceCode" : "/**\r\n * Tests constructing a bean declaration from an undefined key. This should cause an exception.\r\n */\r\n@Test\r\nvoid testInitFromUndefinedKey() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, TEST_VALUES);\r\n    assertThrows(ConfigurationRuntimeException.class, () -> new XMLBeanDeclaration(config, \"undefined_key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testInitFromUndefinedKeyOptional",
  "sourceCode" : "/**\r\n * Tests constructing a bean declaration from a key, which is undefined when the optional flag is set. In this case an\r\n * empty declaration should be created, which can be used for creating beans as long as a default class is provided.\r\n */\r\n@Test\r\nvoid testInitFromUndefinedKeyOptional() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, TEST_VALUES);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, \"undefined_key\", true);\r\n    assertNull(decl.getBeanClassName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "testInterpolateNoInterpolator",
  "sourceCode" : "/**\r\n * Tests interpolate() if no ConfigurationInterpolator is available.\r\n */\r\n@Test\r\nvoid testInterpolateNoInterpolator() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(\"value\", \"expectedValue\");\r\n    setupBeanDeclaration(config, KEY, TEST_PROPS, TEST_VALUES);\r\n    final String value = \"${value}\";\r\n    config.addProperty(KEY + \".config-constrarg[@config-value]\", value);\r\n    config.setInterpolator(null);\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY);\r\n    final Collection<ConstructorArg> args = decl.getConstructorArgs();\r\n    final ConstructorArg arg = args.iterator().next();\r\n    assertEquals(value, arg.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\beanutils\\TestXMLBeanDeclaration.java",
  "methodName" : "tetGetBeanClassNameDefaultOverride",
  "sourceCode" : "/**\r\n * Tests whether a default bean class name is overridden by a value in the configuration.\r\n */\r\n@Test\r\npublic void tetGetBeanClassNameDefaultOverride() {\r\n    final BaseHierarchicalConfiguration config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(KEY + \"[@config-class]\", getClass().getName());\r\n    final XMLBeanDeclaration decl = new XMLBeanDeclaration(config, KEY, false, \"someDefaultClassName\");\r\n    assertEquals(getClass().getName(), decl.getBeanClassName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testGetBuilderAllowFailOnInit",
  "sourceCode" : "/**\r\n * Tests whether the allowFailOnInit flag can be enabled on the builder.\r\n */\r\n@Test\r\nvoid testGetBuilderAllowFailOnInit() throws ConfigurationException {\r\n    checkAllowFailOnInit(true, CombinedConfigurationBuilder.ATTR_OPTIONAL_RES, CombinedConfigurationBuilder.ATTR_FORCECREATE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testGetBuilderNoFailOnInit",
  "sourceCode" : "/**\r\n * Tests that the allowFailOnInit flag is not set per default on the builder.\r\n */\r\n@Test\r\nvoid testGetBuilderNoFailOnInit() throws ConfigurationException {\r\n    checkAllowFailOnInit(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testGetBuilderNotReloading",
  "sourceCode" : "/**\r\n * Tests whether a builder without reloading support can be created.\r\n */\r\n@Test\r\nvoid testGetBuilderNotReloading() throws ConfigurationException {\r\n    final ConfigurationBuilder<? extends Configuration> builder = checkBuilder(false);\r\n    assertEquals(FileBasedConfigurationBuilder.class, builder.getClass());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testGetBuilderReloading",
  "sourceCode" : "/**\r\n * Tests whether a builder with reloading support can be created.\r\n */\r\n@Test\r\nvoid testGetBuilderReloading() throws ConfigurationException {\r\n    final ConfigurationBuilder<? extends Configuration> builder = checkBuilder(true);\r\n    assertEquals(ReloadingFileBasedConfigurationBuilder.class, builder.getClass());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testGetParameterClassesModify",
  "sourceCode" : "/**\r\n * Tests that the collection with parameter classes cannot be modified.\r\n */\r\n@Test\r\nvoid testGetParameterClassesModify() {\r\n    final BaseConfigurationBuilderProvider provider = new BaseConfigurationBuilderProvider(BasicConfigurationBuilder.class.getName(), null, PropertiesConfiguration.class.getName(), Arrays.asList(BasicBuilderParameters.class.getName()));\r\n    final Collection<String> parameterClasses = provider.getParameterClasses();\r\n    assertThrows(UnsupportedOperationException.class, parameterClasses::clear);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testGetReloadingBuilderNotSupported",
  "sourceCode" : "/**\r\n * Tries to create a reloading builder if this is not supported by the provider.\r\n */\r\n@Test\r\nvoid testGetReloadingBuilderNotSupported() {\r\n    final BaseConfigurationBuilderProvider provider = new BaseConfigurationBuilderProvider(FileBasedConfigurationBuilder.class.getName(), null, PropertiesConfiguration.class.getName(), Arrays.asList(FileBasedBuilderParametersImpl.class.getName()));\r\n    final HierarchicalConfiguration<?> declConfig = setUpConfig(true);\r\n    final ConfigurationDeclaration decl = createDeclaration(declConfig);\r\n    assertThrows(ConfigurationException.class, () -> provider.getConfigurationBuilder(decl));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testInitNoBuilderClass",
  "sourceCode" : "/**\r\n * Tries to create an instance without a builder class.\r\n */\r\n@Test\r\nvoid testInitNoBuilderClass() {\r\n    final String configClass = PropertiesConfiguration.class.getName();\r\n    assertThrows(IllegalArgumentException.class, () -> new BaseConfigurationBuilderProvider(null, null, configClass, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testInitNoConfigurationClass",
  "sourceCode" : "/**\r\n * Tries to create an instance without a configuration class.\r\n */\r\n@Test\r\nvoid testInitNoConfigurationClass() {\r\n    final String builderClass = BasicConfigurationBuilder.class.getName();\r\n    assertThrows(IllegalArgumentException.class, () -> new BaseConfigurationBuilderProvider(builderClass, null, null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestBaseConfigurationBuilderProvider.java",
  "methodName" : "testInitNoParameterClasses",
  "sourceCode" : "/**\r\n * Tests whether a null collection of parameter classes is handled correctly.\r\n */\r\n@Test\r\nvoid testInitNoParameterClasses() {\r\n    final BaseConfigurationBuilderProvider provider = new BaseConfigurationBuilderProvider(BasicConfigurationBuilder.class.getName(), null, PropertiesConfiguration.class.getName(), null);\r\n    assertEquals(Collections.emptyList(), new ArrayList<>(provider.getParameterClasses()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests whether cloning works as expected.\r\n */\r\n@Test\r\nvoid testClone() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    params.setBasePath(\"some base path\");\r\n    final XMLBuilderParametersImpl defParams = new XMLBuilderParametersImpl();\r\n    defParams.setSystemID(\"someSysID\");\r\n    params.setDefinitionBuilderParameters(defParams);\r\n    final CombinedBuilderParametersImpl clone = params.clone();\r\n    assertEquals(params.getBasePath(), clone.getBasePath());\r\n    assertNotSame(params.getDefinitionBuilderParameters(), clone.getDefinitionBuilderParameters());\r\n    assertEquals(params.getDefinitionBuilderParameters().getParameters().get(\"systemID\"), clone.getDefinitionBuilderParameters().getParameters().get(\"systemID\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testFromParametersCreate",
  "sourceCode" : "/**\r\n * Tests whether a new instance can be created if none is found in the parameters map.\r\n */\r\n@Test\r\nvoid testFromParametersCreate() {\r\n    final CombinedBuilderParametersImpl params = CombinedBuilderParametersImpl.fromParameters(new HashMap<>(), true);\r\n    assertNotNull(params);\r\n    assertNull(params.getDefinitionBuilder());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testFromParametersExisting",
  "sourceCode" : "/**\r\n * Tests whether an instance can be obtained from a parameters map.\r\n */\r\n@Test\r\nvoid testFromParametersExisting() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertSame(params, CombinedBuilderParametersImpl.fromParameters(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testFromParametersNotFound",
  "sourceCode" : "/**\r\n * Tests fromParameters() if the map does not contain an instance.\r\n */\r\n@Test\r\nvoid testFromParametersNotFound() {\r\n    assertNull(CombinedBuilderParametersImpl.fromParameters(new HashMap<>()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testGetChildDefaultParametersManagerSpecific",
  "sourceCode" : "/**\r\n * Tests whether a default parameters manager can be set and queried.\r\n */\r\n@Test\r\nvoid testGetChildDefaultParametersManagerSpecific() {\r\n    final DefaultParametersManager manager = mock(DefaultParametersManager.class);\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    assertSame(params, params.setChildDefaultParametersManager(manager));\r\n    assertSame(manager, params.getChildDefaultParametersManager());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testGetChildDefaultParametersManagerUndefined",
  "sourceCode" : "/**\r\n * Tests whether a default parameters manager is dynamically created if it has not been set.\r\n */\r\n@Test\r\nvoid testGetChildDefaultParametersManagerUndefined() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    assertNotNull(params.getChildDefaultParametersManager());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testGetParametersInherited",
  "sourceCode" : "/**\r\n * Tests that inherited properties are also stored in the parameters map.\r\n */\r\n@Test\r\nvoid testGetParametersInherited() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    params.setThrowExceptionOnMissing(true);\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertEquals(Boolean.TRUE, map.get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testGetProvidersInitial",
  "sourceCode" : "/**\r\n * Tests whether the map with providers is initially empty.\r\n */\r\n@Test\r\nvoid testGetProvidersInitial() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    assertEquals(Collections.emptyMap(), params.getProviders());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testGetProvidersModify",
  "sourceCode" : "/**\r\n * Tests that the map with providers cannot be modified.\r\n */\r\n@Test\r\nvoid testGetProvidersModify() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    final Map<String, ConfigurationBuilderProvider> providers = params.getProviders();\r\n    final ConfigurationBuilderProvider provider = mock(ConfigurationBuilderProvider.class);\r\n    assertThrows(UnsupportedOperationException.class, () -> providers.put(\"tag\", provider));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testInheritFrom",
  "sourceCode" : "/**\r\n * Tests whether properties can be inherited.\r\n */\r\n@Test\r\nvoid testInheritFrom() {\r\n    final DefaultParametersManager manager = mock(DefaultParametersManager.class);\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl().setInheritSettings(false).setChildDefaultParametersManager(manager);\r\n    params.setThrowExceptionOnMissing(true);\r\n    final CombinedBuilderParametersImpl params2 = new CombinedBuilderParametersImpl();\r\n    params2.inheritFrom(params.getParameters());\r\n    final Map<String, Object> parameters = params2.getParameters();\r\n    assertEquals(Boolean.TRUE, parameters.get(\"throwExceptionOnMissing\"));\r\n    assertEquals(manager, params2.getChildDefaultParametersManager());\r\n    assertFalse(params2.isInheritSettings());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testInheritFromNoParametersInMap",
  "sourceCode" : "/**\r\n * Tests that inheritFrom() can handle a map which does not contain a parameters object.\r\n */\r\n@Test\r\nvoid testInheritFromNoParametersInMap() {\r\n    final BasicBuilderParameters params = new BasicBuilderParameters().setThrowExceptionOnMissing(true);\r\n    final CombinedBuilderParametersImpl params2 = new CombinedBuilderParametersImpl();\r\n    params2.inheritFrom(params.getParameters());\r\n    final Map<String, Object> parameters = params2.getParameters();\r\n    assertEquals(Boolean.TRUE, parameters.get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testProviderForUnknown",
  "sourceCode" : "/**\r\n * Tests the result for an unknown provider.\r\n */\r\n@Test\r\nvoid testProviderForUnknown() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    assertNull(params.providerForTag(\"someTag\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterChildDefaultsHandler",
  "sourceCode" : "/**\r\n * Tests whether a defaults handler for a child source can be registered.\r\n */\r\n@Test\r\nvoid testRegisterChildDefaultsHandler() {\r\n    final DefaultParametersManager manager = mock(DefaultParametersManager.class);\r\n    final DefaultParametersHandler<BuilderParameters> handler = createDefaultsHandlerMock();\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    params.setChildDefaultParametersManager(manager);\r\n    assertSame(params, params.registerChildDefaultsHandler(BuilderParameters.class, handler));\r\n    verify(manager).registerDefaultsHandler(BuilderParameters.class, handler);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterChildDefaultsHandlerWithStartClass",
  "sourceCode" : "/**\r\n * Tests whether a defaults handler for a child source with a class restriction can be registered.\r\n */\r\n@Test\r\nvoid testRegisterChildDefaultsHandlerWithStartClass() {\r\n    final DefaultParametersManager manager = mock(DefaultParametersManager.class);\r\n    final DefaultParametersHandler<BuilderParameters> handler = createDefaultsHandlerMock();\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    params.setChildDefaultParametersManager(manager);\r\n    assertSame(params, params.registerChildDefaultsHandler(BuilderParameters.class, handler, FileBasedBuilderParameters.class));\r\n    verify(manager).registerDefaultsHandler(BuilderParameters.class, handler, FileBasedBuilderParameters.class);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterMissingProviders",
  "sourceCode" : "/**\r\n * Tests whether missing providers can be registered.\r\n */\r\n@Test\r\nvoid testRegisterMissingProviders() {\r\n    final ConfigurationBuilderProvider provider1 = mock(ConfigurationBuilderProvider.class);\r\n    final ConfigurationBuilderProvider provider2 = mock(ConfigurationBuilderProvider.class);\r\n    final ConfigurationBuilderProvider provider3 = mock(ConfigurationBuilderProvider.class);\r\n    final String tagPrefix = \"testTag\";\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    params.registerProvider(tagPrefix, provider1);\r\n    final Map<String, ConfigurationBuilderProvider> map = new HashMap<>();\r\n    map.put(tagPrefix, provider2);\r\n    map.put(tagPrefix + 1, provider3);\r\n    assertSame(params, params.registerMissingProviders(map));\r\n    assertEquals(2, params.getProviders().size());\r\n    assertSame(provider1, params.providerForTag(tagPrefix));\r\n    assertSame(provider3, params.providerForTag(tagPrefix + 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterMissingProvidersNullEntry",
  "sourceCode" : "/**\r\n * Tries to register a map with missing providers containing a null entry.\r\n */\r\n@Test\r\nvoid testRegisterMissingProvidersNullEntry() {\r\n    final Map<String, ConfigurationBuilderProvider> map = new HashMap<>();\r\n    map.put(\"tag\", null);\r\n    final CombinedBuilderParametersImpl builderParameters = new CombinedBuilderParametersImpl();\r\n    assertThrows(IllegalArgumentException.class, () -> builderParameters.registerMissingProviders(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterMissingProvidersNullMap",
  "sourceCode" : "/**\r\n * Tries to register a null map with missing providers.\r\n */\r\n@Test\r\nvoid testRegisterMissingProvidersNullMap() {\r\n    final Map<String, ConfigurationBuilderProvider> map = null;\r\n    final CombinedBuilderParametersImpl builderParameters = new CombinedBuilderParametersImpl();\r\n    assertThrows(IllegalArgumentException.class, () -> builderParameters.registerMissingProviders(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterMissingProvidersParams",
  "sourceCode" : "/**\r\n * Tests whether missing providers can be copied from a parameters object.\r\n */\r\n@Test\r\nvoid testRegisterMissingProvidersParams() {\r\n    final ConfigurationBuilderProvider provider1 = mock(ConfigurationBuilderProvider.class);\r\n    final ConfigurationBuilderProvider provider2 = mock(ConfigurationBuilderProvider.class);\r\n    final ConfigurationBuilderProvider provider3 = mock(ConfigurationBuilderProvider.class);\r\n    final String tagPrefix = \"testTag\";\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    final CombinedBuilderParametersImpl params2 = new CombinedBuilderParametersImpl();\r\n    params.registerProvider(tagPrefix, provider1);\r\n    params2.registerProvider(tagPrefix, provider2);\r\n    params2.registerProvider(tagPrefix + 1, provider3);\r\n    assertSame(params, params.registerMissingProviders(params2));\r\n    assertEquals(2, params.getProviders().size());\r\n    assertSame(provider1, params.providerForTag(tagPrefix));\r\n    assertSame(provider3, params.providerForTag(tagPrefix + 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterMissingProvidersParamsNull",
  "sourceCode" : "/**\r\n * Tries to copy providers from a null parameters object.\r\n */\r\n@Test\r\nvoid testRegisterMissingProvidersParamsNull() {\r\n    final CombinedBuilderParametersImpl builderParameters = new CombinedBuilderParametersImpl();\r\n    assertThrows(IllegalArgumentException.class, () -> builderParameters.registerMissingProviders((CombinedBuilderParametersImpl) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterProvider",
  "sourceCode" : "/**\r\n * Tests whether a new builder provider can be registered.\r\n */\r\n@Test\r\nvoid testRegisterProvider() {\r\n    final ConfigurationBuilderProvider provider = mock(ConfigurationBuilderProvider.class);\r\n    final String tagName = \"testTag\";\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    assertSame(params, params.registerProvider(tagName, provider));\r\n    final Map<String, ConfigurationBuilderProvider> providers = params.getProviders();\r\n    assertEquals(1, providers.size());\r\n    assertSame(provider, providers.get(tagName));\r\n    assertSame(provider, params.providerForTag(tagName));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterProviderNoProvider",
  "sourceCode" : "/**\r\n * Tries to register a null provider.\r\n */\r\n@Test\r\nvoid testRegisterProviderNoProvider() {\r\n    final CombinedBuilderParametersImpl builderParameters = new CombinedBuilderParametersImpl();\r\n    assertThrows(IllegalArgumentException.class, () -> builderParameters.registerProvider(\"aTag\", null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testRegisterProviderNoTag",
  "sourceCode" : "/**\r\n * Tries to register a provider without a tag name.\r\n */\r\n@Test\r\nvoid testRegisterProviderNoTag() {\r\n    final CombinedBuilderParametersImpl builderParameters = new CombinedBuilderParametersImpl();\r\n    final ConfigurationBuilderProvider provider = mock(ConfigurationBuilderProvider.class);\r\n    assertThrows(IllegalArgumentException.class, () -> builderParameters.registerProvider(null, provider));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testSetBasePath",
  "sourceCode" : "/**\r\n * Tests whether the base path can be set.\r\n */\r\n@Test\r\nvoid testSetBasePath() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    final String basePath = ConfigurationAssert.OUT_DIR.getAbsolutePath();\r\n    assertSame(params, params.setBasePath(basePath));\r\n    assertEquals(basePath, params.getBasePath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testSetBeanProperties",
  "sourceCode" : "/**\r\n * Tests whether properties can be set using BeanUtils.\r\n */\r\n@Test\r\nvoid testSetBeanProperties() throws Exception {\r\n    final BuilderParameters defparams = mock(BuilderParameters.class);\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    BeanHelper.setProperty(params, \"basePath\", \"testPath\");\r\n    BeanHelper.setProperty(params, \"definitionBuilderParameters\", defparams);\r\n    BeanHelper.setProperty(params, \"inheritSettings\", false);\r\n    assertEquals(\"testPath\", params.getBasePath());\r\n    assertSame(defparams, params.getDefinitionBuilderParameters());\r\n    assertFalse(params.isInheritSettings());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testSetDefinitionBuilder",
  "sourceCode" : "/**\r\n * Tests whether the definition builder can be set.\r\n */\r\n@Test\r\nvoid testSetDefinitionBuilder() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    assertNull(params.getDefinitionBuilder());\r\n    final ConfigurationBuilder<XMLConfiguration> builder = new BasicConfigurationBuilder<>(XMLConfiguration.class);\r\n    assertSame(params, params.setDefinitionBuilder(builder));\r\n    assertSame(builder, params.getDefinitionBuilder());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testSetDefinitionBuilderParameters",
  "sourceCode" : "/**\r\n * Tests whether a parameters object for the definition builder can be set.\r\n */\r\n@Test\r\nvoid testSetDefinitionBuilderParameters() {\r\n    final BuilderParameters defparams = mock(BuilderParameters.class);\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    assertSame(params, params.setDefinitionBuilderParameters(defparams));\r\n    assertSame(defparams, params.getDefinitionBuilderParameters());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedBuilderParametersImpl.java",
  "methodName" : "testSetInheritSettings",
  "sourceCode" : "/**\r\n * Tests whether the flag that controls settings inheritance can be set.\r\n */\r\n@Test\r\nvoid testSetInheritSettings() {\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    assertTrue(params.isInheritSettings());\r\n    assertSame(params, params.setInheritSettings(false));\r\n    assertFalse(params.isInheritSettings());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testBasePathForChildConfigurations",
  "sourceCode" : "/**\r\n * Tests if the base path is correctly evaluated.\r\n */\r\n@Test\r\nvoid testBasePathForChildConfigurations() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration defConfig = new BaseHierarchicalConfiguration();\r\n    defConfig.addProperty(\"properties[@fileName]\", \"test.properties\");\r\n    final File deepDir = new File(ConfigurationAssert.TEST_DIR, \"config/deep\");\r\n    builder.configure(new CombinedBuilderParametersImpl().setBasePath(deepDir.getAbsolutePath()).setDefinitionBuilder(new ConstantConfigurationBuilder(defConfig)));\r\n    final CombinedConfiguration config = builder.getConfiguration();\r\n    assertEquals(\"somevalue\", config.getString(\"somekey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testBuilderNames",
  "sourceCode" : "/**\r\n * Tests whether the names of sub builders can be queried.\r\n */\r\n@Test\r\nvoid testBuilderNames() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    builder.getConfiguration();\r\n    final Set<String> names = builder.builderNames();\r\n    assertEquals(new HashSet<>(Arrays.asList(\"props\", \"xml\")), names);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testBuilderNamesBeforeConfigurationAccess",
  "sourceCode" : "/**\r\n * Tests the behavior of builderNames() before the result configuration has been created.\r\n */\r\n@Test\r\nvoid testBuilderNamesBeforeConfigurationAccess() {\r\n    assertEquals(Collections.emptySet(), builder.builderNames());\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    assertEquals(Collections.emptySet(), builder.builderNames());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testBuilderNamesManipulate",
  "sourceCode" : "/**\r\n * Tests that the collection with builder names cannot be manipulated.\r\n */\r\n@Test\r\nvoid testBuilderNamesManipulate() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    builder.getConfiguration();\r\n    final Set<String> names = builder.builderNames();\r\n    assertThrows(UnsupportedOperationException.class, () -> names.add(BUILDER_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testChildBuildersAreInitializedOnlyOnce",
  "sourceCode" : "/**\r\n * Tests that child configuration builders are not initialized multiple times. This test is releated to\r\n * CONFIGURATION-687.\r\n */\r\n@Test\r\nvoid testChildBuildersAreInitializedOnlyOnce() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    builder.getConfiguration();\r\n    builder.resetResult();\r\n    builder.getConfiguration();\r\n    final Collection<ConfigurationBuilder<? extends Configuration>> childBuilders = builder.getChildBuilders();\r\n    assertEquals(3, childBuilders.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCombinedConfigurationAttributes",
  "sourceCode" : "/**\r\n * Tests whether attributes are correctly set on the combined configurations for the override and additional sections.\r\n */\r\n@Test\r\nvoid testCombinedConfigurationAttributes() throws ConfigurationException {\r\n    final File initFile = ConfigurationAssert.getTestFile(\"testCCResultInitialization.xml\");\r\n    builder.configure(createParameters().setFile(initFile));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    checkCombinedConfigAttrs(cc);\r\n    final CombinedConfiguration cc2 = (CombinedConfiguration) cc.getConfiguration(CombinedConfigurationBuilder.ADDITIONAL_NAME);\r\n    checkCombinedConfigAttrs(cc2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCombinedConfigurationListNodes",
  "sourceCode" : "/**\r\n * Tests whether the list node definition was correctly processed.\r\n */\r\n@Test\r\nvoid testCombinedConfigurationListNodes() throws ConfigurationException {\r\n    final File initFile = ConfigurationAssert.getTestFile(\"testCCResultInitialization.xml\");\r\n    builder.configure(createParameters().setFile(initFile));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    Set<String> listNodes = cc.getNodeCombiner().getListNodes();\r\n    assertEquals(new HashSet<>(Arrays.asList(\"table\", \"list\")), listNodes);\r\n    final CombinedConfiguration cca = (CombinedConfiguration) cc.getConfiguration(CombinedConfigurationBuilder.ADDITIONAL_NAME);\r\n    listNodes = cca.getNodeCombiner().getListNodes();\r\n    assertEquals(Collections.emptySet(), listNodes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCombinedConfigurationNoAdditional",
  "sourceCode" : "/**\r\n * Tests the structure of the returned combined configuration if there is no additional section.\r\n */\r\n@Test\r\nvoid testCombinedConfigurationNoAdditional() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertNull(cc.getConfiguration(CombinedConfigurationBuilder.ADDITIONAL_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testConcurrentReadAccessWithoutSynchronizer",
  "sourceCode" : "/**\r\n * Tests whether a newly created instance can be read concurrently without a special synchronizer.\r\n */\r\n@Test\r\nvoid testConcurrentReadAccessWithoutSynchronizer() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    final CombinedConfiguration config = builder.getConfiguration();\r\n    final int threadCount = 32;\r\n    final CountDownLatch startLatch = new CountDownLatch(1);\r\n    final ReadThread[] threads = new ReadThread[threadCount];\r\n    for (int i = 0; i < threadCount; i++) {\r\n        threads[i] = new ReadThread(config, startLatch);\r\n        threads[i].start();\r\n    }\r\n    startLatch.countDown();\r\n    for (final ReadThread t : threads) {\r\n        t.verify();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testConfigurationBuilderProvider",
  "sourceCode" : "/**\r\n * Tests whether a configuration builder can itself be declared in a configuration definition file.\r\n */\r\n@Test\r\nvoid testConfigurationBuilderProvider() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration defConfig = new BaseHierarchicalConfiguration();\r\n    defConfig.addProperty(\"override.configuration[@fileName]\", TEST_FILE.getAbsolutePath());\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilder(new ConstantConfigurationBuilder(defConfig)));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n    checkProperties(cc);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testConfigurationBuilderProviderInheritBasePath",
  "sourceCode" : "/**\r\n * Tests whether the base path can be inherited to child combined configuration builders.\r\n */\r\n@Test\r\nvoid testConfigurationBuilderProviderInheritBasePath() throws ConfigurationException {\r\n    final File envFile = ConfigurationAssert.getTestFile(\"testCCEnvProperties.xml\");\r\n    final String basePath = ConfigurationAssert.OUT_DIR.getAbsolutePath();\r\n    builder.configure(new CombinedBuilderParametersImpl().setBasePath(basePath).setDefinitionBuilderParameters(createParameters().setFile(envFile)));\r\n    builder.getConfiguration();\r\n    final CombinedBuilderParametersImpl params = new CombinedBuilderParametersImpl();\r\n    builder.initChildBuilderParameters(params);\r\n    assertEquals(basePath, params.getBasePath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testConfigurationBuilderProviderInheritBasicProperties",
  "sourceCode" : "/**\r\n * Tests whether basic properties defined for the combined configuration are inherited by a child combined configuration\r\n * builder.\r\n */\r\n@Test\r\nvoid testConfigurationBuilderProviderInheritBasicProperties() throws ConfigurationException {\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testCCCombinedChildBuilder.xml\");\r\n    final ListDelimiterHandler listHandler = new DefaultListDelimiterHandler('*');\r\n    final ConfigurationDecoder decoder = mock(ConfigurationDecoder.class);\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilderParameters(new XMLBuilderParametersImpl().setFile(testFile)).setListDelimiterHandler(listHandler).setConfigurationDecoder(decoder));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    final CombinedConfiguration cc2 = (CombinedConfiguration) cc.getConfiguration(\"subcc\");\r\n    assertFalse(cc2.isThrowExceptionOnMissing());\r\n    assertEquals(listHandler, cc2.getListDelimiterHandler());\r\n    assertEquals(decoder, cc2.getConfigurationDecoder());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testConfigurationBuilderProviderInheritCustomProviders",
  "sourceCode" : "/**\r\n * Tests whether custom builder providers are inherited to child combined configuration builder providers.\r\n */\r\n@Test\r\nvoid testConfigurationBuilderProviderInheritCustomProviders() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(ConfigurationAssert.getTestFile(\"testCCCustomProvider.xml\")));\r\n    builder.getConfiguration();\r\n    final CombinedBuilderParametersImpl ccparams = new CombinedBuilderParametersImpl();\r\n    builder.initChildBuilderParameters(ccparams);\r\n    assertNotNull(ccparams.providerForTag(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testConfigurationBuilderProviderInheritEventListeners",
  "sourceCode" : "/**\r\n * Tests whether a child configuration builder inherits the event listeners from its parent.\r\n */\r\n@Test\r\nvoid testConfigurationBuilderProviderInheritEventListeners() throws ConfigurationException {\r\n    @SuppressWarnings(\"unchecked\")\r\n    final EventListener<Event> l1 = mock(EventListener.class);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final EventListener<ConfigurationEvent> l2 = mock(EventListener.class);\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testCCCombinedChildBuilder.xml\");\r\n    builder.configure(new XMLBuilderParametersImpl().setFile(testFile));\r\n    builder.addEventListener(Event.ANY, l1);\r\n    builder.addEventListener(ConfigurationEvent.ANY, l2);\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    final CombinedConfiguration cc2 = (CombinedConfiguration) cc.getConfiguration(\"subcc\");\r\n    final Collection<EventListener<? super ConfigurationEvent>> listeners = cc2.getEventListeners(ConfigurationEvent.ANY);\r\n    assertTrue(listeners.contains(l1));\r\n    assertTrue(listeners.contains(l2));\r\n    final Collection<EventListener<? super Event>> eventListeners = cc2.getEventListeners(Event.ANY);\r\n    assertEquals(1, eventListeners.size());\r\n    assertTrue(eventListeners.contains(l1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testConfigureEntityResolverWithProperties",
  "sourceCode" : "/**\r\n * Tests whether the entity resolver is initialized with other XML-related properties.\r\n */\r\n@Test\r\nvoid testConfigureEntityResolverWithProperties() throws ConfigurationException {\r\n    final HierarchicalConfiguration<ImmutableNode> config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(\"header.entity-resolver[@config-class]\", EntityResolverWithPropertiesTestImpl.class.getName());\r\n    final XMLBuilderParametersImpl xmlParams = new XMLBuilderParametersImpl();\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final String baseDir = ConfigurationAssert.OUT_DIR_NAME;\r\n    xmlParams.setBasePath(baseDir);\r\n    xmlParams.setFileSystem(fs);\r\n    builder.configureEntityResolver(config, xmlParams);\r\n    final EntityResolverWithPropertiesTestImpl resolver = (EntityResolverWithPropertiesTestImpl) xmlParams.getEntityResolver();\r\n    assertSame(fs, resolver.getFileSystem());\r\n    assertSame(baseDir, resolver.getBaseDir());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testConfigureResult",
  "sourceCode" : "/**\r\n * Tests that the return value of configure() is overloaded.\r\n */\r\n@Test\r\nvoid testConfigureResult() {\r\n    final CombinedConfigurationBuilder configuredBuilder = builder.configure(createParameters().setFile(TEST_FILE));\r\n    assertSame(builder, configuredBuilder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCustomBuilderProvider",
  "sourceCode" : "/**\r\n * Tests whether a custom provider can be registered.\r\n */\r\n@Test\r\nvoid testCustomBuilderProvider() throws ConfigurationException {\r\n    final String tagName = \"myTestTag\";\r\n    final BaseHierarchicalConfiguration dataConf = new BaseHierarchicalConfiguration();\r\n    dataConf.addProperty(tagName, Boolean.TRUE);\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    attrs.put(\"config-name\", BUILDER_NAME);\r\n    attrs.put(\"config-at\", \"tests\");\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilder(createDefinitionBuilder(createDefinitionConfig(tagName, attrs))).registerProvider(tagName, decl -> new ConstantConfigurationBuilder(dataConf)));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertEquals(dataConf, cc.getConfiguration(BUILDER_NAME));\r\n    assertEquals(Boolean.TRUE, cc.getProperty(\"tests.\" + tagName));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCustomEntityResolver",
  "sourceCode" : "/**\r\n * Tests whether an entity resolver can be defined in the definition file.\r\n */\r\n@Test\r\nvoid testCustomEntityResolver() throws ConfigurationException {\r\n    final File resolverFile = ConfigurationAssert.getTestFile(\"testCCEntityResolver.xml\");\r\n    builder.configure(createParameters().setFile(resolverFile));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    final XMLConfiguration xmlConf = (XMLConfiguration) cc.getConfiguration(\"xml\");\r\n    final EntityResolverWithPropertiesTestImpl resolver = (EntityResolverWithPropertiesTestImpl) xmlConf.getEntityResolver();\r\n    assertFalse(resolver.getInterpolator().getLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCustomFileSystem",
  "sourceCode" : "/**\r\n * Tests whether a default file system can be configured in the definition file.\r\n */\r\n@Test\r\nvoid testCustomFileSystem() throws ConfigurationException {\r\n    checkFileSystem(ConfigurationAssert.getTestFile(\"testCCFileSystem.xml\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCustomFileSystemForSubConfig",
  "sourceCode" : "/**\r\n * Tests whether a specific file system can be applied to a sub configuration.\r\n */\r\n@Test\r\nvoid testCustomFileSystemForSubConfig() throws ConfigurationException {\r\n    checkFileSystem(ConfigurationAssert.getTestFile(\"testCCFileSystemSubConfig.xml\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCustomLookup",
  "sourceCode" : "/**\r\n * Tests whether a Lookup object can be declared in the definition configuration.\r\n */\r\n@Test\r\nvoid testCustomLookup() throws ConfigurationException {\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testCCLookup.xml\");\r\n    builder.configure(createParameters().setFile(testFile));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertTrue(cc.getInterpolator().getLookups().containsKey(\"test\"));\r\n    final Configuration xmlConf = cc.getConfiguration(\"xml\");\r\n    assertTrue(xmlConf.getInterpolator().getLookups().containsKey(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testCustomResultConfiguration",
  "sourceCode" : "/**\r\n * Tests whether the resulting combined configuration can be customized.\r\n */\r\n@Test\r\nvoid testCustomResultConfiguration() throws ConfigurationException {\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testCCResultClass.xml\");\r\n    final ListDelimiterHandler listHandler = new DefaultListDelimiterHandler('.');\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilderParameters(new XMLBuilderParametersImpl().setFile(testFile)).setListDelimiterHandler(listHandler).setThrowExceptionOnMissing(false));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertInstanceOf(CombinedConfigurationTestImpl.class, cc);\r\n    assertTrue(cc.isThrowExceptionOnMissing());\r\n    assertEquals(listHandler, cc.getListDelimiterHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testDefaultBasePathFromDefinitionBuilder",
  "sourceCode" : "/**\r\n * Tests whether the default base path for file-based configurations is derived from the configuration definition\r\n * builder.\r\n */\r\n@Test\r\nvoid testDefaultBasePathFromDefinitionBuilder() throws ConfigurationException, IOException {\r\n    final String testFile = \"testCCSystemProperties.xml\";\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilderParameters(createParameters().setBasePath(ConfigurationAssert.TEST_DIR.getAbsolutePath()).setFileName(testFile)));\r\n    builder.getConfiguration();\r\n    final XMLBuilderParametersImpl xmlParams = new XMLBuilderParametersImpl();\r\n    builder.initChildBuilderParameters(xmlParams);\r\n    final File basePathFile = FileLocatorUtils.fileFromURL(new URL(xmlParams.getFileHandler().getBasePath()));\r\n    assertEquals(ConfigurationAssert.getTestFile(testFile).getAbsoluteFile(), basePathFile);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testDefaultBasePathInParameters",
  "sourceCode" : "/**\r\n * Tests whether a default base path for all file-based child configurations can be set in the builder parameters.\r\n */\r\n@Test\r\nvoid testDefaultBasePathInParameters() throws ConfigurationException {\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testCCSystemProperties.xml\");\r\n    final String basePath = ConfigurationAssert.OUT_DIR.getAbsolutePath();\r\n    builder.configure(new CombinedBuilderParametersImpl().setBasePath(basePath).setDefinitionBuilderParameters(createParameters().setFile(testFile)));\r\n    builder.getConfiguration();\r\n    final XMLBuilderParametersImpl xmlParams = new XMLBuilderParametersImpl();\r\n    builder.initChildBuilderParameters(xmlParams);\r\n    assertEquals(basePath, xmlParams.getFileHandler().getBasePath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testEnvironmentProperties",
  "sourceCode" : "/**\r\n * Tests whether environment properties can be added as a configuration source.\r\n */\r\n@Test\r\nvoid testEnvironmentProperties() throws ConfigurationException {\r\n    final File envFile = ConfigurationAssert.getTestFile(\"testCCEnvProperties.xml\");\r\n    builder.configure(createParameters().setFile(envFile));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertFalse(cc.isEmpty());\r\n    // The environment may contain settings with values that\r\n    // are altered by interpolation. Disable this for direct access\r\n    // to the String associated with the environment property name.\r\n    cc.setInterpolator(null);\r\n    // Test the environment is available through the configuration\r\n    for (final Map.Entry<String, String> e : System.getenv().entrySet()) {\r\n        assertEquals(e.getValue(), cc.getString(e.getKey()), \"Wrong value for property: \" + e.getKey());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testGetChildBuilders",
  "sourceCode" : "/**\r\n * Tests whether all child builders can be obtained.\r\n */\r\n@Test\r\nvoid testGetChildBuilders() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    builder.getConfiguration();\r\n    final Collection<ConfigurationBuilder<? extends Configuration>> childBuilders = builder.getChildBuilders();\r\n    assertEquals(3, childBuilders.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testGetNamedBuilder",
  "sourceCode" : "/**\r\n * Tests whether named builders can be accessed.\r\n */\r\n@Test\r\nvoid testGetNamedBuilder() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    builder.getConfiguration();\r\n    final ConfigurationBuilder<? extends Configuration> propBuilder = builder.getNamedBuilder(\"props\");\r\n    assertInstanceOf(FileBasedConfigurationBuilder.class, propBuilder);\r\n    assertInstanceOf(PropertiesConfiguration.class, propBuilder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testGetNamedBuilderBeforeConfigurationAccess",
  "sourceCode" : "/**\r\n * Tries to query a named builder before the result configuration has been created.\r\n */\r\n@Test\r\nvoid testGetNamedBuilderBeforeConfigurationAccess() {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    assertThrows(ConfigurationException.class, () -> builder.getNamedBuilder(\"nonExistingBuilder\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testGetNamedBuilderUnknown",
  "sourceCode" : "/**\r\n * Tries to query a non-existing builder by name.\r\n */\r\n@Test\r\nvoid testGetNamedBuilderUnknown() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    builder.getConfiguration();\r\n    assertThrows(ConfigurationException.class, () -> builder.getNamedBuilder(\"nonExistingBuilder\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testInheritProperties",
  "sourceCode" : "/**\r\n * Tests whether builder properties can be inherited by child builders.\r\n */\r\n@Test\r\nvoid testInheritProperties() throws ConfigurationException {\r\n    final Parameters params = new Parameters();\r\n    final XMLBuilderParameters xmlParams = prepareParamsForInheritanceTest(params);\r\n    builder.configure(xmlParams);\r\n    final CombinedConfiguration config = builder.getConfiguration();\r\n    List<String> list = config.getList(String.class, \"test/mixed/array\");\r\n    assertTrue(list.size() > 2);\r\n    final String[] stringArray = config.getStringArray(\"test/mixed/array\");\r\n    assertTrue(stringArray.length > 2);\r\n    final XMLConfiguration xmlConfig = (XMLConfiguration) config.getConfiguration(\"xml\");\r\n    list = xmlConfig.getList(String.class, \"split/list1\");\r\n    assertEquals(3, list.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testINIConfiguration",
  "sourceCode" : "/**\r\n * Tests whether an INI configuration source can be added to the combined configuration.\r\n */\r\n@Test\r\nvoid testINIConfiguration() throws ConfigurationException {\r\n    final File multiFile = ConfigurationAssert.getTestFile(\"testDigesterConfiguration3.xml\");\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilderParameters(createParameters().setFile(multiFile)));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertEquals(\"yes\", cc.getString(\"testini.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testInitChildBuilderParametersDefaultChildProperties",
  "sourceCode" : "/**\r\n * Tests whether default child properties in the combined builder's configuration are inherited by child parameter\r\n * objects.\r\n */\r\n@Test\r\nvoid testInitChildBuilderParametersDefaultChildProperties() throws ConfigurationException {\r\n    final Long defRefresh = 60000L;\r\n    final Long xmlRefresh = 30000L;\r\n    builder.configure(parameters.combined().setDefinitionBuilderParameters(parameters.fileBased().setFile(TEST_FILE)).registerChildDefaultsHandler(FileBasedBuilderProperties.class, new CopyObjectDefaultHandler(new FileBasedBuilderParametersImpl().setReloadingRefreshDelay(defRefresh).setThrowExceptionOnMissing(true))).registerChildDefaultsHandler(XMLBuilderProperties.class, new CopyObjectDefaultHandler(new XMLBuilderParametersImpl().setValidating(false).setExpressionEngine(new XPathExpressionEngine()).setReloadingRefreshDelay(xmlRefresh))));\r\n    builder.getConfiguration();\r\n    final XMLBuilderParametersImpl params = new XMLBuilderParametersImpl();\r\n    builder.initChildBuilderParameters(params);\r\n    assertInstanceOf(XPathExpressionEngine.class, params.getParameters().get(\"expressionEngine\"));\r\n    assertEquals(Boolean.FALSE, params.getParameters().get(\"validating\"));\r\n    assertEquals(xmlRefresh, params.getReloadingRefreshDelay());\r\n    assertEquals(Boolean.TRUE, params.getParameters().get(\"throwExceptionOnMissing\"));\r\n    final PropertiesBuilderParametersImpl params2 = new PropertiesBuilderParametersImpl();\r\n    builder.initChildBuilderParameters(params2);\r\n    assertEquals(defRefresh, params2.getReloadingRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testInterpolationOverMultipleSources",
  "sourceCode" : "/**\r\n * Tests whether variable substitution works across multiple child configurations and also in the definition\r\n * configuration.\r\n */\r\n@Test\r\nvoid testInterpolationOverMultipleSources() throws ConfigurationException {\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testInterpolationBuilder.xml\");\r\n    builder.configure(createParameters().setFile(testFile));\r\n    final CombinedConfiguration combConfig = builder.getConfiguration();\r\n    assertEquals(\"abc-product\", combConfig.getString(\"products.product.desc\"));\r\n    final XMLConfiguration xmlConfig = (XMLConfiguration) combConfig.getConfiguration(\"test\");\r\n    assertEquals(\"abc-product\", xmlConfig.getString(\"products/product/desc\"));\r\n    final HierarchicalConfiguration<ImmutableNode> subConfig = xmlConfig.configurationAt(\"products/product[@name='abc']\", true);\r\n    assertEquals(\"abc-product\", subConfig.getString(\"desc\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testJndiConfiguration",
  "sourceCode" : "/**\r\n * Tests whether a JNDI configuration can be integrated into the combined configuration.\r\n */\r\n@Test\r\nvoid testJndiConfiguration() throws ConfigurationException {\r\n    final File multiFile = ConfigurationAssert.getTestFile(\"testDigesterConfiguration3.xml\");\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilderParameters(createParameters().setFile(multiFile)));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertTrue(cc.getBoolean(\"test.onlyinjndi\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testLoadAdditional",
  "sourceCode" : "/**\r\n * Tests loading a configuration definition file with an additional section.\r\n */\r\n@Test\r\nvoid testLoadAdditional() throws ConfigurationException {\r\n    final File additonalFile = ConfigurationAssert.getTestFile(\"testDigesterConfiguration2.xml\");\r\n    builder.configure(createParameters().setFile(additonalFile));\r\n    final CombinedConfiguration compositeConfiguration = builder.getConfiguration();\r\n    assertEquals(2, compositeConfiguration.getNumberOfConfigurations());\r\n    // Test if union was constructed correctly\r\n    Object prop = compositeConfiguration.getProperty(\"tables.table.name\");\r\n    Collection<?> collection = assertInstanceOf(Collection.class, prop);\r\n    assertEquals(3, collection.size());\r\n    assertEquals(\"users\", compositeConfiguration.getProperty(\"tables.table(0).name\"));\r\n    assertEquals(\"documents\", compositeConfiguration.getProperty(\"tables.table(1).name\"));\r\n    assertEquals(\"tasks\", compositeConfiguration.getProperty(\"tables.table(2).name\"));\r\n    prop = compositeConfiguration.getProperty(\"tables.table.fields.field.name\");\r\n    collection = assertInstanceOf(Collection.class, prop);\r\n    assertEquals(17, collection.size());\r\n    assertEquals(\"smtp.mydomain.org\", compositeConfiguration.getString(\"mail.host.smtp\"));\r\n    assertEquals(\"pop3.mydomain.org\", compositeConfiguration.getString(\"mail.host.pop\"));\r\n    // This was overridden\r\n    assertEquals(\"masterOfPost\", compositeConfiguration.getString(\"mail.account.user\"));\r\n    assertEquals(\"topsecret\", compositeConfiguration.getString(\"mail.account.psswd\"));\r\n    // This was overridden, too, but not in additional section\r\n    assertEquals(\"enhanced factory\", compositeConfiguration.getString(\"test.configuration\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testLoadConfiguration",
  "sourceCode" : "/**\r\n * Tests loading a simple configuration definition file.\r\n */\r\n@Test\r\nvoid testLoadConfiguration() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    checkConfiguration();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testLoadOptional",
  "sourceCode" : "/**\r\n * Tests loading a definition file that contains optional configurations.\r\n */\r\n@Test\r\nvoid testLoadOptional() throws Exception {\r\n    final File optionalFile = ConfigurationAssert.getTestFile(\"testDigesterOptionalConfiguration.xml\");\r\n    builder.configure(createParameters().setFile(optionalFile));\r\n    final Configuration config = builder.getConfiguration();\r\n    assertTrue(config.getBoolean(\"test.boolean\"));\r\n    assertEquals(\"value\", config.getProperty(\"element\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testLoadOptionalForceCreate",
  "sourceCode" : "/**\r\n * Tests whether the force-create attribute is taken into account.\r\n */\r\n@Test\r\nvoid testLoadOptionalForceCreate() throws ConfigurationException {\r\n    final String name = \"optionalConfig\";\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    attrs.put(\"fileName\", \"nonExisting.xml\");\r\n    attrs.put(\"config-name\", name);\r\n    attrs.put(\"config-optional\", Boolean.TRUE);\r\n    attrs.put(\"config-forceCreate\", Boolean.TRUE);\r\n    final BaseHierarchicalConfiguration defConfig = createDefinitionConfig(\"xml\", attrs);\r\n    final BasicConfigurationBuilder<? extends BaseHierarchicalConfiguration> defBuilder = createDefinitionBuilder(defConfig);\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilder(defBuilder));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n    assertInstanceOf(XMLConfiguration.class, cc.getConfiguration(name));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testLoadOptionalWithException",
  "sourceCode" : "/**\r\n * Tests loading a definition file with optional and non optional configuration sources. One non optional does not\r\n * exist, so this should cause an exception.\r\n */\r\n@Test\r\nvoid testLoadOptionalWithException() {\r\n    final File optionalExFile = ConfigurationAssert.getTestFile(\"testDigesterOptionalConfigurationEx.xml\");\r\n    builder.configure(createParameters().setFile(optionalExFile));\r\n    assertThrows(ConfigurationException.class, builder::getConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testMultiTenentConfiguration",
  "sourceCode" : "/**\r\n * Tests whether a MultiFileConfigurationBuilder can be integrated into a combined configuration definition.\r\n */\r\n@Test\r\nvoid testMultiTenentConfiguration() throws ConfigurationException {\r\n    final CombinedConfiguration config = createMultiFileConfig(\"testCCMultiTenent.xml\");\r\n    checkMultiFile(\"1001\", config, 15);\r\n    checkMultiFile(\"1002\", config, 25);\r\n    checkMultiFile(\"1003\", config, 35);\r\n    checkMultiFile(\"1004\", config, 50);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testMultiTenentConfigurationProperties",
  "sourceCode" : "/**\r\n * Tests whether a configuration created by a MultiFileConfigurationBuilder has been initialized correctly.\r\n */\r\n@Test\r\nvoid testMultiTenentConfigurationProperties() throws ConfigurationException {\r\n    final CombinedConfiguration config = createMultiFileConfig(\"testCCMultiTenent.xml\");\r\n    switchToMultiFile(\"1001\");\r\n    final HierarchicalConfiguration<?> multiConf = (HierarchicalConfiguration<?>) config.getConfiguration(\"clientConfig\");\r\n    assertInstanceOf(XPathExpressionEngine.class, multiConf.getExpressionEngine());\r\n    assertEquals(\"#808080\", config.getString(\"colors.background\"));\r\n    assertEquals(\"#000000\", multiConf.getString(\"colors/text\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testMultiTenentConfigurationReloading",
  "sourceCode" : "/**\r\n * Tests whether reloading support works for MultiFileConfigurationBuilder.\r\n */\r\n@Test\r\nvoid testMultiTenentConfigurationReloading() throws ConfigurationException, InterruptedException {\r\n    final CombinedConfiguration config = createMultiFileConfig(\"testCCMultiTenentReloading.xml\");\r\n    final File outFile = ConfigurationAssert.getOutFile(\"MultiFileReloadingTest.xml\");\r\n    switchToMultiFile(outFile.getAbsolutePath());\r\n    final XMLConfiguration reloadConfig = new XMLConfiguration();\r\n    final FileHandler handler = new FileHandler(reloadConfig);\r\n    handler.setFile(outFile);\r\n    final String key = \"test.reload\";\r\n    reloadConfig.setProperty(key, \"no\");\r\n    handler.save();\r\n    try {\r\n        assertEquals(\"no\", config.getString(key));\r\n        final ConfigurationBuilder<? extends Configuration> childBuilder = builder.getNamedBuilder(\"clientConfig\");\r\n        final ReloadingControllerSupport reloadingControllerSupport = assertInstanceOf(ReloadingControllerSupport.class, childBuilder);\r\n        final ReloadingController ctrl = reloadingControllerSupport.getReloadingController();\r\n        // initialize reloading\r\n        ctrl.checkForReloading(null);\r\n        final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n        childBuilder.addEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n        reloadConfig.setProperty(key, \"yes\");\r\n        handler.save();\r\n        int attempts = 10;\r\n        boolean changeDetected;\r\n        do {\r\n            changeDetected = ctrl.checkForReloading(null);\r\n            if (!changeDetected) {\r\n                Thread.sleep(1000);\r\n                handler.save(outFile);\r\n            }\r\n        } while (!changeDetected && --attempts > 0);\r\n        assertTrue(changeDetected);\r\n        assertEquals(\"yes\", builder.getConfiguration().getString(key));\r\n        final ConfigurationBuilderEvent event = listener.nextEvent(ConfigurationBuilderEvent.RESET);\r\n        listener.assertNoMoreEvents();\r\n        final BasicConfigurationBuilder<?> multiBuilder = (BasicConfigurationBuilder<?>) event.getSource();\r\n        childBuilder.removeEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n        multiBuilder.resetResult();\r\n        listener.assertNoMoreEvents();\r\n    } finally {\r\n        assertTrue(outFile.delete());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testNoDefinitionBuilder",
  "sourceCode" : "/**\r\n * Tries to build a configuration if no definition builder is provided.\r\n */\r\n@Test\r\nvoid testNoDefinitionBuilder() {\r\n    assertThrows(ConfigurationException.class, builder::getConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testProviderInDefinitionConfig",
  "sourceCode" : "/**\r\n * Tests whether a custom provider can be defined in the definition file.\r\n */\r\n@Test\r\nvoid testProviderInDefinitionConfig() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(ConfigurationAssert.getTestFile(\"testCCCustomProvider.xml\")));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertTrue(cc.getBoolean(\"testKey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testReactOnSubBuilderChange",
  "sourceCode" : "/**\r\n * Tests whether a reset of one of the sub builders causes the combined configuration to be re-created.\r\n */\r\n@Test\r\nvoid testReactOnSubBuilderChange() throws ConfigurationException {\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    prepareSubBuilderTest(attrs);\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    final BasicConfigurationBuilder<?> subBuilder = (BasicConfigurationBuilder<?>) builder.getNamedBuilder(BUILDER_NAME);\r\n    subBuilder.reset();\r\n    assertNotSame(cc, builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testReloadingBuilder",
  "sourceCode" : "/**\r\n * Tests whether a reloading sub builder can be created.\r\n */\r\n@Test\r\nvoid testReloadingBuilder() throws ConfigurationException {\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    attrs.put(\"config-reload\", Boolean.TRUE);\r\n    prepareSubBuilderTest(attrs);\r\n    builder.getConfiguration();\r\n    assertInstanceOf(ReloadingFileBasedConfigurationBuilder.class, builder.getNamedBuilder(BUILDER_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testRemoveSubBuilderListener",
  "sourceCode" : "/**\r\n * Tests that change listeners registered at sub builders are removed on a reset.\r\n */\r\n@Test\r\nvoid testRemoveSubBuilderListener() throws ConfigurationException {\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    prepareSubBuilderTest(attrs);\r\n    builder.getConfiguration();\r\n    final BasicConfigurationBuilder<?> subBuilder = (BasicConfigurationBuilder<?>) builder.getNamedBuilder(BUILDER_NAME);\r\n    builder.reset();\r\n    prepareSubBuilderTest(attrs);\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    final BasicConfigurationBuilder<?> subBuilder2 = (BasicConfigurationBuilder<?>) builder.getNamedBuilder(BUILDER_NAME);\r\n    assertNotSame(subBuilder, subBuilder2);\r\n    subBuilder.reset();\r\n    assertSame(cc, builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testResetBuilder",
  "sourceCode" : "/**\r\n * Tests a reset of the builder. The configuration instance should be created anew.\r\n */\r\n@Test\r\nvoid testResetBuilder() throws ConfigurationException {\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    final BasicConfigurationBuilder<? extends HierarchicalConfiguration<ImmutableNode>> defBuilder = prepareSubBuilderTest(attrs);\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    final ConfigurationBuilder<? extends Configuration> subBuilder = builder.getNamedBuilder(BUILDER_NAME);\r\n    defBuilder.reset();\r\n    final CombinedConfiguration cc2 = builder.getConfiguration();\r\n    assertNotSame(cc, cc2);\r\n    final ConfigurationBuilder<? extends Configuration> subBuilder2 = builder.getNamedBuilder(BUILDER_NAME);\r\n    assertNotSame(subBuilder, subBuilder2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testRootNodeInitializedAfterCreation",
  "sourceCode" : "/**\r\n * Tests that the combined configuration has been fully constructed (including its root node) when it is returned from\r\n * the builder.\r\n */\r\n@Test\r\nvoid testRootNodeInitializedAfterCreation() throws ConfigurationException {\r\n    builder.configure(createParameters().setFile(TEST_FILE));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertNotNull(cc.getNodeModel().getNodeHandler().getRootNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testSuppressChildBuilderPropertyInheritance",
  "sourceCode" : "/**\r\n * Tests whether the inheritance of builder properties can be disabled.\r\n */\r\n@Test\r\nvoid testSuppressChildBuilderPropertyInheritance() throws ConfigurationException {\r\n    final Parameters params = new Parameters();\r\n    final CombinedBuilderParameters combinedParams = params.combined().setInheritSettings(false);\r\n    builder.configure(combinedParams, prepareParamsForInheritanceTest(params));\r\n    final CombinedConfiguration config = builder.getConfiguration();\r\n    final XMLConfiguration xmlConfig = (XMLConfiguration) config.getConfiguration(\"xml\");\r\n    final List<String> list = xmlConfig.getList(String.class, \"split.list1\");\r\n    assertEquals(1, list.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilder.java",
  "methodName" : "testSystemProperties",
  "sourceCode" : "/**\r\n * Tests whether a file with system properties can be specified in the configuration definition file and that system\r\n * properties can be added to the resulting configuration.\r\n */\r\n@Test\r\nvoid testSystemProperties() throws ConfigurationException {\r\n    final File systemFile = ConfigurationAssert.getTestFile(\"testCCSystemProperties.xml\");\r\n    builder.configure(createParameters().setFile(systemFile));\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertTrue(cc.containsKey(\"user.name\"));\r\n    assertEquals(\"value1\", System.getProperty(\"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestCombinedConfigurationBuilderVFS.java",
  "methodName" : "testSetConfigurationBasePath",
  "sourceCode" : "/**\r\n * Tests if the base path is correctly evaluated.\r\n */\r\n@Test\r\nvoid testSetConfigurationBasePath() throws ConfigurationException {\r\n    final File deepDir = new File(ConfigurationAssert.TEST_DIR, \"config/deep\");\r\n    final Map<String, Object> params = new HashMap<>();\r\n    params.put(\"fileName\", \"test.properties\");\r\n    final BaseHierarchicalConfiguration defConfig = createDefinitionConfig(\"properties\", params);\r\n    defConfig.addProperty(\"override.properties.fileSystem[@config-class]\", VFSFileSystem.class.getName());\r\n    final BasicConfigurationBuilder<? extends HierarchicalConfiguration<ImmutableNode>> defBuilder = createDefinitionBuilder(defConfig);\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilder(defBuilder).setBasePath(deepDir.getAbsolutePath()));\r\n    final Configuration config = builder.getConfiguration();\r\n    assertEquals(\"somevalue\", config.getString(\"somekey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestConfigurationDeclaration.java",
  "methodName" : "testConfigurationDeclarationGetAttributes",
  "sourceCode" : "/**\r\n * Tests access to certain reserved attributes of a ConfigurationDeclaration.\r\n */\r\n@Test\r\nvoid testConfigurationDeclarationGetAttributes() {\r\n    final HierarchicalConfiguration<?> config = new BaseHierarchicalConfiguration();\r\n    config.addProperty(\"xml.fileName\", \"test.xml\");\r\n    ConfigurationDeclaration decl = createDeclaration(config.configurationAt(\"xml\"));\r\n    assertNull(decl.getAt());\r\n    assertFalse(decl.isOptional());\r\n    config.addProperty(\"xml[@config-at]\", \"test1\");\r\n    decl = createDeclaration(config.configurationAt(\"xml\"));\r\n    assertEquals(\"test1\", decl.getAt());\r\n    config.addProperty(\"xml[@at]\", \"test2\");\r\n    decl = createDeclaration(config.configurationAt(\"xml\"));\r\n    assertEquals(\"test1\", decl.getAt());\r\n    config.clearProperty(\"xml[@config-at]\");\r\n    decl = createDeclaration(config.configurationAt(\"xml\"));\r\n    assertEquals(\"test2\", decl.getAt());\r\n    config.addProperty(\"xml[@config-optional]\", \"true\");\r\n    decl = createDeclaration(config.configurationAt(\"xml\"));\r\n    assertTrue(decl.isOptional());\r\n    config.addProperty(\"xml[@optional]\", \"false\");\r\n    decl = createDeclaration(config.configurationAt(\"xml\"));\r\n    assertTrue(decl.isOptional());\r\n    config.clearProperty(\"xml[@config-optional]\");\r\n    config.setProperty(\"xml[@optional]\", Boolean.TRUE);\r\n    decl = createDeclaration(config.configurationAt(\"xml\"));\r\n    assertTrue(decl.isOptional());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestConfigurationDeclaration.java",
  "methodName" : "testConfigurationDeclarationIsReserved",
  "sourceCode" : "/**\r\n * Tests the isReservedNode() method of ConfigurationDeclaration.\r\n */\r\n@Test\r\nvoid testConfigurationDeclarationIsReserved() {\r\n    final ConfigurationDeclaration decl = createDeclaration(null);\r\n    assertTrue(decl.isReservedAttributeName(\"at\"));\r\n    assertTrue(decl.isReservedAttributeName(\"optional\"));\r\n    assertTrue(decl.isReservedAttributeName(\"config-class\"));\r\n    assertFalse(decl.isReservedAttributeName(\"different\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestConfigurationDeclaration.java",
  "methodName" : "testConfigurationDeclarationIsReservedAt",
  "sourceCode" : "/**\r\n * Tests if the at attribute is correctly detected as reserved attribute.\r\n */\r\n@Test\r\nvoid testConfigurationDeclarationIsReservedAt() {\r\n    checkOldReservedAttribute(\"at\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestConfigurationDeclaration.java",
  "methodName" : "testConfigurationDeclarationIsReservedOptional",
  "sourceCode" : "/**\r\n * Tests if the optional attribute is correctly detected as reserved attribute.\r\n */\r\n@Test\r\nvoid testConfigurationDeclarationIsReservedOptional() {\r\n    checkOldReservedAttribute(\"optional\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestConfigurationDeclaration.java",
  "methodName" : "testConfigurationDeclarationOptionalAttributeInvalid",
  "sourceCode" : "/**\r\n * Tests whether an invalid value of an optional attribute is detected.\r\n */\r\n@Test\r\nvoid testConfigurationDeclarationOptionalAttributeInvalid() {\r\n    final HierarchicalConfiguration<?> factory = new BaseHierarchicalConfiguration();\r\n    factory.addProperty(\"xml.fileName\", \"test.xml\");\r\n    factory.setProperty(\"xml[@optional]\", \"invalid value\");\r\n    final ConfigurationDeclaration decl = createDeclaration(factory.configurationAt(\"xml\"));\r\n    assertThrows(ConfigurationRuntimeException.class, decl::isOptional);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testDetermineConfigurationClassExtensionMatch",
  "sourceCode" : "/**\r\n * Tests whether the correct configuration class is selected if the file extension matches.\r\n */\r\n@Test\r\nvoid testDetermineConfigurationClassExtensionMatch() throws ConfigurationException {\r\n    final ConfigurationDeclaration decl = setUpDecl();\r\n    final BuilderParameters params = new FileBasedBuilderParametersImpl().setPath(\"C:\\\\Test\\\\someTestConfiguration.\" + EXT);\r\n    final FileExtensionConfigurationBuilderProvider provider = setUpProvider();\r\n    assertEquals(MATCH_CLASS, provider.determineConfigurationClass(decl, Collections.singleton(params)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testDetermineConfigurationClassExtensionNoMatch",
  "sourceCode" : "/**\r\n * Tests whether the correct configuration class is selected if the file extension does not match.\r\n */\r\n@Test\r\nvoid testDetermineConfigurationClassExtensionNoMatch() throws ConfigurationException {\r\n    final ConfigurationDeclaration decl = setUpDecl();\r\n    final BuilderParameters params = new FileBasedBuilderParametersImpl().setPath(\"C:\\\\Test\\\\someTestConfiguration.properties\");\r\n    final FileExtensionConfigurationBuilderProvider provider = setUpProvider();\r\n    assertEquals(DEF_CLASS, provider.determineConfigurationClass(decl, Collections.singleton(params)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testDetermineConfigurationClassMatchCase",
  "sourceCode" : "/**\r\n * Tests that matches of file extensions are case insensitive.\r\n */\r\n@Test\r\nvoid testDetermineConfigurationClassMatchCase() throws ConfigurationException {\r\n    final ConfigurationDeclaration decl = setUpDecl();\r\n    final BuilderParameters params = new FileBasedBuilderParametersImpl().setPath(\"C:\\\\Test\\\\someTestConfiguration.\" + StringUtils.toRootUpperCase(EXT));\r\n    final FileExtensionConfigurationBuilderProvider provider = setUpProvider();\r\n    assertEquals(MATCH_CLASS, provider.determineConfigurationClass(decl, Collections.singleton(params)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testDetermineConfigurationClassNoExtension",
  "sourceCode" : "/**\r\n * Tests whether the correct configuration class is selected if the file name does not have an extension.\r\n */\r\n@Test\r\nvoid testDetermineConfigurationClassNoExtension() throws ConfigurationException {\r\n    final ConfigurationDeclaration decl = setUpDecl();\r\n    final BuilderParameters params = new FileBasedBuilderParametersImpl().setPath(\"C:\\\\Test\\\\someTestConfiguration\");\r\n    final FileExtensionConfigurationBuilderProvider provider = setUpProvider();\r\n    assertEquals(DEF_CLASS, provider.determineConfigurationClass(decl, Collections.singleton(params)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testDetermineConfigurationClassNoParams",
  "sourceCode" : "/**\r\n * Tests whether the correct configuration class is selected if no file-based parameters are provided.\r\n */\r\n@Test\r\nvoid testDetermineConfigurationClassNoParams() throws ConfigurationException {\r\n    final ConfigurationDeclaration decl = setUpDecl();\r\n    final FileExtensionConfigurationBuilderProvider provider = setUpProvider();\r\n    assertEquals(DEF_CLASS, provider.determineConfigurationClass(decl, new ArrayList<>()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testDeterminieConfigurationClassNoFileName",
  "sourceCode" : "/**\r\n * Tests whether the correct configuration class is selected if no file name is set.\r\n */\r\n@Test\r\nvoid testDeterminieConfigurationClassNoFileName() throws ConfigurationException {\r\n    final ConfigurationDeclaration decl = setUpDecl();\r\n    final BuilderParameters params = new FileBasedBuilderParametersImpl();\r\n    final FileExtensionConfigurationBuilderProvider provider = setUpProvider();\r\n    assertEquals(DEF_CLASS, provider.determineConfigurationClass(decl, Collections.singleton(params)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testInitNoDefaultConfigClass",
  "sourceCode" : "/**\r\n * Tries to create an instance without the default configuration class.\r\n */\r\n@Test\r\nvoid testInitNoDefaultConfigClass() {\r\n    final String builderClass = BasicConfigurationBuilder.class.getName();\r\n    assertThrows(IllegalArgumentException.class, () -> new FileExtensionConfigurationBuilderProvider(builderClass, null, MATCH_CLASS, null, EXT, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testInitNoExt",
  "sourceCode" : "/**\r\n * Tries to create an instance without a file extension.\r\n */\r\n@Test\r\nvoid testInitNoExt() {\r\n    final String builderClass = BasicConfigurationBuilder.class.getName();\r\n    assertThrows(IllegalArgumentException.class, () -> new FileExtensionConfigurationBuilderProvider(builderClass, null, MATCH_CLASS, DEF_CLASS, null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testInitNoMatchingConfigClass",
  "sourceCode" : "/**\r\n * Tries to create an instance without the matching configuration class.\r\n */\r\n@Test\r\nvoid testInitNoMatchingConfigClass() {\r\n    final String builderClass = BasicConfigurationBuilder.class.getName();\r\n    assertThrows(IllegalArgumentException.class, () -> new FileExtensionConfigurationBuilderProvider(builderClass, null, null, DEF_CLASS, EXT, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestFileExtensionConfigurationBuilderProvider.java",
  "methodName" : "testInitSuper",
  "sourceCode" : "/**\r\n * Tests whether the super class is correctly initialized.\r\n */\r\n@Test\r\nvoid testInitSuper() {\r\n    final FileExtensionConfigurationBuilderProvider provider = new FileExtensionConfigurationBuilderProvider(BasicConfigurationBuilder.class.getName(), ReloadingFileBasedConfigurationBuilder.class.getName(), MATCH_CLASS, DEF_CLASS, EXT, null);\r\n    assertEquals(BasicConfigurationBuilder.class.getName(), provider.getBuilderClass());\r\n    assertEquals(ReloadingFileBasedConfigurationBuilder.class.getName(), provider.getReloadingBuilderClass());\r\n    assertEquals(DEF_CLASS, provider.getConfigurationClass());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileBuilderParametersImpl.java",
  "methodName" : "testBeanProperties",
  "sourceCode" : "/**\r\n * Tests whether bean property access is possible.\r\n */\r\n@Test\r\nvoid testBeanProperties() throws Exception {\r\n    final BuilderParameters bp = mock(BuilderParameters.class);\r\n    final String pattern = \"testPattern\";\r\n    BeanHelper.setProperty(params, \"filePattern\", pattern);\r\n    BeanHelper.setProperty(params, \"managedBuilderParameters\", bp);\r\n    BeanHelper.setProperty(params, \"throwExceptionOnMissing\", Boolean.TRUE);\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertEquals(Boolean.TRUE, map.get(\"throwExceptionOnMissing\"));\r\n    assertSame(params, MultiFileBuilderParametersImpl.fromParameters(map));\r\n    assertEquals(pattern, params.getFilePattern());\r\n    assertSame(bp, params.getManagedBuilderParameters());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileBuilderParametersImpl.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests extended cloning functionality.\r\n */\r\n@Test\r\nvoid testClone() {\r\n    final FileBasedBuilderParametersImpl managedParams = new FileBasedBuilderParametersImpl();\r\n    managedParams.setFileName(\"test.xml\");\r\n    params.setManagedBuilderParameters(managedParams);\r\n    params.setFilePattern(\"somePattern\");\r\n    final MultiFileBuilderParametersImpl clone = params.clone();\r\n    assertEquals(params.getFilePattern(), clone.getFilePattern());\r\n    assertNotSame(params.getManagedBuilderParameters(), clone.getManagedBuilderParameters());\r\n    assertEquals(managedParams.getFileHandler().getFileName(), ((FileBasedBuilderParametersImpl) clone.getManagedBuilderParameters()).getFileHandler().getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileBuilderParametersImpl.java",
  "methodName" : "testFromParametersFound",
  "sourceCode" : "/**\r\n * Tests whether an instance can be obtained from a parameters map.\r\n */\r\n@Test\r\nvoid testFromParametersFound() {\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertSame(params, MultiFileBuilderParametersImpl.fromParameters(map, true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileBuilderParametersImpl.java",
  "methodName" : "testFromParametersNewInstance",
  "sourceCode" : "/**\r\n * Tests whether a new instance is created if the parameters map does not contain one.\r\n */\r\n@Test\r\nvoid testFromParametersNewInstance() {\r\n    params = MultiFileBuilderParametersImpl.fromParameters(new HashMap<>(), true);\r\n    assertNotNull(params);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileBuilderParametersImpl.java",
  "methodName" : "testFromParatersNotFound",
  "sourceCode" : "/**\r\n * Tests whether an instance can be obtained from a map if it cannot be found.\r\n */\r\n@Test\r\nvoid testFromParatersNotFound() {\r\n    assertNull(MultiFileBuilderParametersImpl.fromParameters(new HashMap<>()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileBuilderParametersImpl.java",
  "methodName" : "testSetFilePattern",
  "sourceCode" : "/**\r\n * Tests whether a file pattern can be set.\r\n */\r\n@Test\r\nvoid testSetFilePattern() {\r\n    final String pattern = \"somePattern\";\r\n    assertSame(params, params.setFilePattern(pattern));\r\n    assertEquals(pattern, params.getFilePattern());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileBuilderParametersImpl.java",
  "methodName" : "testSetManagedBuilderParameters",
  "sourceCode" : "/**\r\n * Tests whether parameters for managed configurations can be set.\r\n */\r\n@Test\r\nvoid testSetManagedBuilderParameters() {\r\n    final BuilderParameters bp = mock(BuilderParameters.class);\r\n    assertSame(params, params.setManagedBuilderParameters(bp));\r\n    assertSame(bp, params.getManagedBuilderParameters());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testAddConfigurationListener",
  "sourceCode" : "/**\r\n * Tests whether configuration listeners are handled correctly.\r\n */\r\n@Test\r\nvoid testAddConfigurationListener() throws ConfigurationException {\r\n    final EventListener<ConfigurationEvent> l1 = new EventListenerTestImpl(null);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final EventListener<Event> l2 = mock(EventListener.class);\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createTestBuilder(null);\r\n    builder.addEventListener(ConfigurationEvent.ANY, l1);\r\n    switchToConfig(1);\r\n    final XMLConfiguration config = builder.getConfiguration();\r\n    assertTrue(config.getEventListeners(ConfigurationEvent.ANY).contains(l1));\r\n    builder.addEventListener(Event.ANY, l2);\r\n    assertTrue(config.getEventListeners(Event.ANY).contains(l2));\r\n    assertTrue(builder.removeEventListener(Event.ANY, l2));\r\n    assertFalse(builder.removeEventListener(Event.ANY, l2));\r\n    assertFalse(config.getEventListeners(Event.ANY).contains(l2));\r\n    switchToConfig(2);\r\n    final XMLConfiguration config2 = builder.getConfiguration();\r\n    assertFalse(config2.getEventListeners(Event.ANY).contains(l2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testBuilderListenerOtherTypes",
  "sourceCode" : "/**\r\n * Tests whether builder events of other types can be received.\r\n */\r\n@Test\r\nvoid testBuilderListenerOtherTypes() throws ConfigurationException {\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createTestBuilder(null);\r\n    builder.addEventListener(ConfigurationBuilderEvent.ANY, listener);\r\n    switchToConfig(1);\r\n    builder.getConfiguration();\r\n    final ConfigurationBuilderEvent event = listener.nextEvent(ConfigurationBuilderEvent.CONFIGURATION_REQUEST);\r\n    assertEquals(builder, event.getSource());\r\n    final ConfigurationBuilderResultCreatedEvent createdEvent = listener.nextEvent(ConfigurationBuilderResultCreatedEvent.RESULT_CREATED);\r\n    assertEquals(builder, createdEvent.getSource());\r\n    listener.assertNoMoreEvents();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testBuilderListenerReset",
  "sourceCode" : "/**\r\n * Tests whether builder reset events are handled correctly.\r\n */\r\n@Test\r\nvoid testBuilderListenerReset() throws ConfigurationException {\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    final Collection<FileBasedConfigurationBuilder<XMLConfiguration>> managedBuilders = new ArrayList<>();\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createBuilderWithAccessToManagedBuilders(managedBuilders);\r\n    switchToConfig(1);\r\n    builder.addEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n    final XMLConfiguration configuration = builder.getConfiguration();\r\n    managedBuilders.iterator().next().resetResult();\r\n    final ConfigurationBuilderEvent event = listener.nextEvent(ConfigurationBuilderEvent.RESET);\r\n    assertSame(builder, event.getSource());\r\n    assertNotSame(configuration, builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testCaching",
  "sourceCode" : "/**\r\n * Tests whether managed builders are cached.\r\n */\r\n@Test\r\nvoid testCaching() throws ConfigurationException {\r\n    final Collection<FileBasedConfigurationBuilder<XMLConfiguration>> managedBuilders = new ArrayList<>();\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createBuilderWithAccessToManagedBuilders(managedBuilders);\r\n    switchToConfig(1);\r\n    builder.getConfiguration();\r\n    assertEquals(1, managedBuilders.size());\r\n    builder.getConfiguration();\r\n    assertEquals(1, managedBuilders.size());\r\n    switchToConfig(2);\r\n    builder.getConfiguration();\r\n    assertEquals(2, managedBuilders.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testCachingWithReset",
  "sourceCode" : "/**\r\n * Tests whether a reset of the builder configuration also flushes the cache.\r\n */\r\n@Test\r\nvoid testCachingWithReset() throws ConfigurationException {\r\n    final Collection<FileBasedConfigurationBuilder<XMLConfiguration>> managedBuilders = new ArrayList<>();\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createBuilderWithAccessToManagedBuilders(managedBuilders);\r\n    switchToConfig(1);\r\n    builder.getConfiguration();\r\n    builder.resetParameters();\r\n    builder.configure(createTestBuilderParameters(null));\r\n    builder.getConfiguration();\r\n    assertEquals(2, managedBuilders.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testFileNotFound",
  "sourceCode" : "/**\r\n * Tests the behavior if a configuration is accessed which cannot be located.\r\n */\r\n@Test\r\nvoid testFileNotFound() {\r\n    switchToConfig(\"unknown configuration ID\");\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createTestBuilder(null);\r\n    assertThrows(ConfigurationException.class, builder::getConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testFileNotFoundAllowFailOnInit",
  "sourceCode" : "/**\r\n * Tests whether exceptions when creating configurations can be suppressed.\r\n */\r\n@Test\r\nvoid testFileNotFoundAllowFailOnInit() throws ConfigurationException {\r\n    final BasicBuilderParameters params = createTestBuilderParameters(null);\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = new MultiFileConfigurationBuilder<>(XMLConfiguration.class, params.getParameters(), true);\r\n    switchToConfig(\"unknown configuration ID\");\r\n    final XMLConfiguration config = builder.getConfiguration();\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testGetConfiguration",
  "sourceCode" : "/**\r\n * Tests whether access to multiple configurations works.\r\n */\r\n@Test\r\nvoid testGetConfiguration() throws ConfigurationException {\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createTestBuilder(null);\r\n    final String key = \"rowsPerPage\";\r\n    switchToConfig(1);\r\n    assertEquals(15, builder.getConfiguration().getInt(key));\r\n    switchToConfig(2);\r\n    assertEquals(25, builder.getConfiguration().getInt(key));\r\n    switchToConfig(3);\r\n    assertEquals(35, builder.getConfiguration().getInt(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testGetManagedBuilderClonedParameters",
  "sourceCode" : "/**\r\n * Tests whether initialization parameters of managed builders are cloned before they are applied.\r\n */\r\n@Test\r\nvoid testGetManagedBuilderClonedParameters() throws ConfigurationException {\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createTestBuilder(new XMLBuilderParametersImpl());\r\n    switchToConfig(1);\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> managedBuilder1 = builder.getManagedBuilder();\r\n    switchToConfig(2);\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> managedBuilder2 = builder.getManagedBuilder();\r\n    assertNotSame(managedBuilder1.getFileHandler(), managedBuilder2.getFileHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testInterpolatorFromParameters",
  "sourceCode" : "/**\r\n * Tests whether a {@code ConfigurationInterpolator} is created from properties defined in the parameters object if\r\n * necessary.\r\n */\r\n@Test\r\nvoid testInterpolatorFromParameters() throws ConfigurationException {\r\n    final BasicBuilderParameters params = new MultiFileBuilderParametersImpl().setFilePattern(PATTERN).setPrefixLookups(Collections.singletonMap(DefaultLookups.SYSTEM_PROPERTIES.getPrefix(), DefaultLookups.SYSTEM_PROPERTIES.getLookup()));\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = new MultiFileConfigurationBuilder<>(XMLConfiguration.class);\r\n    builder.configure(params);\r\n    switchToConfig(1);\r\n    assertEquals(15, builder.getConfiguration().getInt(\"rowsPerPage\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testInterpolatorReset",
  "sourceCode" : "/**\r\n * Tests whether the ConfigurationInterpolator is reset, too.\r\n */\r\n@Test\r\nvoid testInterpolatorReset() {\r\n    final BasicBuilderParameters params = new MultiFileBuilderParametersImpl().setFilePattern(PATTERN);\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = new MultiFileConfigurationBuilder<>(XMLConfiguration.class);\r\n    builder.configure(params);\r\n    final ConfigurationInterpolator interpolator = builder.getInterpolator();\r\n    assertNotNull(interpolator);\r\n    builder.resetParameters();\r\n    assertNotSame(interpolator, builder.getInterpolator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testManagedConfigurationSettings",
  "sourceCode" : "/**\r\n * Tests whether a managed configuration is properly initialized.\r\n */\r\n@Test\r\nvoid testManagedConfigurationSettings() throws ConfigurationException {\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = new MultiFileConfigurationBuilder<>(XMLConfiguration.class);\r\n    final ExpressionEngine engine = new XPathExpressionEngine();\r\n    final BuilderParameters xmlParams = new XMLBuilderParametersImpl().setExpressionEngine(engine).setListDelimiterHandler(new DefaultListDelimiterHandler(';'));\r\n    final MultiFileBuilderParametersImpl params = new MultiFileBuilderParametersImpl().setFilePattern(PATTERN).setManagedBuilderParameters(xmlParams);\r\n    final ConfigurationInterpolator ci = createInterpolator();\r\n    params.setInterpolator(ci).setListDelimiterHandler(new DefaultListDelimiterHandler('#'));\r\n    builder.configure(params);\r\n    switchToConfig(1);\r\n    final XMLConfiguration config = builder.getConfiguration();\r\n    assertSame(engine, config.getExpressionEngine());\r\n    final DefaultListDelimiterHandler listHandler = (DefaultListDelimiterHandler) config.getListDelimiterHandler();\r\n    assertEquals(';', listHandler.getDelimiter());\r\n    assertNotSame(ci, config.getInterpolator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testNoPattern",
  "sourceCode" : "/**\r\n * Tests whether a missing file name pattern causes an exception.\r\n */\r\n@Test\r\nvoid testNoPattern() {\r\n    final BasicBuilderParameters params = new MultiFileBuilderParametersImpl().setInterpolator(createInterpolator());\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = new MultiFileConfigurationBuilder<>(XMLConfiguration.class, params.getParameters(), true);\r\n    switchToConfig(1);\r\n    assertThrows(ConfigurationException.class, builder::getConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testRecursiveInterpolation",
  "sourceCode" : "/**\r\n * Tests whether infinite loops on constructing the file name using interpolation can be handled. This can happen if a\r\n * pattern cannot be resolved and the {@code ConfigurationInterpolator} causes again a lookup of the builder's\r\n * configuration.\r\n */\r\n@Test\r\nvoid testRecursiveInterpolation() {\r\n    final DynamicCombinedConfiguration config = new DynamicCombinedConfiguration();\r\n    config.setKeyPattern(PATTERN_VAR);\r\n    final BasicBuilderParameters params = createTestBuilderParameters(null);\r\n    final ConfigurationInterpolator ci = new ConfigurationInterpolator();\r\n    ci.addDefaultLookup(new ConfigurationLookup(config));\r\n    params.setInterpolator(ci);\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = new MultiFileConfigurationBuilder<>(XMLConfiguration.class, null, true);\r\n    builder.configure(params);\r\n    final BuilderConfigurationWrapperFactory wrapFactory = new BuilderConfigurationWrapperFactory();\r\n    config.addConfiguration(wrapFactory.createBuilderConfigurationWrapper(HierarchicalConfiguration.class, builder), \"Multi\");\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testRemoveBuilderListenerOnReset",
  "sourceCode" : "/**\r\n * Tests whether listeners at managed builders are removed when the cache is cleared.\r\n */\r\n@Test\r\nvoid testRemoveBuilderListenerOnReset() throws ConfigurationException {\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    final Collection<FileBasedConfigurationBuilder<XMLConfiguration>> managedBuilders = new ArrayList<>();\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createBuilderWithAccessToManagedBuilders(managedBuilders);\r\n    switchToConfig(1);\r\n    builder.addEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n    builder.getConfiguration();\r\n    builder.resetParameters();\r\n    managedBuilders.iterator().next().resetResult();\r\n    listener.assertNoMoreEvents();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiFileConfigurationBuilder.java",
  "methodName" : "testSchemaValidationError",
  "sourceCode" : "/**\r\n * Tests whether XML schema validation can be enabled.\r\n */\r\n@Test\r\nvoid testSchemaValidationError() {\r\n    final MultiFileConfigurationBuilder<XMLConfiguration> builder = createTestBuilder(new XMLBuilderParametersImpl().setValidating(true).setSchemaValidation(true));\r\n    switchToConfig(\"2001\");\r\n    final ConfigurationException ex = assertThrows(ConfigurationException.class, builder::getConfiguration);\r\n    Throwable cause = ex.getCause();\r\n    while (cause != null && !(cause instanceof SAXParseException)) {\r\n        cause = cause.getCause();\r\n    }\r\n    assertNotNull(cause);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testContains",
  "sourceCode" : "/**\r\n * Tests the contains() implementation. This operation is not available.\r\n */\r\n@Test\r\nvoid testContains() {\r\n    final MultiWrapDynaBean bean = createBean(false);\r\n    assertThrows(UnsupportedOperationException.class, () -> bean.contains(MAPPED_PROPERTY, \"someKey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testGetDynaClass",
  "sourceCode" : "/**\r\n * Tests whether the class of bean can be queried.\r\n */\r\n@Test\r\nvoid testGetDynaClass() {\r\n    final DynaClass cls = createBean(false).getDynaClass();\r\n    assertNotNull(cls.getDynaProperty(\"throwExceptionOnMissing\"));\r\n    assertNotNull(cls.getDynaProperty(\"text\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testGetDynaClassName",
  "sourceCode" : "/**\r\n * Checks the name of the DynaClass.\r\n */\r\n@Test\r\nvoid testGetDynaClassName() {\r\n    assertNull(createBean(false).getDynaClass().getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testGetDynaClassNewInstance",
  "sourceCode" : "/**\r\n * Tries to create a new instance of the DynaClass. This is not possible.\r\n */\r\n@Test\r\nvoid testGetDynaClassNewInstance() {\r\n    final DynaClass dynaClass = createBean(false).getDynaClass();\r\n    assertThrows(UnsupportedOperationException.class, dynaClass::newInstance);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testGetIndexedProperty",
  "sourceCode" : "/**\r\n * Tests whether an indexed property can be read.\r\n */\r\n@Test\r\nvoid testGetIndexedProperty() throws Exception {\r\n    final MultiWrapDynaBean bean = createBean(false);\r\n    wrapBean.setIndexedProperty(3, 20121117);\r\n    assertEquals(20121117, PropertyUtils.getIndexedProperty(bean, \"indexedProperty\", 3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testGetMappedProperty",
  "sourceCode" : "/**\r\n * Tests whether a map property can be read.\r\n */\r\n@Test\r\nvoid testGetMappedProperty() throws Exception {\r\n    final MultiWrapDynaBean bean = createBean(true);\r\n    final String key = \"testKey\";\r\n    final String value = \"Hello World\";\r\n    wrapDynaBean.set(MAPPED_PROPERTY, key, value);\r\n    assertEquals(value, PropertyUtils.getMappedProperty(bean, MAPPED_PROPERTY, key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testGetPropertyUnknown",
  "sourceCode" : "/**\r\n * Tries to access an unknown property.\r\n */\r\n@Test\r\nvoid testGetPropertyUnknown() {\r\n    final MultiWrapDynaBean bean = createBean(false);\r\n    assertThrows(IllegalArgumentException.class, () -> bean.get(\"unknown property\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testGetSimpleProperty",
  "sourceCode" : "/**\r\n * Tests whether a simple property can be read.\r\n */\r\n@Test\r\nvoid testGetSimpleProperty() throws Exception {\r\n    final MultiWrapDynaBean bean = createBean(false);\r\n    final String text = \"testText\";\r\n    wrapBean.setText(text);\r\n    assertEquals(text, PropertyUtils.getProperty(bean, \"text\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testOrderOfProperties",
  "sourceCode" : "/**\r\n * Tests that the order of properties is relevant when adding beans to a MultiWrapDynaBean.\r\n */\r\n@Test\r\nvoid testOrderOfProperties() throws Exception {\r\n    final Collection<Object> beans = new ArrayList<>();\r\n    params = new BasicBuilderParameters();\r\n    beans.add(params);\r\n    beans.add(new FileBasedBuilderParametersImpl());\r\n    for (int i = 0; i < 32; i++) {\r\n        beans.add(new BasicBuilderParameters());\r\n    }\r\n    final MultiWrapDynaBean bean = new MultiWrapDynaBean(beans);\r\n    final ListDelimiterHandler listHandler = new DefaultListDelimiterHandler('+');\r\n    PropertyUtils.setProperty(bean, \"throwExceptionOnMissing\", Boolean.TRUE);\r\n    PropertyUtils.setProperty(bean, \"listDelimiterHandler\", listHandler);\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertEquals(Boolean.TRUE, map.get(\"throwExceptionOnMissing\"));\r\n    assertEquals(listHandler, map.get(\"listDelimiterHandler\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testRemove",
  "sourceCode" : "/**\r\n * Tests the remove() implementation. This operation is not available.\r\n */\r\n@Test\r\nvoid testRemove() {\r\n    final MultiWrapDynaBean bean = createBean(false);\r\n    assertThrows(UnsupportedOperationException.class, () -> bean.remove(MAPPED_PROPERTY, \"someKey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testSetIndexedProperty",
  "sourceCode" : "/**\r\n * Tests whether an indexed property can be set.\r\n */\r\n@Test\r\nvoid testSetIndexedProperty() throws Exception {\r\n    PropertyUtils.setIndexedProperty(createBean(false), \"indexedProperty\", 1, 42);\r\n    assertEquals(42, wrapBean.getIndexedProperty(1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testSetMappedProperty",
  "sourceCode" : "/**\r\n * Tests whether a map property can be set.\r\n */\r\n@Test\r\nvoid testSetMappedProperty() throws Exception {\r\n    final MultiWrapDynaBean bean = createBean(true);\r\n    final String key = \"testKey\";\r\n    final String text = \"Hello World\";\r\n    PropertyUtils.setMappedProperty(bean, MAPPED_PROPERTY, key, text);\r\n    assertEquals(text, wrapDynaBean.get(MAPPED_PROPERTY, key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestMultiWrapDynaBean.java",
  "methodName" : "testSetSimpleProperty",
  "sourceCode" : "/**\r\n * Tests whether a simple property can be set.\r\n */\r\n@Test\r\nvoid testSetSimpleProperty() throws Exception {\r\n    PropertyUtils.setProperty(createBean(false), \"throwExceptionOnMissing\", Boolean.TRUE);\r\n    assertEquals(Boolean.TRUE, params.getParameters().get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilder.java",
  "methodName" : "testInitWithFailOnInitFlag",
  "sourceCode" : "/**\r\n * Tests whether the failOnInit flag is passed to the super constructor.\r\n */\r\n@Test\r\nvoid testInitWithFailOnInitFlag() {\r\n    builder = new ReloadingCombinedConfigurationBuilder(null, true);\r\n    assertTrue(builder.isAllowFailOnInit());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilder.java",
  "methodName" : "testInitWithParameters",
  "sourceCode" : "/**\r\n * Tests whether initialization parameters are correctly processed.\r\n */\r\n@Test\r\nvoid testInitWithParameters() throws ConfigurationException {\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    params.setFile(ConfigurationAssert.getTestFile(\"testDigesterConfiguration.xml\"));\r\n    builder = new ReloadingCombinedConfigurationBuilder(params.getParameters());\r\n    final CombinedConfiguration cc = builder.getConfiguration();\r\n    assertTrue(cc.getBoolean(\"test.boolean\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilder.java",
  "methodName" : "testNestedReloadableSources",
  "sourceCode" : "/**\r\n * Tests whether a nested combined configuration definition can be loaded with reloading support.\r\n */\r\n@Test\r\nvoid testNestedReloadableSources() throws ConfigurationException {\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testCCReloadingNested.xml\");\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFile(testFile));\r\n    builder.getConfiguration();\r\n    final CombinedReloadingController rc = (CombinedReloadingController) builder.getReloadingController();\r\n    final Collection<ReloadingController> subControllers = rc.getSubControllers();\r\n    assertEquals(2, subControllers.size());\r\n    final ReloadingControllerSupport ccBuilder = (ReloadingControllerSupport) builder.getNamedBuilder(\"cc\");\r\n    assertTrue(subControllers.contains(ccBuilder.getReloadingController()));\r\n    final CombinedReloadingController rc2 = (CombinedReloadingController) ccBuilder.getReloadingController();\r\n    assertEquals(3, rc2.getSubControllers().size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilder.java",
  "methodName" : "testNoReloadableSources",
  "sourceCode" : "/**\r\n * Tests a definition configuration which does not contain sources with reloading support.\r\n */\r\n@Test\r\nvoid testNoReloadableSources() throws ConfigurationException {\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testDigesterConfiguration.xml\");\r\n    builder.configure(new CombinedBuilderParametersImpl().setDefinitionBuilder(new FileBasedConfigurationBuilder<>(XMLConfiguration.class)).setDefinitionBuilderParameters(new FileBasedBuilderParametersImpl().setFile(testFile)));\r\n    builder.getConfiguration();\r\n    final CombinedReloadingController rc = (CombinedReloadingController) builder.getReloadingController();\r\n    assertTrue(rc.getSubControllers().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilder.java",
  "methodName" : "testReloadableDefinitionBuilder",
  "sourceCode" : "/**\r\n * Tests whether the definition builder created by default supports reloading.\r\n */\r\n@Test\r\nvoid testReloadableDefinitionBuilder() throws ConfigurationException {\r\n    final File testFile = ConfigurationAssert.getTestFile(\"testDigesterConfiguration.xml\");\r\n    final ReloadingCombinedConfigurationBuilder confBuilder = builder.configure(new FileBasedBuilderParametersImpl().setFile(testFile));\r\n    assertSame(builder, confBuilder);\r\n    builder.getConfiguration();\r\n    final CombinedReloadingController rc = (CombinedReloadingController) builder.getReloadingController();\r\n    final Collection<ReloadingController> subControllers = rc.getSubControllers();\r\n    assertEquals(1, subControllers.size());\r\n    final ReloadingController subctrl = ((ReloadingControllerSupport) builder.getDefinitionBuilder()).getReloadingController();\r\n    assertSame(subctrl, subControllers.iterator().next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilderFileBased.java",
  "methodName" : "testConcurrentGetAndReload",
  "sourceCode" : "/**\r\n * Tests concurrent access to a reloading builder for combined configurations.\r\n */\r\n@Test\r\nvoid testConcurrentGetAndReload() throws Exception {\r\n    final int threadCount = 4;\r\n    final int loopCount = 100;\r\n    final ReloadingDetectorFactory detectorFactory = (handler, params) -> new RandomReloadingDetector();\r\n    final BaseHierarchicalConfiguration defConf = new BaseHierarchicalConfiguration();\r\n    defConf.addProperty(\"header.result.nodeCombiner[@config-class]\", MergeCombiner.class.getName());\r\n    defConf.addProperty(\"header.result.expressionEngine[@config-class]\", XPathExpressionEngine.class.getName());\r\n    addReloadSource(defConf, \"configA.xml\");\r\n    addReloadSource(defConf, \"configB.xml\");\r\n    final Synchronizer sync = new ReadWriteSynchronizer();\r\n    builder.configure(parameters.combined().setDefinitionBuilder(new ConstantConfigurationBuilder(defConf)).setSynchronizer(sync).registerChildDefaultsHandler(BasicBuilderProperties.class, new CopyObjectDefaultHandler(new BasicBuilderParameters().setSynchronizer(sync))).registerChildDefaultsHandler(FileBasedBuilderProperties.class, new CopyObjectDefaultHandler(new FileBasedBuilderParametersImpl().setReloadingDetectorFactory(detectorFactory))));\r\n    assertEquals(\"100\", builder.getConfiguration().getString(\"/property[@name='config']/@value\"));\r\n    final Thread[] testThreads = new Thread[threadCount];\r\n    final int[] failures = new int[threadCount];\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i] = new ReloadThread(builder, failures, i, loopCount);\r\n        testThreads[i].start();\r\n    }\r\n    int totalFailures = 0;\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i].join();\r\n        totalFailures += failures[i];\r\n    }\r\n    assertEquals(0, totalFailures);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilderFileBased.java",
  "methodName" : "testReloadDefinitionFileDefaultBuilder",
  "sourceCode" : "/**\r\n * Tests whether the default definition builder is capable of detecting a change in the definition configuration.\r\n */\r\n@Test\r\nvoid testReloadDefinitionFileDefaultBuilder() throws ConfigurationException, IOException, InterruptedException {\r\n    final File defFile = newFile(tempFolder);\r\n    builder.configure(parameters.combined().setDefinitionBuilderParameters(parameters.xml().setReloadingRefreshDelay(0L).setFile(defFile)));\r\n    checkReloadDefinitionFile(defFile);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilderFileBased.java",
  "methodName" : "testReloadDefinitionFileExplicitBuilder",
  "sourceCode" : "/**\r\n * Tests whether a change in the definition file is detected and causes a reload if a specific builder for the\r\n * definition configuration is provided.\r\n */\r\n@Test\r\nvoid testReloadDefinitionFileExplicitBuilder() throws ConfigurationException, IOException, InterruptedException {\r\n    final File defFile = newFile(tempFolder);\r\n    builder.configure(parameters.combined().setDefinitionBuilder(new ReloadingFileBasedConfigurationBuilder<>(XMLConfiguration.class).configure(parameters.xml().setReloadingRefreshDelay(0L).setFile(defFile))));\r\n    checkReloadDefinitionFile(defFile);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingCombinedConfigurationBuilderFileBased.java",
  "methodName" : "testReloadFromFile",
  "sourceCode" : "/**\r\n * Tests whether a changed file is detected on disk.\r\n */\r\n@Test\r\nvoid testReloadFromFile() throws ConfigurationException, IOException {\r\n    final File xmlConf1 = writeReloadFile(null, 1, 0);\r\n    final File xmlConf2 = writeReloadFile(null, 2, 0);\r\n    final ReloadingDetectorFactory detectorFactory = (handler, params) -> new AlwaysReloadingDetector();\r\n    final BaseHierarchicalConfiguration defConf = new BaseHierarchicalConfiguration();\r\n    addReloadSource(defConf, xmlConf1.getAbsolutePath());\r\n    addReloadSource(defConf, xmlConf2.getAbsolutePath());\r\n    builder.configure(parameters.combined().setDefinitionBuilder(new ConstantConfigurationBuilder(defConf)).registerChildDefaultsHandler(FileBasedBuilderProperties.class, new CopyObjectDefaultHandler(new FileBasedBuilderParametersImpl().setReloadingDetectorFactory(detectorFactory))));\r\n    CombinedConfiguration config = builder.getConfiguration();\r\n    assertEquals(0, config.getInt(testProperty(1)));\r\n    assertEquals(0, config.getInt(testProperty(2)));\r\n    writeReloadFile(xmlConf1, 1, 1);\r\n    builder.getReloadingController().checkForReloading(null);\r\n    config = builder.getConfiguration();\r\n    assertEquals(1, config.getInt(testProperty(1)));\r\n    assertEquals(0, config.getInt(testProperty(2)));\r\n    writeReloadFile(xmlConf2, 2, 2);\r\n    builder.getReloadingController().checkForReloading(null);\r\n    config = builder.getConfiguration();\r\n    assertEquals(1, config.getInt(testProperty(1)));\r\n    assertEquals(2, config.getInt(testProperty(2)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingMultiFileConfigurationBuilder.java",
  "methodName" : "testCreateManagedBuilder",
  "sourceCode" : "/**\r\n * Tests whether correct managed builders are created.\r\n */\r\n@Test\r\nvoid testCreateManagedBuilder() throws ConfigurationException {\r\n    final ReloadingMultiFileConfigurationBuilder<XMLConfiguration> builder = new ReloadingMultiFileConfigurationBuilder<>(XMLConfiguration.class);\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> managedBuilder = builder.createManagedBuilder(\"test.xml\", createTestBuilderParameters(null).getParameters());\r\n    assertInstanceOf(ReloadingFileBasedConfigurationBuilder.class, managedBuilder);\r\n    assertFalse(managedBuilder.isAllowFailOnInit());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingMultiFileConfigurationBuilder.java",
  "methodName" : "testCreateManagedBuilderWithAllowFailFlag",
  "sourceCode" : "/**\r\n * Tests whether the allowFailOnInit flag is passed to newly created managed builders.\r\n */\r\n@Test\r\nvoid testCreateManagedBuilderWithAllowFailFlag() throws ConfigurationException {\r\n    final ReloadingMultiFileConfigurationBuilder<XMLConfiguration> builder = new ReloadingMultiFileConfigurationBuilder<>(XMLConfiguration.class, null, true);\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> managedBuilder = builder.createManagedBuilder(\"test.xml\", createTestBuilderParameters(null).getParameters());\r\n    assertTrue(managedBuilder.isAllowFailOnInit());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingMultiFileConfigurationBuilder.java",
  "methodName" : "testInitWithParameters",
  "sourceCode" : "/**\r\n * Tests whether parameters passed to the constructor are passed to the super class.\r\n */\r\n@Test\r\nvoid testInitWithParameters() throws ConfigurationException {\r\n    final ExpressionEngine engine = new XPathExpressionEngine();\r\n    final BasicBuilderParameters params = createTestBuilderParameters(new XMLBuilderParametersImpl().setExpressionEngine(engine));\r\n    final ReloadingMultiFileConfigurationBuilder<XMLConfiguration> builder = new ReloadingMultiFileConfigurationBuilder<>(XMLConfiguration.class, params.getParameters());\r\n    switchToConfig(1);\r\n    final XMLConfiguration config = builder.getConfiguration();\r\n    assertSame(engine, config.getExpressionEngine());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingMultiFileConfigurationBuilder.java",
  "methodName" : "testReloadingControllerCheck",
  "sourceCode" : "/**\r\n * Tests whether a reloading check works correctly.\r\n */\r\n@Test\r\nvoid testReloadingControllerCheck() throws ConfigurationException {\r\n    final ReloadingMultiFileConfigurationBuilderTestImpl builder = new ReloadingMultiFileConfigurationBuilderTestImpl();\r\n    switchToConfig(1);\r\n    builder.getConfiguration();\r\n    switchToConfig(2);\r\n    builder.getConfiguration();\r\n    final List<ReloadingController> controllers = builder.getReloadingControllers();\r\n    assertEquals(2, controllers.size());\r\n    for (final ReloadingController c : controllers) {\r\n        reset(c);\r\n        when(c.checkForReloading(null)).thenReturn(Boolean.FALSE);\r\n    }\r\n    assertFalse(builder.getReloadingController().checkForReloading(this));\r\n    for (final ReloadingController c : controllers) {\r\n        verify(c).checkForReloading(null);\r\n        verifyNoMoreInteractions(c);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingMultiFileConfigurationBuilder.java",
  "methodName" : "testReloadingControllerCheckReloadingRequired",
  "sourceCode" : "/**\r\n * Tests a reloading check which detects the need to reload.\r\n */\r\n@Test\r\nvoid testReloadingControllerCheckReloadingRequired() throws ConfigurationException {\r\n    final ReloadingMultiFileConfigurationBuilderTestImpl builder = new ReloadingMultiFileConfigurationBuilderTestImpl();\r\n    for (int i = 1; i <= 3; i++) {\r\n        switchToConfig(i);\r\n        builder.getConfiguration();\r\n    }\r\n    final List<ReloadingController> controllers = builder.getReloadingControllers();\r\n    reset(controllers.toArray());\r\n    when(controllers.get(0).checkForReloading(null)).thenReturn(Boolean.FALSE);\r\n    when(controllers.get(1).checkForReloading(null)).thenReturn(Boolean.TRUE);\r\n    when(controllers.get(2).checkForReloading(null)).thenReturn(Boolean.FALSE);\r\n    assertTrue(builder.getReloadingController().checkForReloading(this));\r\n    for (final ReloadingController c : controllers) {\r\n        verify(c).checkForReloading(null);\r\n        verifyNoMoreInteractions(c);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\combined\\TestReloadingMultiFileConfigurationBuilder.java",
  "methodName" : "testReloadingControllerResetReloadingState",
  "sourceCode" : "/**\r\n * Tests whether the reloading state of the reloading controller can be reset.\r\n */\r\n@Test\r\nvoid testReloadingControllerResetReloadingState() throws ConfigurationException {\r\n    final ReloadingMultiFileConfigurationBuilderTestImpl builder = new ReloadingMultiFileConfigurationBuilderTestImpl();\r\n    switchToConfig(1);\r\n    builder.getConfiguration();\r\n    switchToConfig(2);\r\n    builder.getConfiguration();\r\n    final List<ReloadingController> controllers = builder.getReloadingControllers();\r\n    reset(controllers.toArray());\r\n    for (final ReloadingController c : controllers) {\r\n        when(c.checkForReloading(null)).thenReturn(Boolean.TRUE);\r\n    }\r\n    builder.getReloadingController().checkForReloading(null);\r\n    builder.getReloadingController().resetReloadingState();\r\n    for (final ReloadingController c : controllers) {\r\n        verify(c).checkForReloading(null);\r\n        verify(c).resetReloadingState();\r\n        verifyNoMoreInteractions(c);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testCombinedBuilderFromFile",
  "sourceCode" : "/**\r\n * Tests whether a combined configuration builder can be constructed for a file.\r\n */\r\n@Test\r\nvoid testCombinedBuilderFromFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final CombinedConfigurationBuilder builder = configs.combinedBuilder(ConfigurationAssert.getTestFile(TEST_COMBINED));\r\n    checkCombined(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testCombinedBuilderFromPath",
  "sourceCode" : "/**\r\n * Tests whether a combined configuration builder can be constructed for a file path.\r\n */\r\n@Test\r\nvoid testCombinedBuilderFromPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final CombinedConfigurationBuilder builder = configs.combinedBuilder(absolutePath(TEST_COMBINED));\r\n    checkCombined(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testCombinedBuilderFromURL",
  "sourceCode" : "/**\r\n * Tests whether a combined configuration builder can be constructed for a URL.\r\n */\r\n@Test\r\nvoid testCombinedBuilderFromURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final CombinedConfigurationBuilder builder = configs.combinedBuilder(ConfigurationAssert.getTestURL(TEST_COMBINED));\r\n    checkCombined(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testCombinedFromFile",
  "sourceCode" : "/**\r\n * Tests whether a combined configuration can be loaded from a file.\r\n */\r\n@Test\r\nvoid testCombinedFromFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final CombinedConfiguration config = configs.combined(ConfigurationAssert.getTestFile(TEST_COMBINED));\r\n    checkCombined(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testCombinedFromPath",
  "sourceCode" : "/**\r\n * Tests whether a combined configuration can be loaded from a file path.\r\n */\r\n@Test\r\nvoid testCombinedFromPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final CombinedConfiguration config = configs.combined(absolutePath(TEST_COMBINED));\r\n    checkCombined(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testCombinedFromURL",
  "sourceCode" : "/**\r\n * Tests whether a combined configuration can be loaded from a URL.\r\n */\r\n@Test\r\nvoid testCombinedFromURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final CombinedConfiguration config = configs.combined(ConfigurationAssert.getTestURL(TEST_COMBINED));\r\n    checkCombined(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testDefaultParameters",
  "sourceCode" : "/**\r\n * Tests whether a default {@code Parameters} instance is created if necessary.\r\n */\r\n@Test\r\nvoid testDefaultParameters() {\r\n    final Configurations configs = new Configurations();\r\n    assertNotNull(configs.getParameters());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testFileBasedBuilderWithFile",
  "sourceCode" : "/**\r\n * Tests whether a builder for a file-based configuration can be created if an input File is specified.\r\n */\r\n@Test\r\nvoid testFileBasedBuilderWithFile() {\r\n    final Configurations configs = new Configurations();\r\n    final File file = ConfigurationAssert.getTestFile(TEST_PROPERTIES);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = configs.fileBasedBuilder(PropertiesConfiguration.class, file);\r\n    assertEquals(file.toURI(), builder.getFileHandler().getFile().toURI());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testFileBasedBuilderWithPath",
  "sourceCode" : "/**\r\n * Tests whether a builder for a file-based configuration can be created if a file name is specified.\r\n */\r\n@Test\r\nvoid testFileBasedBuilderWithPath() {\r\n    final Configurations configs = new Configurations();\r\n    final String filePath = absolutePath(TEST_PROPERTIES);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = configs.fileBasedBuilder(PropertiesConfiguration.class, filePath);\r\n    assertEquals(filePath, builder.getFileHandler().getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testFileBasedBuilderWithURL",
  "sourceCode" : "/**\r\n * Tests whether a builder for a file-based configuration can be created if a URL is specified.\r\n */\r\n@Test\r\nvoid testFileBasedBuilderWithURL() {\r\n    final Configurations configs = new Configurations();\r\n    final URL url = ConfigurationAssert.getTestURL(\"test.properties\");\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = configs.fileBasedBuilder(PropertiesConfiguration.class, url);\r\n    assertEquals(url, builder.getFileHandler().getURL());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testFileBasedFile",
  "sourceCode" : "/**\r\n * Tests whether a file-based configuration can be loaded from a file.\r\n */\r\n@Test\r\nvoid testFileBasedFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final PropertyListConfiguration config = configs.fileBased(PropertyListConfiguration.class, ConfigurationAssert.getTestFile(TEST_PLIST));\r\n    checkPList(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testFileBasedPath",
  "sourceCode" : "/**\r\n * Tests whether a file-based configuration can be loaded from a file path.\r\n */\r\n@Test\r\nvoid testFileBasedPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final PropertyListConfiguration config = configs.fileBased(PropertyListConfiguration.class, absolutePath(TEST_PLIST));\r\n    checkPList(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testFileBasedURL",
  "sourceCode" : "/**\r\n * Tests whether a file-based configuration can be loaded from a URL.\r\n */\r\n@Test\r\nvoid testFileBasedURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final PropertyListConfiguration config = configs.fileBased(PropertyListConfiguration.class, ConfigurationAssert.getTestURL(TEST_PLIST));\r\n    checkPList(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testINIBuilderFromFile",
  "sourceCode" : "/**\r\n * Tests whether a builder for a INI configuration can be created for a given file.\r\n */\r\n@Test\r\nvoid testINIBuilderFromFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<INIConfiguration> builder = configs.iniBuilder(ConfigurationAssert.getTestFile(TEST_INI));\r\n    checkINI(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testINIBuilderFromPath",
  "sourceCode" : "/**\r\n * Tests whether a builder for a INI configuration can be created for a given file path.\r\n */\r\n@Test\r\nvoid testINIBuilderFromPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<INIConfiguration> builder = configs.iniBuilder(absolutePath(TEST_INI));\r\n    checkINI(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testINIBuilderFromURL",
  "sourceCode" : "/**\r\n * Tests whether a builder for a INI configuration can be created for a given URL.\r\n */\r\n@Test\r\nvoid testINIBuilderFromURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<INIConfiguration> builder = configs.iniBuilder(ConfigurationAssert.getTestURL(TEST_INI));\r\n    checkINI(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testINIFromFile",
  "sourceCode" : "/**\r\n * Tests whether a INI configuration can be loaded from a file.\r\n */\r\n@Test\r\nvoid testINIFromFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final INIConfiguration config = configs.ini(ConfigurationAssert.getTestFile(TEST_INI));\r\n    checkINI(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testINIFromPath",
  "sourceCode" : "/**\r\n * Tests whether a INI configuration can be loaded from a file path.\r\n */\r\n@Test\r\nvoid testINIFromPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final INIConfiguration config = configs.ini(absolutePath(TEST_INI));\r\n    checkINI(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testINIFromURL",
  "sourceCode" : "/**\r\n * Tests whether a INI configuration can be loaded from a URL.\r\n */\r\n@Test\r\nvoid testINIFromURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final INIConfiguration config = configs.ini(ConfigurationAssert.getTestURL(TEST_INI));\r\n    checkINI(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testInitWithParameters",
  "sourceCode" : "/**\r\n * Tests whether parameters can be passed in at construction time.\r\n */\r\n@Test\r\nvoid testInitWithParameters() {\r\n    final Parameters params = new Parameters();\r\n    final Configurations configs = new Configurations(params);\r\n    assertSame(params, configs.getParameters());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testPropertiesBuilderFromFile",
  "sourceCode" : "/**\r\n * Tests whether a builder for a properties configuration can be created for a given file.\r\n */\r\n@Test\r\nvoid testPropertiesBuilderFromFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = configs.propertiesBuilder(ConfigurationAssert.getTestFile(TEST_PROPERTIES));\r\n    checkProperties(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testPropertiesBuilderFromPath",
  "sourceCode" : "/**\r\n * Tests whether a builder for a properties configuration can be created for a given file path.\r\n */\r\n@Test\r\nvoid testPropertiesBuilderFromPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = configs.propertiesBuilder(absolutePath(TEST_PROPERTIES));\r\n    checkProperties(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testPropertiesBuilderFromPathIncludeNotFoundFail",
  "sourceCode" : "/**\r\n * Tests whether a builder for a properties configuration can be created for a given file path when an include is not\r\n * found.\r\n */\r\n@Test\r\nvoid testPropertiesBuilderFromPathIncludeNotFoundFail() {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = configs.propertiesBuilder(absolutePath(\"include-not-found.properties\"));\r\n    assertThrows(ConfigurationException.class, builder::getConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testPropertiesBuilderFromPathIncludeNotFoundPass",
  "sourceCode" : "/**\r\n * Tests whether a builder for a properties configuration can be created for a given file path when an include is not\r\n * found.\r\n */\r\n@Test\r\nvoid testPropertiesBuilderFromPathIncludeNotFoundPass() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final String absPath = absolutePath(\"include-not-found.properties\");\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builderFail = configs.propertiesBuilder(absPath);\r\n    assertThrows(ConfigurationException.class, builderFail::getConfiguration);\r\n    assertThrows(ConfigurationException.class, () -> configs.properties(absPath));\r\n    // Expect success:\r\n    // @formatter:off\r\n    final Map<String, Object> map = new Parameters().properties().setPath(absPath).setIncludeListener(PropertiesConfiguration.NOOP_INCLUDE_LISTENER).getParameters();\r\n    // @formatter:on\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builderOk = configs.propertiesBuilder(absPath).addParameters(map);\r\n    assertEquals(\"valueA\", builderOk.getConfiguration().getString(\"keyA\"));\r\n    // Expect success:\r\n    // @formatter:off\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builderOk2 = configs.propertiesBuilder(new Parameters().properties().setPath(absPath).setIncludeListener(PropertiesConfiguration.NOOP_INCLUDE_LISTENER));\r\n    // @formatter:on\r\n    assertEquals(\"valueA\", builderOk2.getConfiguration().getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testPropertiesBuilderFromURL",
  "sourceCode" : "/**\r\n * Tests whether a builder for a properties configuration can be created for a given URL.\r\n */\r\n@Test\r\nvoid testPropertiesBuilderFromURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = configs.propertiesBuilder(ConfigurationAssert.getTestURL(TEST_PROPERTIES));\r\n    checkProperties(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testPropertiesFromFile",
  "sourceCode" : "/**\r\n * Tests whether a properties configuration can be loaded from a file.\r\n */\r\n@Test\r\nvoid testPropertiesFromFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final PropertiesConfiguration config = configs.properties(ConfigurationAssert.getTestFile(TEST_PROPERTIES));\r\n    checkProperties(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testPropertiesFromPath",
  "sourceCode" : "/**\r\n * Tests whether a properties configuration can be loaded from a file path.\r\n */\r\n@Test\r\nvoid testPropertiesFromPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final PropertiesConfiguration config = configs.properties(absolutePath(TEST_PROPERTIES));\r\n    checkProperties(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testPropertiesFromURL",
  "sourceCode" : "/**\r\n * Tests whether a properties configuration can be loaded from a URL.\r\n */\r\n@Test\r\nvoid testPropertiesFromURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final PropertiesConfiguration config = configs.properties(ConfigurationAssert.getTestURL(TEST_PROPERTIES));\r\n    checkProperties(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testXMLBuilderFromFile",
  "sourceCode" : "/**\r\n * Tests whether a builder for a XML configuration can be created for a given file.\r\n */\r\n@Test\r\nvoid testXMLBuilderFromFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = configs.xmlBuilder(ConfigurationAssert.getTestFile(TEST_XML));\r\n    checkXML(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testXMLBuilderFromPath",
  "sourceCode" : "/**\r\n * Tests whether a builder for a XML configuration can be created for a given file path.\r\n */\r\n@Test\r\nvoid testXMLBuilderFromPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = configs.xmlBuilder(absolutePath(TEST_XML));\r\n    checkXML(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testXMLBuilderFromURL",
  "sourceCode" : "/**\r\n * Tests whether a builder for a XML configuration can be created for a given URL.\r\n */\r\n@Test\r\nvoid testXMLBuilderFromURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = configs.xmlBuilder(ConfigurationAssert.getTestURL(TEST_XML));\r\n    checkXML(builder.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testXMLFromFile",
  "sourceCode" : "/**\r\n * Tests whether a XML configuration can be loaded from a file.\r\n */\r\n@Test\r\nvoid testXMLFromFile() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final XMLConfiguration config = configs.xml(ConfigurationAssert.getTestFile(TEST_XML));\r\n    checkXML(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testXMLFromPath",
  "sourceCode" : "/**\r\n * Tests whether a XML configuration can be loaded from a URL.\r\n */\r\n@Test\r\nvoid testXMLFromPath() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final XMLConfiguration config = configs.xml(absolutePath(TEST_XML));\r\n    checkXML(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestConfigurations.java",
  "methodName" : "testXMLFromURL",
  "sourceCode" : "/**\r\n * Tests whether a XML configuration can be loaded from a URL.\r\n */\r\n@Test\r\nvoid testXMLFromURL() throws ConfigurationException {\r\n    final Configurations configs = new Configurations();\r\n    final XMLConfiguration config = configs.xml(ConfigurationAssert.getTestURL(TEST_XML));\r\n    checkXML(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testApplyDefaults",
  "sourceCode" : "/**\r\n * Tests whether default values are set for newly created parameters objects.\r\n */\r\n@Test\r\nvoid testApplyDefaults() {\r\n    final DefaultParametersManager manager = mock(DefaultParametersManager.class);\r\n    final List<Object> initializedParams = new ArrayList<>(1);\r\n    doAnswer(invocation -> {\r\n        initializedParams.add(invocation.getArgument(0));\r\n        return null;\r\n    }).when(manager).initializeParameters(any());\r\n    final Parameters params = new Parameters(manager);\r\n    final XMLBuilderParameters xmlParams = params.xml();\r\n    assertEquals(1, initializedParams.size());\r\n    assertSame(xmlParams, initializedParams.get(0));\r\n    verify(manager).initializeParameters(any());\r\n    verifyNoMoreInteractions(manager);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testBasic",
  "sourceCode" : "/**\r\n * Tests whether a basic parameters object can be created.\r\n */\r\n@Test\r\nvoid testBasic() {\r\n    final BasicBuilderParameters basic = new Parameters().basic();\r\n    assertNotNull(basic);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testCombined",
  "sourceCode" : "/**\r\n * Tests whether a combined parameters object can be created.\r\n */\r\n@Test\r\nvoid testCombined() {\r\n    final Map<String, Object> map = new Parameters().combined().setThrowExceptionOnMissing(true).setBasePath(\"test\").setListDelimiterHandler(listHandler).getParameters();\r\n    final CombinedBuilderParametersImpl cparams = CombinedBuilderParametersImpl.fromParameters(map);\r\n    assertEquals(\"test\", cparams.getBasePath());\r\n    checkBasicProperties(map);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testDatabase",
  "sourceCode" : "/**\r\n * Tests whether a parameters object for a database configuration can be created.\r\n */\r\n@Test\r\nvoid testDatabase() {\r\n    final Map<String, Object> map = new Parameters().database().setThrowExceptionOnMissing(true).setAutoCommit(true).setTable(\"table\").setListDelimiterHandler(listHandler).setKeyColumn(\"keyColumn\").getParameters();\r\n    checkBasicProperties(map);\r\n    assertEquals(\"table\", map.get(\"table\"));\r\n    assertEquals(\"keyColumn\", map.get(\"keyColumn\"));\r\n    assertEquals(Boolean.TRUE, map.get(\"autoCommit\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testDefaultParametersManager",
  "sourceCode" : "/**\r\n * Tests whether an uninitialized default parameters manager is created at construction time.\r\n */\r\n@Test\r\nvoid testDefaultParametersManager() {\r\n    final Parameters parameters = new Parameters();\r\n    assertNotNull(parameters.getDefaultParametersManager());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testFileBased",
  "sourceCode" : "/**\r\n * Tests whether a file-based parameters object can be created.\r\n */\r\n@Test\r\nvoid testFileBased() {\r\n    final Map<String, Object> map = new Parameters().fileBased().setThrowExceptionOnMissing(true).setEncoding(DEF_ENCODING).setListDelimiterHandler(listHandler).setFileName(\"test.xml\").getParameters();\r\n    final FileBasedBuilderParametersImpl fbparams = FileBasedBuilderParametersImpl.fromParameters(map);\r\n    assertEquals(\"test.xml\", fbparams.getFileHandler().getFileName());\r\n    assertEquals(DEF_ENCODING, fbparams.getFileHandler().getEncoding());\r\n    checkBasicProperties(map);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testFileBasedInheritance",
  "sourceCode" : "/**\r\n * Tests the inheritance structure of a fileBased parameters object.\r\n */\r\n@Test\r\nvoid testFileBasedInheritance() {\r\n    checkInheritance(new Parameters().fileBased());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testHierarchical",
  "sourceCode" : "/**\r\n * Tests whether a parameters object for a hierarchical configuration can be created.\r\n */\r\n@Test\r\nvoid testHierarchical() {\r\n    final ExpressionEngine engine = mock(ExpressionEngine.class);\r\n    final Map<String, Object> map = new Parameters().hierarchical().setThrowExceptionOnMissing(true).setExpressionEngine(engine).setFileName(\"test.xml\").setListDelimiterHandler(listHandler).getParameters();\r\n    checkBasicProperties(map);\r\n    final FileBasedBuilderParametersImpl fbp = FileBasedBuilderParametersImpl.fromParameters(map);\r\n    assertEquals(\"test.xml\", fbp.getFileHandler().getFileName());\r\n    assertEquals(engine, map.get(\"expressionEngine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testHierarchicalInheritance",
  "sourceCode" : "/**\r\n * Tests the inheritance structure of a hierarchical parameters object.\r\n */\r\n@Test\r\nvoid testHierarchicalInheritance() {\r\n    checkInheritance(new Parameters().hierarchical(), FileBasedBuilderParameters.class);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testInheritance",
  "sourceCode" : "/**\r\n * Tests whether the parameters objects created by the Parameters instance have a logic inheritance hierarchy. This\r\n * means that they also implement all base interfaces that make sense.\r\n */\r\n@Test\r\nvoid testInheritance() {\r\n    final Object params = new Parameters().xml();\r\n    final FileBasedBuilderParameters fbParams = assertInstanceOf(FileBasedBuilderParameters.class, params);\r\n    fbParams.setListDelimiterHandler(listHandler).setFileName(\"test.xml\").setThrowExceptionOnMissing(true);\r\n    final ExpressionEngine engine = mock(ExpressionEngine.class);\r\n    ((HierarchicalBuilderParameters) params).setExpressionEngine(engine);\r\n    final Map<String, Object> map = fbParams.getParameters();\r\n    checkBasicProperties(map);\r\n    assertSame(engine, map.get(\"expressionEngine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testJndi",
  "sourceCode" : "/**\r\n * Tests whether a JNDI parameters object can be created.\r\n */\r\n@Test\r\nvoid testJndi() {\r\n    final Map<String, Object> map = new Parameters().jndi().setThrowExceptionOnMissing(true).setPrefix(\"test\").setListDelimiterHandler(listHandler).getParameters();\r\n    assertEquals(\"test\", map.get(\"prefix\"));\r\n    checkBasicProperties(map);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testMultiFile",
  "sourceCode" : "/**\r\n * Tests whether a {@code MultiFileBuilderParameters} object can be created.\r\n */\r\n@Test\r\nvoid testMultiFile() {\r\n    final BuilderParameters bp = mock(BuilderParameters.class);\r\n    final String pattern = \"a pattern\";\r\n    final Map<String, Object> map = new Parameters().multiFile().setThrowExceptionOnMissing(true).setFilePattern(pattern).setListDelimiterHandler(listHandler).setManagedBuilderParameters(bp).getParameters();\r\n    checkBasicProperties(map);\r\n    final MultiFileBuilderParametersImpl params = MultiFileBuilderParametersImpl.fromParameters(map);\r\n    assertSame(bp, params.getManagedBuilderParameters());\r\n    assertEquals(pattern, params.getFilePattern());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testProperties",
  "sourceCode" : "/**\r\n * Tests whether a parameters object for a properties configuration can be created.\r\n */\r\n@Test\r\nvoid testProperties() {\r\n    final PropertiesConfiguration.IOFactory factory = mock(PropertiesConfiguration.IOFactory.class);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final ConfigurationConsumer<ConfigurationException> includeListener = mock(ConfigurationConsumer.class);\r\n    // @formatter:off\r\n    final Map<String, Object> map = new Parameters().properties().setThrowExceptionOnMissing(true).setFileName(\"test.properties\").setIncludeListener(includeListener).setIOFactory(factory).setListDelimiterHandler(listHandler).setIncludesAllowed(false).getParameters();\r\n    // @formatter:on\r\n    checkBasicProperties(map);\r\n    final FileBasedBuilderParametersImpl fbp = FileBasedBuilderParametersImpl.fromParameters(map);\r\n    assertEquals(\"test.properties\", fbp.getFileHandler().getFileName());\r\n    assertEquals(Boolean.FALSE, map.get(\"includesAllowed\"));\r\n    assertSame(includeListener, map.get(\"includeListener\"));\r\n    assertSame(factory, map.get(\"IOFactory\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testPropertiesInheritance",
  "sourceCode" : "/**\r\n * Tests the inheritance structure of a properties parameters object.\r\n */\r\n@Test\r\nvoid testPropertiesInheritance() {\r\n    checkInheritance(new Parameters().properties(), FileBasedBuilderParameters.class);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testProxyObjectMethods",
  "sourceCode" : "/**\r\n * Tests whether the proxy parameters object can deal with methods inherited from Object.\r\n */\r\n@Test\r\nvoid testProxyObjectMethods() {\r\n    final FileBasedBuilderParameters params = new Parameters().fileBased();\r\n    final String s = params.toString();\r\n    assertTrue(s.contains(FileBasedBuilderParametersImpl.class.getSimpleName()));\r\n    assertNotEquals(0, params.hashCode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testRegisterDefaultsHandlerNoStartClass",
  "sourceCode" : "/**\r\n * Tests the registration of a defaults handler if no start class is provided.\r\n */\r\n@Test\r\nvoid testRegisterDefaultsHandlerNoStartClass() {\r\n    final DefaultParametersManager manager = mock(DefaultParametersManager.class);\r\n    final DefaultParametersHandler<XMLBuilderParameters> handler = createHandlerMock();\r\n    final Parameters params = new Parameters(manager);\r\n    params.registerDefaultsHandler(XMLBuilderParameters.class, handler);\r\n    verify(manager).registerDefaultsHandler(XMLBuilderParameters.class, handler);\r\n    verifyNoMoreInteractions(manager);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testRegisterDefaultsHandlerWithStartClass",
  "sourceCode" : "/**\r\n * Tests whether a default handler with a start class can be registered.\r\n */\r\n@Test\r\nvoid testRegisterDefaultsHandlerWithStartClass() {\r\n    final DefaultParametersManager manager = mock(DefaultParametersManager.class);\r\n    final DefaultParametersHandler<XMLBuilderParameters> handler = createHandlerMock();\r\n    final Parameters params = new Parameters(manager);\r\n    params.registerDefaultsHandler(XMLBuilderParameters.class, handler, FileBasedBuilderParameters.class);\r\n    verify(manager).registerDefaultsHandler(XMLBuilderParameters.class, handler, FileBasedBuilderParameters.class);\r\n    verifyNoMoreInteractions(manager);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testXml",
  "sourceCode" : "/**\r\n * Tests whether a parameters object for an XML configuration can be created.\r\n */\r\n@Test\r\nvoid testXml() {\r\n    final ExpressionEngine engine = mock(ExpressionEngine.class);\r\n    final Map<String, Object> map = new Parameters().xml().setThrowExceptionOnMissing(true).setFileName(\"test.xml\").setValidating(true).setExpressionEngine(engine).setListDelimiterHandler(listHandler).setSchemaValidation(true).getParameters();\r\n    checkBasicProperties(map);\r\n    final FileBasedBuilderParametersImpl fbp = FileBasedBuilderParametersImpl.fromParameters(map);\r\n    assertEquals(\"test.xml\", fbp.getFileHandler().getFileName());\r\n    assertEquals(Boolean.TRUE, map.get(\"validating\"));\r\n    assertEquals(Boolean.TRUE, map.get(\"schemaValidation\"));\r\n    assertEquals(engine, map.get(\"expressionEngine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\fluent\\TestParameters.java",
  "methodName" : "testXmlInheritance",
  "sourceCode" : "/**\r\n * Tests the inheritance structure of an XML parameters object.\r\n */\r\n@Test\r\nvoid testXmlInheritance() {\r\n    checkInheritance(new Parameters().xml(), HierarchicalBuilderParameters.class, FileBasedBuilderParameters.class);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestAutoSaveListener.java",
  "methodName" : "testConfigurationChangedAfterLoading",
  "sourceCode" : "/**\r\n * Tests that after a load operation changes on the monitored configuration are detected again.\r\n */\r\n@Test\r\nvoid testConfigurationChangedAfterLoading() throws ConfigurationException {\r\n    final FileHandler handler = new FileHandler();\r\n    listener.loading(handler);\r\n    fireChangeEvent(false);\r\n    listener.loaded(handler);\r\n    fireChangeEvent(false);\r\n    verify(builder).save();\r\n    verifyNoMoreInteractions(builder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestAutoSaveListener.java",
  "methodName" : "testConfigurationChangedAutoSave",
  "sourceCode" : "/**\r\n * Tests whether a change of the monitored configuration causes a save operation.\r\n */\r\n@Test\r\nvoid testConfigurationChangedAutoSave() throws ConfigurationException {\r\n    fireChangeEvent(false);\r\n    verify(builder).save();\r\n    verifyNoMoreInteractions(builder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestAutoSaveListener.java",
  "methodName" : "testConfigurationChangedAutoSaveException",
  "sourceCode" : "/**\r\n * Tests whether an exception thrown by the builder's save() method is handled.\r\n */\r\n@Test\r\nvoid testConfigurationChangedAutoSaveException() throws ConfigurationException {\r\n    doThrow(new ConfigurationException()).when(builder).save();\r\n    fireChangeEvent(false);\r\n    verify(builder).save();\r\n    verifyNoMoreInteractions(builder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestAutoSaveListener.java",
  "methodName" : "testConfigurationChangedBeforeUpdateNoSave",
  "sourceCode" : "/**\r\n * Tests whether no auto save is triggered before the change to the monitored configuration actually happens.\r\n */\r\n@Test\r\nvoid testConfigurationChangedBeforeUpdateNoSave() {\r\n    fireChangeEvent(true);\r\n    verifyNoInteractions(builder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestAutoSaveListener.java",
  "methodName" : "testConfigurationChangedWhileLoading",
  "sourceCode" : "/**\r\n * Tests that updated during load operations do not create an auto save.\r\n */\r\n@Test\r\nvoid testConfigurationChangedWhileLoading() {\r\n    listener.loading(new FileHandler());\r\n    fireChangeEvent(false);\r\n    verifyNoInteractions(builder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestAutoSaveListener.java",
  "methodName" : "testUpdateFileHandler",
  "sourceCode" : "/**\r\n * Tests whether the file handler can be updated and is correctly initialized.\r\n */\r\n@Test\r\nvoid testUpdateFileHandler() {\r\n    final FileHandler handler = mock(FileHandler.class);\r\n    final FileHandler handler2 = mock(FileHandler.class);\r\n    listener.updateFileHandler(handler);\r\n    listener.updateFileHandler(handler2);\r\n    verify(handler).addFileHandlerListener(listener);\r\n    verify(handler).removeFileHandlerListener(listener);\r\n    verify(handler2).addFileHandlerListener(listener);\r\n    verifyNoMoreInteractions(builder, handler, handler2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestAutoSaveListener.java",
  "methodName" : "testUpdateFileHandlerNull",
  "sourceCode" : "/**\r\n * Tests whether updateFileHandler() can deal with null input. This is used for removing the listener when it is no\r\n * longer needed.\r\n */\r\n@Test\r\nvoid testUpdateFileHandlerNull() {\r\n    final FileHandler handler = mock(FileHandler.class);\r\n    listener.updateFileHandler(handler);\r\n    listener.updateFileHandler(null);\r\n    verify(handler).addFileHandlerListener(listener);\r\n    verify(handler).removeFileHandlerListener(listener);\r\n    verifyNoMoreInteractions(builder, handler);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testCloneDefaultLookups",
  "sourceCode" : "/**\r\n * Tests whether the collection with default lookups can be cloned, too.\r\n */\r\n@Test\r\nvoid testCloneDefaultLookups() {\r\n    final Lookup look = mock(Lookup.class);\r\n    final Collection<Lookup> looks = Collections.singleton(look);\r\n    params.setDefaultLookups(looks);\r\n    final BasicBuilderParameters clone = params.clone();\r\n    Collection<?> defLooks = (Collection<?>) params.getParameters().get(\"defaultLookups\");\r\n    defLooks.clear();\r\n    defLooks = (Collection<?>) clone.getParameters().get(\"defaultLookups\");\r\n    assertEquals(1, defLooks.size());\r\n    assertTrue(defLooks.contains(look));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testClonePrefixLookups",
  "sourceCode" : "/**\r\n * Tests whether the map with prefix lookups is cloned, too.\r\n */\r\n@Test\r\nvoid testClonePrefixLookups() {\r\n    final Lookup look = mock(Lookup.class);\r\n    final Map<String, Lookup> lookups = Collections.singletonMap(\"test\", look);\r\n    params.setPrefixLookups(lookups);\r\n    final BasicBuilderParameters clone = params.clone();\r\n    Map<?, ?> map = (Map<?, ?>) params.getParameters().get(\"prefixLookups\");\r\n    map.clear();\r\n    map = (Map<?, ?>) clone.getParameters().get(\"prefixLookups\");\r\n    assertEquals(1, map.size());\r\n    assertSame(look, map.get(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testCloneValues",
  "sourceCode" : "/**\r\n * Tests whether a cloned instance contains the same data as the original object.\r\n */\r\n@Test\r\nvoid testCloneValues() {\r\n    final ConfigurationLogger log = mock(ConfigurationLogger.class);\r\n    final ConfigurationInterpolator ci = mock(ConfigurationInterpolator.class);\r\n    final ListDelimiterHandler handler1 = mock(ListDelimiterHandler.class);\r\n    final ListDelimiterHandler handler2 = mock(ListDelimiterHandler.class);\r\n    params.setListDelimiterHandler(handler1);\r\n    params.setLogger(log);\r\n    params.setInterpolator(ci);\r\n    params.setThrowExceptionOnMissing(true);\r\n    final BasicBuilderParameters clone = params.clone();\r\n    params.setListDelimiterHandler(handler2);\r\n    params.setThrowExceptionOnMissing(false);\r\n    final Map<String, Object> map = clone.getParameters();\r\n    assertSame(log, map.get(\"logger\"));\r\n    assertSame(ci, map.get(\"interpolator\"));\r\n    assertEquals(handler1, map.get(\"listDelimiterHandler\"));\r\n    assertEquals(Boolean.TRUE, map.get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testDefaults",
  "sourceCode" : "/**\r\n * Tests the default parameter values.\r\n */\r\n@Test\r\nvoid testDefaults() {\r\n    final Map<String, Object> paramMap = params.getParameters();\r\n    assertTrue(paramMap.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchBeanHelperNoSet",
  "sourceCode" : "/**\r\n * Tests fetchBeanHelper() if no helper was set.\r\n */\r\n@Test\r\nvoid testFetchBeanHelperNoSet() {\r\n    assertNull(BasicBuilderParameters.fetchBeanHelper(params.getParameters()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchBeanHelperNullMap",
  "sourceCode" : "/**\r\n * Tries to invoke fetchBeanHelper() on a null map.\r\n */\r\n@Test\r\nvoid testFetchBeanHelperNullMap() {\r\n    assertThrows(IllegalArgumentException.class, () -> BasicBuilderParameters.fetchBeanHelper(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchInterpolatorSpecification",
  "sourceCode" : "/**\r\n * Tests whether a specification object for interpolation can be obtained.\r\n */\r\n@Test\r\nvoid testFetchInterpolatorSpecification() {\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    final Lookup l1 = mock(Lookup.class);\r\n    final Lookup l2 = mock(Lookup.class);\r\n    final Lookup l3 = mock(Lookup.class);\r\n    final Map<String, Lookup> prefixLookups = new HashMap<>();\r\n    prefixLookups.put(\"p1\", l1);\r\n    prefixLookups.put(\"p2\", l2);\r\n    final Collection<Lookup> defLookups = Collections.singleton(l3);\r\n    params.setParentInterpolator(parent);\r\n    params.setPrefixLookups(prefixLookups);\r\n    params.setDefaultLookups(defLookups);\r\n    final Map<String, Object> map = params.getParameters();\r\n    final InterpolatorSpecification spec = BasicBuilderParameters.fetchInterpolatorSpecification(map);\r\n    assertSame(parent, spec.getParentInterpolator());\r\n    assertEquals(prefixLookups, spec.getPrefixLookups());\r\n    assertEquals(1, spec.getDefaultLookups().size());\r\n    assertTrue(spec.getDefaultLookups().contains(l3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchInterpolatorSpecificationEmpty",
  "sourceCode" : "/**\r\n * Tests that an empty map does not cause any problems.\r\n */\r\n@Test\r\nvoid testFetchInterpolatorSpecificationEmpty() {\r\n    final InterpolatorSpecification spec = BasicBuilderParameters.fetchInterpolatorSpecification(params.getParameters());\r\n    assertNull(spec.getInterpolator());\r\n    assertTrue(spec.getDefaultLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchInterpolatorSpecificationInvalidCollectionValue",
  "sourceCode" : "/**\r\n * Tests fetchInterpolatorSpecification() if the collection with default lookups contains an invalid value.\r\n */\r\n@Test\r\nvoid testFetchInterpolatorSpecificationInvalidCollectionValue() {\r\n    final Map<String, Object> map = new HashMap<>();\r\n    map.put(\"defaultLookups\", Collections.singleton(\"not a lookup\"));\r\n    assertThrows(IllegalArgumentException.class, () -> BasicBuilderParameters.fetchInterpolatorSpecification(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchInterpolatorSpecificationInvalidDataType",
  "sourceCode" : "/**\r\n * Tests fetchInterpolatorSpecification() if the map contains a property of an invalid data type.\r\n */\r\n@Test\r\nvoid testFetchInterpolatorSpecificationInvalidDataType() {\r\n    final Map<String, Object> map = new HashMap<>();\r\n    map.put(\"interpolator\", this);\r\n    assertThrows(IllegalArgumentException.class, () -> BasicBuilderParameters.fetchInterpolatorSpecification(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchInterpolatorSpecificationInvalidMapKey",
  "sourceCode" : "/**\r\n * Tests fetchInterpolatorSpecification() if the map with prefix lookups contains an invalid key.\r\n */\r\n@Test\r\nvoid testFetchInterpolatorSpecificationInvalidMapKey() {\r\n    final Map<String, Object> map = new HashMap<>();\r\n    final Map<Object, Object> prefix = new HashMap<>();\r\n    prefix.put(42, mock(Lookup.class));\r\n    map.put(\"prefixLookups\", prefix);\r\n    assertThrows(IllegalArgumentException.class, () -> BasicBuilderParameters.fetchInterpolatorSpecification(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchInterpolatorSpecificationInvalidMapValue",
  "sourceCode" : "/**\r\n * Tests fetchInterpolatorSpecification() if the map with prefix lookups contains an invalid value.\r\n */\r\n@Test\r\nvoid testFetchInterpolatorSpecificationInvalidMapValue() {\r\n    final Map<String, Object> map = new HashMap<>();\r\n    final Map<Object, Object> prefix = new HashMap<>();\r\n    prefix.put(\"test\", this);\r\n    map.put(\"prefixLookups\", prefix);\r\n    assertThrows(IllegalArgumentException.class, () -> BasicBuilderParameters.fetchInterpolatorSpecification(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchInterpolatorSpecificationNull",
  "sourceCode" : "/**\r\n * Tries to obtain an {@code InterpolatorSpecification} from a null map.\r\n */\r\n@Test\r\nvoid testFetchInterpolatorSpecificationNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> BasicBuilderParameters.fetchInterpolatorSpecification(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testFetchInterpolatorSpecificationWithInterpolator",
  "sourceCode" : "/**\r\n * Tests whether an InterpolatorSpecification can be fetched if a ConfigurationInterpolator is present.\r\n */\r\n@Test\r\nvoid testFetchInterpolatorSpecificationWithInterpolator() {\r\n    final ConfigurationInterpolator ci = mock(ConfigurationInterpolator.class);\r\n    params.setInterpolator(ci);\r\n    final InterpolatorSpecification spec = BasicBuilderParameters.fetchInterpolatorSpecification(params.getParameters());\r\n    assertSame(ci, spec.getInterpolator());\r\n    assertNull(spec.getParentInterpolator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testGetParametersDefensiveCopy",
  "sourceCode" : "/**\r\n * Tests whether a defensive copy is created when the parameter map is returned.\r\n */\r\n@Test\r\nvoid testGetParametersDefensiveCopy() {\r\n    final Map<String, Object> map1 = params.getParameters();\r\n    final Map<String, Object> mapCopy = new HashMap<>(map1);\r\n    map1.put(\"otherProperty\", \"value\");\r\n    final Map<String, Object> map2 = params.getParameters();\r\n    assertNotSame(map1, map2);\r\n    assertEquals(mapCopy, map2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testInheritFrom",
  "sourceCode" : "/**\r\n * Tests whether properties can be inherited from another parameters map.\r\n */\r\n@Test\r\nvoid testInheritFrom() {\r\n    final BeanHelper beanHelper = new BeanHelper();\r\n    final ConfigurationDecoder decoder = mock(ConfigurationDecoder.class);\r\n    final ConversionHandler conversionHandler = new DefaultConversionHandler();\r\n    final ListDelimiterHandler listDelimiterHandler = new DefaultListDelimiterHandler('#');\r\n    final ConfigurationLogger logger = new ConfigurationLogger(\"test\");\r\n    final Synchronizer synchronizer = new ReadWriteSynchronizer();\r\n    params.setBeanHelper(beanHelper).setConfigurationDecoder(decoder).setConversionHandler(conversionHandler).setListDelimiterHandler(listDelimiterHandler).setLogger(logger).setSynchronizer(synchronizer).setThrowExceptionOnMissing(true);\r\n    final BasicBuilderParameters p2 = new BasicBuilderParameters();\r\n    p2.inheritFrom(params.getParameters());\r\n    final Map<String, Object> parameters = p2.getParameters();\r\n    assertEquals(beanHelper, parameters.get(\"config-BeanHelper\"));\r\n    assertEquals(decoder, parameters.get(\"configurationDecoder\"));\r\n    assertEquals(conversionHandler, parameters.get(\"conversionHandler\"));\r\n    assertEquals(listDelimiterHandler, parameters.get(\"listDelimiterHandler\"));\r\n    assertEquals(logger, parameters.get(\"logger\"));\r\n    assertEquals(synchronizer, parameters.get(\"synchronizer\"));\r\n    assertEquals(Boolean.TRUE, parameters.get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testInheritFromNull",
  "sourceCode" : "/**\r\n * Tests whether null input is handled by inheritFrom().\r\n */\r\n@Test\r\nvoid testInheritFromNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> params.inheritFrom(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testInheritFromUndefinedProperties",
  "sourceCode" : "/**\r\n * Tests that undefined properties are not copied over by inheritFrom().\r\n */\r\n@Test\r\nvoid testInheritFromUndefinedProperties() {\r\n    final BasicBuilderParameters p2 = new BasicBuilderParameters().setThrowExceptionOnMissing(true);\r\n    p2.inheritFrom(Collections.<String, Object>emptyMap());\r\n    final Map<String, Object> parameters = p2.getParameters();\r\n    assertEquals(Collections.singletonMap(\"throwExceptionOnMissing\", Boolean.TRUE), parameters);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testMerge",
  "sourceCode" : "/**\r\n * Tests whether properties of other parameter objects can be merged.\r\n */\r\n@Test\r\nvoid testMerge() {\r\n    final ListDelimiterHandler handler1 = mock(ListDelimiterHandler.class);\r\n    final ListDelimiterHandler handler2 = mock(ListDelimiterHandler.class);\r\n    final Map<String, Object> props = new HashMap<>();\r\n    props.put(\"throwExceptionOnMissing\", Boolean.TRUE);\r\n    props.put(\"listDelimiterHandler\", handler1);\r\n    props.put(\"other\", \"test\");\r\n    props.put(BuilderParameters.RESERVED_PARAMETER_PREFIX + \"test\", \"reserved\");\r\n    final BuilderParameters p = mock(BuilderParameters.class);\r\n    when(p.getParameters()).thenReturn(props);\r\n    params.setListDelimiterHandler(handler2);\r\n    params.merge(p);\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertEquals(handler2, map.get(\"listDelimiterHandler\"));\r\n    assertEquals(Boolean.TRUE, map.get(\"throwExceptionOnMissing\"));\r\n    assertEquals(\"test\", map.get(\"other\"));\r\n    assertFalse(map.containsKey(BuilderParameters.RESERVED_PARAMETER_PREFIX + \"test\"));\r\n    verify(p).getParameters();\r\n    verifyNoMoreInteractions(p);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testMergeNull",
  "sourceCode" : "/**\r\n * Tries a merge with a null object.\r\n */\r\n@Test\r\nvoid testMergeNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> params.merge(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetBeanHelper",
  "sourceCode" : "/**\r\n * Tests whether a BeanHelper can be set.\r\n */\r\n@Test\r\nvoid testSetBeanHelper() {\r\n    final BeanHelper helper = new BeanHelper();\r\n    assertSame(params, params.setBeanHelper(helper));\r\n    assertSame(helper, BasicBuilderParameters.fetchBeanHelper(params.getParameters()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetConfigurationDecoder",
  "sourceCode" : "/**\r\n * Tests whether a decoder can be set.\r\n */\r\n@Test\r\nvoid testSetConfigurationDecoder() {\r\n    final ConfigurationDecoder decoder = mock(ConfigurationDecoder.class);\r\n    assertSame(params, params.setConfigurationDecoder(decoder));\r\n    assertSame(decoder, params.getParameters().get(\"configurationDecoder\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetConversionHandler",
  "sourceCode" : "/**\r\n * Tests whether a ConversionHandler can be set.\r\n */\r\n@Test\r\nvoid testSetConversionHandler() {\r\n    final ConversionHandler handler = mock(ConversionHandler.class);\r\n    assertSame(params, params.setConversionHandler(handler));\r\n    assertSame(handler, params.getParameters().get(\"conversionHandler\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetDefaultLookups",
  "sourceCode" : "/**\r\n * Tests whether default lookups can be set.\r\n */\r\n@Test\r\nvoid testSetDefaultLookups() {\r\n    final Lookup look = mock(Lookup.class);\r\n    final Collection<Lookup> looks = Collections.singleton(look);\r\n    assertSame(params, params.setDefaultLookups(looks));\r\n    final Collection<?> col = (Collection<?>) params.getParameters().get(\"defaultLookups\");\r\n    assertNotSame(col, looks);\r\n    assertEquals(1, col.size());\r\n    assertSame(look, col.iterator().next());\r\n    final Collection<?> col2 = (Collection<?>) params.getParameters().get(\"defaultLookups\");\r\n    assertNotSame(col, col2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetDefaultLookupsNull",
  "sourceCode" : "/**\r\n * Tests whether null values are handled by setDefaultLookups().\r\n */\r\n@Test\r\nvoid testSetDefaultLookupsNull() {\r\n    params.setDefaultLookups(new ArrayList<>());\r\n    params.setDefaultLookups(null);\r\n    assertFalse(params.getParameters().containsKey(\"defaultLookups\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetInterpolator",
  "sourceCode" : "/**\r\n * Tests whether a {@code ConfigurationInterpolator} can be set.\r\n */\r\n@Test\r\nvoid testSetInterpolator() {\r\n    final ConfigurationInterpolator ci = mock(ConfigurationInterpolator.class);\r\n    assertSame(params, params.setInterpolator(ci));\r\n    assertSame(ci, params.getParameters().get(\"interpolator\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetListDelimiter",
  "sourceCode" : "/**\r\n * Tests whether the list delimiter handler property can be set.\r\n */\r\n@Test\r\nvoid testSetListDelimiter() {\r\n    final ListDelimiterHandler handler = mock(ListDelimiterHandler.class);\r\n    assertSame(params, params.setListDelimiterHandler(handler));\r\n    assertSame(handler, params.getParameters().get(\"listDelimiterHandler\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetLogger",
  "sourceCode" : "/**\r\n * Tests whether the logger parameter can be set.\r\n */\r\n@Test\r\nvoid testSetLogger() {\r\n    final ConfigurationLogger log = mock(ConfigurationLogger.class);\r\n    assertSame(params, params.setLogger(log));\r\n    assertSame(log, params.getParameters().get(\"logger\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetLookupsAndInterpolator",
  "sourceCode" : "/**\r\n * Tests whether a custom {@code ConfigurationInterpolator} overrides settings for custom lookups.\r\n */\r\n@Test\r\nvoid testSetLookupsAndInterpolator() {\r\n    final Lookup look1 = mock(Lookup.class);\r\n    final Lookup look2 = mock(Lookup.class);\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    final ConfigurationInterpolator ci = mock(ConfigurationInterpolator.class);\r\n    params.setDefaultLookups(Collections.singleton(look1));\r\n    params.setPrefixLookups(Collections.singletonMap(\"test\", look2));\r\n    params.setInterpolator(ci);\r\n    params.setParentInterpolator(parent);\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertFalse(map.containsKey(\"prefixLookups\"));\r\n    assertFalse(map.containsKey(\"defaultLookups\"));\r\n    assertFalse(map.containsKey(\"parentInterpolator\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetParentInterpolator",
  "sourceCode" : "/**\r\n * Tests whether a parent {@code ConfigurationInterpolator} can be set.\r\n */\r\n@Test\r\nvoid testSetParentInterpolator() {\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    assertSame(params, params.setParentInterpolator(parent));\r\n    assertSame(parent, params.getParameters().get(\"parentInterpolator\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetPrefixLookups",
  "sourceCode" : "/**\r\n * Tests whether prefix lookups can be set.\r\n */\r\n@Test\r\nvoid testSetPrefixLookups() {\r\n    final Lookup look = mock(Lookup.class);\r\n    final Map<String, Lookup> lookups = Collections.singletonMap(\"test\", look);\r\n    assertSame(params, params.setPrefixLookups(lookups));\r\n    final Map<?, ?> map = (Map<?, ?>) params.getParameters().get(\"prefixLookups\");\r\n    assertNotSame(lookups, map);\r\n    assertEquals(Collections.singletonMap(\"test\", look), map);\r\n    final Map<?, ?> map2 = (Map<?, ?>) params.getParameters().get(\"prefixLookups\");\r\n    assertNotSame(map, map2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetPrefixLookupsNull",
  "sourceCode" : "/**\r\n * Tests whether null values are handled by setPrefixLookups().\r\n */\r\n@Test\r\nvoid testSetPrefixLookupsNull() {\r\n    params.setPrefixLookups(new HashMap<>());\r\n    params.setPrefixLookups(null);\r\n    assertFalse(params.getParameters().containsKey(\"prefixLookups\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetSynchronizer",
  "sourceCode" : "/**\r\n * Tests whether a Synchronizer can be set.\r\n */\r\n@Test\r\nvoid testSetSynchronizer() {\r\n    final Synchronizer sync = mock(Synchronizer.class);\r\n    assertSame(params, params.setSynchronizer(sync));\r\n    assertSame(sync, params.getParameters().get(\"synchronizer\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicBuilderParameters.java",
  "methodName" : "testSetThrowExceptionOnMissing",
  "sourceCode" : "/**\r\n * Tests whether the throw exception on missing property can be set.\r\n */\r\n@Test\r\nvoid testSetThrowExceptionOnMissing() {\r\n    assertSame(params, params.setThrowExceptionOnMissing(true));\r\n    assertEquals(Boolean.TRUE, params.getParameters().get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testAddConfigurationListener",
  "sourceCode" : "/**\r\n * Tests whether configuration listeners can be added.\r\n */\r\n@Test\r\nvoid testAddConfigurationListener() throws ConfigurationException {\r\n    final EventListener<ConfigurationEvent> l1 = createEventListener();\r\n    final EventListener<ConfigurationEvent> l2 = createEventListener();\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.addEventListener(ConfigurationEvent.ANY, l1);\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    builder.addEventListener(ConfigurationEvent.ANY, l2);\r\n    final Collection<EventListener<? super ConfigurationEvent>> listeners = config.getEventListeners(ConfigurationEvent.ANY);\r\n    assertTrue(listeners.contains(l1));\r\n    assertTrue(listeners.contains(l2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testAddParameters",
  "sourceCode" : "/**\r\n * Tests whether additional parameters can be added.\r\n */\r\n@Test\r\nvoid testAddParameters() {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, createTestParameters());\r\n    final Map<String, Object> params = createTestParameters();\r\n    params.put(\"anotherParameter\", \"value\");\r\n    assertSame(builder, builder.addParameters(params));\r\n    final Map<String, Object> params2 = builder.getParameters();\r\n    assertTrue(params2.keySet().containsAll(createTestParameters().keySet()));\r\n    assertEquals(\"value\", params2.get(\"anotherParameter\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testAddParametersNull",
  "sourceCode" : "/**\r\n * Tests whether null parameters are handled correctly by addParameters().\r\n */\r\n@Test\r\nvoid testAddParametersNull() {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, createTestParameters());\r\n    final Map<String, Object> params = builder.getParameters();\r\n    builder.addParameters(null);\r\n    assertEquals(params, builder.getParameters());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testBeanHelperInConfiguration",
  "sourceCode" : "/**\r\n * Tests whether a configured BeanHelper is used for result creation.\r\n */\r\n@Test\r\nvoid testBeanHelperInConfiguration() throws ConfigurationException {\r\n    final Set<Class<?>> classesPassedToFactory = new HashSet<>();\r\n    final BeanFactory factory = new DefaultBeanFactory() {\r\n\r\n        @Override\r\n        public Object createBean(final BeanCreationContext bcc) throws Exception {\r\n            classesPassedToFactory.add(bcc.getBeanClass());\r\n            return super.createBean(bcc);\r\n        }\r\n    };\r\n    final BeanHelper helper = new BeanHelper(factory);\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.configure(new BasicBuilderParameters().setBeanHelper(helper));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertTrue(classesPassedToFactory.contains(config.getClass()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testConfigure",
  "sourceCode" : "/**\r\n * Tests whether parameters can be set using the configure() method.\r\n */\r\n@Test\r\nvoid testConfigure() {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class).configure(new BasicBuilderParameters().setListDelimiterHandler(listHandler).setThrowExceptionOnMissing(true));\r\n    final Map<String, Object> params2 = new HashMap<>(builder.getParameters());\r\n    assertEquals(createTestParameters(), params2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testConnectToReloadingController",
  "sourceCode" : "/**\r\n * Tests whether a builder can be connected to a reloading controller.\r\n */\r\n@Test\r\nvoid testConnectToReloadingController() throws ConfigurationException {\r\n    final ReloadingDetector detector = mock(ReloadingDetector.class);\r\n    final ReloadingController controller = new ReloadingController(detector);\r\n    final BasicConfigurationBuilder<Configuration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final Configuration configuration = builder.getConfiguration();\r\n    when(detector.isReloadingRequired()).thenReturn(Boolean.TRUE);\r\n    builder.connectToReloadingController(controller);\r\n    controller.checkForReloading(null);\r\n    assertTrue(controller.isInReloadingState());\r\n    assertNotSame(configuration, builder.getConfiguration());\r\n    assertFalse(controller.isInReloadingState());\r\n    verify(detector).isReloadingRequired();\r\n    verify(detector).reloadingPerformed();\r\n    verifyNoMoreInteractions(detector);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testConnectToReloadingControllerNull",
  "sourceCode" : "/**\r\n * Tries to connect to a null reloading controller.\r\n */\r\n@Test\r\nvoid testConnectToReloadingControllerNull() {\r\n    final BasicConfigurationBuilder<Configuration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    assertThrows(IllegalArgumentException.class, () -> builder.connectToReloadingController(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testCopyEventListeners",
  "sourceCode" : "/**\r\n * Tests whether event listeners can be copied to another builder.\r\n */\r\n@Test\r\nvoid testCopyEventListeners() throws ConfigurationException {\r\n    final EventListener<ConfigurationEvent> l1 = createEventListener();\r\n    final EventListener<ConfigurationEvent> l2 = createEventListener();\r\n    final EventListener<ConfigurationErrorEvent> l3 = new ErrorListenerTestImpl(null);\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.addEventListener(ConfigurationEvent.ANY, l1);\r\n    builder.addEventListener(ConfigurationEvent.ANY_HIERARCHICAL, l2);\r\n    builder.addEventListener(ConfigurationErrorEvent.ANY, l3);\r\n    final BasicConfigurationBuilder<XMLConfiguration> builder2 = new BasicConfigurationBuilder<>(XMLConfiguration.class);\r\n    builder.copyEventListeners(builder2);\r\n    final XMLConfiguration config = builder2.getConfiguration();\r\n    Collection<EventListener<? super ConfigurationEvent>> listeners = config.getEventListeners(ConfigurationEvent.ANY);\r\n    assertEquals(1, listeners.size());\r\n    assertTrue(listeners.contains(l1));\r\n    listeners = config.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL);\r\n    assertEquals(2, listeners.size());\r\n    assertTrue(listeners.contains(l1));\r\n    assertTrue(listeners.contains(l2));\r\n    final Collection<EventListener<? super ConfigurationErrorEvent>> errListeners = config.getEventListeners(ConfigurationErrorEvent.ANY);\r\n    assertEquals(1, errListeners.size());\r\n    assertTrue(errListeners.contains(l3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testEventListenerConfiguration",
  "sourceCode" : "/**\r\n * Tests whether configuration listeners can be defined via the configure() method.\r\n */\r\n@Test\r\nvoid testEventListenerConfiguration() throws ConfigurationException {\r\n    final EventListenerTestImpl listener1 = new EventListenerTestImpl(null);\r\n    final EventListenerRegistrationData<ConfigurationErrorEvent> regData = new EventListenerRegistrationData<>(ConfigurationErrorEvent.WRITE, new ErrorListenerTestImpl(null));\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class).configure(new EventListenerParameters().addEventListener(ConfigurationEvent.ANY, listener1).addEventListener(regData));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertTrue(config.getEventListeners(ConfigurationEvent.ANY).contains(listener1));\r\n    assertTrue(config.getEventListeners(regData.getEventType()).contains(regData.getListener()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testGetConfiguration",
  "sourceCode" : "/**\r\n * Tests whether the builder can create a correctly initialized configuration object.\r\n */\r\n@Test\r\nvoid testGetConfiguration() throws ConfigurationException {\r\n    final PropertiesConfiguration config = new BasicConfigurationBuilder<>(PropertiesConfiguration.class).configure(new BasicBuilderParameters().setListDelimiterHandler(listHandler).setThrowExceptionOnMissing(true)).getConfiguration();\r\n    assertTrue(config.isThrowExceptionOnMissing());\r\n    assertEquals(listHandler, config.getListDelimiterHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testGetConfigurationConcurrently",
  "sourceCode" : "/**\r\n * Tests whether the builder can be accessed by multiple threads and that only a single result object is produced.\r\n */\r\n@Test\r\nvoid testGetConfigurationConcurrently() throws Exception {\r\n    final int threadCount = 32;\r\n    final CountDownLatch startLatch = new CountDownLatch(1);\r\n    final CountDownLatch endLatch = new CountDownLatch(threadCount);\r\n    final ConfigurationBuilder<?> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final AccessBuilderThread[] threads = new AccessBuilderThread[threadCount];\r\n    for (int i = 0; i < threadCount; i++) {\r\n        threads[i] = new AccessBuilderThread(startLatch, endLatch, builder);\r\n        threads[i].start();\r\n    }\r\n    startLatch.countDown();\r\n    assertTrue(endLatch.await(5, TimeUnit.SECONDS));\r\n    final Set<Object> results = new HashSet<>();\r\n    for (final AccessBuilderThread t : threads) {\r\n        results.add(t.result);\r\n    }\r\n    assertEquals(1, results.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testGetParametersModify",
  "sourceCode" : "/**\r\n * Tests that the map with parameters cannot be modified.\r\n */\r\n@Test\r\nvoid testGetParametersModify() {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, createTestParameters());\r\n    final Map<String, Object> parameters = builder.getParameters();\r\n    assertThrows(UnsupportedOperationException.class, parameters::clear);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testGetResultDeclarationInvalidBeanClass",
  "sourceCode" : "/**\r\n * Tests whether a check for the correct bean class is made.\r\n */\r\n@Test\r\nvoid testGetResultDeclarationInvalidBeanClass() {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<PropertiesConfiguration>(PropertiesConfiguration.class, createTestParameters()) {\r\n\r\n        @Override\r\n        protected BeanDeclaration createResultDeclaration(final Map<String, Object> params) {\r\n            return new XMLBeanDeclaration(new BaseHierarchicalConfiguration(), \"bean\", true, Object.class.getName());\r\n        }\r\n    };\r\n    assertThrows(ConfigurationRuntimeException.class, builder::getConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testInitializableCalled",
  "sourceCode" : "/**\r\n * Tests whether a configuration implementing {@code Initializable} is correctly handled.\r\n */\r\n@Test\r\nvoid testInitializableCalled() throws ConfigurationException {\r\n    final BasicConfigurationBuilder<InitializableConfiguration> builder = new BasicConfigurationBuilder<>(InitializableConfiguration.class);\r\n    builder.configure(new BasicBuilderParameters().setThrowExceptionOnMissing(true));\r\n    final InitializableConfiguration config = builder.getConfiguration();\r\n    assertEquals(\"Initialized with flag true\", config.getInitProperty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testInitializationErrorAllowed",
  "sourceCode" : "/**\r\n * Tests an exception during configuration initialization if the allowFailOnInit flag is true.\r\n */\r\n@Test\r\nvoid testInitializationErrorAllowed() throws ConfigurationException {\r\n    final BasicConfigurationBuilderInitFailImpl builder = new BasicConfigurationBuilderInitFailImpl(true);\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testInitializationErrorNotAllowed",
  "sourceCode" : "/**\r\n * Tests an exception during configuration initialization if the allowFailOnInit flag is false.\r\n */\r\n@Test\r\nvoid testInitializationErrorNotAllowed() {\r\n    final BasicConfigurationBuilderInitFailImpl builder = new BasicConfigurationBuilderInitFailImpl(false);\r\n    assertThrows(ConfigurationException.class, builder::getConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testInitNoClass",
  "sourceCode" : "/**\r\n * Tries to create an instance without a result class.\r\n */\r\n@Test\r\nvoid testInitNoClass() {\r\n    assertThrows(IllegalArgumentException.class, () -> new BasicConfigurationBuilder<Configuration>(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testInitWithParameters",
  "sourceCode" : "/**\r\n * Tests whether initialization parameters can be passed to the constructor.\r\n */\r\n@Test\r\nvoid testInitWithParameters() {\r\n    final Map<String, Object> params = createTestParameters();\r\n    final BasicConfigurationBuilder<Configuration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, params);\r\n    final Map<String, Object> params2 = new HashMap<>(builder.getParameters());\r\n    assertEquals(createTestParameters(), params2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testInitWithParametersDefensiveCopy",
  "sourceCode" : "/**\r\n * Tests whether a copy of the passed in parameters is created.\r\n */\r\n@Test\r\nvoid testInitWithParametersDefensiveCopy() {\r\n    final Map<String, Object> params = createTestParameters();\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, params);\r\n    params.put(\"anotherParameter\", \"value\");\r\n    final Map<String, Object> params2 = new HashMap<>(builder.getParameters());\r\n    assertEquals(createTestParameters(), params2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testInitWithParametersNull",
  "sourceCode" : "/**\r\n * Tests whether null parameters are handled correctly.\r\n */\r\n@Test\r\nvoid testInitWithParametersNull() {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, null);\r\n    assertTrue(builder.getParameters().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testRemoveConfigurationListener",
  "sourceCode" : "/**\r\n * Tests whether configuration listeners can be removed.\r\n */\r\n@Test\r\nvoid testRemoveConfigurationListener() throws ConfigurationException {\r\n    final EventListener<ConfigurationEvent> l1 = createEventListener();\r\n    final EventListener<ConfigurationEvent> l2 = createEventListener();\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.addEventListener(ConfigurationEvent.ANY_HIERARCHICAL, l1);\r\n    builder.addEventListener(ConfigurationEvent.ANY, l2);\r\n    assertTrue(builder.removeEventListener(ConfigurationEvent.ANY, l2));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertFalse(config.getEventListeners(ConfigurationEvent.ANY).contains(l2));\r\n    assertTrue(config.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL).contains(l1));\r\n    builder.removeEventListener(ConfigurationEvent.ANY_HIERARCHICAL, l1);\r\n    assertFalse(config.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL).contains(l1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testRemoveConfigurationListenersOnReset",
  "sourceCode" : "/**\r\n * Tests whether configuration listeners are removed from the managed configuration when the builder's result object is\r\n * reset.\r\n */\r\n@Test\r\nvoid testRemoveConfigurationListenersOnReset() throws ConfigurationException {\r\n    final EventListenerTestImpl listener = new EventListenerTestImpl(null);\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class).configure(new EventListenerParameters().addEventListener(ConfigurationEvent.ANY, listener));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    builder.resetResult();\r\n    config.addProperty(\"foo\", \"bar\");\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testReservedParameter",
  "sourceCode" : "/**\r\n * Tests whether parameters starting with a reserved prefix are filtered out before result objects are initialized.\r\n */\r\n@Test\r\nvoid testReservedParameter() throws ConfigurationException {\r\n    final Map<String, Object> params = new HashMap<>();\r\n    params.put(\"throwExceptionOnMissing\", Boolean.TRUE);\r\n    params.put(\"config-test\", \"a test\");\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, params);\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertTrue(config.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testReset",
  "sourceCode" : "/**\r\n * Tests a full reset of the builder.\r\n */\r\n@Test\r\nvoid testReset() throws ConfigurationException {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, createTestParameters());\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    builder.reset();\r\n    final PropertiesConfiguration config2 = builder.getConfiguration();\r\n    assertNotSame(config, config2);\r\n    assertFalse(config2.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testResetParameters",
  "sourceCode" : "/**\r\n * Tests whether all parameters can be reset.\r\n */\r\n@Test\r\nvoid testResetParameters() {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, createTestParameters());\r\n    builder.resetParameters();\r\n    assertTrue(builder.getParameters().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testResetResult",
  "sourceCode" : "/**\r\n * Tests whether a reset of the result object can be performed.\r\n */\r\n@Test\r\nvoid testResetResult() throws ConfigurationException {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, createTestParameters());\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    builder.resetResult();\r\n    final PropertiesConfiguration config2 = builder.getConfiguration();\r\n    assertNotSame(config, config2);\r\n    assertTrue(config2.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilder.java",
  "methodName" : "testSetParameters",
  "sourceCode" : "/**\r\n * Tests whether new parameters can be set to replace existing ones.\r\n */\r\n@Test\r\nvoid testSetParameters() {\r\n    final Map<String, Object> params1 = new HashMap<>();\r\n    params1.put(\"someParameter\", \"value\");\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class, params1);\r\n    assertSame(builder, builder.setParameters(createTestParameters()));\r\n    final Map<String, Object> params2 = new HashMap<>(builder.getParameters());\r\n    assertEquals(createTestParameters(), params2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testBuilderEventType",
  "sourceCode" : "/**\r\n * Tests whether the base type for builder events is correctly configured.\r\n */\r\n@Test\r\nvoid testBuilderEventType() {\r\n    final EventType<ConfigurationBuilderEvent> builderEventType = ConfigurationBuilderEvent.ANY;\r\n    assertEquals(Event.ANY, builderEventType.getSuperType());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testBuilderResetEvent",
  "sourceCode" : "/**\r\n * Tests whether builder reset events are correctly distributed.\r\n */\r\n@Test\r\nvoid testBuilderResetEvent() {\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.addEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n    builder.reset();\r\n    builder.resetResult();\r\n    ConfigurationBuilderEvent event = listener.nextEvent(ConfigurationBuilderEvent.RESET);\r\n    assertSame(builder, event.getSource());\r\n    event = listener.nextEvent(ConfigurationBuilderEvent.RESET);\r\n    assertSame(builder, event.getSource());\r\n    listener.assertNoMoreEvents();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testBuilderResetEventType",
  "sourceCode" : "/**\r\n * Tests whether the reset builder event type is correctly configured.\r\n */\r\n@Test\r\nvoid testBuilderResetEventType() {\r\n    final EventType<ConfigurationBuilderEvent> builderResetType = ConfigurationBuilderEvent.RESET;\r\n    assertEquals(ConfigurationBuilderEvent.ANY, builderResetType.getSuperType());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testConfigurationRequestEvent",
  "sourceCode" : "/**\r\n * Tests whether a configuration request event is generated.\r\n */\r\n@Test\r\nvoid testConfigurationRequestEvent() throws ConfigurationException {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.getConfiguration();\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    builder.addEventListener(ConfigurationBuilderEvent.ANY, listener);\r\n    builder.getConfiguration();\r\n    final ConfigurationBuilderEvent event = listener.nextEvent(ConfigurationBuilderEvent.CONFIGURATION_REQUEST);\r\n    assertSame(builder, event.getSource());\r\n    listener.assertNoMoreEvents();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testConfigurationRequestEventType",
  "sourceCode" : "/**\r\n * Tests whether the configuration request event type is correctly configured.\r\n */\r\n@Test\r\nvoid testConfigurationRequestEventType() {\r\n    final EventType<ConfigurationBuilderEvent> eventType = ConfigurationBuilderEvent.CONFIGURATION_REQUEST;\r\n    assertEquals(ConfigurationBuilderEvent.ANY, eventType.getSuperType());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testRemoveEventListener",
  "sourceCode" : "/**\r\n * Tests whether an event listener can be removed again.\r\n */\r\n@Test\r\nvoid testRemoveEventListener() {\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.addEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n    builder.reset();\r\n    assertTrue(builder.removeEventListener(ConfigurationBuilderEvent.RESET, listener));\r\n    builder.resetResult();\r\n    listener.nextEvent(ConfigurationBuilderEvent.RESET);\r\n    listener.assertNoMoreEvents();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testRemoveEventListenerNotExisting",
  "sourceCode" : "/**\r\n * Tests removeEventListener() for a non-existing listener.\r\n */\r\n@Test\r\nvoid testRemoveEventListenerNotExisting() {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    builder.addEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n    assertFalse(builder.removeEventListener(ConfigurationBuilderEvent.CONFIGURATION_REQUEST, listener));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testResetOnConfigurationRequestEvent",
  "sourceCode" : "/**\r\n * Tests the use case that a listener on the request event triggers a reset of the builder.\r\n */\r\n@Test\r\nvoid testResetOnConfigurationRequestEvent() throws ConfigurationException {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final PropertiesConfiguration configuration = builder.getConfiguration();\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    builder.addEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n    builder.addEventListener(ConfigurationBuilderEvent.CONFIGURATION_REQUEST, event -> builder.resetResult());\r\n    final PropertiesConfiguration configuration2 = builder.getConfiguration();\r\n    assertNotSame(configuration, configuration2);\r\n    listener.nextEvent(ConfigurationBuilderEvent.RESET);\r\n    listener.assertNoMoreEvents();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testResultCreatedEvent",
  "sourceCode" : "/**\r\n * Tests whether a result created event is correctly generated.\r\n */\r\n@Test\r\nvoid testResultCreatedEvent() throws ConfigurationException {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    builder.addEventListener(ConfigurationBuilderEvent.ANY, listener);\r\n    final PropertiesConfiguration configuration = builder.getConfiguration();\r\n    listener.nextEvent(ConfigurationBuilderEvent.CONFIGURATION_REQUEST);\r\n    final ConfigurationBuilderResultCreatedEvent event = listener.nextEvent(ConfigurationBuilderResultCreatedEvent.RESULT_CREATED);\r\n    assertSame(builder, event.getSource());\r\n    assertSame(configuration, event.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testResultCreatedEventNoConfiguration",
  "sourceCode" : "/**\r\n * Tries to create an event about a newly created configuration without a configuration instance.\r\n */\r\n@Test\r\nvoid testResultCreatedEventNoConfiguration() {\r\n    final BasicConfigurationBuilder<Configuration> builder = new BasicConfigurationBuilder<>(Configuration.class);\r\n    assertThrows(IllegalArgumentException.class, () -> new ConfigurationBuilderResultCreatedEvent(builder, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBasicConfigurationBuilderEvents.java",
  "methodName" : "testResultCreatedEventType",
  "sourceCode" : "/**\r\n * Tests whether the type of a result created event is correctly configured.\r\n */\r\n@Test\r\nvoid testResultCreatedEventType() {\r\n    assertEquals(ConfigurationBuilderEvent.ANY, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED.getSuperType());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBuilderConfigurationWrapperFactory.java",
  "methodName" : "testConfigurationBuilderWrapper",
  "sourceCode" : "/**\r\n * Tests whether the returned configuration correctly wraps the builder.\r\n */\r\n@Test\r\nvoid testConfigurationBuilderWrapper() {\r\n    final BaseHierarchicalConfiguration conf = new BaseHierarchicalConfiguration();\r\n    final ConfigurationBuilder<BaseHierarchicalConfiguration> builder = createBuilderMock(conf);\r\n    conf.addProperty(\"test1\", \"value1\");\r\n    conf.addProperty(\"test2\", \"42\");\r\n    final BuilderConfigurationWrapperFactory factory = new BuilderConfigurationWrapperFactory();\r\n    final HierarchicalConfiguration<?> wrapper = factory.createBuilderConfigurationWrapper(HierarchicalConfiguration.class, builder);\r\n    assertEquals(\"value1\", wrapper.getString(\"test1\"));\r\n    assertEquals(42, wrapper.getInt(\"test2\"));\r\n    assertSame(conf.getNodeModel().getNodeHandler().getRootNode(), wrapper.getNodeModel().getNodeHandler().getRootNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBuilderConfigurationWrapperFactory.java",
  "methodName" : "testCreateBuilderConfigurationWrapperNoBuilder",
  "sourceCode" : "/**\r\n * Tries to create a wrapper without passing a builder.\r\n */\r\n@Test\r\nvoid testCreateBuilderConfigurationWrapperNoBuilder() {\r\n    final BuilderConfigurationWrapperFactory factory = new BuilderConfigurationWrapperFactory();\r\n    assertThrows(IllegalArgumentException.class, () -> factory.createBuilderConfigurationWrapper(Configuration.class, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBuilderConfigurationWrapperFactory.java",
  "methodName" : "testCreateBuilderConfigurationWrapperNoClass",
  "sourceCode" : "/**\r\n * Tries to create a wrapper without passing an interface class.\r\n */\r\n@Test\r\nvoid testCreateBuilderConfigurationWrapperNoClass() {\r\n    final BuilderConfigurationWrapperFactory factory = new BuilderConfigurationWrapperFactory(EventSourceSupport.BUILDER);\r\n    final ConfigurationBuilder<BaseHierarchicalConfiguration> builder = createBuilderMock(new BaseHierarchicalConfiguration());\r\n    assertThrows(IllegalArgumentException.class, () -> factory.createBuilderConfigurationWrapper(null, builder));\r\n    verifyNoInteractions(builder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBuilderConfigurationWrapperFactory.java",
  "methodName" : "testDefaultEventSourceSupport",
  "sourceCode" : "/**\r\n * Tests the default event source support level.\r\n */\r\n@Test\r\nvoid testDefaultEventSourceSupport() {\r\n    final BuilderConfigurationWrapperFactory factory = new BuilderConfigurationWrapperFactory();\r\n    assertEquals(EventSourceSupport.NONE, factory.getEventSourceSupport());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBuilderConfigurationWrapperFactory.java",
  "methodName" : "testEventSourceSupportBuilder",
  "sourceCode" : "/**\r\n * Tests whether EventSource methods can be delegated to the builder.\r\n */\r\n@Test\r\nvoid testEventSourceSupportBuilder() throws ConfigurationException {\r\n    final BasicConfigurationBuilder<PropertiesConfiguration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final EventListener<ConfigurationEvent> l1 = new EventListenerTestImpl(null);\r\n    final EventListener<ConfigurationEvent> l2 = new EventListenerTestImpl(null);\r\n    final BuilderConfigurationWrapperFactory factory = new BuilderConfigurationWrapperFactory(EventSourceSupport.BUILDER);\r\n    final EventSource src = (EventSource) factory.createBuilderConfigurationWrapper(Configuration.class, builder);\r\n    src.addEventListener(ConfigurationEvent.ANY, l1);\r\n    src.addEventListener(ConfigurationEvent.ANY_HIERARCHICAL, l2);\r\n    assertTrue(src.removeEventListener(ConfigurationEvent.ANY_HIERARCHICAL, l2));\r\n    assertFalse(src.removeEventListener(ConfigurationEvent.ANY_HIERARCHICAL, l2));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    final Collection<EventListener<? super ConfigurationEvent>> listeners = config.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL);\r\n    assertTrue(listeners.contains(l1));\r\n    assertFalse(listeners.contains(l2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBuilderConfigurationWrapperFactory.java",
  "methodName" : "testEventSourceSupportDummy",
  "sourceCode" : "/**\r\n * Tests the EventSource support level 'dummy'.\r\n */\r\n@Test\r\nvoid testEventSourceSupportDummy() {\r\n    final BaseHierarchicalConfiguration conf = new BaseHierarchicalConfiguration();\r\n    final ConfigurationBuilder<BaseHierarchicalConfiguration> builder = createBuilderMock(conf);\r\n    final BuilderConfigurationWrapperFactory factory = new BuilderConfigurationWrapperFactory(EventSourceSupport.DUMMY);\r\n    final EventSource src = (EventSource) factory.createBuilderConfigurationWrapper(HierarchicalConfiguration.class, builder);\r\n    src.addEventListener(ConfigurationEvent.ANY, null);\r\n    verifyNoInteractions(builder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBuilderConfigurationWrapperFactory.java",
  "methodName" : "testEventSourceSupportMockBuilder",
  "sourceCode" : "/**\r\n * Tests whether event source support of level builder is possible even for a mock builder.\r\n */\r\n@Test\r\nvoid testEventSourceSupportMockBuilder() {\r\n    final BaseHierarchicalConfiguration conf = new BaseHierarchicalConfiguration();\r\n    final ConfigurationBuilder<BaseHierarchicalConfiguration> builder = createBuilderMock(conf);\r\n    final EventListenerTestImpl listener = new EventListenerTestImpl(null);\r\n    final BuilderConfigurationWrapperFactory factory = new BuilderConfigurationWrapperFactory(EventSourceSupport.BUILDER);\r\n    final EventSource src = (EventSource) factory.createBuilderConfigurationWrapper(HierarchicalConfiguration.class, builder);\r\n    src.addEventListener(ConfigurationEvent.ANY, listener);\r\n    verify(builder).addEventListener(ConfigurationEvent.ANY, listener);\r\n    verifyNoMoreInteractions(builder);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestBuilderConfigurationWrapperFactory.java",
  "methodName" : "testEventSourceSupportNone",
  "sourceCode" : "/**\r\n * Tests the factory if support for EventSource is disabled.\r\n */\r\n@Test\r\nvoid testEventSourceSupportNone() {\r\n    final BaseHierarchicalConfiguration conf = new BaseHierarchicalConfiguration();\r\n    final ConfigurationBuilder<BaseHierarchicalConfiguration> builder = createBuilderMock(conf);\r\n    final BuilderConfigurationWrapperFactory factory = new BuilderConfigurationWrapperFactory();\r\n    final HierarchicalConfiguration<?> wrapper = factory.createBuilderConfigurationWrapper(HierarchicalConfiguration.class, builder);\r\n    assertFalse(wrapper instanceof EventSource);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestCopyObjectDefaultHandler.java",
  "methodName" : "testInitializeDefaultsBaseType",
  "sourceCode" : "/**\r\n * Tests whether a base type can be initialized with default values. Unknown properties should silently be ignored.\r\n */\r\n@Test\r\nvoid testInitializeDefaultsBaseType() {\r\n    final Long refresh = 50000L;\r\n    final XMLBuilderParametersImpl paramsXml = new XMLBuilderParametersImpl();\r\n    paramsXml.setValidating(true).setExpressionEngine(mock(ExpressionEngine.class)).setReloadingRefreshDelay(refresh);\r\n    final CopyObjectDefaultHandler handler = new CopyObjectDefaultHandler(paramsXml);\r\n    final FileBasedBuilderParametersImpl paramsFb = new FileBasedBuilderParametersImpl();\r\n    handler.initializeDefaults(paramsFb);\r\n    assertEquals(refresh, paramsFb.getReloadingRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestCopyObjectDefaultHandler.java",
  "methodName" : "testInitializeDefaultsException",
  "sourceCode" : "/**\r\n * Tests whether exceptions during copying are re-thrown as runtime exceptions.\r\n */\r\n@Test\r\nvoid testInitializeDefaultsException() {\r\n    final ExpressionEngine engine = mock(ExpressionEngine.class);\r\n    final XMLBuilderParametersImpl source = new XMLBuilderParametersImpl();\r\n    source.setExpressionEngine(engine);\r\n    final XMLBuilderParametersImpl dest = new XMLBuilderParametersImpl() {\r\n\r\n        @Override\r\n        public HierarchicalBuilderParametersImpl setExpressionEngine(final ExpressionEngine engine) {\r\n            throw new ConfigurationRuntimeException(\"Test exception\");\r\n        }\r\n    };\r\n    final CopyObjectDefaultHandler handler = new CopyObjectDefaultHandler(source);\r\n    assertThrows(ConfigurationRuntimeException.class, () -> handler.initializeDefaults(dest));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestCopyObjectDefaultHandler.java",
  "methodName" : "testInitializeDefaultsSameType",
  "sourceCode" : "/**\r\n * Tests whether default values can be copied onto an object of the same type.\r\n */\r\n@Test\r\nvoid testInitializeDefaultsSameType() {\r\n    final Long refresh = 50000L;\r\n    final FileBasedBuilderParametersImpl source = new FileBasedBuilderParametersImpl();\r\n    source.setReloadingRefreshDelay(refresh).setThrowExceptionOnMissing(true);\r\n    final CopyObjectDefaultHandler handler = new CopyObjectDefaultHandler(source);\r\n    final FileBasedBuilderParametersImpl copy = new FileBasedBuilderParametersImpl();\r\n    handler.initializeDefaults(copy);\r\n    final Map<String, Object> map = copy.getParameters();\r\n    assertEquals(Boolean.TRUE, map.get(\"throwExceptionOnMissing\"));\r\n    assertEquals(refresh, copy.getReloadingRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestCopyObjectDefaultHandler.java",
  "methodName" : "testInitNull",
  "sourceCode" : "/**\r\n * Tries to create an instance without a source object.\r\n */\r\n@Test\r\nvoid testInitNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> new CopyObjectDefaultHandler(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDatabaseBuilderParametersImpl.java",
  "methodName" : "testBeanProperties",
  "sourceCode" : "/**\r\n * Tests whether properties can be set through BeanUtils.\r\n */\r\n@Test\r\nvoid testBeanProperties() throws Exception {\r\n    BeanHelper.setProperty(params, \"table\", \"testTable\");\r\n    BeanHelper.setProperty(params, \"autoCommit\", Boolean.FALSE);\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertEquals(\"testTable\", map.get(\"table\"));\r\n    assertEquals(Boolean.FALSE, map.get(\"autoCommit\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDatabaseBuilderParametersImpl.java",
  "methodName" : "testSetAutoCommit",
  "sourceCode" : "/**\r\n * Tests whether the auto commit flag can be set.\r\n */\r\n@Test\r\nvoid testSetAutoCommit() {\r\n    assertSame(params, params.setAutoCommit(true));\r\n    assertEquals(Boolean.TRUE, params.getParameters().get(\"autoCommit\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDatabaseBuilderParametersImpl.java",
  "methodName" : "testSetConfigurationName",
  "sourceCode" : "/**\r\n * Tests whether the configuration name can be set.\r\n */\r\n@Test\r\nvoid testSetConfigurationName() {\r\n    final String confName = \"TestConfiguration\";\r\n    assertSame(params, params.setConfigurationName(confName));\r\n    assertEquals(confName, params.getParameters().get(\"configurationName\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDatabaseBuilderParametersImpl.java",
  "methodName" : "testSetConfigurationNameColumn",
  "sourceCode" : "/**\r\n * Tests whether the configuration name column can be set.\r\n */\r\n@Test\r\nvoid testSetConfigurationNameColumn() {\r\n    final String colName = \"CONFIG_COLUMN\";\r\n    assertSame(params, params.setConfigurationNameColumn(colName));\r\n    assertEquals(colName, params.getParameters().get(\"configurationNameColumn\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDatabaseBuilderParametersImpl.java",
  "methodName" : "testSetDataSource",
  "sourceCode" : "/**\r\n * Tests whether the data source property can be set.\r\n */\r\n@Test\r\nvoid testSetDataSource() {\r\n    final DataSource src = mock(DataSource.class);\r\n    assertSame(params, params.setDataSource(src));\r\n    assertSame(src, params.getParameters().get(\"dataSource\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDatabaseBuilderParametersImpl.java",
  "methodName" : "testSetKeyColumn",
  "sourceCode" : "/**\r\n * Tests whether the key column name can be set.\r\n */\r\n@Test\r\nvoid testSetKeyColumn() {\r\n    final String colName = \"KEY_COLUMN\";\r\n    assertSame(params, params.setKeyColumn(colName));\r\n    assertEquals(colName, params.getParameters().get(\"keyColumn\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDatabaseBuilderParametersImpl.java",
  "methodName" : "testSetTable",
  "sourceCode" : "/**\r\n * Tests whether the table name can be set.\r\n */\r\n@Test\r\nvoid testSetTable() {\r\n    final String table = \"TestTable\";\r\n    assertSame(params, params.setTable(table));\r\n    assertEquals(table, params.getParameters().get(\"table\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDatabaseBuilderParametersImpl.java",
  "methodName" : "testSetValueColumn",
  "sourceCode" : "/**\r\n * Tests whether the value column name can be set.\r\n */\r\n@Test\r\nvoid testSetValueColumn() {\r\n    final String colName = \"VALUE_COLUMN\";\r\n    assertSame(params, params.setValueColumn(colName));\r\n    assertEquals(colName, params.getParameters().get(\"valueColumn\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testApplyDefaults",
  "sourceCode" : "/**\r\n * Tests whether default values are set for newly created parameters objects.\r\n */\r\n@Test\r\nvoid testApplyDefaults() {\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, new FileBasedDefaultsHandler());\r\n    final FileBasedBuilderParameters params = parameters.fileBased();\r\n    manager.initializeParameters(params);\r\n    final Map<String, Object> map = params.getParameters();\r\n    checkDefaultValues(map);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testApplyDefaultsMultipleHandlers",
  "sourceCode" : "/**\r\n * Tests whether multiple handlers can be registered for the same classes and whether they are called in the correct\r\n * order.\r\n */\r\n@Test\r\nvoid testApplyDefaultsMultipleHandlers() {\r\n    final ExpressionEngine engine = mock(ExpressionEngine.class);\r\n    manager.registerDefaultsHandler(XMLBuilderParameters.class, parameters -> parameters.setThrowExceptionOnMissing(false).setListDelimiterHandler(mock(ListDelimiterHandler.class)).setExpressionEngine(engine));\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, new FileBasedDefaultsHandler());\r\n    final XMLBuilderParameters params = parameters.xml();\r\n    manager.initializeParameters(params);\r\n    final Map<String, Object> map = params.getParameters();\r\n    checkDefaultValues(map);\r\n    assertSame(engine, map.get(\"expressionEngine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testApplyDefaultsOnSubClass",
  "sourceCode" : "/**\r\n * Tests whether default values are also applied when a sub parameters class is created.\r\n */\r\n@Test\r\nvoid testApplyDefaultsOnSubClass() {\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, new FileBasedDefaultsHandler());\r\n    final XMLBuilderParameters params = parameters.xml();\r\n    manager.initializeParameters(params);\r\n    final Map<String, Object> map = params.getParameters();\r\n    checkDefaultValues(map);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testApplyDefaultsStartClass",
  "sourceCode" : "/**\r\n * Tests that default values are only applied if the start class provided at registration time matches.\r\n */\r\n@Test\r\nvoid testApplyDefaultsStartClass() {\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, new FileBasedDefaultsHandler(), XMLBuilderParameters.class);\r\n    final XMLBuilderParameters paramsXml = parameters.xml();\r\n    manager.initializeParameters(paramsXml);\r\n    Map<String, Object> map = paramsXml.getParameters();\r\n    checkDefaultValues(map);\r\n    final PropertiesBuilderParameters paramsProps = parameters.properties();\r\n    manager.initializeParameters(paramsProps);\r\n    map = paramsProps.getParameters();\r\n    checkNoDefaultValues(map);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testInitializeParametersNull",
  "sourceCode" : "/**\r\n * Tests whether initializeParameters() ignores null input. (We can only test that no exception is thrown.)\r\n */\r\n@Test\r\nvoid testInitializeParametersNull() {\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, new FileBasedDefaultsHandler());\r\n    manager.initializeParameters(null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testRegisterDefaultsHandlerNoClass",
  "sourceCode" : "/**\r\n * Tries to register a default handler without a class.\r\n */\r\n@Test\r\nvoid testRegisterDefaultsHandlerNoClass() {\r\n    final FileBasedDefaultsHandler handler = new FileBasedDefaultsHandler();\r\n    assertThrows(IllegalArgumentException.class, () -> manager.registerDefaultsHandler(null, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testRegisterDefaultsHandlerNoHandler",
  "sourceCode" : "/**\r\n * Tries to register a null default handler.\r\n */\r\n@Test\r\nvoid testRegisterDefaultsHandlerNoHandler() {\r\n    assertThrows(IllegalArgumentException.class, () -> manager.registerDefaultsHandler(BasicBuilderProperties.class, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testUnregisterDefaultsHandlerAll",
  "sourceCode" : "/**\r\n * Tests whether all occurrences of a given defaults handler can be removed.\r\n */\r\n@Test\r\nvoid testUnregisterDefaultsHandlerAll() {\r\n    final FileBasedDefaultsHandler handler = new FileBasedDefaultsHandler();\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, handler, XMLBuilderParameters.class);\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, handler, PropertiesBuilderParameters.class);\r\n    manager.unregisterDefaultsHandler(handler);\r\n    final XMLBuilderParameters paramsXml = parameters.xml();\r\n    manager.initializeParameters(paramsXml);\r\n    checkNoDefaultValues(paramsXml.getParameters());\r\n    final PropertiesBuilderParameters paramsProps = parameters.properties();\r\n    manager.initializeParameters(paramsProps);\r\n    checkNoDefaultValues(paramsProps.getParameters());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultParametersManager.java",
  "methodName" : "testUnregisterDefaultsHandlerSpecific",
  "sourceCode" : "/**\r\n * Tests whether a specific occurrence of a defaults handler can be removed.\r\n */\r\n@Test\r\nvoid testUnregisterDefaultsHandlerSpecific() {\r\n    final FileBasedDefaultsHandler handler = new FileBasedDefaultsHandler();\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, handler, XMLBuilderParameters.class);\r\n    manager.registerDefaultsHandler(FileBasedBuilderParameters.class, handler, PropertiesBuilderParameters.class);\r\n    manager.unregisterDefaultsHandler(handler, PropertiesBuilderParameters.class);\r\n    final XMLBuilderParameters paramsXml = parameters.xml();\r\n    manager.initializeParameters(paramsXml);\r\n    checkDefaultValues(paramsXml.getParameters());\r\n    final PropertiesBuilderParameters paramsProps = parameters.properties();\r\n    manager.initializeParameters(paramsProps);\r\n    checkNoDefaultValues(paramsProps.getParameters());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultReloadingDetectorFactory.java",
  "methodName" : "testCreateReloadingDetector",
  "sourceCode" : "/**\r\n * Tests whether a reloading detector is created correctly.\r\n */\r\n@Test\r\nvoid testCreateReloadingDetector() throws ConfigurationException {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    final Long refreshDelay = 10000L;\r\n    params.setReloadingRefreshDelay(refreshDelay);\r\n    final FileHandlerReloadingDetector detector = (FileHandlerReloadingDetector) factory.createReloadingDetector(handler, params);\r\n    assertSame(handler, detector.getFileHandler());\r\n    assertEquals(refreshDelay.longValue(), detector.getRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestDefaultReloadingDetectorFactory.java",
  "methodName" : "testCreateReloadingDetectorDefaultRefreshDelay",
  "sourceCode" : "/**\r\n * Tests whether an undefined refresh delay is handled correctly.\r\n */\r\n@Test\r\nvoid testCreateReloadingDetectorDefaultRefreshDelay() throws ConfigurationException {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    final FileHandlerReloadingDetector detector = (FileHandlerReloadingDetector) factory.createReloadingDetector(handler, params);\r\n    assertNotEquals(0, detector.getRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestEventListenerParameters.java",
  "methodName" : "testAddEventListener",
  "sourceCode" : "/**\r\n * Tests whether an event listener with its type can be added.\r\n */\r\n@Test\r\nvoid testAddEventListener() {\r\n    final EventListenerTestImpl listener = new EventListenerTestImpl(null);\r\n    final EventListenerParameters parameters = new EventListenerParameters();\r\n    assertSame(parameters, parameters.addEventListener(ConfigurationEvent.ADD_PROPERTY, listener));\r\n    assertEquals(1, parameters.getListeners().getRegistrations().size());\r\n    final EventListenerRegistrationData<?> reg = parameters.getListeners().getRegistrations().get(0);\r\n    assertEquals(ConfigurationEvent.ADD_PROPERTY, reg.getEventType());\r\n    assertEquals(listener, reg.getListener());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestEventListenerParameters.java",
  "methodName" : "testAddEventListenerRegistration",
  "sourceCode" : "/**\r\n * Tests whether an event listener registration can be added.\r\n */\r\n@Test\r\nvoid testAddEventListenerRegistration() {\r\n    final EventListenerRegistrationData<ConfigurationEvent> reg = new EventListenerRegistrationData<>(ConfigurationEvent.SET_PROPERTY, new EventListenerTestImpl(null));\r\n    final EventListenerParameters parameters = new EventListenerParameters();\r\n    assertSame(parameters, parameters.addEventListener(reg));\r\n    assertEquals(Arrays.asList(reg), parameters.getListeners().getRegistrations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestEventListenerParameters.java",
  "methodName" : "testGetParameters",
  "sourceCode" : "/**\r\n * Tests the map with parameters.\r\n */\r\n@Test\r\nvoid testGetParameters() {\r\n    final EventListenerParameters parameters = new EventListenerParameters();\r\n    assertTrue(parameters.getParameters().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestEventListenerParameters.java",
  "methodName" : "testRegistrationsAfterCreation",
  "sourceCode" : "/**\r\n * Tests that the list of event listeners is empty for a newly created instance.\r\n */\r\n@Test\r\nvoid testRegistrationsAfterCreation() {\r\n    final EventListenerParameters parameters = new EventListenerParameters();\r\n    assertTrue(parameters.getListeners().getRegistrations().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testBeanPropertiesAccess",
  "sourceCode" : "/**\r\n * Tests whether reflection-based property access through BeanUtils is possible.\r\n */\r\n@Test\r\nvoid testBeanPropertiesAccess() throws Exception {\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    BeanHelper.setProperty(params, \"throwExceptionOnMissing\", Boolean.TRUE);\r\n    BeanHelper.setProperty(params, \"fileName\", \"test.xml\");\r\n    assertEquals(\"test.xml\", params.getFileHandler().getFileName());\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertEquals(Boolean.TRUE, map.get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests a clone operation.\r\n */\r\n@Test\r\nvoid testClone() {\r\n    final FileBased content = mock(FileBased.class);\r\n    final FileHandler fh = new FileHandler(content);\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl(fh);\r\n    params.setThrowExceptionOnMissing(true);\r\n    params.setFileName(\"test.xml\");\r\n    final FileBasedBuilderParametersImpl clone = params.clone();\r\n    assertEquals(Boolean.TRUE, clone.getParameters().get(\"throwExceptionOnMissing\"));\r\n    assertEquals(\"test.xml\", clone.getFileHandler().getFileName());\r\n    assertSame(content, clone.getFileHandler().getContent());\r\n    assertNotSame(params.getFileHandler(), clone.getFileHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testFromMap",
  "sourceCode" : "/**\r\n * Tests whether an instance can be created from a map.\r\n */\r\n@Test\r\nvoid testFromMap() {\r\n    final ReloadingDetectorFactory factory = mock(ReloadingDetectorFactory.class);\r\n    final Map<String, Object> map = new HashMap<>();\r\n    final String fileName = \"someFileName\";\r\n    final String basePath = \"someBasePath\";\r\n    final Long refreshDelay = 20140628222302L;\r\n    map.put(\"basePath\", basePath);\r\n    map.put(\"fileName\", fileName);\r\n    map.put(\"reloadingDetectorFactory\", factory);\r\n    map.put(\"reloadingRefreshDelay\", refreshDelay);\r\n    final FileBasedBuilderParametersImpl params = FileBasedBuilderParametersImpl.fromMap(map);\r\n    assertEquals(basePath, params.getFileHandler().getBasePath());\r\n    assertEquals(fileName, params.getFileHandler().getFileName());\r\n    assertEquals(factory, params.getReloadingDetectorFactory());\r\n    assertEquals(refreshDelay, params.getReloadingRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testFromMapNull",
  "sourceCode" : "/**\r\n * Tests fromMap() for null input.\r\n */\r\n@Test\r\nvoid testFromMapNull() {\r\n    final FileBasedBuilderParametersImpl params = FileBasedBuilderParametersImpl.fromMap(null);\r\n    assertNull(params.getReloadingRefreshDelay());\r\n    assertNull(params.getFileHandler().getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testFromParametersDefaultInstance",
  "sourceCode" : "/**\r\n * Tests whether fromParameters() can return a default instance if the map does not contain an instance.\r\n */\r\n@Test\r\nvoid testFromParametersDefaultInstance() {\r\n    final FileBasedBuilderParametersImpl params = FileBasedBuilderParametersImpl.fromParameters(new HashMap<>(), true);\r\n    assertFalse(params.getFileHandler().isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testFromParametersExtract",
  "sourceCode" : "/**\r\n * Tests whether an instance can be extracted from a parameters map.\r\n */\r\n@Test\r\nvoid testFromParametersExtract() {\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertSame(params, FileBasedBuilderParametersImpl.fromParameters(map));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testFromParametersNotFound",
  "sourceCode" : "/**\r\n * Tests fromParameters() if the map does not contain an instance.\r\n */\r\n@Test\r\nvoid testFromParametersNotFound() {\r\n    assertNull(FileBasedBuilderParametersImpl.fromParameters(new HashMap<>()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testFromParametersNull",
  "sourceCode" : "/**\r\n * Tries to obtain an instance from a null parameters map.\r\n */\r\n@Test\r\nvoid testFromParametersNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> FileBasedBuilderParametersImpl.fromParameters(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testGetParameters",
  "sourceCode" : "/**\r\n * Tests whether a map with parameters can be queried.\r\n */\r\n@Test\r\nvoid testGetParameters() {\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl().setReloadingRefreshDelay(1000L);\r\n    params.setThrowExceptionOnMissing(true);\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertTrue(map.containsValue(params));\r\n    assertEquals(Boolean.TRUE, params.getParameters().get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testInheritFrom",
  "sourceCode" : "/**\r\n * Tests whether properties can be inherited from another object.\r\n */\r\n@Test\r\nvoid testInheritFrom() {\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    params.setEncoding(\"ISO-8856-1\");\r\n    params.setPath(\"A path\");\r\n    params.setReloadingDetectorFactory(mock(ReloadingDetectorFactory.class));\r\n    params.setFileSystem(mock(FileSystem.class));\r\n    params.setLocationStrategy(mock(FileLocationStrategy.class));\r\n    params.setReloadingRefreshDelay(20160213171737L);\r\n    params.setThrowExceptionOnMissing(true);\r\n    final FileBasedBuilderParametersImpl params2 = new FileBasedBuilderParametersImpl();\r\n    params2.inheritFrom(params.getParameters());\r\n    assertEquals(params.getFileHandler().getEncoding(), params2.getFileHandler().getEncoding());\r\n    assertEquals(params.getFileHandler().getFileSystem(), params2.getFileHandler().getFileSystem());\r\n    assertEquals(params.getFileHandler().getLocationStrategy(), params2.getFileHandler().getLocationStrategy());\r\n    assertEquals(params.getReloadingDetectorFactory(), params2.getReloadingDetectorFactory());\r\n    assertEquals(params.getReloadingRefreshDelay(), params2.getReloadingRefreshDelay());\r\n    assertNull(params2.getFileHandler().getPath());\r\n    assertEquals(Boolean.TRUE, params2.getParameters().get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testInheritFromNoParametersObject",
  "sourceCode" : "/**\r\n * Tests inheritFrom() if no parameters object can be found in the map.\r\n */\r\n@Test\r\nvoid testInheritFromNoParametersObject() {\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl().setReloadingRefreshDelay(20160213211429L);\r\n    params.inheritFrom(new HashMap<>());\r\n    assertNotNull(params.getReloadingRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testInheritFromSkipMissingProperties",
  "sourceCode" : "/**\r\n * Tests that missing properties in the passed in map are skipped by inheritFrom().\r\n */\r\n@Test\r\nvoid testInheritFromSkipMissingProperties() {\r\n    final String encoding = StandardCharsets.UTF_16.name();\r\n    final ReloadingDetectorFactory factory = mock(ReloadingDetectorFactory.class);\r\n    final Long refreshDelay = 20160213172611L;\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl().setEncoding(encoding).setReloadingDetectorFactory(factory).setReloadingRefreshDelay(refreshDelay);\r\n    params.inheritFrom(new FileBasedBuilderParametersImpl().getParameters());\r\n    assertEquals(encoding, params.getFileHandler().getEncoding());\r\n    assertEquals(factory, params.getReloadingDetectorFactory());\r\n    assertEquals(refreshDelay, params.getReloadingRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testInitDefaults",
  "sourceCode" : "/**\r\n * Tests the standard constructor.\r\n */\r\n@Test\r\nvoid testInitDefaults() {\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertFalse(params.getFileHandler().isLocationDefined());\r\n    assertNull(params.getReloadingRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testInitFileHandler",
  "sourceCode" : "/**\r\n * Tests whether a file handler is accepted by the constructor.\r\n */\r\n@Test\r\nvoid testInitFileHandler() {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl(handler);\r\n    assertSame(handler, params.getFileHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetBasePath",
  "sourceCode" : "/**\r\n * Tests whether a base path can be set.\r\n */\r\n@Test\r\nvoid testSetBasePath() {\r\n    final String path = ConfigurationAssert.getTestFile(\"test.properties\").getParentFile().getAbsolutePath();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertSame(params, params.setBasePath(path));\r\n    assertEquals(path, params.getFileHandler().getBasePath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetEncoding",
  "sourceCode" : "/**\r\n * Tests whether an encoding can be set.\r\n */\r\n@Test\r\nvoid testSetEncoding() {\r\n    final String enc = StandardCharsets.ISO_8859_1.name();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertSame(params, params.setEncoding(enc));\r\n    assertSame(enc, params.getFileHandler().getEncoding());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetFile",
  "sourceCode" : "/**\r\n * Tests whether a file can be set.\r\n */\r\n@Test\r\nvoid testSetFile() {\r\n    final File file = ConfigurationAssert.getTestFile(\"test.properties\").getAbsoluteFile();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertSame(params, params.setFile(file));\r\n    assertEquals(file, params.getFileHandler().getFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetFileName",
  "sourceCode" : "/**\r\n * Tests whether a file name can be set.\r\n */\r\n@Test\r\nvoid testSetFileName() {\r\n    final String name = \"testConfig.xml\";\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertSame(params, params.setFileName(name));\r\n    assertEquals(name, params.getFileHandler().getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetFileSystem",
  "sourceCode" : "/**\r\n * Tests whether a file system can be set.\r\n */\r\n@Test\r\nvoid testSetFileSystem() {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertSame(params, params.setFileSystem(fs));\r\n    assertSame(fs, params.getFileHandler().getFileSystem());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetLocationStrategy",
  "sourceCode" : "/**\r\n * Tests whether a location strategy can be set.\r\n */\r\n@Test\r\nvoid testSetLocationStrategy() {\r\n    final FileLocationStrategy strat = mock(FileLocationStrategy.class);\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertSame(params, params.setLocationStrategy(strat));\r\n    assertSame(strat, params.getFileHandler().getLocationStrategy());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetPath",
  "sourceCode" : "/**\r\n * Tests whether a path can be set.\r\n */\r\n@Test\r\nvoid testSetPath() {\r\n    final String path = ConfigurationAssert.getTestFile(\"test.properties\").getAbsolutePath();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertSame(params, params.setPath(path));\r\n    assertEquals(path, params.getFileHandler().getPath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetReloadingDetectorFactory",
  "sourceCode" : "/**\r\n * Tests whether a factory for reloading detectors can be set.\r\n */\r\n@Test\r\nvoid testSetReloadingDetectorFactory() {\r\n    final ReloadingDetectorFactory factory = mock(ReloadingDetectorFactory.class);\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertNull(params.getReloadingDetectorFactory());\r\n    assertSame(params, params.setReloadingDetectorFactory(factory));\r\n    assertSame(factory, params.getReloadingDetectorFactory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetReloadingRefreshDelay",
  "sourceCode" : "/**\r\n * Tests whether the refresh delay can be set.\r\n */\r\n@Test\r\nvoid testSetReloadingRefreshDelay() {\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    final Long delay = 10000L;\r\n    assertSame(params, params.setReloadingRefreshDelay(delay));\r\n    assertEquals(delay, params.getReloadingRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedBuilderParameters.java",
  "methodName" : "testSetURL",
  "sourceCode" : "/**\r\n * Tests whether a URL can be set.\r\n */\r\n@Test\r\nvoid testSetURL() {\r\n    final URL url = ConfigurationAssert.getTestURL(\"test.properties\");\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    assertSame(params, params.setURL(url));\r\n    assertEquals(url.toExternalForm(), params.getFileHandler().getURL().toExternalForm());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testAutoSave",
  "sourceCode" : "/**\r\n * Tests whether auto save mode works.\r\n */\r\n@Test\r\nvoid testAutoSave() throws ConfigurationException {\r\n    final File file = createTestFile(0);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    assertFalse(builder.isAutoSave());\r\n    builder.setAutoSave(true);\r\n    assertTrue(builder.isAutoSave());\r\n    // should have no effect\r\n    builder.setAutoSave(true);\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    config.setProperty(PROP, 1);\r\n    checkSavedConfig(file, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testAutoSaveWithPropertiesConfiguration",
  "sourceCode" : "/**\r\n * Tests whether auto save mode works with a properties configuration.\r\n * This is related to CONFIGURATION-646.\r\n */\r\n@Test\r\nvoid testAutoSaveWithPropertiesConfiguration() throws ConfigurationException, IOException {\r\n    final File file = newFile(tempFolder);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    builder.setAutoSave(true);\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    config.setProperty(PROP, 1);\r\n    checkSavedConfig(file, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testAutoSaveWithReset",
  "sourceCode" : "/**\r\n * Tests that the auto save mechanism survives a reset of the builder's\r\n * configuration.\r\n */\r\n@Test\r\nvoid testAutoSaveWithReset() throws ConfigurationException {\r\n    final File file = createTestFile(0);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    final PropertiesConfiguration config1 = builder.getConfiguration();\r\n    builder.setAutoSave(true);\r\n    builder.resetResult();\r\n    final PropertiesConfiguration config2 = builder.getConfiguration();\r\n    assertNotSame(config1, config2);\r\n    config2.setProperty(PROP, 1);\r\n    config1.setProperty(PROP, 2);\r\n    checkSavedConfig(file, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testChangeLocationAfterCreation",
  "sourceCode" : "/**\r\n * Tests whether the location can be changed after a configuration has been\r\n * created.\r\n */\r\n@Test\r\nvoid testChangeLocationAfterCreation() throws ConfigurationException {\r\n    final File file1 = createTestFile(1);\r\n    final File file2 = createTestFile(2);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file1));\r\n    builder.getConfiguration();\r\n    builder.getFileHandler().setFile(file2);\r\n    builder.resetResult();\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertEquals(2, config.getInt(PROP));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testChangeLocationAfterReset",
  "sourceCode" : "/**\r\n * Tests whether it is possible to permanently change the location after a\r\n * reset of parameters.\r\n */\r\n@Test\r\nvoid testChangeLocationAfterReset() throws ConfigurationException {\r\n    final File file1 = createTestFile(1);\r\n    final File file2 = createTestFile(2);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file1));\r\n    builder.getConfiguration();\r\n    builder.getFileHandler().setFile(file2);\r\n    builder.reset();\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFile(file1));\r\n    PropertiesConfiguration config = builder.getConfiguration();\r\n    assertEquals(1, config.getInt(PROP));\r\n    builder.getFileHandler().setFile(file2);\r\n    builder.resetResult();\r\n    config = builder.getConfiguration();\r\n    assertEquals(2, config.getInt(PROP));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testCreateConfigurationNonExistingFileAndThenSave",
  "sourceCode" : "/**\r\n * Tests whether a configuration can be created and associated with a file that does\r\n * not yet exist. Later the configuration is saved to this file.\r\n */\r\n@Test\r\nvoid testCreateConfigurationNonExistingFileAndThenSave() throws ConfigurationException {\r\n    final File outFile = ConfigurationAssert.getOutFile(\"save.properties\");\r\n    final Parameters parameters = new Parameters();\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class, null, true).configure(parameters.properties().setFile(outFile));\r\n    final Configuration config = builder.getConfiguration();\r\n    config.setProperty(PROP, 1);\r\n    builder.save();\r\n    checkSavedConfig(outFile, 1);\r\n    assertTrue(outFile.delete());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testDisableAutoSave",
  "sourceCode" : "/**\r\n * Tests whether auto save mode can be disabled again.\r\n */\r\n@Test\r\nvoid testDisableAutoSave() throws ConfigurationException {\r\n    final File file = createTestFile(0);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    builder.setAutoSave(true);\r\n    config.setProperty(PROP, 1);\r\n    builder.setAutoSave(false);\r\n    config.setProperty(PROP, 2);\r\n    // should have no effect\r\n    builder.setAutoSave(false);\r\n    checkSavedConfig(file, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testFileBasedConfigurationBuilderWithHomeDirectoryLocationStrategy",
  "sourceCode" : "/**\r\n * Tests whether HomeDirectoryLocationStrategy can be properly initialized\r\n * and that it shouldn't throw {@code ConfigurationException} when\r\n * everything is correctly in place. Without the code fix for\r\n * <a href=\"https://issues.apache.org/jira/browse/CONFIGURATION-634\">CONFIGURATION-634</a>,\r\n * this test will throw {@code ConfigurationException}\r\n * @throws IOException              Shouldn't happen\r\n * @throws ConfigurationException   Shouldn't happen\r\n */\r\n@Test\r\nvoid testFileBasedConfigurationBuilderWithHomeDirectoryLocationStrategy() throws IOException, ConfigurationException {\r\n    final String folderName = \"test\";\r\n    final String fileName = \"sample.properties\";\r\n    newFolder(folderName, tempFolder);\r\n    newFile(folderName + File.separator + fileName, tempFolder);\r\n    final FileBasedConfigurationBuilder<FileBasedConfiguration> homeDirConfigurationBuilder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final PropertiesBuilderParameters homeDirProperties = new Parameters().properties();\r\n    final HomeDirectoryLocationStrategy strategy = new HomeDirectoryLocationStrategy(tempFolder.getAbsolutePath(), true);\r\n    final FileBasedConfigurationBuilder<FileBasedConfiguration> builder = homeDirConfigurationBuilder.configure(homeDirProperties.setLocationStrategy(strategy).setBasePath(folderName).setListDelimiterHandler(new DefaultListDelimiterHandler(',')).setFileName(fileName));\r\n    assertDoesNotThrow(builder::getConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testGetConfigurationLoadFromFile",
  "sourceCode" : "/**\r\n * Tests whether a configuration is loaded from file if a location is provided.\r\n */\r\n@Test\r\nvoid testGetConfigurationLoadFromFile() throws ConfigurationException {\r\n    final File file = createTestFile(1);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertEquals(1, config.getInt(PROP));\r\n    assertSame(config, builder.getFileHandler().getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testGetConfigurationLoadFromJarFile",
  "sourceCode" : "/**\r\n * Tests whether a configuration is loaded from a JAR file if a location is provided. CONFIGURATION-794: Unclosed file\r\n * handle when reading config from JAR file URL.\r\n */\r\n@Test\r\nvoid testGetConfigurationLoadFromJarFile() throws ConfigurationException, IOException {\r\n    final URL jarResourceUrl = getClass().getClassLoader().getResource(\"org/apache/commons/configuration2/test.jar\");\r\n    assertNotNull(jarResourceUrl);\r\n    final Path testJar = Paths.get(tempFolder.getAbsolutePath(), \"test.jar\");\r\n    try (InputStream inputStream = jarResourceUrl.openStream()) {\r\n        Files.copy(inputStream, testJar);\r\n    }\r\n    final URL url = new URL(\"jar:\" + testJar.toUri() + \"!/configuration.properties\");\r\n    //@formatter:off\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setURL(url, new URLConnectionOptions().setUseCaches(false)));\r\n    //@formatter:off\r\n    // CONFIGURATION-794\r\n    // the next line causes:\r\n    //        java.lang.AssertionError: Unable to clean up temporary folder C:\\Users\\ggregory\\AppData\\Local\\Temp\\junit7789840233804508643\r\n    //        at org.junit.Assert.fail(Assert.java:89)\r\n    //        at org.junit.rules.TemporaryFolder.delete(TemporaryFolder.java:274)\r\n    //        at org.junit.rules.TemporaryFolder.after(TemporaryFolder.java:138)\r\n    //        at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:59)\r\n    //        at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\r\n    //        at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)\r\n    //        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)\r\n    //        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)\r\n    //        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)\r\n    //        at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)\r\n    //        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)\r\n    //        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)\r\n    //        at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)\r\n    //        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)\r\n    //        at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\r\n    //        at org.junit.runners.ParentRunner.run(ParentRunner.java:413)\r\n    //        at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:89)\r\n    //        at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41)\r\n    //        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:542)\r\n    //        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770)\r\n    //        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464)\r\n    //        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)\r\n    // builder contains the current FileHandler which loads the file.\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertEquals(1, config.getInt(PROP));\r\n    assertSame(config, builder.getFileHandler().getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testGetConfigurationNoLocation",
  "sourceCode" : "/**\r\n * Tests whether a configuration can be created if no location is set.\r\n */\r\n@Test\r\nvoid testGetConfigurationNoLocation() throws ConfigurationException {\r\n    final Map<String, Object> params = new HashMap<>();\r\n    params.put(\"throwExceptionOnMissing\", Boolean.TRUE);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class, params);\r\n    final PropertiesConfiguration conf = builder.getConfiguration();\r\n    assertTrue(conf.isThrowExceptionOnMissing());\r\n    assertTrue(conf.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testGetDefaultEncodingInterface",
  "sourceCode" : "/**\r\n * Tests whether a default encoding can be determined even if it was set for\r\n * an interface.\r\n */\r\n@Test\r\nvoid testGetDefaultEncodingInterface() {\r\n    final String encoding = \"testEncoding\";\r\n    FileBasedConfigurationBuilder.setDefaultEncoding(Configuration.class, encoding);\r\n    assertEquals(encoding, FileBasedConfigurationBuilder.getDefaultEncoding(XMLConfiguration.class));\r\n    FileBasedConfigurationBuilder.setDefaultEncoding(Configuration.class, null);\r\n    assertNull(FileBasedConfigurationBuilder.getDefaultEncoding(XMLConfiguration.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testGetDefaultEncodingProperties",
  "sourceCode" : "/**\r\n * Tests whether a default encoding for properties configurations is\r\n * defined.\r\n */\r\n@Test\r\nvoid testGetDefaultEncodingProperties() {\r\n    assertEquals(PropertiesConfiguration.DEFAULT_ENCODING, FileBasedConfigurationBuilder.getDefaultEncoding(PropertiesConfiguration.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testGetDefaultEncodingSubClass",
  "sourceCode" : "/**\r\n * Tests whether a default encoding is find even if a sub class is queried.\r\n */\r\n@Test\r\nvoid testGetDefaultEncodingSubClass() {\r\n    final PropertiesConfiguration conf = new PropertiesConfiguration() {\r\n    };\r\n    assertEquals(PropertiesConfiguration.DEFAULT_ENCODING, FileBasedConfigurationBuilder.getDefaultEncoding(conf.getClass()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testGetDefaultEncodingXmlProperties",
  "sourceCode" : "/**\r\n * Tests whether a default encoding for XML properties configurations is\r\n * defined.\r\n */\r\n@Test\r\nvoid testGetDefaultEncodingXmlProperties() {\r\n    assertEquals(XMLPropertiesConfiguration.DEFAULT_ENCODING, FileBasedConfigurationBuilder.getDefaultEncoding(XMLPropertiesConfiguration.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testInitAllowFailOnInitFlag",
  "sourceCode" : "/**\r\n * Tests whether the allowFailOnInit flag is correctly initialized.\r\n */\r\n@Test\r\nvoid testInitAllowFailOnInitFlag() {\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class, null, true);\r\n    assertTrue(builder.isAllowFailOnInit());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testInitFileHandlerOverrideDefaultEncoding",
  "sourceCode" : "/**\r\n * Tests whether the default encoding can be overridden when initializing\r\n * the file handler.\r\n */\r\n@Test\r\nvoid testInitFileHandlerOverrideDefaultEncoding() throws ConfigurationException {\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final FileHandler handler = new FileHandler();\r\n    final String encoding = \"testEncoding\";\r\n    handler.setEncoding(encoding);\r\n    builder.initFileHandler(handler);\r\n    assertEquals(encoding, handler.getEncoding());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testInitFileHandlerSetDefaultEncoding",
  "sourceCode" : "/**\r\n * Tests whether the default encoding is set for the file handler if none is\r\n * specified.\r\n */\r\n@Test\r\nvoid testInitFileHandlerSetDefaultEncoding() throws ConfigurationException {\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final FileHandler handler = new FileHandler();\r\n    builder.initFileHandler(handler);\r\n    assertEquals(PropertiesConfiguration.DEFAULT_ENCODING, handler.getEncoding());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testLocationIsFullyDefined",
  "sourceCode" : "/**\r\n * Tests whether the location in the FileHandler is fully defined. This\r\n * ensures that saving writes to the expected file.\r\n */\r\n@Test\r\nvoid testLocationIsFullyDefined() throws ConfigurationException {\r\n    final File file = createTestFile(1);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    builder.getConfiguration();\r\n    final FileLocator locator = builder.getFileHandler().getFileLocator();\r\n    assertTrue(FileLocatorUtils.isFullyInitialized(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testLocationSurvivesResetResult",
  "sourceCode" : "/**\r\n * Tests that the location in the FileHandler remains the same if the\r\n * builder's result is reset.\r\n */\r\n@Test\r\nvoid testLocationSurvivesResetResult() throws ConfigurationException {\r\n    final File file = createTestFile(1);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    builder.resetResult();\r\n    final PropertiesConfiguration config2 = builder.getConfiguration();\r\n    assertNotSame(config, config2);\r\n    assertEquals(1, config2.getInt(PROP));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testResetLocation",
  "sourceCode" : "/**\r\n * Tests whether a reset of the builder's initialization parameters also\r\n * resets the file location.\r\n */\r\n@Test\r\nvoid testResetLocation() throws ConfigurationException {\r\n    final File file = createTestFile(1);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    builder.getConfiguration();\r\n    builder.reset();\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertTrue(config.isEmpty());\r\n    assertFalse(builder.getFileHandler().isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testSave",
  "sourceCode" : "/**\r\n * Tests whether the managed configuration can be saved.\r\n */\r\n@Test\r\nvoid testSave() throws ConfigurationException {\r\n    final File file = createTestFile(1);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    config.setProperty(PROP, 5);\r\n    builder.save();\r\n    checkSavedConfig(file, 5);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testSaveNewFile",
  "sourceCode" : "/**\r\n * Tests whether a new configuration can be saved to a file.\r\n */\r\n@Test\r\nvoid testSaveNewFile() throws ConfigurationException, IOException {\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    config.setProperty(PROP, 2);\r\n    final File file = newFile(tempFolder);\r\n    builder.getFileHandler().setFile(file);\r\n    builder.save();\r\n    checkSavedConfig(file, 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testSetDefaultEncodingNull",
  "sourceCode" : "/**\r\n * Tries to set a default encoding for a null class.\r\n */\r\n@Test\r\nvoid testSetDefaultEncodingNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> FileBasedConfigurationBuilder.setDefaultEncoding(null, StandardCharsets.UTF_8.name()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestFileBasedConfigurationBuilder.java",
  "methodName" : "testSetLocationNoFileHandler",
  "sourceCode" : "/**\r\n * Tests whether a file handler can be accessed and manipulated even if no\r\n * file-based parameters are part of the initialization parameters.\r\n */\r\n@Test\r\nvoid testSetLocationNoFileHandler() throws ConfigurationException {\r\n    final File file = createTestFile(1);\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.getFileHandler().setFile(file);\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertFalse(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestHierarchicalBuilderParametersImpl.java",
  "methodName" : "testBeanPropertiesAccess",
  "sourceCode" : "/**\r\n * Tests whether properties can be set via BeanUtils.\r\n */\r\n@Test\r\nvoid testBeanPropertiesAccess() throws Exception {\r\n    final ExpressionEngine engine = mock(ExpressionEngine.class);\r\n    BeanHelper.setProperty(params, \"expressionEngine\", engine);\r\n    BeanHelper.setProperty(params, \"throwExceptionOnMissing\", Boolean.TRUE);\r\n    final Map<String, Object> map = params.getParameters();\r\n    assertSame(engine, map.get(\"expressionEngine\"));\r\n    assertEquals(Boolean.TRUE, map.get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestHierarchicalBuilderParametersImpl.java",
  "methodName" : "testInheritFrom",
  "sourceCode" : "/**\r\n * Tests whether inheritFrom() copies additional properties.\r\n */\r\n@Test\r\nvoid testInheritFrom() {\r\n    final ExpressionEngine engine = mock(ExpressionEngine.class);\r\n    final HierarchicalBuilderParametersImpl params = new HierarchicalBuilderParametersImpl();\r\n    params.setExpressionEngine(engine);\r\n    params.setThrowExceptionOnMissing(true);\r\n    final HierarchicalBuilderParametersImpl params2 = new HierarchicalBuilderParametersImpl();\r\n    params2.inheritFrom(params.getParameters());\r\n    final Map<String, Object> parameters = params2.getParameters();\r\n    assertEquals(Boolean.TRUE, parameters.get(\"throwExceptionOnMissing\"));\r\n    assertEquals(engine, parameters.get(\"expressionEngine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestHierarchicalBuilderParametersImpl.java",
  "methodName" : "testSetExpressionEngine",
  "sourceCode" : "/**\r\n * Tests whether the expression engine can be set.\r\n */\r\n@Test\r\nvoid testSetExpressionEngine() {\r\n    final ExpressionEngine engine = mock(ExpressionEngine.class);\r\n    assertSame(params, params.setExpressionEngine(engine));\r\n    assertSame(engine, params.getParameters().get(\"expressionEngine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestJndiBuilderParametersImpl.java",
  "methodName" : "testGetParametersBaseProperties",
  "sourceCode" : "/**\r\n * Tests whether the parameters map contains inherited properties, too.\r\n */\r\n@Test\r\nvoid testGetParametersBaseProperties() {\r\n    params.setPrefix(\"somePrefix\");\r\n    params.setThrowExceptionOnMissing(true);\r\n    final Map<String, Object> paramsMap = params.getParameters();\r\n    assertEquals(Boolean.TRUE, paramsMap.get(\"throwExceptionOnMissing\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestJndiBuilderParametersImpl.java",
  "methodName" : "testSetBeanProperties",
  "sourceCode" : "/**\r\n * Tests whether properties can be set through BeanUtils.\r\n */\r\n@Test\r\nvoid testSetBeanProperties() throws Exception {\r\n    final Context ctx = mock(Context.class);\r\n    final String prefix = \"testJndiPrefix\";\r\n    BeanHelper.setProperty(params, \"context\", ctx);\r\n    BeanHelper.setProperty(params, \"prefix\", prefix);\r\n    final Map<String, Object> paramsMap = params.getParameters();\r\n    assertSame(ctx, paramsMap.get(\"context\"));\r\n    assertEquals(prefix, paramsMap.get(\"prefix\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestJndiBuilderParametersImpl.java",
  "methodName" : "testSetContext",
  "sourceCode" : "/**\r\n * Tests whether a JNDI context can be set.\r\n */\r\n@Test\r\nvoid testSetContext() {\r\n    final Context ctx = mock(Context.class);\r\n    assertSame(params, params.setContext(ctx));\r\n    final Map<String, Object> paramsMap = params.getParameters();\r\n    assertSame(ctx, paramsMap.get(\"context\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestJndiBuilderParametersImpl.java",
  "methodName" : "testSetPrefix",
  "sourceCode" : "/**\r\n * Tests whether a prefix can be set.\r\n */\r\n@Test\r\nvoid testSetPrefix() {\r\n    final String prefix = \"testJndiPrefix\";\r\n    assertSame(params, params.setPrefix(prefix));\r\n    final Map<String, Object> paramsMap = params.getParameters();\r\n    assertEquals(prefix, paramsMap.get(\"prefix\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestPropertiesBuilderParametersImpl.java",
  "methodName" : "testBeanPropertiesAccess",
  "sourceCode" : "/**\r\n * Tests whether properties can be set using BeanUtils.\r\n */\r\n@Test\r\nvoid testBeanPropertiesAccess() throws Exception {\r\n    final PropertiesConfiguration.IOFactory factory = mock(PropertiesConfiguration.IOFactory.class);\r\n    BeanHelper.setProperty(params, \"IOFactory\", factory);\r\n    BeanHelper.setProperty(params, \"throwExceptionOnMissing\", Boolean.TRUE);\r\n    BeanHelper.setProperty(params, \"fileName\", \"test.properties\");\r\n    assertEquals(\"test.properties\", params.getFileHandler().getFileName());\r\n    final Map<String, Object> paramsMap = params.getParameters();\r\n    assertEquals(Boolean.TRUE, paramsMap.get(\"throwExceptionOnMissing\"));\r\n    assertSame(factory, params.getParameters().get(\"IOFactory\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestPropertiesBuilderParametersImpl.java",
  "methodName" : "testInheritFrom",
  "sourceCode" : "/**\r\n * Tests whether properties can be inherited.\r\n */\r\n@Test\r\nvoid testInheritFrom() {\r\n    final PropertiesConfiguration.IOFactory factory = mock(PropertiesConfiguration.IOFactory.class);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final ConfigurationConsumer<ConfigurationException> includeListener = mock(ConfigurationConsumer.class);\r\n    params.setIOFactory(factory).setIncludeListener(includeListener).setIncludesAllowed(false).setLayout(new PropertiesConfigurationLayout()).setThrowExceptionOnMissing(true);\r\n    final PropertiesBuilderParametersImpl params2 = new PropertiesBuilderParametersImpl();\r\n    params2.inheritFrom(params.getParameters());\r\n    final Map<String, Object> parameters = params2.getParameters();\r\n    assertEquals(Boolean.TRUE, parameters.get(\"throwExceptionOnMissing\"));\r\n    assertEquals(includeListener, parameters.get(\"includeListener\"));\r\n    assertEquals(factory, parameters.get(\"IOFactory\"));\r\n    assertEquals(Boolean.FALSE, parameters.get(\"includesAllowed\"));\r\n    assertNull(parameters.get(\"layout\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestPropertiesBuilderParametersImpl.java",
  "methodName" : "testSetIncludeListener",
  "sourceCode" : "/**\r\n * Tests whether the include listener can be set.\r\n */\r\n@Test\r\nvoid testSetIncludeListener() {\r\n    @SuppressWarnings(\"unchecked\")\r\n    final ConfigurationConsumer<ConfigurationException> includeListener = mock(ConfigurationConsumer.class);\r\n    assertSame(params, params.setIncludeListener(includeListener));\r\n    assertSame(includeListener, params.getParameters().get(\"includeListener\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestPropertiesBuilderParametersImpl.java",
  "methodName" : "testSetIncludeListenerProperty",
  "sourceCode" : "/**\r\n * Tests whether the IncludeListener property can be correctly set.\r\n */\r\n@Test\r\nvoid testSetIncludeListenerProperty() throws ConfigurationException {\r\n    final ConfigurationConsumer<ConfigurationException> includeListener = PropertiesConfiguration.DEFAULT_INCLUDE_LISTENER;\r\n    final ConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(params.setIncludeListener(includeListener));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertEquals(includeListener, config.getIncludeListener());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestPropertiesBuilderParametersImpl.java",
  "methodName" : "testSetIncludesAllowed",
  "sourceCode" : "/**\r\n * Tests whether the includesAllowed property can be set.\r\n */\r\n@Test\r\nvoid testSetIncludesAllowed() {\r\n    assertSame(params, params.setIncludesAllowed(true));\r\n    assertEquals(Boolean.TRUE, params.getParameters().get(\"includesAllowed\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestPropertiesBuilderParametersImpl.java",
  "methodName" : "testSetIOFactory",
  "sourceCode" : "/**\r\n * Tests whether the IO factory can be set.\r\n */\r\n@Test\r\nvoid testSetIOFactory() {\r\n    final PropertiesConfiguration.IOFactory factory = mock(PropertiesConfiguration.IOFactory.class);\r\n    assertSame(params, params.setIOFactory(factory));\r\n    assertSame(factory, params.getParameters().get(\"IOFactory\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestPropertiesBuilderParametersImpl.java",
  "methodName" : "testSetIOFactoryProperty",
  "sourceCode" : "/**\r\n * Tests whether the IOFactory property can be correctly set. This test is related to CONFIGURATION-648.\r\n */\r\n@Test\r\nvoid testSetIOFactoryProperty() throws ConfigurationException {\r\n    final PropertiesConfiguration.IOFactory factory = new PropertiesConfiguration.DefaultIOFactory();\r\n    final ConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class).configure(params.setIOFactory(factory));\r\n    final PropertiesConfiguration config = builder.getConfiguration();\r\n    assertEquals(factory, config.getIOFactory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestPropertiesBuilderParametersImpl.java",
  "methodName" : "testSetLayout",
  "sourceCode" : "/**\r\n * Tests whether the layout object can be set.\r\n */\r\n@Test\r\nvoid testSetLayout() {\r\n    final PropertiesConfigurationLayout layout = new PropertiesConfigurationLayout();\r\n    assertSame(params, params.setLayout(layout));\r\n    assertSame(layout, params.getParameters().get(\"layout\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingBuilderSupportListener.java",
  "methodName" : "testResetBuilderOnReloadingEvent",
  "sourceCode" : "/**\r\n * Tests that the builder is reset when a reloading event notification occurs.\r\n */\r\n@Test\r\nvoid testResetBuilderOnReloadingEvent() {\r\n    final ReloadingDetector detector = mock(ReloadingDetector.class);\r\n    when(detector.isReloadingRequired()).thenReturn(true);\r\n    final ReloadingController controller = new ReloadingController(detector);\r\n    final BasicConfigurationBuilder<Configuration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final BuilderEventListenerImpl builderListener = new BuilderEventListenerImpl();\r\n    builder.addEventListener(ConfigurationBuilderEvent.ANY, builderListener);\r\n    final ReloadingBuilderSupportListener listener = ReloadingBuilderSupportListener.connect(builder, controller);\r\n    assertNotNull(listener);\r\n    controller.checkForReloading(null);\r\n    builderListener.nextEvent(ConfigurationBuilderEvent.RESET);\r\n    builderListener.assertNoMoreEvents();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingBuilderSupportListener.java",
  "methodName" : "testResetReloadingStateOnResultCreation",
  "sourceCode" : "/**\r\n * Tests that the controller's reloading state is reset when a new result object is created.\r\n */\r\n@Test\r\nvoid testResetReloadingStateOnResultCreation() throws ConfigurationException {\r\n    final ReloadingController controller = mock(ReloadingController.class);\r\n    final BasicConfigurationBuilder<Configuration> builder = new BasicConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final ReloadingBuilderSupportListener listener = ReloadingBuilderSupportListener.connect(builder, controller);\r\n    assertNotNull(listener);\r\n    builder.getConfiguration();\r\n    verify(controller).addEventListener(eq(ReloadingEvent.ANY), any());\r\n    verify(controller).resetReloadingState();\r\n    verifyNoMoreInteractions(controller);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testCreateReloadingDetectorDefaultFactory",
  "sourceCode" : "/**\r\n * Tests whether a correct reloading detector is created if no custom factory was set.\r\n */\r\n@Test\r\nvoid testCreateReloadingDetectorDefaultFactory() throws ConfigurationException {\r\n    final ReloadingFileBasedConfigurationBuilder<PropertiesConfiguration> builder = new ReloadingFileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final FileHandler handler = new FileHandler();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    final long refreshDelay = 60000L;\r\n    params.setReloadingRefreshDelay(refreshDelay);\r\n    final FileHandlerReloadingDetector detector = (FileHandlerReloadingDetector) builder.createReloadingDetector(handler, params);\r\n    assertSame(handler, detector.getFileHandler());\r\n    assertEquals(refreshDelay, detector.getRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testCreateReloadingDetectoryCustomFactory",
  "sourceCode" : "/**\r\n * Tests whether a custom reloading detector factory can be installed.\r\n */\r\n@Test\r\nvoid testCreateReloadingDetectoryCustomFactory() throws ConfigurationException {\r\n    final ReloadingDetector detector = mock(ReloadingDetector.class);\r\n    final ReloadingDetectorFactory factory = mock(ReloadingDetectorFactory.class);\r\n    final FileHandler handler = new FileHandler();\r\n    final FileBasedBuilderParametersImpl params = new FileBasedBuilderParametersImpl();\r\n    when(factory.createReloadingDetector(handler, params)).thenReturn(detector);\r\n    params.setReloadingDetectorFactory(factory);\r\n    final ReloadingFileBasedConfigurationBuilder<PropertiesConfiguration> builder = new ReloadingFileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    assertSame(detector, builder.createReloadingDetector(handler, params));\r\n    verify(factory).createReloadingDetector(handler, params);\r\n    verifyNoMoreInteractions(factory);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testGetConfigurationNoLocation",
  "sourceCode" : "/**\r\n * Tests whether a configuration can be created if no location is set. This tests also ensures that the super\r\n * constructor is called correctly.\r\n */\r\n@Test\r\nvoid testGetConfigurationNoLocation() throws ConfigurationException {\r\n    final Map<String, Object> params = new HashMap<>();\r\n    params.put(\"throwExceptionOnMissing\", Boolean.TRUE);\r\n    final ReloadingFileBasedConfigurationBuilder<PropertiesConfiguration> builder = new ReloadingFileBasedConfigurationBuilder<>(PropertiesConfiguration.class, params);\r\n    final PropertiesConfiguration conf = builder.getConfiguration();\r\n    assertTrue(conf.isThrowExceptionOnMissing());\r\n    assertTrue(conf.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testInitAllowFailOnInitFlag",
  "sourceCode" : "/**\r\n * Tests whether the allowFailOnInit flag is correctly initialized.\r\n */\r\n@Test\r\nvoid testInitAllowFailOnInitFlag() {\r\n    final ReloadingFileBasedConfigurationBuilder<PropertiesConfiguration> builder = new ReloadingFileBasedConfigurationBuilder<>(PropertiesConfiguration.class, null, true);\r\n    assertTrue(builder.isAllowFailOnInit());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testReloadingControllerEvents",
  "sourceCode" : "/**\r\n * Tests whether this builder reacts on events fired by the reloading controller.\r\n */\r\n@Test\r\nvoid testReloadingControllerEvents() throws ConfigurationException {\r\n    final ReloadingDetector detector = mock(ReloadingDetector.class);\r\n    when(detector.isReloadingRequired()).thenReturn(Boolean.TRUE);\r\n    final ReloadingFileBasedConfigurationBuilderTestImpl builder = new ReloadingFileBasedConfigurationBuilderTestImpl(detector);\r\n    final BuilderEventListenerImpl listener = new BuilderEventListenerImpl();\r\n    builder.addEventListener(ConfigurationBuilderEvent.RESET, listener);\r\n    builder.getConfiguration();\r\n    builder.getReloadingController().checkForReloading(null);\r\n    listener.nextEvent(ConfigurationBuilderEvent.RESET);\r\n    listener.assertNoMoreEvents();\r\n    verify(detector).isReloadingRequired();\r\n    verifyNoMoreInteractions(detector);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testReloadingDetectorIsReloadingRequired",
  "sourceCode" : "/**\r\n * Tests the isReloadingRequired() implementation of the detector associated with the reloading controller.\r\n */\r\n@Test\r\nvoid testReloadingDetectorIsReloadingRequired() throws ConfigurationException {\r\n    final ReloadingDetector detector = mock(ReloadingDetector.class);\r\n    when(detector.isReloadingRequired()).thenReturn(Boolean.TRUE, Boolean.FALSE);\r\n    final ReloadingFileBasedConfigurationBuilderTestImpl builder = new ReloadingFileBasedConfigurationBuilderTestImpl(detector);\r\n    builder.getConfiguration();\r\n    final ReloadingDetector ctrlDetector = builder.getReloadingController().getDetector();\r\n    assertTrue(ctrlDetector.isReloadingRequired());\r\n    assertFalse(ctrlDetector.isReloadingRequired());\r\n    assertSame(builder.getFileHandler(), builder.getHandlerForDetector());\r\n    verify(detector, times(2)).isReloadingRequired();\r\n    verifyNoMoreInteractions(detector);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testReloadingDetectorNoFileHandler",
  "sourceCode" : "/**\r\n * Tests the behavior of the reloading detector if no underlying detector is available.\r\n */\r\n@Test\r\nvoid testReloadingDetectorNoFileHandler() {\r\n    final ReloadingFileBasedConfigurationBuilder<PropertiesConfiguration> builder = new ReloadingFileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    final ReloadingDetector ctrlDetector = builder.getReloadingController().getDetector();\r\n    ctrlDetector.reloadingPerformed();\r\n    assertFalse(ctrlDetector.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testReloadingDetectorReloadingPerformed",
  "sourceCode" : "/**\r\n * Tests the reloadingPerformed() implementation of the detector associated with the reloading controller.\r\n */\r\n@Test\r\nvoid testReloadingDetectorReloadingPerformed() throws ConfigurationException {\r\n    final ReloadingDetector detector = mock(ReloadingDetector.class);\r\n    final ReloadingFileBasedConfigurationBuilderTestImpl builder = new ReloadingFileBasedConfigurationBuilderTestImpl(detector);\r\n    builder.getConfiguration();\r\n    final ReloadingDetector ctrlDetector = builder.getReloadingController().getDetector();\r\n    ctrlDetector.reloadingPerformed();\r\n    verify(detector).reloadingPerformed();\r\n    verifyNoMoreInteractions(detector);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestReloadingFileBasedConfigurationBuilder.java",
  "methodName" : "testResetReloadingStateInGetConfiguration",
  "sourceCode" : "/**\r\n * Tests whether the controller's reloading state is reset when a new result configuration is created.\r\n */\r\n@Test\r\nvoid testResetReloadingStateInGetConfiguration() throws ConfigurationException {\r\n    final ReloadingDetector detector = mock(ReloadingDetector.class);\r\n    when(detector.isReloadingRequired()).thenReturn(Boolean.TRUE);\r\n    final ReloadingFileBasedConfigurationBuilderTestImpl builder = new ReloadingFileBasedConfigurationBuilderTestImpl(detector);\r\n    final PropertiesConfiguration config1 = builder.getConfiguration();\r\n    builder.getReloadingController().checkForReloading(null);\r\n    final PropertiesConfiguration config2 = builder.getConfiguration();\r\n    assertNotSame(config1, config2);\r\n    assertFalse(builder.getReloadingController().isInReloadingState());\r\n    verify(detector).isReloadingRequired();\r\n    verify(detector).reloadingPerformed();\r\n    verifyNoMoreInteractions(detector);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestXMLBuilderParametersImpl.java",
  "methodName" : "testBeanPropertiesAccess",
  "sourceCode" : "/**\r\n * Tests whether properties can be set through BeanUtils.\r\n */\r\n@Test\r\nvoid testBeanPropertiesAccess() throws Exception {\r\n    final EntityResolver resolver = mock(EntityResolver.class);\r\n    final DocumentBuilder builder = mock(DocumentBuilder.class);\r\n    BeanHelper.setProperty(params, \"throwExceptionOnMissing\", Boolean.TRUE);\r\n    BeanHelper.setProperty(params, \"fileName\", \"test.xml\");\r\n    BeanHelper.setProperty(params, \"entityResolver\", resolver);\r\n    BeanHelper.setProperty(params, \"documentBuilder\", builder);\r\n    assertEquals(\"test.xml\", params.getFileHandler().getFileName());\r\n    final Map<String, Object> paramsMap = params.getParameters();\r\n    assertEquals(Boolean.TRUE, paramsMap.get(\"throwExceptionOnMissing\"));\r\n    assertSame(resolver, paramsMap.get(\"entityResolver\"));\r\n    assertSame(builder, paramsMap.get(\"documentBuilder\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestXMLBuilderParametersImpl.java",
  "methodName" : "testInheritFrom",
  "sourceCode" : "/**\r\n * Tests whether properties can be inherited.\r\n */\r\n@Test\r\nvoid testInheritFrom() {\r\n    final EntityResolver resolver = mock(EntityResolver.class);\r\n    final DocumentBuilder builder = mock(DocumentBuilder.class);\r\n    params.setDocumentBuilder(builder).setEntityResolver(resolver).setSchemaValidation(true).setValidating(true);\r\n    params.setThrowExceptionOnMissing(true);\r\n    final XMLBuilderParametersImpl params2 = new XMLBuilderParametersImpl();\r\n    params2.inheritFrom(params.getParameters());\r\n    final Map<String, Object> parameters = params2.getParameters();\r\n    assertEquals(Boolean.TRUE, parameters.get(\"throwExceptionOnMissing\"));\r\n    assertEquals(resolver, parameters.get(\"entityResolver\"));\r\n    assertEquals(builder, parameters.get(\"documentBuilder\"));\r\n    assertEquals(Boolean.TRUE, parameters.get(\"validating\"));\r\n    assertEquals(Boolean.TRUE, parameters.get(\"schemaValidation\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestXMLBuilderParametersImpl.java",
  "methodName" : "testSetDocumentBuilder",
  "sourceCode" : "/**\r\n * Tests whether a document builder can be set.\r\n */\r\n@Test\r\nvoid testSetDocumentBuilder() {\r\n    final DocumentBuilder builder = mock(DocumentBuilder.class);\r\n    assertSame(params, params.setDocumentBuilder(builder));\r\n    assertSame(builder, params.getParameters().get(\"documentBuilder\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestXMLBuilderParametersImpl.java",
  "methodName" : "testSetEntityResolver",
  "sourceCode" : "/**\r\n * Tests whether an entity resolver can be set.\r\n */\r\n@Test\r\nvoid testSetEntityResolver() {\r\n    final EntityResolver resolver = mock(EntityResolver.class);\r\n    assertSame(params, params.setEntityResolver(resolver));\r\n    assertSame(resolver, params.getEntityResolver());\r\n    assertSame(resolver, params.getParameters().get(\"entityResolver\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestXMLBuilderParametersImpl.java",
  "methodName" : "testSetPublicID",
  "sourceCode" : "/**\r\n * Tests whether a public ID can be set.\r\n */\r\n@Test\r\nvoid testSetPublicID() {\r\n    final String pubID = \"testPublicID\";\r\n    assertSame(params, params.setPublicID(pubID));\r\n    assertEquals(pubID, params.getParameters().get(\"publicID\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestXMLBuilderParametersImpl.java",
  "methodName" : "testSetSchemaValidation",
  "sourceCode" : "/**\r\n * Tests whether the schema validation flag can be set.\r\n */\r\n@Test\r\nvoid testSetSchemaValidation() {\r\n    assertSame(params, params.setSchemaValidation(false));\r\n    assertEquals(Boolean.FALSE, params.getParameters().get(\"schemaValidation\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestXMLBuilderParametersImpl.java",
  "methodName" : "testSetSystemID",
  "sourceCode" : "/**\r\n * Tests whether a system ID can be set.\r\n */\r\n@Test\r\nvoid testSetSystemID() {\r\n    final String sysID = \"testSystemID\";\r\n    assertSame(params, params.setSystemID(sysID));\r\n    assertEquals(sysID, params.getParameters().get(\"systemID\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\builder\\TestXMLBuilderParametersImpl.java",
  "methodName" : "testSetValidating",
  "sourceCode" : "/**\r\n * Tests whether validating property can be set.\r\n */\r\n@Test\r\nvoid testSetValidating() {\r\n    assertSame(params, params.setValidating(true));\r\n    assertEquals(Boolean.TRUE, params.getParameters().get(\"validating\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testGetDateFormatNotSet",
  "sourceCode" : "/**\r\n * Tests whether the default date format is used if no format has been set.\r\n */\r\n@Test\r\nvoid testGetDateFormatNotSet() {\r\n    assertEquals(DefaultConversionHandler.DEFAULT_DATE_FORMAT, handler.getDateFormat());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testListDelimiterHandler",
  "sourceCode" : "@Test\r\npublic synchronized void testListDelimiterHandler() {\r\n    assertEquals(DefaultConversionHandler.LIST_DELIMITER_HANDLER, handler.getListDelimiterHandler());\r\n    handler.setListDelimiterHandler(null);\r\n    assertEquals(DefaultConversionHandler.LIST_DELIMITER_HANDLER, handler.getListDelimiterHandler());\r\n    final LegacyListDelimiterHandler legacyListDelimiterHandler = new LegacyListDelimiterHandler(',');\r\n    handler.setListDelimiterHandler(legacyListDelimiterHandler);\r\n    assertEquals(legacyListDelimiterHandler, handler.getListDelimiterHandler());\r\n    handler.setListDelimiterHandler(null);\r\n    assertEquals(DefaultConversionHandler.LIST_DELIMITER_HANDLER, handler.getListDelimiterHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testSetDateFormat",
  "sourceCode" : "/**\r\n * Tests whether the date format can be changed.\r\n */\r\n@Test\r\nvoid testSetDateFormat() {\r\n    final String dateFormat = \"dd.MM.yyyy\";\r\n    handler.setDateFormat(dateFormat);\r\n    assertEquals(dateFormat, handler.getDateFormat());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToArrayEmptyString",
  "sourceCode" : "/**\r\n * Tests a conversion to an array from an empty string. An empty string should be interpreted as an empty array.\r\n */\r\n@Test\r\nvoid testToArrayEmptyString() {\r\n    final int[] array = (int[]) handler.toArray(\"\", Integer.TYPE, null);\r\n    assertEquals(0, array.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToArrayNullInput",
  "sourceCode" : "/**\r\n * Tests toArray() if the source object is null.\r\n */\r\n@Test\r\nvoid testToArrayNullInput() {\r\n    assertNull(handler.toArray(null, Integer.class, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToArrayObject",
  "sourceCode" : "/**\r\n * Tests a conversion to an array of Objects.\r\n */\r\n@Test\r\nvoid testToArrayObject() {\r\n    final List<String> src = Arrays.asList(VAR, \"100\");\r\n    final Integer[] array = (Integer[]) handler.toArray(src, Integer.class, createInterpolator());\r\n    assertArrayEquals(new Integer[] { Integer.valueOf(REPLACEMENT), Integer.valueOf(src.get(1)) }, array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToArrayPrimitiveOtherType",
  "sourceCode" : "/**\r\n * Tests a conversion to an array of primitive type if the source object is something else.\r\n */\r\n@Test\r\nvoid testToArrayPrimitiveOtherType() {\r\n    final List<String> src = Arrays.asList(VAR, \"100\");\r\n    final int[] array = (int[]) handler.toArray(src, Integer.TYPE, createInterpolator());\r\n    assertArrayEquals(new int[] { Integer.parseInt(REPLACEMENT), Integer.parseInt(src.get(1)) }, array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToArrayPrimitiveSameType",
  "sourceCode" : "/**\r\n * Tests a conversion to an array of primitive type if the source array already has the correct type.\r\n */\r\n@Test\r\nvoid testToArrayPrimitiveSameType() {\r\n    final int[] src = { 1, 2, 3, 4, 5, 6 };\r\n    final int[] array = (int[]) handler.toArray(src, Integer.TYPE, createInterpolator());\r\n    assertArrayEquals(src, array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToArrayPrimitiveWrapperType",
  "sourceCode" : "/**\r\n * Tests a conversion to an array of primitive type if the source array is of the corresponding wrapper type.\r\n */\r\n@Test\r\nvoid testToArrayPrimitiveWrapperType() {\r\n    final Integer[] src = { 0, 1, 2, 4, 8, 16, 32, 64, 128 };\r\n    final int[] array = (int[]) handler.toArray(src, Integer.TYPE, createInterpolator());\r\n    assertArrayEquals(new int[] { 0, 1, 2, 4, 8, 16, 32, 64, 128 }, array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToCalendarWithDefaultFormat",
  "sourceCode" : "/**\r\n * Tests a conversion to a Calendar object using the default format.\r\n */\r\n@Test\r\nvoid testToCalendarWithDefaultFormat() {\r\n    final Calendar cal = handler.to(\"2013-08-19 21:17:22\", Calendar.class, null);\r\n    assertEquals(19, cal.get(Calendar.DATE));\r\n    assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\r\n    assertEquals(2013, cal.get(Calendar.YEAR));\r\n    assertEquals(21, cal.get(Calendar.HOUR_OF_DAY));\r\n    assertEquals(17, cal.get(Calendar.MINUTE));\r\n    assertEquals(22, cal.get(Calendar.SECOND));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToCollectionEmptyString",
  "sourceCode" : "/**\r\n * Tests a conversion to a collection if an empty string is passed in. An empty string should be interpreted as a list\r\n * with no values.\r\n */\r\n@Test\r\nvoid testToCollectionEmptyString() {\r\n    final List<Integer> col = new ArrayList<>(1);\r\n    handler.toCollection(\"\", Integer.class, null, col);\r\n    assertTrue(col.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToCollectionNullCollection",
  "sourceCode" : "/**\r\n * Tries to pass a null collection to toCollection().\r\n */\r\n@Test\r\nvoid testToCollectionNullCollection() {\r\n    final List<Integer> src = Arrays.asList(1, 2, 3);\r\n    assertThrows(IllegalArgumentException.class, () -> handler.toCollection(src, Integer.class, null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToCollectionNullInput",
  "sourceCode" : "/**\r\n * Tests a conversion to a collection if the source object is null.\r\n */\r\n@Test\r\nvoid testToCollectionNullInput() {\r\n    final ArrayList<Integer> col = new ArrayList<>();\r\n    handler.toCollection(null, Integer.class, null, col);\r\n    assertTrue(col.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToCollectionSuccess",
  "sourceCode" : "/**\r\n * Tests a successful conversion to a collection.\r\n */\r\n@Test\r\nvoid testToCollectionSuccess() {\r\n    final Object[] src = { VAR, \"100\" };\r\n    final List<Integer> col = new ArrayList<>(src.length);\r\n    handler.toCollection(src, Integer.class, createInterpolator(), col);\r\n    assertEquals(Arrays.asList(Integer.valueOf(REPLACEMENT), Integer.valueOf(src[1].toString())), col);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToCustomNumber",
  "sourceCode" : "@Test\r\nvoid testToCustomNumber() {\r\n    // convertValue()\r\n    assertEquals(new MyNumber(1), DefaultConversionHandler.INSTANCE.convertValue(new MyNumber(1), MyNumber.class, null));\r\n    assertEquals(new MyNumber(2), DefaultConversionHandler.INSTANCE.convertValue(new MyNumber(2), MyNumber.class, null));\r\n    assertEquals(new MyNumber(3), DefaultConversionHandler.INSTANCE.convertValue(\"3\", MyNumber.class, null));\r\n    assertNull(DefaultConversionHandler.INSTANCE.convertValue(null, MyNumber.class, null));\r\n    // to()\r\n    assertEquals(new MyNumber(1), DefaultConversionHandler.INSTANCE.to(new MyNumber(1), MyNumber.class, null));\r\n    assertEquals(new MyNumber(2), DefaultConversionHandler.INSTANCE.to(new MyNumber(2), MyNumber.class, null));\r\n    assertEquals(new MyNumber(3), DefaultConversionHandler.INSTANCE.to(\"3\", MyNumber.class, null));\r\n    assertNull(DefaultConversionHandler.INSTANCE.to(null, MyNumber.class, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToDateWithFormat",
  "sourceCode" : "/**\r\n * Tests whether a conversion to a date object is possible if a specific date format is used.\r\n */\r\n@Test\r\nvoid testToDateWithFormat() {\r\n    handler.setDateFormat(\"dd.MM.yyyy\");\r\n    final Date dt = handler.to(\"19.08.2013\", Date.class, null);\r\n    final Calendar cal = Calendar.getInstance();\r\n    cal.setTime(dt);\r\n    assertEquals(19, cal.get(Calendar.DATE));\r\n    assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\r\n    assertEquals(2013, cal.get(Calendar.YEAR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToFailedConversion",
  "sourceCode" : "/**\r\n * Tests a failed conversion.\r\n */\r\n@Test\r\nvoid testToFailedConversion() {\r\n    assertThrows(ConversionException.class, () -> handler.to(VAR, Integer.class, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToFromArray",
  "sourceCode" : "/**\r\n * Tests whether a conversion from an array is possible.\r\n */\r\n@Test\r\nvoid testToFromArray() {\r\n    final Object[] src = { VAR, true, 20130808221759L };\r\n    checkSingleValue(handler.to(src, Integer.class, createInterpolator()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToFromCollection",
  "sourceCode" : "/**\r\n * Tests whether a conversion from a collection is possible.\r\n */\r\n@Test\r\nvoid testToFromCollection() {\r\n    final Collection<String> src = Arrays.asList(VAR, \"true\", \"1000\");\r\n    checkSingleValue(handler.to(src, Integer.class, createInterpolator()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToFromEmptyCollection",
  "sourceCode" : "/**\r\n * Tests whether empty complex objects are handled when converting to a single value.\r\n */\r\n@Test\r\nvoid testToFromEmptyCollection() {\r\n    assertNull(handler.to(new ArrayList<>(), Integer.class, createInterpolator()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToFromIterator",
  "sourceCode" : "/**\r\n * Tests whether a conversion from an iterator is possible.\r\n */\r\n@Test\r\nvoid testToFromIterator() {\r\n    final Iterator<String> src = Arrays.asList(VAR, \"true\", \"1000\").iterator();\r\n    checkSingleValue(handler.to(src, Integer.class, createInterpolator()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToNoInterpolator",
  "sourceCode" : "/**\r\n * Tests whether a ConfigurationInterpolator is optional.\r\n */\r\n@Test\r\nvoid testToNoInterpolator() {\r\n    final Integer result = handler.to(REPLACEMENT, Integer.class, null);\r\n    checkSingleValue(result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToNull",
  "sourceCode" : "/**\r\n * Tests whether null input is handled by to().\r\n */\r\n@Test\r\nvoid testToNull() {\r\n    assertNull(handler.to(null, Integer.class, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToPrimitive",
  "sourceCode" : "/**\r\n * Tests a conversion to a primitive type.\r\n */\r\n@Test\r\nvoid testToPrimitive() {\r\n    final Long value = 20130819214935L;\r\n    final Object result = handler.to(value.toString(), Long.TYPE, null);\r\n    assertEquals(value, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultConversionHandler.java",
  "methodName" : "testToWithInterpolator",
  "sourceCode" : "/**\r\n * Tests a conversion with a ConfigurationInterpolator.\r\n */\r\n@Test\r\nvoid testToWithInterpolator() {\r\n    final Integer result = handler.to(VAR, Integer.class, createInterpolator());\r\n    checkSingleValue(result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testEscapeIntegerList",
  "sourceCode" : "@Test\r\nvoid testEscapeIntegerList() {\r\n    final ValueTransformer trans = ListDelimiterHandler.NOOP_TRANSFORMER;\r\n    final List<Integer> data = Arrays.asList(1, 2, 3, 4);\r\n    assertEquals(\"1,2,3,4\", handler.escapeList(data, trans));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testEscapeList",
  "sourceCode" : "/**\r\n * Tests whether a list is correctly escaped.\r\n */\r\n@Test\r\nvoid testEscapeList() {\r\n    final ValueTransformer trans = value -> String.valueOf(value) + \"_trans\";\r\n    final List<String> data = Arrays.asList(\"simple\", \"Hello,world!\", \"\\\\,\\\\\", \"end\");\r\n    assertEquals(\"simple_trans,Hello\\\\,world!_trans,\\\\\\\\\\\\,\\\\\\\\_trans,end_trans\", handler.escapeList(data, trans));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testEscapeStringBackslash",
  "sourceCode" : "/**\r\n * Tests whether a backslash is correctly escaped.\r\n */\r\n@Test\r\nvoid testEscapeStringBackslash() {\r\n    assertEquals(\"C:\\\\\\\\Temp\\\\\\\\\", handler.escapeString(\"C:\\\\Temp\\\\\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testEscapeStringListDelimiter",
  "sourceCode" : "/**\r\n * Tests whether the list delimiter character is correctly escaped in a string.\r\n */\r\n@Test\r\nvoid testEscapeStringListDelimiter() {\r\n    assertEquals(\"3\\\\,1415\", handler.escapeString(\"3,1415\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testEscapeStringListDelimiterAndBackslash",
  "sourceCode" : "/**\r\n * Tests whether combinations of list delimiters and backslashes are correctly escaped.\r\n */\r\n@Test\r\nvoid testEscapeStringListDelimiterAndBackslash() {\r\n    assertEquals(\"C:\\\\\\\\Temp\\\\\\\\\\\\,\\\\\\\\\\\\\\\\Share\\\\,/root\", handler.escapeString(\"C:\\\\Temp\\\\,\\\\\\\\Share,/root\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testEscapeStringNoSpecialCharacter",
  "sourceCode" : "/**\r\n * Tests whether a string is correctly escaped which does not contain any special character.\r\n */\r\n@Test\r\nvoid testEscapeStringNoSpecialCharacter() {\r\n    assertEquals(\"test\", handler.escapeString(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testEscapeWithTransformer",
  "sourceCode" : "/**\r\n * Tests whether a value transformer is correctly called when escaping a single value.\r\n */\r\n@Test\r\nvoid testEscapeWithTransformer() {\r\n    final ValueTransformer trans = mock(ValueTransformer.class);\r\n    when(trans.transformValue(\"a\\\\,b\")).thenReturn(\"ok\");\r\n    assertEquals(\"ok\", handler.escape(\"a,b\", trans));\r\n    verify(trans).transformValue(\"a\\\\,b\");\r\n    verifyNoMoreInteractions(trans);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testSplitEscapeBackslash",
  "sourceCode" : "/**\r\n * Tests whether split() deals correctly with escaped backslashes.\r\n */\r\n@Test\r\nvoid testSplitEscapeBackslash() {\r\n    checkSplit(\"C:\\\\\\\\Temp\\\\\\\\\", true, \"C:\\\\Temp\\\\\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testSplitEscapeLineDelimiter",
  "sourceCode" : "/**\r\n * Tests whether a line delimiter can be escaped when splitting a list.\r\n */\r\n@Test\r\nvoid testSplitEscapeLineDelimiter() {\r\n    checkSplit(\"3\\\\,1415\", true, \"3,1415\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testSplitEscapeListDelimiterAndBackslashes",
  "sourceCode" : "/**\r\n * Tests a split operation with a complex combination of list delimiters and backslashes.\r\n */\r\n@Test\r\nvoid testSplitEscapeListDelimiterAndBackslashes() {\r\n    checkSplit(\"C:\\\\\\\\Temp\\\\\\\\\\\\,\\\\\\\\\\\\\\\\Share\\\\\\\\,/root\", false, \"C:\\\\Temp\\\\,\\\\\\\\Share\\\\\", \"/root\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testSplitList",
  "sourceCode" : "/**\r\n * Tests whether a string list is split correctly.\r\n */\r\n@Test\r\nvoid testSplitList() {\r\n    checkSplit(\"a, b,c   ,   d\", true, \"a\", \"b\", \"c\", \"d\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testSplitNoTrim",
  "sourceCode" : "/**\r\n * Tests whether trimming can be disabled when splitting a list.\r\n */\r\n@Test\r\nvoid testSplitNoTrim() {\r\n    checkSplit(\"a , b,  c  ,d\", false, \"a \", \" b\", \"  c  \", \"d\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testSplitSingleElement",
  "sourceCode" : "/**\r\n * Tests split() if there is only a single element.\r\n */\r\n@Test\r\nvoid testSplitSingleElement() {\r\n    checkSplit(\"test\", true, \"test\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDefaultListDelimiterHandler.java",
  "methodName" : "testSplitUnexpectedEscape",
  "sourceCode" : "/**\r\n * Tests whether an unexpected escape character is handled properly.\r\n */\r\n@Test\r\nvoid testSplitUnexpectedEscape() {\r\n    checkSplit(\"\\\\x, \\\\,y, \\\\\", true, \"\\\\x\", \",y\", \"\\\\\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testEscapeList",
  "sourceCode" : "/**\r\n * Tests escapeList(). This operation is not supported.\r\n */\r\n@Test\r\nvoid testEscapeList() {\r\n    final List<Object> values = Arrays.asList(VALUES);\r\n    assertThrows(UnsupportedOperationException.class, () -> handler.escapeList(values, ListDelimiterHandler.NOOP_TRANSFORMER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testEscapeNonStringValue",
  "sourceCode" : "/**\r\n * Tests whether a non-string value is correctly escaped. The object should not be modified.\r\n */\r\n@Test\r\nvoid testEscapeNonStringValue() {\r\n    final Object value = 42;\r\n    assertEquals(value, handler.escape(value, ListDelimiterHandler.NOOP_TRANSFORMER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testEscapeNonStringValueTransformer",
  "sourceCode" : "/**\r\n * Tests whether the transformer is correctly called when escaping a non string value.\r\n */\r\n@Test\r\nvoid testEscapeNonStringValueTransformer() {\r\n    final ValueTransformer trans = mock(ValueTransformer.class);\r\n    final Object value = 42;\r\n    when(trans.transformValue(value)).thenReturn(STR_VALUE);\r\n    assertEquals(STR_VALUE, handler.escape(value, trans));\r\n    verify(trans).transformValue(value);\r\n    verifyNoMoreInteractions(trans);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testEscapeStringValue",
  "sourceCode" : "/**\r\n * Tests whether a string value is correctly escaped. The string should not be modified.\r\n */\r\n@Test\r\nvoid testEscapeStringValue() {\r\n    assertEquals(STR_VALUE, handler.escape(STR_VALUE, ListDelimiterHandler.NOOP_TRANSFORMER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testEscapeStringValueTransformer",
  "sourceCode" : "/**\r\n * Tests whether the transformer is correctly invoked when escaping a string.\r\n */\r\n@Test\r\nvoid testEscapeStringValueTransformer() {\r\n    final ValueTransformer trans = mock(ValueTransformer.class);\r\n    final String testStr = \"Some other string\";\r\n    when(trans.transformValue(testStr)).thenReturn(STR_VALUE);\r\n    assertEquals(STR_VALUE, handler.escape(testStr, trans));\r\n    verify(trans).transformValue(testStr);\r\n    verifyNoMoreInteractions(trans);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testFlattenArrayWithLimit",
  "sourceCode" : "/**\r\n * Tests whether a limit is applied when extracting values from an array.\r\n */\r\n@Test\r\nvoid testFlattenArrayWithLimit() {\r\n    final Collection<?> res = handler.flatten(VALUES, 1);\r\n    assertEquals(1, res.size());\r\n    assertEquals(VALUES[0], res.iterator().next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testFlattenCollectionWithArrayWithLimit",
  "sourceCode" : "/**\r\n * Tests whether elements can be extracted from a collection that contains an array if a limit is specified.\r\n */\r\n@Test\r\nvoid testFlattenCollectionWithArrayWithLimit() {\r\n    final Collection<Object> src = new ArrayList<>(2);\r\n    src.add(STR_VALUE);\r\n    src.add(VALUES);\r\n    final Collection<?> res = handler.flatten(src, 2);\r\n    assertEquals(2, res.size());\r\n    final Iterator<?> it = res.iterator();\r\n    assertEquals(STR_VALUE, it.next());\r\n    assertEquals(VALUES[0], it.next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testFlattenCollectionWithLimit",
  "sourceCode" : "/**\r\n * Tests whether a limit is applied when extracting elements from a collection.\r\n */\r\n@Test\r\nvoid testFlattenCollectionWithLimit() {\r\n    final Collection<Object> src = Arrays.asList(VALUES);\r\n    final Collection<?> res = handler.flatten(src, 1);\r\n    assertEquals(1, res.size());\r\n    assertEquals(VALUES[0], res.iterator().next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testParseArray",
  "sourceCode" : "/**\r\n * Tests whether the values of an array can be extracted.\r\n */\r\n@Test\r\nvoid testParseArray() {\r\n    checkIterator(handler.parse(VALUES));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testParseIterable",
  "sourceCode" : "/**\r\n * Tests whether the values of an Iterable object can be extracted.\r\n */\r\n@Test\r\nvoid testParseIterable() {\r\n    checkIterator(handler.parse(Arrays.asList(VALUES)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testParseIterator",
  "sourceCode" : "/**\r\n * Tests whether the values of an Iterator object can be extracted.\r\n */\r\n@Test\r\nvoid testParseIterator() {\r\n    checkIterator(handler.parse(Arrays.asList(VALUES).iterator()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testParseNull",
  "sourceCode" : "/**\r\n * Tests whether a null value can be parsed.\r\n */\r\n@Test\r\nvoid testParseNull() {\r\n    assertFalse(handler.parse(null).iterator().hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestDisabledListDelimiterHandler.java",
  "methodName" : "testParseSimpleValue",
  "sourceCode" : "/**\r\n * Tests whether a simple string value can be parsed.\r\n */\r\n@Test\r\nvoid testParseSimpleValue() {\r\n    final Iterator<?> it = handler.parse(STR_VALUE).iterator();\r\n    assertEquals(STR_VALUE, it.next());\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToBigDecimalDoubleConstructor",
  "sourceCode" : "/**\r\n * See CONFIGURATION-766.\r\n */\r\n@Test\r\nvoid testToBigDecimalDoubleConstructor() {\r\n    // If the conversion uses new BigDecimal(0.1) the result is not exact due to round off.\r\n    // The result is 0.1000000000000000055511151231257827021181583404541015625.\r\n    // See Sonar rule: https://rules.sonarsource.com/java/type/Bug/RSPEC-2111\r\n    final double d = 0.1;\r\n    // Use BigDecimal#valueOf() Fix PMD AvoidDecimalLiteralsInBigDecimalConstructor\r\n    assertEquals(BigDecimal.valueOf(d), PropertyConverter.toBigDecimal(d));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToBigDecimalStringConstructor",
  "sourceCode" : "/**\r\n * See CONFIGURATION-766.\r\n */\r\n@Test\r\n@Disabled\r\nvoid testToBigDecimalStringConstructor() {\r\n    // If the conversion uses new BigDecimal(0.1) the result is not exact due to round off.\r\n    // The result is 0.1000000000000000055511151231257827021181583404541015625.\r\n    // See Sonar rule: https://rules.sonarsource.com/java/type/Bug/RSPEC-2111\r\n    final double d = 0.1;\r\n    assertEquals(new BigDecimal(Double.toString(d)), PropertyConverter.toBigDecimal(d));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToCharFailed",
  "sourceCode" : "/**\r\n * Tests a failed conversion to character.\r\n */\r\n@Test\r\nvoid testToCharFailed() {\r\n    final DefaultConversionHandler conversionHandler = new DefaultConversionHandler();\r\n    assertThrows(ConversionException.class, () -> PropertyConverter.to(Character.TYPE, \"FF\", conversionHandler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToCharSuccess",
  "sourceCode" : "/**\r\n * Tests whether a conversion to character is possible.\r\n */\r\n@Test\r\nvoid testToCharSuccess() {\r\n    assertEquals(Character.valueOf('t'), PropertyConverter.to(Character.class, \"t\", new DefaultConversionHandler()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToCharViaToString",
  "sourceCode" : "/**\r\n * Tests whether other objects implementing a toString() method can be converted to character.\r\n */\r\n@Test\r\nvoid testToCharViaToString() {\r\n    final Object value = new Object() {\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"X\";\r\n        }\r\n    };\r\n    assertEquals(Character.valueOf('X'), PropertyConverter.to(Character.TYPE, value, new DefaultConversionHandler()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToCustomNumber",
  "sourceCode" : "@Test\r\nvoid testToCustomNumber() {\r\n    assertEquals(new MyNumber(1), PropertyConverter.to(MyNumber.class, \"1\", null));\r\n    assertEquals(new MyNumber(2), PropertyConverter.to(MyNumber.class, new MyNumber(2), null));\r\n    assertEquals(new MyNumber(0), PropertyConverter.to(MyNumber.class, null, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToEnumFromEnum",
  "sourceCode" : "@Test\r\nvoid testToEnumFromEnum() {\r\n    assertEquals(ElementType.METHOD, PropertyConverter.toEnum(ElementType.METHOD, ENUM_CLASS));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToEnumFromInvalidNumber",
  "sourceCode" : "@Test\r\nvoid testToEnumFromInvalidNumber() {\r\n    assertThrows(ConversionException.class, () -> PropertyConverter.toEnum(-1, ENUM_CLASS));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToEnumFromInvalidString",
  "sourceCode" : "@Test\r\nvoid testToEnumFromInvalidString() {\r\n    assertThrows(ConversionException.class, () -> PropertyConverter.toEnum(\"FOO\", ENUM_CLASS));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToEnumFromNumber",
  "sourceCode" : "@Test\r\nvoid testToEnumFromNumber() {\r\n    assertEquals(PropertyConverter.toEnum(Integer.valueOf(ElementType.METHOD.ordinal()), ENUM_CLASS), ElementType.METHOD);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToEnumFromString",
  "sourceCode" : "@Test\r\nvoid testToEnumFromString() {\r\n    assertEquals(ElementType.METHOD, PropertyConverter.toEnum(\"METHOD\", ENUM_CLASS));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToFileDirect",
  "sourceCode" : "/**\r\n * Tests conversion to files when the passed in objects are already files.\r\n */\r\n@Test\r\nvoid testToFileDirect() {\r\n    final File f = new File(\"dir\", \"file\");\r\n    assertSame(f, PropertyConverter.toFile(f));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToFileFromPath",
  "sourceCode" : "/**\r\n * Tests conversion to file when the passed in objects are paths.\r\n */\r\n@Test\r\nvoid testToFileFromPath() {\r\n    final Path p = Paths.get(\"dir\", \"file\");\r\n    assertEquals(new File(\"dir\", \"file\"), PropertyConverter.toFile(p));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToFileFromString",
  "sourceCode" : "/**\r\n * Tests conversion to file when the passed in objects have a compatible string representation.\r\n */\r\n@Test\r\nvoid testToFileFromString() {\r\n    assertEquals(new File(\"dir\", \"file\"), PropertyConverter.toFile(\"dir/file\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNoConversionNeeded",
  "sourceCode" : "/**\r\n * Tests a trivial conversion: the value has already the desired type.\r\n */\r\n@Test\r\nvoid testToNoConversionNeeded() {\r\n    final String value = \"testValue\";\r\n    assertEquals(value, PropertyConverter.to(String.class, value, new DefaultConversionHandler()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNumberDirect",
  "sourceCode" : "/**\r\n * Tests conversion to numbers when the passed in objects are already numbers.\r\n */\r\n@Test\r\nvoid testToNumberDirect() {\r\n    final Integer i = Integer.valueOf(42);\r\n    assertSame(i, PropertyConverter.toNumber(i, Integer.class));\r\n    final BigDecimal d = new BigDecimal(\"3.1415\");\r\n    assertSame(d, PropertyConverter.toNumber(d, Integer.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNumberFromBinaryString",
  "sourceCode" : "/**\r\n * Tests conversion to numbers when the passed in objects are strings with prefixes for special radices.\r\n */\r\n@Test\r\nvoid testToNumberFromBinaryString() {\r\n    final Number n = PropertyConverter.toNumber(\"0b1111\", Integer.class);\r\n    assertEquals(15, n.intValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNumberFromHexString",
  "sourceCode" : "/**\r\n * Tests conversion to numbers when the passed in objects are strings with prefixes for special radices.\r\n */\r\n@Test\r\nvoid testToNumberFromHexString() {\r\n    final Number n = PropertyConverter.toNumber(\"0x10\", Integer.class);\r\n    assertEquals(16, n.intValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNumberFromInvalidBinaryString",
  "sourceCode" : "/**\r\n * Tests conversion to numbers when an invalid binary value is passed in. This should cause an exception.\r\n */\r\n@Test\r\nvoid testToNumberFromInvalidBinaryString() {\r\n    assertThrows(ConversionException.class, () -> PropertyConverter.toNumber(\"0bNotABinValue\", Integer.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNumberFromInvalidHexString",
  "sourceCode" : "/**\r\n * Tests conversion to numbers when an invalid Hex value is passed in. This should cause an exception.\r\n */\r\n@Test\r\nvoid testToNumberFromInvalidHexString() {\r\n    assertThrows(ConversionException.class, () -> PropertyConverter.toNumber(\"0xNotAHexValue\", Integer.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNumberFromInvalidString",
  "sourceCode" : "/**\r\n * Tests conversion to numbers when the passed in objects have no numeric String representation. This should cause an\r\n * exception.\r\n */\r\n@Test\r\nvoid testToNumberFromInvalidString() {\r\n    assertThrows(ConversionException.class, () -> PropertyConverter.toNumber(\"Not a number\", Byte.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNumberFromString",
  "sourceCode" : "/**\r\n * Tests conversion to numbers when the passed in objects have a compatible string representation.\r\n */\r\n@Test\r\nvoid testToNumberFromString() {\r\n    assertEquals(Integer.valueOf(42), PropertyConverter.toNumber(\"42\", Integer.class));\r\n    assertEquals(Short.valueOf((short) 10), PropertyConverter.toNumber(new StringBuffer(\"10\"), Short.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToNumberWithInvalidClass",
  "sourceCode" : "/**\r\n * Tests conversion to numbers when the passed in target class is invalid. This should cause an exception.\r\n */\r\n@Test\r\nvoid testToNumberWithInvalidClass() {\r\n    assertThrows(ConversionException.class, () -> PropertyConverter.toNumber(\"42\", Object.class));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToPathDirect",
  "sourceCode" : "/**\r\n * Tests conversion to paths when the passed in objects are already paths.\r\n */\r\n@Test\r\nvoid testToPathDirect() {\r\n    final Path p = Paths.get(\"dir\", \"file\");\r\n    assertSame(p, PropertyConverter.toPath(p));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToPathFromFile",
  "sourceCode" : "/**\r\n * Tests conversion to path when the passed in objects are files.\r\n */\r\n@Test\r\nvoid testToPathFromFile() {\r\n    final File f = new File(\"dir\", \"file\");\r\n    assertEquals(Paths.get(\"dir\", \"file\"), PropertyConverter.toPath(f));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToPathFromString",
  "sourceCode" : "/**\r\n * Tests conversion to file when the passed in objects have a compatible string representation.\r\n */\r\n@Test\r\nvoid testToPathFromString() {\r\n    assertEquals(Paths.get(\"dir\", \"file\"), PropertyConverter.toPath(\"dir/file\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToPatternDirect",
  "sourceCode" : "/**\r\n * Tests conversion to patterns when the passed in objects are already patterns.\r\n */\r\n@Test\r\nvoid testToPatternDirect() {\r\n    final Pattern p = Pattern.compile(\".+\");\r\n    assertSame(p, PropertyConverter.toPattern(p));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToPatternFromString",
  "sourceCode" : "/**\r\n * Tests conversion to patterns when the passed in objects have a compatible string representation.\r\n */\r\n@Test\r\nvoid testToPatternFromString() {\r\n    final Pattern p = Pattern.compile(\".+\");\r\n    assertEquals(p.pattern(), PropertyConverter.toPattern(\".+\").pattern());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\convert\\TestPropertyConverter.java",
  "methodName" : "testToStringConversion",
  "sourceCode" : "/**\r\n * Tests a conversion to a string.\r\n */\r\n@Test\r\nvoid testToStringConversion() {\r\n    final Integer src = 42;\r\n    final Object result = PropertyConverter.to(String.class, src, new DefaultConversionHandler());\r\n    assertEquals(\"42\", result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\AbstractTestConfigurationEvents.java",
  "methodName" : "testAddPropertyEvent",
  "sourceCode" : "/**\r\n * Tests events generated by addProperty().\r\n */\r\n@Test\r\nvoid testAddPropertyEvent() {\r\n    config.addProperty(TEST_PROPNAME, TEST_PROPVALUE);\r\n    listener.checkEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, true);\r\n    listener.checkEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\AbstractTestConfigurationEvents.java",
  "methodName" : "testAddPropertyEventWithDetails",
  "sourceCode" : "/**\r\n * Tests events generated by addProperty() when detail events are enabled.\r\n */\r\n@Test\r\nvoid testAddPropertyEventWithDetails() {\r\n    config.setDetailEvents(true);\r\n    config.addProperty(TEST_PROPNAME, TEST_PROPVALUE);\r\n    listener.checkEventCount(2);\r\n    listener.checkEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, true);\r\n    listener.skipToLast(ConfigurationEvent.ADD_PROPERTY);\r\n    listener.checkEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\AbstractTestConfigurationEvents.java",
  "methodName" : "testClearEvent",
  "sourceCode" : "/**\r\n * Tests the events generated by the clear() method.\r\n */\r\n@Test\r\nvoid testClearEvent() {\r\n    config.clear();\r\n    listener.checkEvent(ConfigurationEvent.CLEAR, null, null, true);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR, null, null, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\AbstractTestConfigurationEvents.java",
  "methodName" : "testClearEventWithDetails",
  "sourceCode" : "/**\r\n * Tests the events generated by the clear method when detail events are enabled.\r\n */\r\n@Test\r\nvoid testClearEventWithDetails() {\r\n    config.setDetailEvents(true);\r\n    config.clear();\r\n    listener.checkEventCount(2);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR, null, null, true);\r\n    listener.skipToLast(ConfigurationEvent.CLEAR);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR, null, null, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\AbstractTestConfigurationEvents.java",
  "methodName" : "testClearPropertyEvent",
  "sourceCode" : "/**\r\n * Tests events generated by clearProperty().\r\n */\r\n@Test\r\nvoid testClearPropertyEvent() {\r\n    config.clearProperty(EXIST_PROPERTY);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR_PROPERTY, EXIST_PROPERTY, null, true);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR_PROPERTY, EXIST_PROPERTY, null, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\AbstractTestConfigurationEvents.java",
  "methodName" : "testClearPropertyEventWithDetails",
  "sourceCode" : "/**\r\n * Tests events generated by clearProperty() when detail events are enabled.\r\n */\r\n@Test\r\nvoid testClearPropertyEventWithDetails() {\r\n    config.setDetailEvents(true);\r\n    config.clearProperty(EXIST_PROPERTY);\r\n    listener.checkEventCount(2);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR_PROPERTY, EXIST_PROPERTY, null, true);\r\n    listener.skipToLast(ConfigurationEvent.CLEAR_PROPERTY);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR_PROPERTY, EXIST_PROPERTY, null, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\AbstractTestConfigurationEvents.java",
  "methodName" : "testSetPropertyEvent",
  "sourceCode" : "/**\r\n * Tests events generated by setProperty().\r\n */\r\n@Test\r\nvoid testSetPropertyEvent() {\r\n    config.setProperty(EXIST_PROPERTY, TEST_PROPVALUE);\r\n    listener.checkEvent(ConfigurationEvent.SET_PROPERTY, EXIST_PROPERTY, TEST_PROPVALUE, true);\r\n    listener.checkEvent(ConfigurationEvent.SET_PROPERTY, EXIST_PROPERTY, TEST_PROPVALUE, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\AbstractTestConfigurationEvents.java",
  "methodName" : "testSetPropertyEventWithDetails",
  "sourceCode" : "/**\r\n * Tests events generated by setProperty() when detail events are enabled.\r\n */\r\n@Test\r\nvoid testSetPropertyEventWithDetails() {\r\n    config.setDetailEvents(true);\r\n    config.setProperty(EXIST_PROPERTY, TEST_PROPVALUE);\r\n    listener.checkEventCount(2);\r\n    listener.checkEvent(ConfigurationEvent.SET_PROPERTY, EXIST_PROPERTY, TEST_PROPVALUE, true);\r\n    listener.skipToLast(ConfigurationEvent.SET_PROPERTY);\r\n    listener.checkEvent(ConfigurationEvent.SET_PROPERTY, EXIST_PROPERTY, TEST_PROPVALUE, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testAddNodesEventType",
  "sourceCode" : "/**\r\n * Tests the event type for an add nodes operation.\r\n */\r\n@Test\r\nvoid testAddNodesEventType() {\r\n    checkHierarchicalEvent(ConfigurationEvent.ADD_NODES);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testAddPropertyEventType",
  "sourceCode" : "/**\r\n * Tests the event type for adding a property.\r\n */\r\n@Test\r\nvoid testAddPropertyEventType() {\r\n    checkUpdateEvent(ConfigurationEvent.ADD_PROPERTY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testBaseErrorEventType",
  "sourceCode" : "/**\r\n * Tests the common base event type for error events.\r\n */\r\n@Test\r\nvoid testBaseErrorEventType() {\r\n    assertEquals(Event.ANY, ConfigurationErrorEvent.ANY.getSuperType());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testClearEventType",
  "sourceCode" : "/**\r\n * Tests the event type for clearing a whole configuration.\r\n */\r\n@Test\r\nvoid testClearEventType() {\r\n    checkUpdateEvent(ConfigurationEvent.CLEAR);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testClearPropertyEventType",
  "sourceCode" : "/**\r\n * Tests the event type for clearing a property.\r\n */\r\n@Test\r\nvoid testClearPropertyEventType() {\r\n    checkUpdateEvent(ConfigurationEvent.CLEAR_PROPERTY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testClearTreeEventType",
  "sourceCode" : "/**\r\n * Tests the event type for a clear tree operation.\r\n */\r\n@Test\r\nvoid testClearTreeEventType() {\r\n    checkHierarchicalEvent(ConfigurationEvent.CLEAR_TREE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testConfigurationEventType",
  "sourceCode" : "/**\r\n * Tests the base event type for configuration events.\r\n */\r\n@Test\r\nvoid testConfigurationEventType() {\r\n    assertSame(Event.ANY, ConfigurationEvent.ANY.getSuperType());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testFetchSuperEventTypesForBaseType",
  "sourceCode" : "/**\r\n * Tests whether the set of super event types for the base type can be obtained.\r\n */\r\n@Test\r\nvoid testFetchSuperEventTypesForBaseType() {\r\n    final Set<EventType<?>> superTypes = EventType.fetchSuperEventTypes(Event.ANY);\r\n    assertEquals(Collections.singleton(Event.ANY), superTypes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testFetchSuperEventTypesNull",
  "sourceCode" : "/**\r\n * Tests whether the set of super event types for null input can be obtained.\r\n */\r\n@Test\r\nvoid testFetchSuperEventTypesNull() {\r\n    final Set<EventType<?>> superTypes = EventType.fetchSuperEventTypes(null);\r\n    assertTrue(superTypes.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testFetchSuperEventTypesOfType",
  "sourceCode" : "/**\r\n * Tests whether the super event types of a specific type can be retrieved.\r\n */\r\n@Test\r\nvoid testFetchSuperEventTypesOfType() {\r\n    final Set<EventType<?>> superTypes = EventType.fetchSuperEventTypes(ConfigurationEvent.ADD_NODES);\r\n    final Set<EventType<? extends Event>> expected = new HashSet<>();\r\n    expected.add(ConfigurationEvent.ADD_NODES);\r\n    expected.add(ConfigurationEvent.ANY_HIERARCHICAL);\r\n    expected.add(ConfigurationEvent.ANY);\r\n    expected.add(Event.ANY);\r\n    assertEquals(expected, superTypes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testHierarchicalEventType",
  "sourceCode" : "/**\r\n * Tests the common base event type for hierarchical update events.\r\n */\r\n@Test\r\nvoid testHierarchicalEventType() {\r\n    checkUpdateEvent(ConfigurationEvent.ANY_HIERARCHICAL);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testIsInstanceOfBaseNull",
  "sourceCode" : "/**\r\n * Tests isInstanceOf() if the base type is null.\r\n */\r\n@Test\r\nvoid testIsInstanceOfBaseNull() {\r\n    assertFalse(EventType.isInstanceOf(ConfigurationEvent.ANY, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testIsInstanceOfDerivedNull",
  "sourceCode" : "/**\r\n * Tests isInstanceOf() if the derived type is null.\r\n */\r\n@Test\r\nvoid testIsInstanceOfDerivedNull() {\r\n    assertFalse(EventType.isInstanceOf(null, Event.ANY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testIsInstanceOfFalse",
  "sourceCode" : "/**\r\n * Tests isInstanceOf() if there is no instanceof relationship.\r\n */\r\n@Test\r\nvoid testIsInstanceOfFalse() {\r\n    assertFalse(EventType.isInstanceOf(ConfigurationErrorEvent.READ, ConfigurationEvent.ANY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testIsInstanceOfTrue",
  "sourceCode" : "/**\r\n * Tests isInstanceOf() if the expected result is true.\r\n */\r\n@Test\r\nvoid testIsInstanceOfTrue() {\r\n    assertTrue(EventType.isInstanceOf(ConfigurationEvent.ADD_NODES, ConfigurationEvent.ANY_HIERARCHICAL));\r\n    assertTrue(EventType.isInstanceOf(ConfigurationEvent.ADD_NODES, ConfigurationEvent.ANY));\r\n    assertTrue(EventType.isInstanceOf(ConfigurationEvent.ADD_NODES, Event.ANY));\r\n    assertTrue(EventType.isInstanceOf(ConfigurationEvent.ADD_NODES, ConfigurationEvent.ADD_NODES));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testReadErrorEventType",
  "sourceCode" : "/**\r\n * Tests the event type indicating a read error.\r\n */\r\n@Test\r\nvoid testReadErrorEventType() {\r\n    checkErrorEvent(ConfigurationErrorEvent.READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testSetPropertyEventType",
  "sourceCode" : "/**\r\n * Tests the event type for setting a property.\r\n */\r\n@Test\r\nvoid testSetPropertyEventType() {\r\n    checkUpdateEvent(ConfigurationEvent.SET_PROPERTY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testSubnodeChangedEventType",
  "sourceCode" : "/**\r\n * Tests the event type indicating a change on a sub configuration.\r\n */\r\n@Test\r\nvoid testSubnodeChangedEventType() {\r\n    checkHierarchicalEvent(ConfigurationEvent.SUBNODE_CHANGED);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestConfigurationEventTypes.java",
  "methodName" : "testWriteErrorEventType",
  "sourceCode" : "/**\r\n * Tests the event type indicating a write error.\r\n */\r\n@Test\r\nvoid testWriteErrorEventType() {\r\n    checkErrorEvent(ConfigurationErrorEvent.WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEvent.java",
  "methodName" : "testInitNoSource",
  "sourceCode" : "/**\r\n * Tries to create an instance without a source.\r\n */\r\n@Test\r\nvoid testInitNoSource() {\r\n    assertThrows(IllegalArgumentException.class, () -> new Event(null, Event.ANY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEvent.java",
  "methodName" : "testInitNoType",
  "sourceCode" : "/**\r\n * Tries to create an instance without a type.\r\n */\r\n@Test\r\nvoid testInitNoType() {\r\n    assertThrows(IllegalArgumentException.class, () -> new Event(this, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEvent.java",
  "methodName" : "testToString",
  "sourceCode" : "/**\r\n * Tests the string representation.\r\n */\r\n@Test\r\nvoid testToString() {\r\n    final Event event = new Event(this, Event.ANY);\r\n    final String s = event.toString();\r\n    assertEquals(\"Event [ source=\" + this + \" eventType=\" + Event.ANY + \" ]\", s);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testAddAll",
  "sourceCode" : "/**\r\n * Tests whether the content of another list can be added.\r\n */\r\n@Test\r\nvoid testAddAll() {\r\n    final EventListener<EventBase> l1 = new ListenerTestImpl();\r\n    final EventListener<EventBase> l2 = new ListenerTestImpl();\r\n    final EventListener<EventBase> l3 = new ListenerTestImpl();\r\n    list.addEventListener(typeBase, l1);\r\n    final EventListenerList list2 = new EventListenerList();\r\n    list2.addEventListener(typeSub1, l2);\r\n    list2.addEventListener(typeBase, l3);\r\n    list.addAll(list2);\r\n    final Iterator<EventListenerRegistrationData<?>> it = list.getRegistrations().iterator();\r\n    EventListenerRegistrationData<?> reg = it.next();\r\n    assertEquals(typeBase, reg.getEventType());\r\n    assertEquals(l1, reg.getListener());\r\n    reg = it.next();\r\n    assertEquals(typeSub1, reg.getEventType());\r\n    assertEquals(l2, reg.getListener());\r\n    reg = it.next();\r\n    assertEquals(typeBase, reg.getEventType());\r\n    assertEquals(l3, reg.getListener());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testAddAllNull",
  "sourceCode" : "/**\r\n * Tries to add the content of a null list.\r\n */\r\n@Test\r\nvoid testAddAllNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> list.addAll(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testClear",
  "sourceCode" : "/**\r\n * Tests whether the list can be cleared.\r\n */\r\n@Test\r\nvoid testClear() {\r\n    list.addEventListener(typeSub1, new ListenerTestImpl());\r\n    list.addEventListener(typeSub2, new ListenerTestImpl());\r\n    list.clear();\r\n    assertTrue(list.getRegistrations().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testEventListenerIteratorNullEvent",
  "sourceCode" : "/**\r\n * Tests that a null event is handled by the iterator.\r\n */\r\n@Test\r\nvoid testEventListenerIteratorNullEvent() {\r\n    list.addEventListener(typeBase, new ListenerTestImpl());\r\n    final EventListenerList.EventListenerIterator<EventBase> iterator = list.getEventListenerIterator(typeBase);\r\n    assertThrows(IllegalArgumentException.class, () -> iterator.invokeNext(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testEventListenerIteratorWrongEvent",
  "sourceCode" : "/**\r\n * Tests whether the event listener iterator validates the passed in event object.\r\n */\r\n@Test\r\nvoid testEventListenerIteratorWrongEvent() {\r\n    final EventListener<EventSub2> listener = event -> {\r\n    };\r\n    list.addEventListener(typeSub2, listener);\r\n    final EventListenerList.EventListenerIterator<EventSub2> iterator = list.getEventListenerIterator(typeSub2);\r\n    assertTrue(iterator.hasNext());\r\n    final Event event = new EventBase(this, typeBase, \"Test\");\r\n    assertThrows(IllegalArgumentException.class, () -> iterator.invokeNext(event));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testFireNullEvent",
  "sourceCode" : "/**\r\n * Tests that a null event is rejected by fire().\r\n */\r\n@Test\r\nvoid testFireNullEvent() {\r\n    assertThrows(IllegalArgumentException.class, () -> list.fire(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetEventListenerRegistrationsForSuperType",
  "sourceCode" : "/**\r\n * Tests whether event listener registrations derived from a super type can be queried.\r\n */\r\n@Test\r\nvoid testGetEventListenerRegistrationsForSuperType() {\r\n    final ListenerTestImpl l1 = new ListenerTestImpl();\r\n    final ListenerTestImpl l2 = new ListenerTestImpl();\r\n    @SuppressWarnings(\"unchecked\")\r\n    final EventListener<Event> l3 = mock(EventListener.class);\r\n    list.addEventListener(typeSub1, l1);\r\n    list.addEventListener(Event.ANY, l3);\r\n    list.addEventListener(typeBase, l2);\r\n    final List<EventListenerRegistrationData<? extends EventBase>> regs = list.getRegistrationsForSuperType(typeBase);\r\n    final Iterator<EventListenerRegistrationData<? extends EventBase>> iterator = regs.iterator();\r\n    assertEquals(l1, iterator.next().getListener());\r\n    assertEquals(l2, iterator.next().getListener());\r\n    assertFalse(iterator.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetEventListenersBaseType",
  "sourceCode" : "/**\r\n * Tests whether the base type is taken into account when querying for event listeners.\r\n */\r\n@Test\r\nvoid testGetEventListenersBaseType() {\r\n    final ListenerTestImpl listener1 = new ListenerTestImpl();\r\n    final ListenerTestImpl listener2 = new ListenerTestImpl();\r\n    list.addEventListener(typeBase, listener1);\r\n    list.addEventListener(typeBase, listener2);\r\n    checkEventListenersForType(typeSub1, listener1, listener2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetEventListenersIteratorNextNoElement",
  "sourceCode" : "/**\r\n * Tests that the iterator returned by getEventListeners() throws an exception if the iteration goes beyond the last\r\n * element.\r\n */\r\n@Test\r\nvoid testGetEventListenersIteratorNextNoElement() {\r\n    final ListenerTestImpl listener1 = new ListenerTestImpl();\r\n    final ListenerTestImpl listener2 = new ListenerTestImpl();\r\n    list.addEventListener(typeBase, listener1);\r\n    list.addEventListener(typeBase, listener2);\r\n    final Iterator<EventListener<? super EventBase>> iterator = list.getEventListeners(typeBase).iterator();\r\n    for (int i = 0; i < 2; i++) {\r\n        iterator.next();\r\n    }\r\n    assertThrows(NoSuchElementException.class, iterator::next);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetEventListenersIteratorRemove",
  "sourceCode" : "/**\r\n * Tests that the iterator returned by getEventListeners() does not support remove() operations.\r\n */\r\n@Test\r\nvoid testGetEventListenersIteratorRemove() {\r\n    list.addEventListener(typeBase, new ListenerTestImpl());\r\n    final Iterator<EventListener<? super EventBase>> iterator = list.getEventListeners(typeBase).iterator();\r\n    assertTrue(iterator.hasNext());\r\n    assertThrows(UnsupportedOperationException.class, iterator::remove);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetEventListenersMatchingType",
  "sourceCode" : "/**\r\n * Tests whether only matching event listeners are returned by getEventListeners().\r\n */\r\n@Test\r\nvoid testGetEventListenersMatchingType() {\r\n    final ListenerTestImpl listener1 = new ListenerTestImpl();\r\n    final ListenerTestImpl listener2 = new ListenerTestImpl();\r\n    list.addEventListener(typeSub1, listener1);\r\n    list.addEventListener(typeSub2, listener2);\r\n    checkEventListenersForType(typeSub1, listener1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetEventListenersNoMatch",
  "sourceCode" : "/**\r\n * Tests that an empty result is correctly handled by getEventListeners().\r\n */\r\n@Test\r\nvoid testGetEventListenersNoMatch() {\r\n    list.addEventListener(typeSub1, new ListenerTestImpl());\r\n    checkEventListenersForType(typeSub2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetEventListenersNull",
  "sourceCode" : "/**\r\n * Tests whether event listeners for a null type can be queried.\r\n */\r\n@Test\r\nvoid testGetEventListenersNull() {\r\n    assertTrue(fetchElements(list.getEventListeners(null)).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetRegistrations",
  "sourceCode" : "/**\r\n * Tests whether all event listener registrations can be queried.\r\n */\r\n@Test\r\nvoid testGetRegistrations() {\r\n    final EventListenerRegistrationData<EventSub1> reg1 = new EventListenerRegistrationData<>(typeSub1, new ListenerTestImpl());\r\n    final EventListenerRegistrationData<EventSub2> reg2 = new EventListenerRegistrationData<>(typeSub2, new ListenerTestImpl());\r\n    list.addEventListener(reg1);\r\n    list.addEventListener(reg2);\r\n    final List<EventListenerRegistrationData<?>> registrations = list.getRegistrations();\r\n    assertEquals(Arrays.asList(reg1, reg2), registrations);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testGetRegistrationsModify",
  "sourceCode" : "/**\r\n * Tests that the list with registration information cannot be modified.\r\n */\r\n@Test\r\nvoid testGetRegistrationsModify() {\r\n    final EventListenerRegistrationData<EventBase> registrationData = new EventListenerRegistrationData<>(typeBase, new ListenerTestImpl());\r\n    final List<EventListenerRegistrationData<?>> registrations = list.getRegistrations();\r\n    assertThrows(UnsupportedOperationException.class, () -> registrations.add(registrationData));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testListenerRegistrationWithListenerData",
  "sourceCode" : "/**\r\n * Tests whether an event listener can be registered via a registration data object.\r\n */\r\n@Test\r\nvoid testListenerRegistrationWithListenerData() {\r\n    final ListenerTestImpl listener = new ListenerTestImpl();\r\n    final EventListenerRegistrationData<EventSub1> regData = new EventListenerRegistrationData<>(typeSub1, listener);\r\n    list.addEventListener(regData);\r\n    list.fire(new EventSub1(this, typeSub1, MESSAGE));\r\n    listener.assertEvent(this, typeSub1, MESSAGE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testListenerRegistrationWithNullListenerData",
  "sourceCode" : "/**\r\n * Tries to register a listener with a null registration data object.\r\n */\r\n@Test\r\nvoid testListenerRegistrationWithNullListenerData() {\r\n    assertThrows(IllegalArgumentException.class, () -> list.addEventListener(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testMultipleListenerRegistration",
  "sourceCode" : "/**\r\n * Tests that a listener can be registered multiple times for different event types.\r\n */\r\n@Test\r\nvoid testMultipleListenerRegistration() {\r\n    final ListenerTestImpl listener = new ListenerTestImpl();\r\n    list.addEventListener(typeSub1, listener);\r\n    list.addEventListener(typeSub2, listener);\r\n    list.fire(new EventSub2(this, typeSub2, MESSAGE));\r\n    list.removeEventListener(typeSub1, listener);\r\n    list.fire(new EventSub1(this, typeSub1, MESSAGE));\r\n    listener.assertEvent(this, typeSub2, MESSAGE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testReceiveEventDifferentType",
  "sourceCode" : "/**\r\n * Tests whether the event type is taken into account when calling listeners.\r\n */\r\n@Test\r\nvoid testReceiveEventDifferentType() {\r\n    final ListenerTestImpl listener1 = new ListenerTestImpl();\r\n    final ListenerTestImpl listener2 = new ListenerTestImpl();\r\n    list.addEventListener(typeSub1, listener1);\r\n    list.addEventListener(typeSub2, listener2);\r\n    list.fire(new EventSub1(this, typeSub1, MESSAGE));\r\n    listener1.assertEvent(this, typeSub1, MESSAGE);\r\n    listener2.assertNoEvent();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testReceiveEventMultipleListeners",
  "sourceCode" : "/**\r\n * Tests whether multiple event listeners can be registered.\r\n */\r\n@Test\r\nvoid testReceiveEventMultipleListeners() {\r\n    final ListenerTestImpl listener1 = new ListenerTestImpl();\r\n    final ListenerTestImpl listener2 = new ListenerTestImpl();\r\n    list.addEventListener(typeSub1, listener1);\r\n    list.addEventListener(typeSub1, listener2);\r\n    list.fire(new EventSub1(this, typeSub1, MESSAGE));\r\n    listener1.assertEvent(this, typeSub1, MESSAGE);\r\n    listener2.assertEvent(this, typeSub1, MESSAGE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testReceiveEventOfExactType",
  "sourceCode" : "/**\r\n * Tests whether events matching the registration type are delivered.\r\n */\r\n@Test\r\nvoid testReceiveEventOfExactType() {\r\n    final ListenerTestImpl listener = new ListenerTestImpl();\r\n    list.addEventListener(typeSub1, listener);\r\n    list.fire(new EventSub1(this, typeSub1, MESSAGE));\r\n    listener.assertEvent(this, typeSub1, MESSAGE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testReceiveEventSubType",
  "sourceCode" : "/**\r\n * Tests that events of a derived type are delivered to listeners registered for a base type.\r\n */\r\n@Test\r\nvoid testReceiveEventSubType() {\r\n    final ListenerTestImpl listener = new ListenerTestImpl();\r\n    list.addEventListener(typeBase, listener);\r\n    list.fire(new EventSub1(this, typeSub1, MESSAGE));\r\n    listener.assertEvent(this, typeSub1, MESSAGE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testRegisterEventTypeNull",
  "sourceCode" : "/**\r\n * Tries to register a listener for a null event type.\r\n */\r\n@Test\r\nvoid testRegisterEventTypeNull() {\r\n    final ListenerTestImpl listener = new ListenerTestImpl();\r\n    assertThrows(IllegalArgumentException.class, () -> list.addEventListener(null, listener));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testRegisterListenerNull",
  "sourceCode" : "/**\r\n * Tests that null event listeners cannot be registered.\r\n */\r\n@Test\r\nvoid testRegisterListenerNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> list.addEventListener(typeBase, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testRemoveEventListenerExisting",
  "sourceCode" : "/**\r\n * Tests whether an event listener can be removed.\r\n */\r\n@Test\r\nvoid testRemoveEventListenerExisting() {\r\n    final ListenerTestImpl listener = new ListenerTestImpl();\r\n    list.addEventListener(typeSub1, listener);\r\n    assertTrue(list.removeEventListener(typeSub1, listener));\r\n    list.fire(new EventSub1(this, typeSub1, MESSAGE));\r\n    listener.assertNoEvent();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testRemoveEventListenerNonExistingEventType",
  "sourceCode" : "/**\r\n * Tests removeEventListener() if another event type is specified for an existing listener.\r\n */\r\n@Test\r\nvoid testRemoveEventListenerNonExistingEventType() {\r\n    final ListenerTestImpl listener = new ListenerTestImpl();\r\n    list.addEventListener(typeSub1, listener);\r\n    assertFalse(list.removeEventListener(typeBase, listener));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testRemoveEventListenerNonExistingListener",
  "sourceCode" : "/**\r\n * Tests removeEventListener() for a non-existing event listener.\r\n */\r\n@Test\r\nvoid testRemoveEventListenerNonExistingListener() {\r\n    list.addEventListener(typeBase, new ListenerTestImpl());\r\n    assertFalse(list.removeEventListener(typeBase, new ListenerTestImpl()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testRemoveEventListenerNullListener",
  "sourceCode" : "/**\r\n * Tests that removeEventListener() can handle a null listener.\r\n */\r\n@Test\r\nvoid testRemoveEventListenerNullListener() {\r\n    assertFalse(list.removeEventListener(typeBase, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testRemoveEventListenerNullRegistration",
  "sourceCode" : "/**\r\n * Tests that removeEventListener() can handle a null registration object.\r\n */\r\n@Test\r\nvoid testRemoveEventListenerNullRegistration() {\r\n    assertFalse(list.removeEventListener(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testRemoveEventListenerNullType",
  "sourceCode" : "/**\r\n * Tests that removeEventListener() can handle a null event type.\r\n */\r\n@Test\r\nvoid testRemoveEventListenerNullType() {\r\n    assertFalse(list.removeEventListener(null, new ListenerTestImpl()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventListenerList.java",
  "methodName" : "testSuppressEventOfSuperType",
  "sourceCode" : "/**\r\n * Tests that events of a base type do not cause a listener to be invoked.\r\n */\r\n@Test\r\nvoid testSuppressEventOfSuperType() {\r\n    final ListenerTestImpl listener = new ListenerTestImpl();\r\n    list.addEventListener(typeSub1, listener);\r\n    list.fire(new EventBase(this, typeBase, MESSAGE));\r\n    listener.assertNoEvent();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testAddEventListener",
  "sourceCode" : "/**\r\n * Tests registering a new listener.\r\n */\r\n@Test\r\nvoid testAddEventListener() {\r\n    final EventListenerTestImpl l = new EventListenerTestImpl(this);\r\n    source.addEventListener(ConfigurationEvent.ANY, l);\r\n    final Collection<EventListener<? super ConfigurationEvent>> listeners = source.getEventListeners(ConfigurationEvent.ANY);\r\n    assertEquals(1, listeners.size());\r\n    assertTrue(listeners.contains(l));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testAddNullEventListener",
  "sourceCode" : "/**\r\n * Tests adding an undefined configuration listener. This should cause an exception.\r\n */\r\n@Test\r\nvoid testAddNullEventListener() {\r\n    assertThrows(IllegalArgumentException.class, () -> source.addEventListener(ConfigurationEvent.ANY, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testClearErrorListeners",
  "sourceCode" : "/**\r\n * Tests whether all error listeners can be cleared.\r\n */\r\n@Test\r\nvoid testClearErrorListeners() {\r\n    final EventListener<ConfigurationEvent> cl = new EventListenerTestImpl(null);\r\n    final ErrorListenerTestImpl el1 = new ErrorListenerTestImpl(null);\r\n    final ErrorListenerTestImpl el2 = new ErrorListenerTestImpl(null);\r\n    final ErrorListenerTestImpl el3 = new ErrorListenerTestImpl(null);\r\n    source.addEventListener(ConfigurationErrorEvent.READ, el1);\r\n    source.addEventListener(ConfigurationErrorEvent.ANY, el2);\r\n    source.addEventListener(ConfigurationEvent.ANY, cl);\r\n    source.addEventListener(ConfigurationErrorEvent.WRITE, el3);\r\n    source.clearErrorListeners();\r\n    final List<EventListenerRegistrationData<?>> regs = source.getEventListenerRegistrations();\r\n    assertEquals(1, regs.size());\r\n    assertSame(cl, regs.get(0).getListener());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testClearEventListeners",
  "sourceCode" : "/**\r\n * Tests whether all event listeners can be removed.\r\n */\r\n@Test\r\nvoid testClearEventListeners() {\r\n    source.addEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(source));\r\n    source.addEventListener(ConfigurationEvent.ANY_HIERARCHICAL, new EventListenerTestImpl(source));\r\n    source.clearEventListeners();\r\n    assertTrue(source.getEventListeners(ConfigurationEvent.ANY).isEmpty());\r\n    assertTrue(source.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests cloning an event source object. The registered listeners should not be registered at the clone.\r\n */\r\n@Test\r\nvoid testClone() throws CloneNotSupportedException {\r\n    source.addEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(source));\r\n    final BaseEventSource copy = (BaseEventSource) source.clone();\r\n    assertTrue(copy.getEventListenerRegistrations().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testCopyEventListeners",
  "sourceCode" : "/**\r\n * Tests whether event listeners can be copied to another source.\r\n */\r\n@Test\r\nvoid testCopyEventListeners() {\r\n    final EventListenerTestImpl l1 = new EventListenerTestImpl(source);\r\n    final EventListenerTestImpl l2 = new EventListenerTestImpl(source);\r\n    source.addEventListener(ConfigurationEvent.ANY, l1);\r\n    source.addEventListener(ConfigurationEvent.ANY_HIERARCHICAL, l2);\r\n    final BaseEventSource source2 = new BaseEventSource();\r\n    source.copyEventListeners(source2);\r\n    Collection<EventListener<? super ConfigurationEvent>> listeners = source2.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL);\r\n    assertEquals(2, listeners.size());\r\n    assertTrue(listeners.contains(l1));\r\n    assertTrue(listeners.contains(l2));\r\n    listeners = source2.getEventListeners(ConfigurationEvent.ANY);\r\n    assertEquals(1, listeners.size());\r\n    assertTrue(listeners.contains(l1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testCopyEventListenersNullSource",
  "sourceCode" : "/**\r\n * Tries to copy event listeners to a null source.\r\n */\r\n@Test\r\nvoid testCopyEventListenersNullSource() {\r\n    assertThrows(IllegalArgumentException.class, () -> source.copyEventListeners(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testFireError",
  "sourceCode" : "/**\r\n * Tests delivering an error event to a listener.\r\n */\r\n@Test\r\nvoid testFireError() {\r\n    final ErrorListenerTestImpl lstRead = new ErrorListenerTestImpl(source);\r\n    final ErrorListenerTestImpl lstWrite = new ErrorListenerTestImpl(source);\r\n    final ErrorListenerTestImpl lstAll = new ErrorListenerTestImpl(source);\r\n    source.addEventListener(ConfigurationErrorEvent.READ, lstRead);\r\n    source.addEventListener(ConfigurationErrorEvent.WRITE, lstWrite);\r\n    source.addEventListener(ConfigurationErrorEvent.ANY, lstAll);\r\n    final Exception testException = new Exception(\"A test\");\r\n    source.fireError(ConfigurationErrorEvent.WRITE, ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, testException);\r\n    lstRead.done();\r\n    assertEquals(testException, lstWrite.checkEvent(ConfigurationErrorEvent.WRITE, ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE));\r\n    lstWrite.done();\r\n    assertEquals(testException, lstAll.checkEvent(ConfigurationErrorEvent.WRITE, ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE));\r\n    lstAll.done();\r\n    assertEquals(1, source.errorCount);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testFireErrorNoListeners",
  "sourceCode" : "/**\r\n * Tests firing an error event if there are no error listeners.\r\n */\r\n@Test\r\nvoid testFireErrorNoListeners() {\r\n    source.fireError(ConfigurationErrorEvent.ANY, ConfigurationEvent.ANY, TEST_PROPNAME, TEST_PROPVALUE, new Exception());\r\n    assertEquals(0, source.errorCount);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testFireEvent",
  "sourceCode" : "/**\r\n * Tests delivering an event to a listener.\r\n */\r\n@Test\r\nvoid testFireEvent() {\r\n    final EventListenerTestImpl l = new EventListenerTestImpl(source);\r\n    source.addEventListener(ConfigurationEvent.ANY, l);\r\n    source.fireEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, true);\r\n    l.checkEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, true);\r\n    l.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testFireEventNoDetails",
  "sourceCode" : "/**\r\n * Tests generating a detail event if detail events are not allowed.\r\n */\r\n@Test\r\nvoid testFireEventNoDetails() {\r\n    final EventListenerTestImpl l = new EventListenerTestImpl(source);\r\n    source.addEventListener(ConfigurationEvent.ANY, l);\r\n    source.setDetailEvents(false);\r\n    source.fireEvent(ConfigurationEvent.SET_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, false);\r\n    assertEquals(0, source.eventCount);\r\n    l.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testFireEventNoListeners",
  "sourceCode" : "/**\r\n * Tests firing an event if there are no listeners.\r\n */\r\n@Test\r\nvoid testFireEventNoListeners() {\r\n    source.fireEvent(ConfigurationEvent.ADD_NODES, TEST_PROPNAME, TEST_PROPVALUE, false);\r\n    assertEquals(0, source.eventCount);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testGetEventListenersAddNew",
  "sourceCode" : "/**\r\n * Tests that the collection returned by getEventListeners() is really a snapshot. A later added listener must not be\r\n * visible.\r\n */\r\n@Test\r\nvoid testGetEventListenersAddNew() {\r\n    final Collection<EventListener<? super ConfigurationEvent>> list = source.getEventListeners(ConfigurationEvent.ANY);\r\n    source.addEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(null));\r\n    assertTrue(list.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testGetEventListenersUpdate",
  "sourceCode" : "/**\r\n * Tests whether the listeners list is read only.\r\n */\r\n@Test\r\nvoid testGetEventListenersUpdate() {\r\n    source.addEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(null));\r\n    final Collection<EventListener<? super ConfigurationEvent>> list = source.getEventListeners(ConfigurationEvent.ANY);\r\n    assertThrows(UnsupportedOperationException.class, list::clear);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testInit",
  "sourceCode" : "/**\r\n * Tests a newly created source object.\r\n */\r\n@Test\r\nvoid testInit() {\r\n    assertTrue(source.getEventListenerRegistrations().isEmpty());\r\n    assertFalse(source.removeEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(null)));\r\n    assertFalse(source.isDetailEvents());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testRemoveEventListener",
  "sourceCode" : "/**\r\n * Tests removing a listener.\r\n */\r\n@Test\r\nvoid testRemoveEventListener() {\r\n    final EventListenerTestImpl l = new EventListenerTestImpl(this);\r\n    assertFalse(source.removeEventListener(ConfigurationEvent.ANY, l));\r\n    source.addEventListener(ConfigurationEvent.ADD_NODES, new EventListenerTestImpl(this));\r\n    source.addEventListener(ConfigurationEvent.ANY, l);\r\n    assertFalse(source.removeEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(null)));\r\n    assertTrue(source.removeEventListener(ConfigurationEvent.ANY, l));\r\n    assertFalse(source.getEventListeners(ConfigurationEvent.ANY).contains(l));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testRemoveListenerInFireEvent",
  "sourceCode" : "/**\r\n * Tests whether an event listener can deregister itself in reaction of a delivered event.\r\n */\r\n@Test\r\nvoid testRemoveListenerInFireEvent() {\r\n    final EventListener<ConfigurationEvent> lstRemove = new EventListener<ConfigurationEvent>() {\r\n\r\n        @Override\r\n        public void onEvent(final ConfigurationEvent event) {\r\n            source.removeEventListener(ConfigurationEvent.ANY, this);\r\n        }\r\n    };\r\n    source.addEventListener(ConfigurationEvent.ANY, lstRemove);\r\n    final EventListenerTestImpl l = new EventListenerTestImpl(source);\r\n    source.addEventListener(ConfigurationEvent.ANY, l);\r\n    source.fireEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, false);\r\n    l.checkEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPNAME, TEST_PROPVALUE, false);\r\n    assertEquals(1, source.getEventListeners(ConfigurationEvent.ANY).size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testRemoveNullEventListener",
  "sourceCode" : "/**\r\n * Tests if a null listener can be removed. This should be a no-op.\r\n */\r\n@Test\r\nvoid testRemoveNullEventListener() {\r\n    source.addEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(null));\r\n    assertFalse(source.removeEventListener(ConfigurationEvent.ANY, null));\r\n    assertEquals(1, source.getEventListeners(ConfigurationEvent.ANY).size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventSource.java",
  "methodName" : "testSetDetailEvents",
  "sourceCode" : "/**\r\n * Tests enabling and disabling the detail events flag.\r\n */\r\n@Test\r\nvoid testSetDetailEvents() {\r\n    source.setDetailEvents(true);\r\n    assertTrue(source.isDetailEvents());\r\n    source.setDetailEvents(true);\r\n    source.setDetailEvents(false);\r\n    assertTrue(source.isDetailEvents());\r\n    source.setDetailEvents(false);\r\n    assertFalse(source.isDetailEvents());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestEventType.java",
  "methodName" : "testToString",
  "sourceCode" : "/**\r\n * Tests the string representation.\r\n */\r\n@Test\r\nvoid testToString() {\r\n    final String s = eventType.toString();\r\n    assertEquals(\"EventType [ TEST ]\", s);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestHierarchicalConfigurationEvents.java",
  "methodName" : "testAddNodesEmptyEvent",
  "sourceCode" : "/**\r\n * Tests events generated by addNodes() when the list of nodes is empty. In this case no events should be generated.\r\n */\r\n@Test\r\nvoid testAddNodesEmptyEvent() {\r\n    ((BaseHierarchicalConfiguration) config).addNodes(TEST_PROPNAME, new ArrayList<>());\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestHierarchicalConfigurationEvents.java",
  "methodName" : "testAddNodesEvent",
  "sourceCode" : "/**\r\n * Tests events generated by the addNodes() method.\r\n */\r\n@Test\r\nvoid testAddNodesEvent() {\r\n    final BaseHierarchicalConfiguration hc = (BaseHierarchicalConfiguration) config;\r\n    final Collection<ImmutableNode> nodes = new ArrayList<>(1);\r\n    nodes.add(NodeStructureHelper.createNode(\"a_key\", TEST_PROPVALUE));\r\n    hc.addNodes(TEST_PROPNAME, nodes);\r\n    listener.checkEvent(ConfigurationEvent.ADD_NODES, TEST_PROPNAME, nodes, true);\r\n    listener.checkEvent(ConfigurationEvent.ADD_NODES, TEST_PROPNAME, nodes, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestHierarchicalConfigurationEvents.java",
  "methodName" : "testClearTreeEvent",
  "sourceCode" : "/**\r\n * Tests events generated by the clearTree() method.\r\n */\r\n@Test\r\nvoid testClearTreeEvent() {\r\n    final BaseHierarchicalConfiguration hc = (BaseHierarchicalConfiguration) config;\r\n    final String key = EXIST_PROPERTY.substring(0, EXIST_PROPERTY.indexOf('.'));\r\n    final NodeHandler<ImmutableNode> nodeHandler = hc.getNodeModel().getNodeHandler();\r\n    final Collection<QueryResult<ImmutableNode>> nodes = hc.getExpressionEngine().query(nodeHandler.getRootNode(), key, nodeHandler);\r\n    hc.clearTree(key);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR_TREE, key, null, true);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR_TREE, key, nodes, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestHierarchicalConfigurationEvents.java",
  "methodName" : "testSubConfigurationChangedEventConnected",
  "sourceCode" : "/**\r\n * Tests whether manipulations of a connected sub configuration trigger correct events.\r\n */\r\n@Test\r\nvoid testSubConfigurationChangedEventConnected() {\r\n    final HierarchicalConfiguration<ImmutableNode> sub = ((BaseHierarchicalConfiguration) config).configurationAt(EXIST_PROPERTY, true);\r\n    sub.addProperty(\"newProp\", \"newValue\");\r\n    checkSubnodeEvent(listener.nextEvent(ConfigurationEvent.SUBNODE_CHANGED), true);\r\n    checkSubnodeEvent(listener.nextEvent(ConfigurationEvent.SUBNODE_CHANGED), false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\event\\TestHierarchicalConfigurationEvents.java",
  "methodName" : "testSubConfigurationChangedEventNotConnected",
  "sourceCode" : "/**\r\n * Tests that no events are generated for a disconnected sub configuration.\r\n */\r\n@Test\r\nvoid testSubConfigurationChangedEventNotConnected() {\r\n    final HierarchicalConfiguration<ImmutableNode> sub = ((BaseHierarchicalConfiguration) config).configurationAt(EXIST_PROPERTY);\r\n    sub.addProperty(\"newProp\", \"newValue\");\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testAddDefaultLookups",
  "sourceCode" : "/**\r\n * Tests whether multiple default lookups can be added.\r\n */\r\n@Test\r\nvoid testAddDefaultLookups() {\r\n    final List<Lookup> lookups = new ArrayList<>();\r\n    lookups.add(setUpTestLookup());\r\n    lookups.add(setUpTestLookup(\"test\", \"value\"));\r\n    interpolator.addDefaultLookups(lookups);\r\n    final List<Lookup> lookups2 = interpolator.getDefaultLookups();\r\n    assertEquals(lookups, lookups2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testAddDefaultLookupsNull",
  "sourceCode" : "/**\r\n * Tests whether a null collection of default lookups is handled correctly.\r\n */\r\n@Test\r\nvoid testAddDefaultLookupsNull() {\r\n    interpolator.addDefaultLookups(null);\r\n    assertTrue(interpolator.getDefaultLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDefaultStringLookupsHolderAllLookups",
  "sourceCode" : "@Test\r\nvoid testDefaultStringLookupsHolderAllLookups() {\r\n    final Properties props = new Properties();\r\n    props.setProperty(ConfigurationInterpolator.DEFAULT_PREFIX_LOOKUPS_PROPERTY, \"BASE64_DECODER BASE64_ENCODER const, date, dns, environment \" + \"file ,java, local_host properties, resource_bundle,script,system_properties \" + \"url url_decoder  , url_encoder, xml\");\r\n    checkDefaultPrefixLookupsHolder(props, \"base64\", StringLookupFactory.KEY_BASE64_DECODER, StringLookupFactory.KEY_BASE64_ENCODER, StringLookupFactory.KEY_CONST, StringLookupFactory.KEY_DATE, StringLookupFactory.KEY_ENV, StringLookupFactory.KEY_FILE, StringLookupFactory.KEY_JAVA, StringLookupFactory.KEY_LOCALHOST, StringLookupFactory.KEY_PROPERTIES, StringLookupFactory.KEY_RESOURCE_BUNDLE, StringLookupFactory.KEY_SYS, StringLookupFactory.KEY_URL_DECODER, StringLookupFactory.KEY_URL_ENCODER, StringLookupFactory.KEY_XML, StringLookupFactory.KEY_DNS, StringLookupFactory.KEY_URL, StringLookupFactory.KEY_SCRIPT);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDefaultStringLookupsHolderGivenSingleLookup",
  "sourceCode" : "@Test\r\nvoid testDefaultStringLookupsHolderGivenSingleLookup() {\r\n    final Properties props = new Properties();\r\n    props.setProperty(ConfigurationInterpolator.DEFAULT_PREFIX_LOOKUPS_PROPERTY, \"base64_encoder\");\r\n    checkDefaultPrefixLookupsHolder(props, \"base64\", StringLookupFactory.KEY_BASE64_ENCODER);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDefaultStringLookupsHolderGivenSingleLookupWeirdString",
  "sourceCode" : "@Test\r\nvoid testDefaultStringLookupsHolderGivenSingleLookupWeirdString() {\r\n    final Properties props = new Properties();\r\n    props.setProperty(ConfigurationInterpolator.DEFAULT_PREFIX_LOOKUPS_PROPERTY, \" \\n \\t  ,, DnS , , \");\r\n    checkDefaultPrefixLookupsHolder(props, StringLookupFactory.KEY_DNS);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDefaultStringLookupsHolderInvalidLookupsDefinition",
  "sourceCode" : "@Test\r\nvoid testDefaultStringLookupsHolderInvalidLookupsDefinition() {\r\n    final Properties props = new Properties();\r\n    props.setProperty(ConfigurationInterpolator.DEFAULT_PREFIX_LOOKUPS_PROPERTY, \"base64_encoder nope\");\r\n    final Exception exc = assertThrows(Exception.class, () -> new ConfigurationInterpolator.DefaultPrefixLookupsHolder(props));\r\n    assertEquals(\"Invalid default lookups definition: base64_encoder nope\", exc.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDefaultStringLookupsHolderLookupsPropertyEmptyAndBlank",
  "sourceCode" : "@Test\r\nvoid testDefaultStringLookupsHolderLookupsPropertyEmptyAndBlank() {\r\n    final Properties propsWithNull = new Properties();\r\n    propsWithNull.setProperty(ConfigurationInterpolator.DEFAULT_PREFIX_LOOKUPS_PROPERTY, \"\");\r\n    checkDefaultPrefixLookupsHolder(propsWithNull);\r\n    final Properties propsWithBlank = new Properties();\r\n    propsWithBlank.setProperty(ConfigurationInterpolator.DEFAULT_PREFIX_LOOKUPS_PROPERTY, \" \");\r\n    checkDefaultPrefixLookupsHolder(propsWithBlank);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDefaultStringLookupsHolderLookupsPropertyNotPresent",
  "sourceCode" : "@Test\r\nvoid testDefaultStringLookupsHolderLookupsPropertyNotPresent() {\r\n    checkDefaultPrefixLookupsHolder(new Properties(), \"base64\", StringLookupFactory.KEY_BASE64_DECODER, StringLookupFactory.KEY_BASE64_ENCODER, StringLookupFactory.KEY_CONST, StringLookupFactory.KEY_DATE, StringLookupFactory.KEY_ENV, StringLookupFactory.KEY_FILE, StringLookupFactory.KEY_JAVA, StringLookupFactory.KEY_LOCALHOST, StringLookupFactory.KEY_PROPERTIES, StringLookupFactory.KEY_RESOURCE_BUNDLE, StringLookupFactory.KEY_SYS, StringLookupFactory.KEY_URL_DECODER, StringLookupFactory.KEY_URL_ENCODER, StringLookupFactory.KEY_XML);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDefaultStringLookupsHolderMultipleLookups",
  "sourceCode" : "@Test\r\nvoid testDefaultStringLookupsHolderMultipleLookups() {\r\n    final Properties props = new Properties();\r\n    props.setProperty(ConfigurationInterpolator.DEFAULT_PREFIX_LOOKUPS_PROPERTY, \"dns, url script \");\r\n    checkDefaultPrefixLookupsHolder(props, StringLookupFactory.KEY_DNS, StringLookupFactory.KEY_URL, StringLookupFactory.KEY_SCRIPT);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDeregisterLookup",
  "sourceCode" : "/**\r\n * Tests deregistering a lookup object.\r\n */\r\n@Test\r\nvoid testDeregisterLookup() {\r\n    final Lookup lookup = mock(Lookup.class);\r\n    interpolator.registerLookup(TEST_PREFIX, lookup);\r\n    assertTrue(interpolator.deregisterLookup(TEST_PREFIX));\r\n    assertFalse(interpolator.prefixSet().contains(TEST_PREFIX));\r\n    assertTrue(interpolator.getLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testDeregisterLookupNonExisting",
  "sourceCode" : "/**\r\n * Tests deregistering an unknown lookup object.\r\n */\r\n@Test\r\nvoid testDeregisterLookupNonExisting() {\r\n    assertFalse(interpolator.deregisterLookup(TEST_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testEnableSubstitutionInVariables",
  "sourceCode" : "/**\r\n * Tests whether the flag for substitution in variable names can be modified.\r\n */\r\n@Test\r\nvoid testEnableSubstitutionInVariables() {\r\n    assertFalse(interpolator.isEnableSubstitutionInVariables());\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"java.version\", \"1.4\"));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"jre-1.4\", \"C:\\\\java\\\\1.4\"));\r\n    final String var = \"${jre-${java.version}}\";\r\n    assertEquals(var, interpolator.interpolate(var));\r\n    interpolator.setEnableSubstitutionInVariables(true);\r\n    assertTrue(interpolator.isEnableSubstitutionInVariables());\r\n    assertEquals(\"C:\\\\java\\\\1.4\", interpolator.interpolate(var));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testFromSpecificationInterpolator",
  "sourceCode" : "/**\r\n * Tests fromSpecification() if the specification contains an instance.\r\n */\r\n@Test\r\nvoid testFromSpecificationInterpolator() {\r\n    final ConfigurationInterpolator ci = mock(ConfigurationInterpolator.class);\r\n    final InterpolatorSpecification spec = new InterpolatorSpecification.Builder().withDefaultLookup(mock(Lookup.class)).withParentInterpolator(interpolator).withInterpolator(ci).create();\r\n    assertSame(ci, ConfigurationInterpolator.fromSpecification(spec));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testFromSpecificationNewInstance",
  "sourceCode" : "/**\r\n * Tests fromSpecification() if a new instance has to be created.\r\n */\r\n@Test\r\nvoid testFromSpecificationNewInstance() {\r\n    final Lookup defLookup = mock(Lookup.class);\r\n    final Lookup preLookup = mock(Lookup.class);\r\n    final Function<Object, String> stringConverter = obj -> Objects.toString(obj, null);\r\n    final InterpolatorSpecification spec = new InterpolatorSpecification.Builder().withDefaultLookup(defLookup).withPrefixLookup(\"p\", preLookup).withParentInterpolator(interpolator).withStringConverter(stringConverter).create();\r\n    final ConfigurationInterpolator ci = ConfigurationInterpolator.fromSpecification(spec);\r\n    assertEquals(Arrays.asList(defLookup), ci.getDefaultLookups());\r\n    assertEquals(1, ci.getLookups().size());\r\n    assertSame(preLookup, ci.getLookups().get(\"p\"));\r\n    assertSame(interpolator, ci.getParentInterpolator());\r\n    assertSame(stringConverter, ci.getStringConverter());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testFromSpecificationNull",
  "sourceCode" : "/**\r\n * Tries to obtain an instance from a null specification.\r\n */\r\n@Test\r\nvoid testFromSpecificationNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> ConfigurationInterpolator.fromSpecification(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testGetDefaultLookupsModify",
  "sourceCode" : "/**\r\n * Tests whether modification of the list of default lookups does not affect the object.\r\n */\r\n@Test\r\nvoid testGetDefaultLookupsModify() {\r\n    final List<Lookup> lookups = interpolator.getDefaultLookups();\r\n    lookups.add(setUpTestLookup());\r\n    assertTrue(interpolator.getDefaultLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testGetDefaultPrefixLookups",
  "sourceCode" : "/**\r\n * Tests whether default prefix lookups can be queried as a map.\r\n */\r\n@Test\r\nvoid testGetDefaultPrefixLookups() {\r\n    final EnumSet<DefaultLookups> excluded = EnumSet.of(DefaultLookups.DNS, DefaultLookups.URL, DefaultLookups.SCRIPT);\r\n    final EnumSet<DefaultLookups> included = EnumSet.complementOf(excluded);\r\n    final Map<String, Lookup> lookups = ConfigurationInterpolator.getDefaultPrefixLookups();\r\n    assertEquals(included.size(), lookups.size());\r\n    for (final DefaultLookups l : included) {\r\n        assertSame(l.getLookup(), lookups.get(l.getPrefix()), \"Wrong entry for \" + l);\r\n    }\r\n    for (final DefaultLookups l : excluded) {\r\n        assertNull(lookups.get(l.getPrefix()), \"Unexpected entry for \" + l);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testGetDefaultPrefixLookupsModify",
  "sourceCode" : "/**\r\n * Tests that the map with default lookups cannot be modified.\r\n */\r\n@Test\r\nvoid testGetDefaultPrefixLookupsModify() {\r\n    final Map<String, Lookup> lookups = ConfigurationInterpolator.getDefaultPrefixLookups();\r\n    final Lookup lookup = mock(Lookup.class);\r\n    assertThrows(UnsupportedOperationException.class, () -> lookups.put(\"test\", lookup));\r\n    verifyNoInteractions(lookup);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testGetLookupsModify",
  "sourceCode" : "/**\r\n * Tests that modification of the map with lookups does not affect the object.\r\n */\r\n@Test\r\nvoid testGetLookupsModify() {\r\n    final Map<String, Lookup> lookups = interpolator.getLookups();\r\n    lookups.put(TEST_PREFIX, setUpTestLookup());\r\n    assertTrue(interpolator.getLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInit",
  "sourceCode" : "/**\r\n * Tests creating an instance. Does it contain some predefined lookups and a default string converter?\r\n */\r\n@Test\r\nvoid testInit() {\r\n    assertTrue(interpolator.getDefaultLookups().isEmpty());\r\n    assertTrue(interpolator.getLookups().isEmpty());\r\n    assertNull(interpolator.getParentInterpolator());\r\n    assertNotNull(interpolator.getStringConverter());\r\n    assertEquals(\"1\", interpolator.getStringConverter().apply(Arrays.asList(1, 2)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolateArray",
  "sourceCode" : "/**\r\n * Tests interpolation of an array argument.\r\n */\r\n@Test\r\nvoid testInterpolateArray() {\r\n    final int[] value = { 1, 2 };\r\n    assertSame(value, interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolateBlankVariable",
  "sourceCode" : "/**\r\n * Tests that a blank variable definition does not cause problems.\r\n */\r\n@Test\r\nvoid testInterpolateBlankVariable() {\r\n    final String value = \"${ }\";\r\n    assertEquals(value, interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolateCollection",
  "sourceCode" : "/**\r\n * Tests interpolation of a collection argument.\r\n */\r\n@Test\r\nvoid testInterpolateCollection() {\r\n    final List<Integer> value = Arrays.asList(1, 2);\r\n    assertSame(value, interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolateEmptyVariable",
  "sourceCode" : "/**\r\n * Tests that an empty variable definition does not cause problems.\r\n */\r\n@Test\r\nvoid testInterpolateEmptyVariable() {\r\n    final String value = \"${}\";\r\n    assertEquals(value, interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolateObject",
  "sourceCode" : "/**\r\n * Tests interpolation of a non string argument.\r\n */\r\n@Test\r\nvoid testInterpolateObject() {\r\n    final Object value = 42;\r\n    assertSame(value, interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolateString",
  "sourceCode" : "/**\r\n * Tests a successful interpolation of a string value.\r\n */\r\n@Test\r\nvoid testInterpolateString() {\r\n    final String value = \"${\" + TEST_PREFIX + ':' + TEST_NAME + \"}\";\r\n    interpolator.registerLookup(TEST_PREFIX, setUpTestLookup());\r\n    assertEquals(TEST_VALUE, interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolateStringUnknownVariable",
  "sourceCode" : "/**\r\n * Tests interpolation with a variable which cannot be resolved.\r\n */\r\n@Test\r\nvoid testInterpolateStringUnknownVariable() {\r\n    final String value = \"${unknownVariable}\";\r\n    assertEquals(value, interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationBeginningAndEndingRiskyVariableLookups",
  "sourceCode" : "/**\r\n * Tests an interpolated string that begins and ends with variable lookups that have\r\n * the potential to fail. Part of CONFIGURATION-764.\r\n */\r\n@Test\r\nvoid testInterpolationBeginningAndEndingRiskyVariableLookups() {\r\n    interpolator.registerLookups(ConfigurationInterpolator.getDefaultPrefixLookups());\r\n    final String result = (String) interpolator.interpolate(\"${date:yyyy-MM}-${date:dd}\");\r\n    assertTrue(result.matches(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationMultipleArrayVariables",
  "sourceCode" : "/**\r\n * Tests interpolation with multiple variables containing arrays.\r\n */\r\n@Test\r\nvoid testInterpolationMultipleArrayVariables() {\r\n    final String value = \"${single}bc${multi}23${empty}${null}\";\r\n    final int[] multi = { 1, 0, 0 };\r\n    final String[] single = { \"a\" };\r\n    final int[] empty = {};\r\n    final Object[] containsNull = { null };\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"multi\", multi));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"single\", single));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"empty\", empty));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"null\", containsNull));\r\n    assertEquals(\"abc123${empty}${null}\", interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationMultipleCollectionVariables",
  "sourceCode" : "/**\r\n * Tests interpolation with multiple variables containing collections and iterators.\r\n */\r\n@Test\r\nvoid testInterpolationMultipleCollectionVariables() {\r\n    final String value = \"${single}bc${multi}23${empty}${null}${multiIt}${emptyIt}${nullIt}\";\r\n    final List<Integer> multi = Arrays.asList(1, 0, 0);\r\n    final List<String> single = Arrays.asList(\"a\");\r\n    final List<Object> empty = Collections.emptyList();\r\n    final List<Object> containsNull = Arrays.asList((Object) null);\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"multi\", multi));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"multiIt\", multi.iterator()));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"single\", single));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"empty\", empty));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"emptyIt\", empty.iterator()));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"null\", containsNull));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"nullIt\", containsNull.iterator()));\r\n    assertEquals(\"abc123${empty}${null}1${emptyIt}${nullIt}\", interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationMultipleSimpleNonStringVariables",
  "sourceCode" : "/**\r\n * Tests interpolation with variables containing multiple simple non-string variables.\r\n */\r\n@Test\r\nvoid testInterpolationMultipleSimpleNonStringVariables() {\r\n    final String value = \"${x} = ${y} is ${result}\";\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"x\", 1));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"y\", 2));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"result\", false));\r\n    assertEquals(\"1 = 2 is false\", interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationMultipleVariables",
  "sourceCode" : "/**\r\n * Tests a property value consisting of multiple variables.\r\n */\r\n@Test\r\nvoid testInterpolationMultipleVariables() {\r\n    final String value = \"The ${subject} jumps over ${object}.\";\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"subject\", \"quick brown fox\"));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"object\", \"the lazy dog\"));\r\n    assertEquals(\"The quick brown fox jumps over the lazy dog.\", interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationSingleArrayVariable",
  "sourceCode" : "/**\r\n * Tests an interpolation that consists of a single array variable only. The variable's value\r\n * should be returned verbatim.\r\n */\r\n@Test\r\nvoid testInterpolationSingleArrayVariable() {\r\n    final int[] value = { 42, -1 };\r\n    interpolator.addDefaultLookup(setUpTestLookup(TEST_NAME, value));\r\n    assertEquals(value, interpolator.interpolate(\"${\" + TEST_NAME + \"}\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationSingleCollectionVariable",
  "sourceCode" : "/**\r\n * Tests an interpolation that consists of a single collection variable only. The variable's value\r\n * should be returned verbatim.\r\n */\r\n@Test\r\nvoid testInterpolationSingleCollectionVariable() {\r\n    final List<Integer> value = Arrays.asList(42);\r\n    interpolator.addDefaultLookup(setUpTestLookup(TEST_NAME, value));\r\n    assertEquals(value, interpolator.interpolate(\"${\" + TEST_NAME + \"}\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationSingleVariable",
  "sourceCode" : "/**\r\n * Tests an interpolation that consists of a single variable only. The variable's value should be returned verbatim.\r\n */\r\n@Test\r\nvoid testInterpolationSingleVariable() {\r\n    final Object value = 42;\r\n    interpolator.addDefaultLookup(setUpTestLookup(TEST_NAME, value));\r\n    assertEquals(value, interpolator.interpolate(\"${\" + TEST_NAME + \"}\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationSingleVariableDefaultValue",
  "sourceCode" : "/**\r\n * Tests an interpolation that consists of a single undefined variable only with and without a default value.\r\n */\r\n@Test\r\nvoid testInterpolationSingleVariableDefaultValue() {\r\n    final Object value = 42;\r\n    interpolator.addDefaultLookup(setUpTestLookup(TEST_NAME, value));\r\n    assertEquals(\"${I_am_not_defined}\", interpolator.interpolate(\"${I_am_not_defined}\"));\r\n    assertEquals(\"42\", interpolator.interpolate(\"${I_am_not_defined:-42}\"));\r\n    assertEquals(\"\", interpolator.interpolate(\"${I_am_not_defined:-}\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testInterpolationVariableIncomplete",
  "sourceCode" : "/**\r\n * Tests a variable declaration which lacks the trailing closing bracket.\r\n */\r\n@Test\r\nvoid testInterpolationVariableIncomplete() {\r\n    final String value = \"${\" + TEST_NAME;\r\n    interpolator.addDefaultLookup(setUpTestLookup(TEST_NAME, \"someValue\"));\r\n    assertEquals(value, interpolator.interpolate(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testNullSafeLookupExisting",
  "sourceCode" : "/**\r\n * Tests nullSafeLookup() if a lookup object was provided.\r\n */\r\n@Test\r\nvoid testNullSafeLookupExisting() {\r\n    final Lookup look = mock(Lookup.class);\r\n    assertSame(look, ConfigurationInterpolator.nullSafeLookup(look));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testNullSafeLookupNull",
  "sourceCode" : "/**\r\n * Tests whether nullSafeLookup() can handle null input.\r\n */\r\n@Test\r\nvoid testNullSafeLookupNull() {\r\n    final Lookup lookup = ConfigurationInterpolator.nullSafeLookup(null);\r\n    assertNull(lookup.lookup(\"someVar\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testPrefixSetModify",
  "sourceCode" : "/**\r\n * Tests that the prefix set cannot be modified.\r\n */\r\n@Test\r\nvoid testPrefixSetModify() {\r\n    interpolator.registerLookup(TEST_PREFIX, setUpTestLookup());\r\n    final Iterator<String> it = interpolator.prefixSet().iterator();\r\n    it.next();\r\n    assertThrows(UnsupportedOperationException.class, it::remove);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testRegisterLookup",
  "sourceCode" : "/**\r\n * Tests registering a lookup object at an instance.\r\n */\r\n@Test\r\nvoid testRegisterLookup() {\r\n    final Lookup lookup = mock(Lookup.class);\r\n    interpolator.registerLookup(TEST_PREFIX, lookup);\r\n    assertSame(lookup, interpolator.getLookups().get(TEST_PREFIX));\r\n    assertTrue(interpolator.prefixSet().contains(TEST_PREFIX));\r\n    assertTrue(interpolator.getDefaultLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testRegisterLookupNull",
  "sourceCode" : "/**\r\n * Tests registering a null lookup object. This should cause an exception.\r\n */\r\n@Test\r\nvoid testRegisterLookupNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> interpolator.registerLookup(TEST_PREFIX, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testRegisterLookupNullPrefix",
  "sourceCode" : "/**\r\n * Tests registering a lookup object for an undefined prefix. This should cause an exception.\r\n */\r\n@Test\r\nvoid testRegisterLookupNullPrefix() {\r\n    final Lookup lookup = mock(Lookup.class);\r\n    assertThrows(IllegalArgumentException.class, () -> interpolator.registerLookup(null, lookup));\r\n    verifyNoInteractions(lookup);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testRegisterLookups",
  "sourceCode" : "/**\r\n * Tests whether a map with lookup objects can be registered.\r\n */\r\n@Test\r\nvoid testRegisterLookups() {\r\n    final Lookup l1 = setUpTestLookup();\r\n    final Lookup l2 = setUpTestLookup(\"someVar\", \"someValue\");\r\n    final Map<String, Lookup> lookups = new HashMap<>();\r\n    lookups.put(TEST_PREFIX, l1);\r\n    final String prefix2 = TEST_PREFIX + \"_other\";\r\n    lookups.put(prefix2, l2);\r\n    interpolator.registerLookups(lookups);\r\n    final Map<String, Lookup> lookups2 = interpolator.getLookups();\r\n    final Map<String, Lookup> expected = new HashMap<>();\r\n    expected.put(TEST_PREFIX, l1);\r\n    expected.put(prefix2, l2);\r\n    assertEquals(expected, lookups2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testRegisterLookupsNull",
  "sourceCode" : "/**\r\n * Tests whether a null map with lookup objects is handled correctly.\r\n */\r\n@Test\r\nvoid testRegisterLookupsNull() {\r\n    interpolator.registerLookups(null);\r\n    assertTrue(interpolator.getLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testRemoveDefaultLookup",
  "sourceCode" : "/**\r\n * Tests whether a default lookup object can be removed.\r\n */\r\n@Test\r\nvoid testRemoveDefaultLookup() {\r\n    final List<Lookup> lookups = new ArrayList<>();\r\n    lookups.add(setUpTestLookup());\r\n    lookups.add(setUpTestLookup(\"test\", \"value\"));\r\n    interpolator.addDefaultLookups(lookups);\r\n    assertTrue(interpolator.removeDefaultLookup(lookups.get(0)));\r\n    assertFalse(interpolator.getDefaultLookups().contains(lookups.get(0)));\r\n    assertEquals(1, interpolator.getDefaultLookups().size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testRemoveDefaultLookupNonExisting",
  "sourceCode" : "/**\r\n * Tests whether a non existing default lookup object can be removed.\r\n */\r\n@Test\r\nvoid testRemoveDefaultLookupNonExisting() {\r\n    assertFalse(interpolator.removeDefaultLookup(setUpTestLookup()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveDefault",
  "sourceCode" : "/**\r\n * Tests looking up a variable without a prefix. This should trigger the default lookup object.\r\n */\r\n@Test\r\nvoid testResolveDefault() {\r\n    final Lookup l1 = mock(Lookup.class);\r\n    final Lookup l2 = mock(Lookup.class);\r\n    final Lookup l3 = mock(Lookup.class);\r\n    when(l1.lookup(TEST_NAME)).thenReturn(null);\r\n    when(l2.lookup(TEST_NAME)).thenReturn(TEST_VALUE);\r\n    interpolator.addDefaultLookups(Arrays.asList(l1, l2, l3));\r\n    assertEquals(TEST_VALUE, interpolator.resolve(TEST_NAME));\r\n    verify(l1).lookup(TEST_NAME);\r\n    verify(l2).lookup(TEST_NAME);\r\n    verifyNoMoreInteractions(l1, l2, l3);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveDefaultAfterPrefixFails",
  "sourceCode" : "/**\r\n * Tests whether the default lookup is called for variables with a prefix when the lookup that was registered for this\r\n * prefix is not able to resolve the variable.\r\n */\r\n@Test\r\nvoid testResolveDefaultAfterPrefixFails() {\r\n    final String varName = TEST_PREFIX + ':' + TEST_NAME + \"2\";\r\n    interpolator.registerLookup(TEST_PREFIX, setUpTestLookup());\r\n    interpolator.addDefaultLookup(setUpTestLookup(varName, TEST_VALUE));\r\n    assertEquals(TEST_VALUE, interpolator.resolve(varName));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveDefaultEmptyVarName",
  "sourceCode" : "/**\r\n * Tests an empty variable name without a prefix.\r\n */\r\n@Test\r\nvoid testResolveDefaultEmptyVarName() {\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"\", TEST_VALUE));\r\n    assertEquals(TEST_VALUE, interpolator.resolve(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveEmptyPrefix",
  "sourceCode" : "/**\r\n * Tests the empty variable prefix. This is a special case, but legal.\r\n */\r\n@Test\r\nvoid testResolveEmptyPrefix() {\r\n    interpolator.registerLookup(\"\", setUpTestLookup());\r\n    assertEquals(TEST_VALUE, interpolator.resolve(\":\" + TEST_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveEmptyVarName",
  "sourceCode" : "/**\r\n * Tests an empty variable name.\r\n */\r\n@Test\r\nvoid testResolveEmptyVarName() {\r\n    interpolator.registerLookup(TEST_PREFIX, setUpTestLookup(\"\", TEST_VALUE));\r\n    assertEquals(TEST_VALUE, interpolator.resolve(TEST_PREFIX + \":\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveNoDefault",
  "sourceCode" : "/**\r\n * Tests looking up a variable without a prefix when no default lookup is specified. Result should be null in this case.\r\n */\r\n@Test\r\nvoid testResolveNoDefault() {\r\n    assertNull(interpolator.resolve(TEST_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveNull",
  "sourceCode" : "/**\r\n * Tests looking up a null variable. Result should be null, too.\r\n */\r\n@Test\r\nvoid testResolveNull() {\r\n    assertNull(interpolator.resolve(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveParentVariableFound",
  "sourceCode" : "/**\r\n * Tests handling of a parent {@code ConfigurationInterpolator} if the variable can already be resolved by the current\r\n * instance.\r\n */\r\n@Test\r\nvoid testResolveParentVariableFound() {\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    interpolator.setParentInterpolator(parent);\r\n    interpolator.registerLookup(TEST_PREFIX, setUpTestLookup());\r\n    assertEquals(TEST_VALUE, interpolator.resolve(TEST_PREFIX + ':' + TEST_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveParentVariableNotFound",
  "sourceCode" : "/**\r\n * Tests whether the parent {@code ConfigurationInterpolator} is invoked if the test instance cannot resolve a variable.\r\n */\r\n@Test\r\nvoid testResolveParentVariableNotFound() {\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    when(parent.resolve(TEST_NAME)).thenReturn(TEST_VALUE);\r\n    interpolator.setParentInterpolator(parent);\r\n    assertEquals(TEST_VALUE, interpolator.resolve(TEST_NAME));\r\n    verify(parent).resolve(TEST_NAME);\r\n    verifyNoMoreInteractions(parent);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveWithPrefix",
  "sourceCode" : "/**\r\n * Tests whether a variable can be resolved using the associated lookup object. The lookup is identified by the\r\n * variable's prefix.\r\n */\r\n@Test\r\nvoid testResolveWithPrefix() {\r\n    interpolator.registerLookup(TEST_PREFIX, setUpTestLookup());\r\n    assertEquals(TEST_VALUE, interpolator.resolve(TEST_PREFIX + ':' + TEST_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testResolveWithUnknownPrefix",
  "sourceCode" : "/**\r\n * Tests the behavior of the lookup method for variables with an unknown prefix. These variables should not be resolved.\r\n */\r\n@Test\r\nvoid testResolveWithUnknownPrefix() {\r\n    interpolator.registerLookup(TEST_PREFIX, setUpTestLookup());\r\n    assertNull(interpolator.resolve(\"UnknownPrefix:\" + TEST_NAME));\r\n    assertNull(interpolator.resolve(\":\" + TEST_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testSetStringConverter",
  "sourceCode" : "/**\r\n * Tests that a custom string converter can be used.\r\n */\r\n@Test\r\nvoid testSetStringConverter() {\r\n    final Function<Object, String> stringConverter = obj -> \"'\" + obj + \"'\";\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"x\", Arrays.asList(1, 2)));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"y\", \"abc\"));\r\n    interpolator.setStringConverter(stringConverter);\r\n    assertSame(stringConverter, interpolator.getStringConverter());\r\n    assertEquals(\"'abc': '[1, 2]'\", interpolator.interpolate(\"${y}: ${x}\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConfigurationInterpolator.java",
  "methodName" : "testSetStringConverterNullArgumentUsesDefault",
  "sourceCode" : "/**\r\n * Tests that the default string converter can be reapplied by passing {@code null}.\r\n */\r\n@Test\r\nvoid testSetStringConverterNullArgumentUsesDefault() {\r\n    final Function<Object, String> stringConverter = obj -> \"'\" + obj + \"'\";\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"x\", Arrays.asList(1, 2)));\r\n    interpolator.addDefaultLookup(setUpTestLookup(\"y\", \"abc\"));\r\n    interpolator.setStringConverter(stringConverter);\r\n    interpolator.setStringConverter(null);\r\n    assertNotSame(stringConverter, interpolator.getStringConverter());\r\n    assertEquals(\"abc: 1\", interpolator.interpolate(\"${y}: ${x}\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConstantLookup.java",
  "methodName" : "testLookupCache",
  "sourceCode" : "/**\r\n * Tests accessing the cache by querying a variable twice.\r\n */\r\n@Test\r\nvoid testLookupCache() {\r\n    testLookupConstant();\r\n    testLookupConstant();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConstantLookup.java",
  "methodName" : "testLookupConstant",
  "sourceCode" : "/**\r\n * Tests resolving a valid constant.\r\n */\r\n@Test\r\nvoid testLookupConstant() {\r\n    assertEquals(FIELD, lookup.lookup(variable(\"FIELD\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConstantLookup.java",
  "methodName" : "testLookupInvalidSyntax",
  "sourceCode" : "/**\r\n * Tries to resolve a variable with an invalid syntax: The name does not contain a dot as a field separator.\r\n */\r\n@Test\r\nvoid testLookupInvalidSyntax() {\r\n    assertNull(lookup.lookup(\"InvalidVariableName\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConstantLookup.java",
  "methodName" : "testLookupNonExisting",
  "sourceCode" : "/**\r\n * Tests resolving a non existing constant. Result should be null.\r\n */\r\n@Test\r\nvoid testLookupNonExisting() {\r\n    assertNull(lookup.lookup(variable(\"NO_FIELD\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConstantLookup.java",
  "methodName" : "testLookupNonStringFromCache",
  "sourceCode" : "/**\r\n * Tests resolving a non string constant. Then looks the same variable up from the cache.\r\n */\r\n@Test\r\nvoid testLookupNonStringFromCache() {\r\n    final String var = KeyEvent.class.getName() + \".VK_ESCAPE\";\r\n    final Object expected = KeyEvent.VK_ESCAPE;\r\n    assertEquals(expected, lookup.lookup(var));\r\n    assertEquals(expected, lookup.lookup(var));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConstantLookup.java",
  "methodName" : "testLookupNull",
  "sourceCode" : "/**\r\n * Tests looking up a null variable.\r\n */\r\n@Test\r\nvoid testLookupNull() {\r\n    assertNull(lookup.lookup(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConstantLookup.java",
  "methodName" : "testLookupPrivate",
  "sourceCode" : "/**\r\n * Tests resolving a private constant. Because a private field cannot be accessed this should again yield null.\r\n */\r\n@Test\r\nvoid testLookupPrivate() {\r\n    assertNull(lookup.lookup(variable(\"PRIVATE_FIELD\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestConstantLookup.java",
  "methodName" : "testLookupUnknownClass",
  "sourceCode" : "/**\r\n * Tests resolving a field from an unknown class.\r\n */\r\n@Test\r\nvoid testLookupUnknownClass() {\r\n    assertNull(lookup.lookup(\"org.apache.commons.configuration.NonExistingConfig.\" + FIELD));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestDummyLookup.java",
  "methodName" : "testLookup",
  "sourceCode" : "/**\r\n * Tests the lookup() method.\r\n */\r\n@Test\r\nvoid testLookup() {\r\n    assertNull(DummyLookup.INSTANCE.lookup(\"someVariable\"));\r\n    assertNull(DummyLookup.INSTANCE.lookup(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestEnvironmentLookup.java",
  "methodName" : "testLookup",
  "sourceCode" : "/**\r\n * Tests whether environment variables can be queried.\r\n */\r\n@Test\r\nvoid testLookup() {\r\n    for (final Map.Entry<String, String> e : System.getenv().entrySet()) {\r\n        assertEquals(e.getValue(), lookup.lookup(e.getKey()), \"Wrong value for \" + e.getKey());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestEnvironmentLookup.java",
  "methodName" : "testLookupNonExisting",
  "sourceCode" : "/**\r\n * Tries to lookup a non existing property.\r\n */\r\n@Test\r\nvoid testLookupNonExisting() {\r\n    assertNull(lookup.lookup(\"a non existing variable!\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestExprLookup.java",
  "methodName" : "testGetVariables",
  "sourceCode" : "/**\r\n * Tests whether variables can be queried.\r\n */\r\n@Test\r\nvoid testGetVariables() {\r\n    final ExprLookup.Variables vars = new ExprLookup.Variables();\r\n    vars.add(new ExprLookup.Variable(\"String\", org.apache.commons.lang3.StringUtils.class));\r\n    final ExprLookup lookup = new ExprLookup(vars);\r\n    assertEquals(vars, lookup.getVariables());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestExprLookup.java",
  "methodName" : "testGetVariablesDefensiveCopy",
  "sourceCode" : "/**\r\n * Tests that getVariables() returns a copy of the original variables.\r\n */\r\n@Test\r\nvoid testGetVariablesDefensiveCopy() {\r\n    final ExprLookup.Variables vars = new ExprLookup.Variables();\r\n    vars.add(new ExprLookup.Variable(\"String\", org.apache.commons.lang3.StringUtils.class));\r\n    final ExprLookup lookup = new ExprLookup(vars);\r\n    final ExprLookup.Variables vars2 = lookup.getVariables();\r\n    vars2.add(new ExprLookup.Variable(\"System\", \"Class:java.lang.System\"));\r\n    assertEquals(vars, lookup.getVariables());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestExprLookup.java",
  "methodName" : "testLookup",
  "sourceCode" : "@Test\r\nvoid testLookup() throws Exception {\r\n    final ConsoleAppender app = new ConsoleAppender(new SimpleLayout());\r\n    final Log log = LogFactory.getLog(\"TestLogger\");\r\n    //final Logger logger = ((Log4JLogger) log).getLogger();\r\n    //logger.addAppender(app);\r\n    //logger.setLevel(Level.DEBUG);\r\n    //logger.setAdditivity(false);\r\n    final ExprLookup.Variables vars = new ExprLookup.Variables();\r\n    vars.add(new ExprLookup.Variable(\"String\", org.apache.commons.lang3.StringUtils.class));\r\n    vars.add(new ExprLookup.Variable(\"Util\", new Utility(\"Hello\")));\r\n    vars.add(new ExprLookup.Variable(\"System\", \"Class:java.lang.System\"));\r\n    final XMLConfiguration config = loadConfig();\r\n    final ConfigurationLogger testLogger = new ConfigurationLogger(\"TestLogger\");\r\n    config.setLogger(testLogger);\r\n    final ExprLookup lookup = new ExprLookup(vars);\r\n    lookup.setInterpolator(config.getInterpolator());\r\n    lookup.setLogger(testLogger);\r\n    String str = lookup.lookup(PATTERN1);\r\n    assertTrue(str.startsWith(\"Goodbye\"));\r\n    str = lookup.lookup(PATTERN2);\r\n    assertEquals(\"value Some text\", str);\r\n    //logger.removeAppender(app);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestExprLookup.java",
  "methodName" : "testLookupLog4j1",
  "sourceCode" : "@Test\r\nvoid testLookupLog4j1() throws Exception {\r\n    final ConsoleAppender app = new ConsoleAppender(new SimpleLayout());\r\n    final Log log = LogFactory.getLog(\"TestLogger\");\r\n    if (log instanceof Log4JLogger) {\r\n        final Logger logger = ((Log4JLogger) log).getLogger();\r\n        logger.addAppender(app);\r\n        logger.setLevel(Level.DEBUG);\r\n        logger.setAdditivity(false);\r\n        final ExprLookup.Variables vars = new ExprLookup.Variables();\r\n        vars.add(new ExprLookup.Variable(\"String\", org.apache.commons.lang3.StringUtils.class));\r\n        vars.add(new ExprLookup.Variable(\"Util\", new Utility(\"Hello\")));\r\n        vars.add(new ExprLookup.Variable(\"System\", \"Class:java.lang.System\"));\r\n        final XMLConfiguration config = loadConfig();\r\n        final ConfigurationLogger testLogger = new ConfigurationLogger(\"TestLogger\");\r\n        config.setLogger(testLogger);\r\n        final ExprLookup lookup = new ExprLookup(vars);\r\n        lookup.setInterpolator(config.getInterpolator());\r\n        lookup.setLogger(testLogger);\r\n        String str = lookup.lookup(PATTERN1);\r\n        assertTrue(str.startsWith(\"Goodbye\"));\r\n        str = lookup.lookup(PATTERN2);\r\n        assertEquals(\"value Some text\", str);\r\n        logger.removeAppender(app);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestExprLookup.java",
  "methodName" : "testLookupNoConfigurationInterpolator",
  "sourceCode" : "/**\r\n * Tests a lookup() operation if no ConfigurationInterpolator object has been set.\r\n */\r\n@Test\r\nvoid testLookupNoConfigurationInterpolator() {\r\n    final ExprLookup.Variables vars = new ExprLookup.Variables();\r\n    vars.add(new ExprLookup.Variable(\"String\", org.apache.commons.lang3.StringUtils.class));\r\n    final ExprLookup lookup = new ExprLookup(vars);\r\n    final String value = \"test\";\r\n    assertEquals(value, lookup.lookup(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestExprLookup.java",
  "methodName" : "testLookupNonStringExpression",
  "sourceCode" : "/**\r\n * Tests an expression that does not yield a string.\r\n */\r\n@Test\r\nvoid testLookupNonStringExpression() throws ConfigurationException {\r\n    final ExprLookup.Variables vars = new ExprLookup.Variables();\r\n    vars.add(new ExprLookup.Variable(\"System\", \"Class:java.lang.System\"));\r\n    final ExprLookup lookup = new ExprLookup(vars);\r\n    final XMLConfiguration config = loadConfig();\r\n    lookup.setInterpolator(config.getInterpolator());\r\n    final String pattern = \"System.currentTimeMillis()\";\r\n    final String result = lookup.lookup(pattern);\r\n    assertNotEquals(pattern, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestExprLookup.java",
  "methodName" : "testLookupNullExpression",
  "sourceCode" : "/**\r\n * Tests an expression that yields a null value.\r\n */\r\n@Test\r\nvoid testLookupNullExpression() throws ConfigurationException {\r\n    final ExprLookup.Variables vars = new ExprLookup.Variables();\r\n    vars.add(new ExprLookup.Variable(\"System\", \"Class:java.lang.System\"));\r\n    final ExprLookup lookup = new ExprLookup(vars);\r\n    final XMLConfiguration config = loadConfig();\r\n    lookup.setInterpolator(config.getInterpolator());\r\n    assertNull(lookup.lookup(\"System.getProperty('undefined.property')\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testBuilderReuse",
  "sourceCode" : "/**\r\n * Tests whether a builder can be reused.\r\n */\r\n@Test\r\nvoid testBuilderReuse() {\r\n    builder.withDefaultLookup(createLookup()).withInterpolator(mock(ConfigurationInterpolator.class)).withPrefixLookup(\"test\", createLookup()).withParentInterpolator(mock(ConfigurationInterpolator.class)).withStringConverter(obj -> \"test\").create();\r\n    final Lookup prefLook1 = createLookup();\r\n    final Lookup prefLook2 = createLookup();\r\n    final Lookup defLook1 = createLookup();\r\n    final Lookup defLook2 = createLookup();\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    final Function<Object, String> stringConverter = Objects::toString;\r\n    final InterpolatorSpecification spec = builder.withPrefixLookup(PREFIX1, prefLook1).withPrefixLookup(PREFIX2, prefLook2).withDefaultLookups(Arrays.asList(defLook1, defLook2)).withParentInterpolator(parent).withStringConverter(stringConverter).create();\r\n    assertNull(spec.getInterpolator());\r\n    assertSame(parent, spec.getParentInterpolator());\r\n    assertSame(stringConverter, spec.getStringConverter());\r\n    checkPrefixLookups(spec, prefLook1, prefLook2);\r\n    checkDefaultLookups(spec, defLook1, defLook2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testCreateInstance",
  "sourceCode" : "/**\r\n * Tests whether an instance with all possible properties can be set.\r\n */\r\n@Test\r\nvoid testCreateInstance() {\r\n    final Lookup prefLook1 = createLookup();\r\n    final Lookup prefLook2 = createLookup();\r\n    final Lookup defLook1 = createLookup();\r\n    final Lookup defLook2 = createLookup();\r\n    final ConfigurationInterpolator interpolator = mock(ConfigurationInterpolator.class);\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    final Function<Object, String> stringConverter = Objects::toString;\r\n    final InterpolatorSpecification spec = builder.withPrefixLookup(PREFIX1, prefLook1).withDefaultLookup(defLook1).withPrefixLookup(PREFIX2, prefLook2).withParentInterpolator(parent).withDefaultLookup(defLook2).withInterpolator(interpolator).withStringConverter(stringConverter).create();\r\n    assertSame(interpolator, spec.getInterpolator());\r\n    assertSame(parent, spec.getParentInterpolator());\r\n    assertSame(stringConverter, spec.getStringConverter());\r\n    checkPrefixLookups(spec, prefLook1, prefLook2);\r\n    checkDefaultLookups(spec, defLook1, defLook2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testCreateInstanceCollections",
  "sourceCode" : "/**\r\n * Tests whether lookups can be set passing in full collections.\r\n */\r\n@Test\r\nvoid testCreateInstanceCollections() {\r\n    final Lookup prefLook1 = createLookup();\r\n    final Lookup prefLook2 = createLookup();\r\n    final Lookup defLook1 = createLookup();\r\n    final Lookup defLook2 = createLookup();\r\n    final Map<String, Lookup> prefixLookups = new HashMap<>();\r\n    prefixLookups.put(PREFIX1, prefLook1);\r\n    prefixLookups.put(PREFIX2, prefLook2);\r\n    final InterpolatorSpecification spec = builder.withPrefixLookups(prefixLookups).withDefaultLookups(Arrays.asList(defLook1, defLook2)).create();\r\n    checkPrefixLookups(spec, prefLook1, prefLook2);\r\n    checkDefaultLookups(spec, defLook1, defLook2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testGetDefaultLookupsModify",
  "sourceCode" : "/**\r\n * Tests that the collection with default lookups cannot be modified.\r\n */\r\n@Test\r\nvoid testGetDefaultLookupsModify() {\r\n    final InterpolatorSpecification spec = builder.withDefaultLookup(createLookup()).create();\r\n    final Collection<Lookup> lookups = spec.getDefaultLookups();\r\n    final Lookup lookup = createLookup();\r\n    assertThrows(UnsupportedOperationException.class, () -> lookups.add(lookup));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testGetPrefixLookupsModify",
  "sourceCode" : "/**\r\n * Tests that the map with prefix lookups cannot be modified.\r\n */\r\n@Test\r\nvoid testGetPrefixLookupsModify() {\r\n    final InterpolatorSpecification spec = builder.withPrefixLookup(PREFIX1, createLookup()).create();\r\n    final Lookup lookup = createLookup();\r\n    assertThrows(UnsupportedOperationException.class, () -> spec.getPrefixLookups().put(PREFIX1, lookup));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testWithDefaultLookupNull",
  "sourceCode" : "/**\r\n * Tests whether a null default lookup causes an exception.\r\n */\r\n@Test\r\nvoid testWithDefaultLookupNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> builder.withDefaultLookup(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testWithDefaultLookupsNull",
  "sourceCode" : "/**\r\n * Tests whether a null collection with default lookups is accepted.\r\n */\r\n@Test\r\nvoid testWithDefaultLookupsNull() {\r\n    final InterpolatorSpecification spec = builder.withDefaultLookups(null).create();\r\n    assertTrue(spec.getDefaultLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testWithPrefixLookupNoLookup",
  "sourceCode" : "/**\r\n * Tests whether a null prefix lookup causes an exception.\r\n */\r\n@Test\r\nvoid testWithPrefixLookupNoLookup() {\r\n    assertThrows(IllegalArgumentException.class, () -> builder.withPrefixLookup(PREFIX1, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testWithPrefixLookupNoPrefix",
  "sourceCode" : "/**\r\n * Tests whether a null prefix causes an exception.\r\n */\r\n@Test\r\nvoid testWithPrefixLookupNoPrefix() {\r\n    final Lookup lookup = createLookup();\r\n    assertThrows(IllegalArgumentException.class, () -> builder.withPrefixLookup(null, lookup));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestInterpolatorSpecification.java",
  "methodName" : "testWithPrefixLookupsNull",
  "sourceCode" : "/**\r\n * Tests whether a null map with prefix lookups is accepted.\r\n */\r\n@Test\r\nvoid testWithPrefixLookupsNull() {\r\n    final InterpolatorSpecification spec = builder.withPrefixLookups(null).create();\r\n    assertTrue(spec.getPrefixLookups().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestSystemPropertiesLookup.java",
  "methodName" : "testLookupProperties",
  "sourceCode" : "/**\r\n * Tests whether system properties can be looked up.\r\n */\r\n@Test\r\nvoid testLookupProperties() {\r\n    for (final Map.Entry<Object, Object> e : System.getProperties().entrySet()) {\r\n        assertEquals(e.getValue(), lookup.lookup(String.valueOf(e.getKey())), \"Wrong property value for \" + e.getKey());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\interpol\\TestSystemPropertiesLookup.java",
  "methodName" : "testLookupUnknownProperty",
  "sourceCode" : "/**\r\n * Tests whether an unknown property is handled correctly.\r\n */\r\n@Test\r\nvoid testLookupUnknownProperty() {\r\n    assertNull(lookup.lookup(\"a non existing system property!\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestAbsoluteNameLocationStrategy.java",
  "methodName" : "testExistingAbsoluteFile",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation.\r\n */\r\n@Test\r\nvoid testExistingAbsoluteFile() {\r\n    final File file = ConfigurationAssert.getTestFile(\"test.xml\");\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(file.getAbsolutePath()).create();\r\n    final URL url = strategy.locate(fileSystem, locator);\r\n    assertEquals(file.getAbsoluteFile(), FileLocatorUtils.fileFromURL(url).getAbsoluteFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestAbsoluteNameLocationStrategy.java",
  "methodName" : "testNoAbsoluteFileName",
  "sourceCode" : "/**\r\n * Tests a locate() operation if no absolute file name is provided.\r\n */\r\n@Test\r\nvoid testNoAbsoluteFileName() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(\"test.xml\").create();\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestAbsoluteNameLocationStrategy.java",
  "methodName" : "testNoFileName",
  "sourceCode" : "/**\r\n * Tests a locate() operation if no file name is provided.\r\n */\r\n@Test\r\nvoid testNoFileName() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().create();\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestAbsoluteNameLocationStrategy.java",
  "methodName" : "testNonExistingAbsoluteFile",
  "sourceCode" : "/**\r\n * Tests a locate() operation if an absolute file name is provided, but this file does not exist.\r\n */\r\n@Test\r\nvoid testNonExistingAbsoluteFile() {\r\n    final File file = ConfigurationAssert.getOutFile(\"NotExistingFile.tst\");\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(file.getAbsolutePath()).create();\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestBasePathLocationStrategy.java",
  "methodName" : "testLocateSuccess",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation with a valid base path and file name.\r\n */\r\n@Test\r\nvoid testLocateSuccess() {\r\n    final File path = ConfigurationAssert.TEST_DIR;\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(path.getAbsolutePath()).fileName(TEST_FILE).create();\r\n    checkURL(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestBasePathLocationStrategy.java",
  "methodName" : "testLocateSuccessRelativePrefix",
  "sourceCode" : "/**\r\n * Tests whether a prefix for relative file names is handled correctly.\r\n */\r\n@Test\r\nvoid testLocateSuccessRelativePrefix() {\r\n    final File path = ConfigurationAssert.TEST_DIR;\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(path.getAbsolutePath()).fileName(\".\" + File.separator + TEST_FILE).create();\r\n    checkURL(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestBasePathLocationStrategy.java",
  "methodName" : "testNullBasePath",
  "sourceCode" : "/**\r\n * Tests whether a null base path is handled correctly.\r\n */\r\n@Test\r\nvoid testNullBasePath() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(TEST_FILE).create();\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestBasePathLocationStrategy.java",
  "methodName" : "testNullFileName",
  "sourceCode" : "/**\r\n * Tests a locate() operation if no file name is provided.\r\n */\r\n@Test\r\nvoid testNullFileName() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(ConfigurationAssert.getTestFile(TEST_FILE).getAbsolutePath()).create();\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestClasspathLocationStrategy.java",
  "methodName" : "testLocateFailed",
  "sourceCode" : "/**\r\n * Tests a failed locate() operation.\r\n */\r\n@Test\r\nvoid testLocateFailed() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(\"non existing resource name!\").create();\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestClasspathLocationStrategy.java",
  "methodName" : "testLocateNoFileName",
  "sourceCode" : "/**\r\n * Tests a locate() operation if no file name is provided.\r\n */\r\n@Test\r\nvoid testLocateNoFileName() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(\"\").create();\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestClasspathLocationStrategy.java",
  "methodName" : "testLocateSuccess",
  "sourceCode" : "/**\r\n * Tests a successful location of a provided resource name.\r\n */\r\n@Test\r\nvoid testLocateSuccess() throws ConfigurationException {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(FILE_NAME).basePath(\"somePath\").create();\r\n    final URL url = strategy.locate(fileSystem, locator);\r\n    final Configurations configurations = new Configurations();\r\n    final XMLConfiguration config1 = configurations.xml(url);\r\n    final XMLConfiguration config2 = configurations.xml(ConfigurationAssert.getTestURL(FILE_NAME));\r\n    ConfigurationAssert.assertConfigurationEquals(config1, config2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestCombinedLocationStrategy.java",
  "methodName" : "testGetSubStrategiesModify",
  "sourceCode" : "/**\r\n * Tests that the collection with sub strategies cannot be modified.\r\n */\r\n@Test\r\nvoid testGetSubStrategiesModify() {\r\n    final CombinedLocationStrategy strategy = createCombinedStrategy();\r\n    final Collection<FileLocationStrategy> strategies = strategy.getSubStrategies();\r\n    assertThrows(UnsupportedOperationException.class, strategies::clear);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestCombinedLocationStrategy.java",
  "methodName" : "testInitCollectionWithNullEntries",
  "sourceCode" : "/**\r\n * Tries to create an instance containing a null element.\r\n */\r\n@Test\r\nvoid testInitCollectionWithNullEntries() {\r\n    final Collection<FileLocationStrategy> col = new LinkedList<>(Arrays.asList(getSubStrategies()));\r\n    col.add(null);\r\n    assertThrows(IllegalArgumentException.class, () -> new CombinedLocationStrategy(col));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestCombinedLocationStrategy.java",
  "methodName" : "testInitDefensiveCopy",
  "sourceCode" : "/**\r\n * Tests whether a defensive copy of the collection with sub strategies is made.\r\n */\r\n@Test\r\nvoid testInitDefensiveCopy() {\r\n    final Collection<FileLocationStrategy> col = new LinkedList<>(Arrays.asList(getSubStrategies()));\r\n    final CombinedLocationStrategy strategy = new CombinedLocationStrategy(col);\r\n    col.add(mock(FileLocationStrategy.class));\r\n    checkSubStrategies(strategy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestCombinedLocationStrategy.java",
  "methodName" : "testInitNullCollection",
  "sourceCode" : "/**\r\n * Tries to create an instance with a null collection.\r\n */\r\n@Test\r\nvoid testInitNullCollection() {\r\n    assertThrows(IllegalArgumentException.class, () -> new CombinedLocationStrategy(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestCombinedLocationStrategy.java",
  "methodName" : "testLocateFailed",
  "sourceCode" : "/**\r\n * Tests a failed locate() operation.\r\n */\r\n@Test\r\nvoid testLocateFailed() {\r\n    when(getSubStrategies()[0].locate(getFileSystem(), locator)).thenReturn(null);\r\n    when(getSubStrategies()[1].locate(getFileSystem(), locator)).thenReturn(null);\r\n    final CombinedLocationStrategy strategy = createCombinedStrategy();\r\n    assertNull(strategy.locate(getFileSystem(), locator));\r\n    verify(getSubStrategies()[0]).locate(getFileSystem(), locator);\r\n    verify(getSubStrategies()[1]).locate(getFileSystem(), locator);\r\n    verifyNoMoreSubCategoryInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestCombinedLocationStrategy.java",
  "methodName" : "testLocateSuccessFirstSubStrategy",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation if the first sub strategy can locate the file.\r\n */\r\n@Test\r\nvoid testLocateSuccessFirstSubStrategy() {\r\n    when(getSubStrategies()[0].locate(getFileSystem(), locator)).thenReturn(locateURL);\r\n    final CombinedLocationStrategy strategy = createCombinedStrategy();\r\n    assertSame(locateURL, strategy.locate(getFileSystem(), locator));\r\n    verify(getSubStrategies()[0]).locate(getFileSystem(), locator);\r\n    verifyNoMoreSubCategoryInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestCombinedLocationStrategy.java",
  "methodName" : "testLocateSuccessSecondSubStrategy",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation if the 2nd sub strategy can locate the file.\r\n */\r\n@Test\r\nvoid testLocateSuccessSecondSubStrategy() {\r\n    when(getSubStrategies()[0].locate(getFileSystem(), locator)).thenReturn(null);\r\n    when(getSubStrategies()[1].locate(getFileSystem(), locator)).thenReturn(locateURL);\r\n    final CombinedLocationStrategy strategy = createCombinedStrategy();\r\n    assertSame(locateURL, strategy.locate(getFileSystem(), locator));\r\n    verify(getSubStrategies()[0]).locate(getFileSystem(), locator);\r\n    verify(getSubStrategies()[1]).locate(getFileSystem(), locator);\r\n    verifyNoMoreSubCategoryInteractions();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testAbstractConfigurationDefaultLogger",
  "sourceCode" : "/**\r\n * Tests the logger set per default.\r\n */\r\n@Test\r\nvoid testAbstractConfigurationDefaultLogger() {\r\n    final AbstractConfiguration config = new BaseConfiguration();\r\n    assertInstanceOf(NoOpLog.class, config.getLogger().getLog());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testAbstractConfigurationSetLogger",
  "sourceCode" : "/**\r\n * Tests whether the logger can be set.\r\n */\r\n@Test\r\nvoid testAbstractConfigurationSetLogger() {\r\n    final ConfigurationLogger logger = new ConfigurationLogger(getClass());\r\n    final AbstractConfiguration config = new BaseConfiguration();\r\n    config.setLogger(logger);\r\n    assertSame(logger, config.getLogger());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testAbstractConfigurationSetLoggerNull",
  "sourceCode" : "/**\r\n * Tests that the logger can be disabled by setting it to null.\r\n */\r\n@Test\r\nvoid testAbstractConfigurationSetLoggerNull() {\r\n    final AbstractConfiguration config = new BaseConfiguration();\r\n    config.setLogger(new ConfigurationLogger(getClass()));\r\n    config.setLogger(null);\r\n    assertInstanceOf(NoOpLog.class, config.getLogger().getLog());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testDebug",
  "sourceCode" : "/**\r\n * Tests whether debug logging is possible.\r\n */\r\n@Test\r\nvoid testDebug() {\r\n    final Log log = mock(Log.class);\r\n    final ConfigurationLogger logger = new ConfigurationLogger(log);\r\n    logger.debug(MSG);\r\n    verify(log).debug(MSG);\r\n    verifyNoMoreInteractions(log);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testDummyLogger",
  "sourceCode" : "/**\r\n * Tests whether a dummy logger can be created.\r\n */\r\n@Test\r\nvoid testDummyLogger() {\r\n    final ConfigurationLogger logger = ConfigurationLogger.newDummyLogger();\r\n    assertInstanceOf(NoOpLog.class, logger.getLog());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testError",
  "sourceCode" : "/**\r\n * Tests whether error logging is possible.\r\n */\r\n@Test\r\nvoid testError() {\r\n    final Log log = mock(Log.class);\r\n    final ConfigurationLogger logger = new ConfigurationLogger(log);\r\n    logger.error(MSG);\r\n    verify(log).error(MSG);\r\n    verifyNoMoreInteractions(log);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testErrorWithException",
  "sourceCode" : "/**\r\n * Tests whether an exception can be logged on error level.\r\n */\r\n@Test\r\nvoid testErrorWithException() {\r\n    final Log log = mock(Log.class);\r\n    final Throwable ex = new Exception(\"Test exception\");\r\n    final ConfigurationLogger logger = new ConfigurationLogger(log);\r\n    logger.error(MSG, ex);\r\n    verify(log).error(MSG, ex);\r\n    verifyNoMoreInteractions(log);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testInfo",
  "sourceCode" : "/**\r\n * Tests whether info logging is possible.\r\n */\r\n@Test\r\nvoid testInfo() {\r\n    final Log log = mock(Log.class);\r\n    final ConfigurationLogger logger = new ConfigurationLogger(log);\r\n    logger.info(MSG);\r\n    verify(log).info(MSG);\r\n    verifyNoMoreInteractions(log);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testInitNoLoggerClass",
  "sourceCode" : "/**\r\n * Tries to create an instance without passing a logger class.\r\n */\r\n@Test\r\nvoid testInitNoLoggerClass() {\r\n    assertThrows(IllegalArgumentException.class, () -> new ConfigurationLogger((Class<?>) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testInitNoLoggerName",
  "sourceCode" : "/**\r\n * Tries to create an instance without passing in a logger name.\r\n */\r\n@Test\r\nvoid testInitNoLoggerName() {\r\n    assertThrows(IllegalArgumentException.class, () -> new ConfigurationLogger((String) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testInitWithLoggerSpec",
  "sourceCode" : "/**\r\n * Tests whether a correct internal logger is created.\r\n */\r\n@Test\r\nvoid testInitWithLoggerSpec() {\r\n    final ConfigurationLogger logger1 = new ConfigurationLogger(getClass().getName());\r\n    final ConfigurationLogger logger2 = new ConfigurationLogger(getClass());\r\n    assertNotNull(logger1.getLog());\r\n    if (logger1.getLog() instanceof Log4JLogger) {\r\n        assertEquals(logger1.getLog(), logger2.getLog());\r\n    }\r\n    // else: TODO assert what for the Slf4j adapter?\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testIsDebugEnabled",
  "sourceCode" : "/**\r\n * Tests whether the debug status can be queried.\r\n */\r\n@Test\r\nvoid testIsDebugEnabled() {\r\n    final Log log = mock(Log.class);\r\n    when(log.isDebugEnabled()).thenReturn(Boolean.TRUE);\r\n    final ConfigurationLogger logger = new ConfigurationLogger(log);\r\n    assertTrue(logger.isDebugEnabled());\r\n    verify(log).isDebugEnabled();\r\n    verifyNoMoreInteractions(log);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testIsInfoEnabled",
  "sourceCode" : "/**\r\n * Tests whether the info status can be queried.\r\n */\r\n@Test\r\nvoid testIsInfoEnabled() {\r\n    final Log log = mock(Log.class);\r\n    when(log.isInfoEnabled()).thenReturn(Boolean.FALSE);\r\n    final ConfigurationLogger logger = new ConfigurationLogger(log);\r\n    assertFalse(logger.isInfoEnabled());\r\n    verify(log).isInfoEnabled();\r\n    verifyNoMoreInteractions(log);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testSubClass",
  "sourceCode" : "/**\r\n * Tests that a derived class can be created for a logger.\r\n */\r\n@Test\r\nvoid testSubClass() {\r\n    final StringBuilder buf = new StringBuilder();\r\n    final ConfigurationLogger logger = new ConfigurationLogger() {\r\n\r\n        @Override\r\n        public void info(final String msg) {\r\n            buf.append(msg);\r\n        }\r\n    };\r\n    assertNull(logger.getLog());\r\n    logger.info(MSG);\r\n    assertEquals(MSG, buf.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testWarn",
  "sourceCode" : "/**\r\n * Tests whether warn logging is possible.\r\n */\r\n@Test\r\nvoid testWarn() {\r\n    final Log log = mock(Log.class);\r\n    final ConfigurationLogger logger = new ConfigurationLogger(log);\r\n    logger.warn(MSG);\r\n    verify(log).warn(MSG);\r\n    verifyNoMoreInteractions(log);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestConfigurationLogger.java",
  "methodName" : "testWarnWithException",
  "sourceCode" : "/**\r\n * Tests whether an exception can be logged on warn level.\r\n */\r\n@Test\r\nvoid testWarnWithException() {\r\n    final Log log = mock(Log.class);\r\n    final Throwable ex = new Exception(\"Test exception\");\r\n    final ConfigurationLogger logger = new ConfigurationLogger(log);\r\n    logger.warn(MSG, ex);\r\n    verify(log).warn(MSG, ex);\r\n    verifyNoMoreInteractions(log);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestDefaultFileSystem.java",
  "methodName" : "testDefaultLogger",
  "sourceCode" : "/**\r\n * Tests the default logger.\r\n */\r\n@Test\r\nvoid testDefaultLogger() {\r\n    assertNotNull(fileSystem.getLogger());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestDefaultFileSystem.java",
  "methodName" : "testGetOutputStreamInvalidPath",
  "sourceCode" : "/**\r\n * Tests that an invalid output path causes an exception to be thrown when creating an ouput stream.\r\n */\r\n@Test\r\nvoid testGetOutputStreamInvalidPath() {\r\n    final File file = new File(\"\");\r\n    assertThrows(ConfigurationException.class, () -> fileSystem.getOutputStream(file));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestDefaultFileSystem.java",
  "methodName" : "testSetLogger",
  "sourceCode" : "/**\r\n * Tests whether the logger can be changed.\r\n */\r\n@Test\r\nvoid testSetLogger() {\r\n    final ConfigurationLogger log = new ConfigurationLogger(getClass());\r\n    fileSystem.setLogger(log);\r\n    assertSame(log, fileSystem.getLogger());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testAddFileHandlerListenerNull",
  "sourceCode" : "/**\r\n * Tries to add a null listener.\r\n */\r\n@Test\r\nvoid testAddFileHandlerListenerNull() {\r\n    final FileHandler fileHandler = new FileHandler();\r\n    assertThrows(IllegalArgumentException.class, () -> fileHandler.addFileHandlerListener(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testAssignNullHandler",
  "sourceCode" : "/**\r\n * Tries to invoke the assignment constructor with a null handler.\r\n */\r\n@Test\r\nvoid testAssignNullHandler() {\r\n    final FileBased obj = new FileBasedTestImpl();\r\n    assertThrows(IllegalArgumentException.class, () -> new FileHandler(obj, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testAssignWithFileBased",
  "sourceCode" : "/**\r\n * Tests whether a FileHandler object can be used to specify a location and later be assigned to a FileBased object.\r\n */\r\n@Test\r\nvoid testAssignWithFileBased() {\r\n    final FileHandler h1 = new FileHandler();\r\n    final File f = new File(\"testfile.txt\");\r\n    h1.setFile(f);\r\n    final FileBased content = new FileBasedTestImpl();\r\n    final FileHandler h2 = new FileHandler(content, h1);\r\n    h1.setFileName(\"someOtherFile.txt\");\r\n    assertSame(content, h2.getContent());\r\n    assertEquals(f, h2.getFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testClearLocation",
  "sourceCode" : "/**\r\n * Tests whether the location can be cleared.\r\n */\r\n@Test\r\nvoid testClearLocation() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFile(createTestFile());\r\n    handler.clearLocation();\r\n    assertFalse(handler.isLocationDefined());\r\n    assertNull(handler.getFile());\r\n    assertNull(handler.getURL());\r\n    assertNull(handler.getBasePath());\r\n    assertNull(handler.getPath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testGetBasePathUndefined",
  "sourceCode" : "/**\r\n * Tests getBasePath() if no information is available.\r\n */\r\n@Test\r\nvoid testGetBasePathUndefined() {\r\n    assertNull(new FileHandler().getBasePath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testGetFileNameUndefined",
  "sourceCode" : "/**\r\n * Tests getFileName() if no information is set.\r\n */\r\n@Test\r\nvoid testGetFileNameUndefined() {\r\n    assertNull(new FileHandler().getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testGetFileSystemDefault",
  "sourceCode" : "/**\r\n * Tests whether a newly created instance has a default file system.\r\n */\r\n@Test\r\nvoid testGetFileSystemDefault() {\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    assertEquals(FileLocatorUtils.DEFAULT_FILE_SYSTEM, handler.getFileSystem());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testGetLocationStrategyDefault",
  "sourceCode" : "/**\r\n * Tests whether a newly created instance uses the default location strategy.\r\n */\r\n@Test\r\nvoid testGetLocationStrategyDefault() {\r\n    final FileHandler handler = new FileHandler();\r\n    assertNull(handler.getFileLocator().getLocationStrategy());\r\n    assertSame(FileLocatorUtils.DEFAULT_LOCATION_STRATEGY, handler.getLocationStrategy());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testInitFromMap",
  "sourceCode" : "/**\r\n * Tests whether an instance can be created from a map with the properties of a FileLocator.\r\n */\r\n@Test\r\nvoid testInitFromMap() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(TEST_FILENAME).basePath(\"someBasePath\").encoding(\"someEncoding\").create();\r\n    final Map<String, Object> map = new HashMap<>();\r\n    FileLocatorUtils.put(locator, map);\r\n    final FileHandler handler = FileHandler.fromMap(map);\r\n    assertEquals(locator, handler.getFileLocator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testInitPropertiesMultiThreaded",
  "sourceCode" : "/**\r\n * Tests whether the initialization of properties is safe even if performed in multiple threads.\r\n */\r\n@Test\r\nvoid testInitPropertiesMultiThreaded() throws InterruptedException {\r\n    final String encoding = \"TestEncoding\";\r\n    final FileSystem fileSystem = new DefaultFileSystem();\r\n    final FileLocationStrategy locationStrategy = new ProvidedURLLocationStrategy();\r\n    final int loops = 8;\r\n    for (int i = 0; i < loops; i++) {\r\n        final FileHandler handler = new FileHandler();\r\n        final Thread t1 = new Thread(() -> handler.setFileSystem(fileSystem));\r\n        final Thread t2 = new Thread(() -> handler.setFileName(TEST_FILENAME));\r\n        final Thread t3 = new Thread(() -> handler.setEncoding(encoding));\r\n        final Thread t4 = new Thread(() -> handler.setLocationStrategy(locationStrategy));\r\n        final List<Thread> threads = Arrays.asList(t1, t2, t3, t4);\r\n        for (final Thread t : threads) {\r\n            t.start();\r\n        }\r\n        for (final Thread t : threads) {\r\n            t.join();\r\n        }\r\n        final FileLocator locator = handler.getFileLocator();\r\n        assertEquals(TEST_FILENAME, locator.getFileName());\r\n        assertNull(locator.getSourceURL());\r\n        assertEquals(encoding, locator.getEncoding());\r\n        assertSame(fileSystem, locator.getFileSystem());\r\n        assertSame(locationStrategy, locator.getLocationStrategy());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testIsLocationDefinedBasePathOnly",
  "sourceCode" : "/**\r\n * Tests isLocationDefined() if only a base path is set.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedBasePathOnly() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setBasePath(createTestFile().getParent());\r\n    assertFalse(handler.isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testIsLocationDefinedFalse",
  "sourceCode" : "/**\r\n * Tests whether an undefined location can be queried.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedFalse() {\r\n    final FileHandler handler = new FileHandler();\r\n    assertFalse(handler.isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testIsLocationDefinedFile",
  "sourceCode" : "/**\r\n * Tests isLocationDefined() if a File has been set.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedFile() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFile(createTestFile());\r\n    assertTrue(handler.isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testIsLocationDefinedFileName",
  "sourceCode" : "/**\r\n * Tests isLocationDefined() if a file name has been set.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedFileName() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFileName(createTestFile().getName());\r\n    assertTrue(handler.isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testIsLocationDefinedPath",
  "sourceCode" : "/**\r\n * Tests isLocationDefined() if a path has been set.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedPath() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setPath(createTestFile().getAbsolutePath());\r\n    assertTrue(handler.isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testIsLocationDefinedURL",
  "sourceCode" : "/**\r\n * Tests isLocationDefined() if a URL has been set.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedURL() throws IOException {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setURL(createTestURL());\r\n    assertTrue(handler.isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadDirectoryFile",
  "sourceCode" : "/**\r\n * Tests that it is not possible to load a directory using the load() method which expects a File.\r\n */\r\n@Test\r\nvoid testLoadDirectoryFile() {\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    assertThrows(ConfigurationException.class, () -> handler.load(ConfigurationAssert.TEST_DIR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadDirectoryString",
  "sourceCode" : "/**\r\n * Checks that loading a directory instead of a file throws an exception.\r\n */\r\n@Test\r\nvoid testLoadDirectoryString() {\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    final String fileName = ConfigurationAssert.TEST_DIR.getAbsolutePath();\r\n    assertThrows(ConfigurationException.class, () -> handler.load(fileName));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadEvents",
  "sourceCode" : "/**\r\n * Tests notifications about load operations.\r\n */\r\n@Test\r\nvoid testLoadEvents() throws ConfigurationException {\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    handler.load(createTestFile());\r\n    listener.checkMethods(\"loadingloaded\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFileLocatorAware",
  "sourceCode" : "/**\r\n * Tests whether a FileLocatorAware object is initialized correctly when loading data.\r\n */\r\n@Test\r\nvoid testLoadFileLocatorAware() throws IOException, ConfigurationException {\r\n    final File file = createTestFile();\r\n    final FileBasedFileLocatorAwareTestImpl content = new FileBasedFileLocatorAwareTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.setFile(file);\r\n    handler.load();\r\n    assertEquals(file.toURI().toURL().toString() + \": \" + CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFileLocatorAwareReader",
  "sourceCode" : "/**\r\n * Tests a load operation with a FileLocatorAware object if data is loaded from a reader.\r\n */\r\n@Test\r\nvoid testLoadFileLocatorAwareReader() throws ConfigurationException {\r\n    final FileBasedFileLocatorAwareTestImpl content = new FileBasedFileLocatorAwareTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.load(new StringReader(CONTENT));\r\n    checkEmptyLocator(content);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFileLocatorAwareStream",
  "sourceCode" : "/**\r\n * Tests loading with a FileLocatorAware object if data is loaded from a stream.\r\n */\r\n@Test\r\nvoid testLoadFileLocatorAwareStream() throws ConfigurationException {\r\n    final FileBasedFileLocatorAwareTestImpl content = new FileBasedFileLocatorAwareTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    final ByteArrayInputStream bos = new ByteArrayInputStream(CONTENT.getBytes());\r\n    handler.load(bos);\r\n    checkEmptyLocator(content);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromClassPath",
  "sourceCode" : "/**\r\n * Tests whether whether data can be loaded from class path.\r\n */\r\n@Test\r\nvoid testLoadFromClassPath() throws ConfigurationException {\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler config1 = new FileHandler(content);\r\n    config1.setFileName(\"config/deep/deeptest.properties\");\r\n    config1.load();\r\n    assertFalse(content.getContent().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromFile",
  "sourceCode" : "/**\r\n * Tests whether data from a File can be loaded.\r\n */\r\n@Test\r\nvoid testLoadFromFile() throws ConfigurationException {\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final File file = createTestFile();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.load(file);\r\n    assertEquals(CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromFileNameLocation",
  "sourceCode" : "/**\r\n * Tests a load operation using the current location which is a file name.\r\n */\r\n@Test\r\nvoid testLoadFromFileNameLocation() throws ConfigurationException {\r\n    final File file = createTestFile();\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.setBasePath(file.getParentFile().getAbsolutePath());\r\n    handler.setFileName(file.getName());\r\n    handler.load();\r\n    assertEquals(CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromFileNoContent",
  "sourceCode" : "/**\r\n * Tries to load data from a File if no content object was set.\r\n */\r\n@Test\r\nvoid testLoadFromFileNoContent() {\r\n    final FileHandler handler = new FileHandler();\r\n    final File file = createTestFile();\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> handler.load(file));\r\n    assertEquals(\"No content available!\", cex.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromFilePath",
  "sourceCode" : "/**\r\n * Tests whether data from an absolute path can be loaded.\r\n */\r\n@Test\r\nvoid testLoadFromFilePath() throws ConfigurationException {\r\n    final File file = createTestFile();\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.load(file.getAbsolutePath());\r\n    assertEquals(CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromFilePathWithURLDefined",
  "sourceCode" : "/**\r\n * Tests that a load() operation with a file path overrides a URL which might have been set.\r\n */\r\n@Test\r\nvoid testLoadFromFilePathWithURLDefined() throws ConfigurationException {\r\n    final File file = createTestFile();\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.setURL(ConfigurationAssert.getTestURL(\"test.xml\"));\r\n    handler.load(file.getAbsolutePath());\r\n    assertEquals(CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromReader",
  "sourceCode" : "/**\r\n * Tests whether data from a reader can be read.\r\n */\r\n@Test\r\nvoid testLoadFromReader() throws Exception {\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    try (Reader in = new FileReader(createTestFile())) {\r\n        handler.load(in);\r\n    }\r\n    assertEquals(CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromReaderIOException",
  "sourceCode" : "/**\r\n * Tests whether an IOException is handled when loading data from a reader.\r\n */\r\n@Test\r\nvoid testLoadFromReaderIOException() throws IOException, ConfigurationException {\r\n    final FileBased content = mock(FileBased.class);\r\n    final Reader in = new StringReader(CONTENT);\r\n    final IOException ioex = new IOException(\"Test exception\");\r\n    doThrow(ioex).when(content).read(in);\r\n    final FileHandler handler = new FileHandler(content);\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> handler.load(in));\r\n    assertEquals(ioex, cex.getCause());\r\n    verify(content).read(in);\r\n    verifyNoMoreInteractions(content);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromStream",
  "sourceCode" : "/**\r\n * Tests whether data from an input stream can be read.\r\n */\r\n@Test\r\nvoid testLoadFromStream() throws Exception {\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    try (InputStream in = Files.newInputStream(createTestPath())) {\r\n        handler.load(in);\r\n    }\r\n    assertEquals(CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromURL",
  "sourceCode" : "/**\r\n * Tests whether data from a URL can be loaded.\r\n */\r\n@Test\r\nvoid testLoadFromURL() throws Exception {\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.load(createTestURL());\r\n    assertEquals(CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadFromURLLocation",
  "sourceCode" : "/**\r\n * Tests a load operation using the current location which is a URL.\r\n */\r\n@Test\r\nvoid testLoadFromURLLocation() throws Exception {\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.setURL(createTestURL());\r\n    handler.load();\r\n    assertEquals(CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadInputStreamSupport",
  "sourceCode" : "/**\r\n * Tests whether data can be read from an input stream.\r\n */\r\n@Test\r\nvoid testLoadInputStreamSupport() throws ConfigurationException {\r\n    final FileBasedInputStreamSupportTestImpl content = new FileBasedInputStreamSupportTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    final ByteArrayInputStream bin = new ByteArrayInputStream(CONTENT.getBytes());\r\n    handler.load(bin);\r\n    assertEquals(\"InputStream = \" + CONTENT, content.getContent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadInputStreamSupportIOException",
  "sourceCode" : "/**\r\n * Tests whether an IOException is handled when reading from an input stream.\r\n */\r\n@Test\r\nvoid testLoadInputStreamSupportIOException() throws ConfigurationException, IOException {\r\n    final FileBasedInputStreamSupportTestImpl content = mock(FileBasedInputStreamSupportTestImpl.class);\r\n    final ByteArrayInputStream bin = new ByteArrayInputStream(CONTENT.getBytes());\r\n    final IOException ioex = new IOException();\r\n    doThrow(ioex).when(content).read(bin);\r\n    final FileHandler handler = new FileHandler(content);\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> handler.load(bin));\r\n    assertEquals(ioex, cex.getCause());\r\n    verify(content).read(bin);\r\n    verifyNoMoreInteractions(content);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadNoContent",
  "sourceCode" : "/**\r\n * Tries to call a load() method if no content object is available.\r\n */\r\n@Test\r\nvoid testLoadNoContent() {\r\n    final FileHandler handler = new FileHandler();\r\n    final StringReader reader = new StringReader(CONTENT);\r\n    assertThrows(ConfigurationException.class, () -> handler.load(reader));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadNoLocation",
  "sourceCode" : "/**\r\n * Tries to load data if no location has been set.\r\n */\r\n@Test\r\nvoid testLoadNoLocation() {\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    assertThrows(ConfigurationException.class, handler::load);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLoadSynchronized",
  "sourceCode" : "/**\r\n * Tests whether a load() operation is correctly synchronized.\r\n */\r\n@Test\r\nvoid testLoadSynchronized() throws ConfigurationException {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    config.setSynchronizer(sync);\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.load(ConfigurationAssert.getTestFile(\"test.properties\"));\r\n    sync.verifyStart(Methods.BEGIN_WRITE);\r\n    sync.verifyEnd(Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocateSuccess",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation.\r\n */\r\n@Test\r\nvoid testLocateSuccess() throws ConfigurationException {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFileName(TEST_FILENAME);\r\n    assertTrue(handler.locate());\r\n    final FileLocator locator = handler.getFileLocator();\r\n    assertNotNull(locator.getSourceURL());\r\n    assertNotNull(locator.getBasePath());\r\n    assertEquals(TEST_FILENAME, locator.getFileName());\r\n    // check whether the correct URL was obtained\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final FileHandler h2 = new FileHandler(config);\r\n    h2.setURL(locator.getSourceURL());\r\n    h2.load();\r\n    assertTrue(config.getBoolean(\"configuration.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocateUndefinedLocator",
  "sourceCode" : "/**\r\n * Tests a locate() operation if there is not enough information.\r\n */\r\n@Test\r\nvoid testLocateUndefinedLocator() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setBasePath(\"only/a/base/path\");\r\n    final FileLocator locator = handler.getFileLocator();\r\n    assertFalse(handler.locate());\r\n    assertSame(locator, handler.getFileLocator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocateUnknownFile",
  "sourceCode" : "/**\r\n * Tests a locate() operation if the specified file cannot be resolved.\r\n */\r\n@Test\r\nvoid testLocateUnknownFile() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFileName(\"unknown file\");\r\n    final FileLocator locator = handler.getFileLocator();\r\n    assertFalse(handler.locate());\r\n    assertSame(locator, handler.getFileLocator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocationChangedBasePath",
  "sourceCode" : "/**\r\n * Tests a notification about a changed base path.\r\n */\r\n@Test\r\nvoid testLocationChangedBasePath() {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    handler.setBasePath(TEST_FILENAME);\r\n    listener.checkMethods(\"locationChanged\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocationChangedEncoding",
  "sourceCode" : "/**\r\n * Tests a notification about a changed encoding.\r\n */\r\n@Test\r\nvoid testLocationChangedEncoding() {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    handler.setEncoding(StandardCharsets.UTF_8.name());\r\n    listener.checkMethods(\"locationChanged\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocationChangedFile",
  "sourceCode" : "/**\r\n * Tests a notification about a changed file.\r\n */\r\n@Test\r\nvoid testLocationChangedFile() throws IOException {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    handler.setFile(newFile(tempFolder));\r\n    listener.checkMethods(\"locationChanged\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocationChangedFileName",
  "sourceCode" : "/**\r\n * Tests a notification about a changed file name.\r\n */\r\n@Test\r\nvoid testLocationChangedFileName() {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    handler.setFileName(TEST_FILENAME);\r\n    listener.checkMethods(\"locationChanged\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocationChangedFileSystem",
  "sourceCode" : "/**\r\n * Tests a notification about a changed file system.\r\n */\r\n@Test\r\nvoid testLocationChangedFileSystem() {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    handler.setFileSystem(fs);\r\n    listener.checkMethods(\"locationChanged\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocationChangedLocator",
  "sourceCode" : "/**\r\n * Tests whether a notification is sent if the whole locator was changed.\r\n */\r\n@Test\r\nvoid testLocationChangedLocator() {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    handler.setFileLocator(FileLocatorUtils.fileLocator().fileName(TEST_FILENAME).create());\r\n    listener.checkMethods(\"locationChanged\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocationChangedPath",
  "sourceCode" : "/**\r\n * Tests a notification about a changed path.\r\n */\r\n@Test\r\nvoid testLocationChangedPath() {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    handler.setPath(TEST_FILENAME);\r\n    listener.checkMethods(\"locationChanged\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocationChangedURL",
  "sourceCode" : "/**\r\n * Tests a notification about a changed URL.\r\n */\r\n@Test\r\nvoid testLocationChangedURL() throws IOException {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    final URL url = newFile(tempFolder).toURI().toURL();\r\n    handler.setURL(url);\r\n    listener.checkMethods(\"locationChanged\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testLocatorAwareEncoding",
  "sourceCode" : "/**\r\n * Tests that the locator injected into the content object has an encoding set.\r\n */\r\n@Test\r\nvoid testLocatorAwareEncoding() throws ConfigurationException {\r\n    final FileBasedFileLocatorAwareTestImpl content = new FileBasedFileLocatorAwareTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    final String encoding = \"testEncoding\";\r\n    handler.setEncoding(encoding);\r\n    handler.save(new StringWriter());\r\n    assertEquals(encoding, content.getLocator().getEncoding());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testPathWithPlus",
  "sourceCode" : "/**\r\n * Tests whether file names containing a \"+\" character are handled correctly. This test is related to CONFIGURATION-415.\r\n */\r\n@Test\r\nvoid testPathWithPlus() throws ConfigurationException, IOException {\r\n    final File saveFile = newFile(\"test+config.properties\", tempFolder);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.setFile(saveFile);\r\n    handler.save();\r\n    assertEquals(CONTENT, readFile(saveFile));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testPathWithSpaces",
  "sourceCode" : "/**\r\n * Tests loading and saving a configuration file with a complicated path name including spaces. (related to issue 35210)\r\n */\r\n@Test\r\nvoid testPathWithSpaces() throws ConfigurationException, IOException {\r\n    final File path = newFolder(\"path with spaces\", tempFolder);\r\n    final File confFile = new File(path, \"config-test.properties\");\r\n    final File testFile = createTestFile(confFile);\r\n    final URL url = testFile.toURI().toURL();\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.setURL(url);\r\n    handler.load();\r\n    assertEquals(CONTENT, content.getContent());\r\n    final File out = new File(path, \"out.txt\");\r\n    handler.save(out);\r\n    assertEquals(CONTENT, readFile(out));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testResetFileSystem",
  "sourceCode" : "/**\r\n * Tests whether the file system can be reset.\r\n */\r\n@Test\r\nvoid testResetFileSystem() {\r\n    final FileSystem sys = mock(FileSystem.class);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.setFileSystem(sys);\r\n    handler.resetFileSystem();\r\n    assertEquals(FileLocatorUtils.DEFAULT_FILE_SYSTEM, handler.getFileSystem());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveEvents",
  "sourceCode" : "/**\r\n * Tests notifications about save operations.\r\n */\r\n@Test\r\nvoid testSaveEvents() throws IOException, ConfigurationException {\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    final FileHandlerListenerTestImpl listener = new FileHandlerListenerTestImpl(handler);\r\n    handler.addFileHandlerListener(listener);\r\n    final File f = newFile(tempFolder);\r\n    handler.save(f);\r\n    listener.checkMethods(\"savingsaved\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveFileLocatorAware",
  "sourceCode" : "/**\r\n * Tests whether a FileLocatorAware is correctly handled when saving data.\r\n */\r\n@Test\r\nvoid testSaveFileLocatorAware() throws ConfigurationException, IOException {\r\n    final File file = newFile(tempFolder);\r\n    final FileBasedFileLocatorAwareTestImpl content = new FileBasedFileLocatorAwareTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.save(file);\r\n    assertEquals(file.toURI().toURL() + \": \" + CONTENT, readFile(file));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveFileLocatorAwareToStream",
  "sourceCode" : "/**\r\n * Tests a save operation with a FileLocatorAware object if the target is a stream.\r\n */\r\n@Test\r\nvoid testSaveFileLocatorAwareToStream() throws ConfigurationException {\r\n    final FileBasedFileLocatorAwareTestImpl content = new FileBasedFileLocatorAwareTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.save(new ByteArrayOutputStream());\r\n    checkEmptyLocator(content);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveFileLocatorAwareToWriter",
  "sourceCode" : "/**\r\n * Tests a save operation with a FileLocatorAware object if the target is a writer.\r\n */\r\n@Test\r\nvoid testSaveFileLocatorAwareToWriter() throws ConfigurationException {\r\n    final FileBasedFileLocatorAwareTestImpl content = new FileBasedFileLocatorAwareTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    handler.save(new StringWriter());\r\n    checkEmptyLocator(content);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveNoLocation",
  "sourceCode" : "/**\r\n * Tries to save the locator if no location has been set.\r\n */\r\n@Test\r\nvoid testSaveNoLocation() {\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    assertThrows(ConfigurationException.class, handler::save);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveSynchronized",
  "sourceCode" : "/**\r\n * Tests whether a save() operation is correctly synchronized.\r\n */\r\n@Test\r\nvoid testSaveSynchronized() throws ConfigurationException, IOException {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(\"test.synchronized\", Boolean.TRUE);\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    config.setSynchronizer(sync);\r\n    final FileHandler handler = new FileHandler(config);\r\n    final File f = newFile(tempFolder);\r\n    handler.save(f);\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToFile",
  "sourceCode" : "/**\r\n * Tests whether data can be saved to a file.\r\n */\r\n@Test\r\nvoid testSaveToFile() throws ConfigurationException, IOException {\r\n    final File file = newFile(tempFolder);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.save(file);\r\n    assertEquals(CONTENT, readFile(file));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToFileName",
  "sourceCode" : "/**\r\n * Tests whether data can be saved to a file name.\r\n */\r\n@Test\r\nvoid testSaveToFileName() throws ConfigurationException, IOException {\r\n    final File file = newFile(tempFolder);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.save(file.getAbsolutePath());\r\n    assertEquals(CONTENT, readFile(file));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToFileNameLocation",
  "sourceCode" : "/**\r\n * Tests whether data can be saved to the internal location if it is a file name.\r\n */\r\n@Test\r\nvoid testSaveToFileNameLocation() throws ConfigurationException, IOException {\r\n    final File file = newFile(tempFolder);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.setFileName(file.getAbsolutePath());\r\n    handler.save();\r\n    assertEquals(CONTENT, readFile(file));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToFileNameURLException",
  "sourceCode" : "/**\r\n * Tests whether a URL exception is handled when saving a file to a file name.\r\n */\r\n@Test\r\nvoid testSaveToFileNameURLException() throws IOException {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final File file = newFile(tempFolder);\r\n    final String basePath = \"some base path\";\r\n    final MalformedURLException urlex = new MalformedURLException(\"Test exception\");\r\n    final String fileName = file.getName();\r\n    when(fs.getURL(basePath, fileName)).thenThrow(urlex);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.setBasePath(basePath);\r\n    handler.setFileSystem(fs);\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> handler.save(fileName));\r\n    assertEquals(urlex, cex.getCause());\r\n    verify(fs).getURL(basePath, fileName);\r\n    verifyNoMoreInteractions(fs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToFileNameURLNotResolved",
  "sourceCode" : "/**\r\n * Tries to save data to a file name if the name cannot be located.\r\n */\r\n@Test\r\nvoid testSaveToFileNameURLNotResolved() throws IOException {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final File file = newFile(tempFolder);\r\n    final String fileName = file.getName();\r\n    when(fs.getURL(null, fileName)).thenReturn(null);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.setFileSystem(fs);\r\n    assertThrows(ConfigurationException.class, () -> handler.save(fileName));\r\n    verify(fs).getURL(null, fileName);\r\n    verifyNoMoreInteractions(fs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToStream",
  "sourceCode" : "/**\r\n * Tests whether data can be saved to a stream.\r\n */\r\n@Test\r\nvoid testSaveToStream() throws ConfigurationException, IOException {\r\n    final File file = newFile(tempFolder);\r\n    try (FileOutputStream out = new FileOutputStream(file)) {\r\n        final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n        handler.save(out);\r\n    }\r\n    assertEquals(CONTENT, readFile(file));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToURL",
  "sourceCode" : "/**\r\n * Tests whether data can be saved to a URL.\r\n */\r\n@Test\r\nvoid testSaveToURL() throws Exception {\r\n    final File file = newFile(tempFolder);\r\n    final URL url = file.toURI().toURL();\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.save(url);\r\n    assertEquals(CONTENT, readFile(file));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToURLLocation",
  "sourceCode" : "/**\r\n * Tests whether data can be saved to the internal location if it is a URL.\r\n */\r\n@Test\r\nvoid testSaveToURLLocation() throws ConfigurationException, IOException {\r\n    final File file = newFile(tempFolder);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.setURL(file.toURI().toURL());\r\n    handler.save();\r\n    assertEquals(CONTENT, readFile(file));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToWriter",
  "sourceCode" : "/**\r\n * Tests whether data can be saved into a Writer.\r\n */\r\n@Test\r\nvoid testSaveToWriter() throws ConfigurationException {\r\n    final FileBasedTestImpl content = new FileBasedTestImpl();\r\n    final FileHandler handler = new FileHandler(content);\r\n    final StringWriter out = new StringWriter();\r\n    handler.save(out);\r\n    assertEquals(CONTENT, out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToWriterIOException",
  "sourceCode" : "/**\r\n * Tests whether an I/O exception during a save operation to a Writer is handled correctly.\r\n */\r\n@Test\r\nvoid testSaveToWriterIOException() throws ConfigurationException, IOException {\r\n    final FileBased content = mock(FileBased.class);\r\n    final StringWriter out = new StringWriter();\r\n    final IOException ioex = new IOException(\"Test exception!\");\r\n    doThrow(ioex).when(content).write(out);\r\n    final FileHandler handler = new FileHandler(content);\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> handler.save(out));\r\n    assertEquals(ioex, cex.getCause());\r\n    verify(content).write(out);\r\n    verifyNoMoreInteractions(content);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSaveToWriterNoContent",
  "sourceCode" : "/**\r\n * Tries to save something to a Writer if no content is set.\r\n */\r\n@Test\r\nvoid testSaveToWriterNoContent() {\r\n    final FileHandler handler = new FileHandler();\r\n    final StringWriter writer = new StringWriter();\r\n    assertThrows(ConfigurationException.class, () -> handler.save(writer));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetBasePath",
  "sourceCode" : "/**\r\n * Tests whether a base path can be set and whether this removes an already set URL.\r\n */\r\n@Test\r\nvoid testSetBasePath() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setURL(ConfigurationAssert.getTestURL(TEST_FILENAME));\r\n    final String basePath = ConfigurationAssert.TEST_DIR_NAME;\r\n    handler.setBasePath(basePath);\r\n    final FileLocator locator = handler.getFileLocator();\r\n    assertEquals(basePath, locator.getBasePath());\r\n    assertNull(locator.getSourceURL());\r\n    assertNull(locator.getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetBasePathFileScheme",
  "sourceCode" : "/**\r\n * Tests whether the file scheme is corrected when setting the base path.\r\n */\r\n@Test\r\nvoid testSetBasePathFileScheme() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setBasePath(\"file:/test/path/\");\r\n    assertEquals(\"file:///test/path/\", handler.getFileLocator().getBasePath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetFile",
  "sourceCode" : "/**\r\n * Tests whether the location can be set as a file.\r\n */\r\n@Test\r\nvoid testSetFile() {\r\n    final FileHandler handler = new FileHandler();\r\n    final File directory = ConfigurationAssert.TEST_DIR;\r\n    final File file = ConfigurationAssert.getTestFile(TEST_FILENAME);\r\n    handler.setFile(file);\r\n    assertEquals(directory.getAbsolutePath(), handler.getBasePath());\r\n    assertEquals(TEST_FILENAME, handler.getFileName());\r\n    assertEquals(file.getAbsolutePath(), handler.getPath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetFileLocator",
  "sourceCode" : "/**\r\n * Tests whether the handler can be initialized using a FileLocator.\r\n */\r\n@Test\r\nvoid testSetFileLocator() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(TEST_FILENAME).create();\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFileLocator(locator);\r\n    assertEquals(TEST_FILENAME, handler.getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetFileLocatorNull",
  "sourceCode" : "/**\r\n * Tries to set the FileLocator to null.\r\n */\r\n@Test\r\nvoid testSetFileLocatorNull() {\r\n    final FileHandler handler = new FileHandler();\r\n    assertThrows(IllegalArgumentException.class, () -> handler.setFileLocator(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetFileName",
  "sourceCode" : "/**\r\n * Tests whether the location can be set using file name and base path.\r\n */\r\n@Test\r\nvoid testSetFileName() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setURL(ConfigurationAssert.getTestURL(TEST_FILENAME));\r\n    handler.setFileName(TEST_FILENAME);\r\n    assertNull(handler.getBasePath());\r\n    assertEquals(TEST_FILENAME, handler.getFileName());\r\n    assertEquals(TEST_FILENAME, handler.getFileLocator().getFileName());\r\n    assertNull(handler.getFileLocator().getSourceURL());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetFileNameFileScheme",
  "sourceCode" : "/**\r\n * Tests whether the file scheme is corrected when setting the file name.\r\n */\r\n@Test\r\nvoid testSetFileNameFileScheme() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFileName(\"file:/test/path/test.txt\");\r\n    assertEquals(\"file:///test/path/test.txt\", handler.getFileLocator().getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetFileSystemNull",
  "sourceCode" : "/**\r\n * Tests whether a null file system can be set to reset this property.\r\n */\r\n@Test\r\nvoid testSetFileSystemNull() {\r\n    final FileSystem sys = mock(FileSystem.class);\r\n    final FileHandler handler = new FileHandler(new FileBasedTestImpl());\r\n    handler.setFileSystem(sys);\r\n    assertSame(sys, handler.getFileSystem());\r\n    handler.setFileSystem(null);\r\n    assertEquals(FileLocatorUtils.DEFAULT_FILE_SYSTEM, handler.getFileSystem());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetLocationStrategy",
  "sourceCode" : "/**\r\n * Tests whether the location strategy can be changed.\r\n */\r\n@Test\r\nvoid testSetLocationStrategy() {\r\n    final FileLocationStrategy strategy = mock(FileLocationStrategy.class);\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setLocationStrategy(strategy);\r\n    assertSame(strategy, handler.getFileLocator().getLocationStrategy());\r\n    assertSame(strategy, handler.getLocationStrategy());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetPath",
  "sourceCode" : "/**\r\n * Tests whether the location can be set as a file.\r\n */\r\n@Test\r\nvoid testSetPath() throws MalformedURLException {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setPath(ConfigurationAssert.TEST_DIR_NAME + File.separator + TEST_FILENAME);\r\n    assertEquals(TEST_FILENAME, handler.getFileName());\r\n    assertEquals(ConfigurationAssert.TEST_DIR.getAbsolutePath(), handler.getBasePath());\r\n    final File file = ConfigurationAssert.getTestFile(TEST_FILENAME);\r\n    assertEquals(file.getAbsolutePath(), handler.getPath());\r\n    assertEquals(file.toURI().toURL(), handler.getURL());\r\n    assertNull(handler.getFileLocator().getSourceURL());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSettingFileNames",
  "sourceCode" : "/**\r\n * Additional tests for setting file names in various ways. (Copied from the test for XMLConfiguration)\r\n */\r\n@Test\r\nvoid testSettingFileNames() {\r\n    final String testProperties = ConfigurationAssert.getTestFile(\"test.xml\").getAbsolutePath();\r\n    final String testBasePath = ConfigurationAssert.TEST_DIR.getAbsolutePath();\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFileName(testProperties);\r\n    assertEquals(testProperties.toString(), handler.getFileName());\r\n    handler.setBasePath(testBasePath);\r\n    handler.setFileName(\"hello.xml\");\r\n    assertEquals(\"hello.xml\", handler.getFileName());\r\n    assertEquals(testBasePath.toString(), handler.getBasePath());\r\n    assertEquals(new File(testBasePath, \"hello.xml\"), handler.getFile());\r\n    handler.setBasePath(testBasePath);\r\n    handler.setFileName(\"subdir/hello.xml\");\r\n    assertEquals(\"subdir/hello.xml\", handler.getFileName());\r\n    assertEquals(testBasePath.toString(), handler.getBasePath());\r\n    assertEquals(new File(testBasePath, \"subdir/hello.xml\"), handler.getFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetURL",
  "sourceCode" : "/**\r\n * Tests whether a URL can be set.\r\n */\r\n@Test\r\nvoid testSetURL() throws Exception {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setURL(new URL(\"https://commons.apache.org/configuration/index.html\"));\r\n    assertEquals(\"https://commons.apache.org/configuration/\", handler.getBasePath());\r\n    assertEquals(\"index.html\", handler.getFileName());\r\n    assertNull(handler.getFileLocator().getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetURLFileScheme",
  "sourceCode" : "/**\r\n * Tests whether the correct file scheme is applied.\r\n */\r\n@Test\r\nvoid testSetURLFileScheme() throws MalformedURLException {\r\n    final FileHandler handler = new FileHandler();\r\n    // file URL - This url is invalid, a valid url would be\r\n    // file:///temp/test.properties.\r\n    handler.setURL(new URL(\"file:/temp/test.properties\"));\r\n    assertEquals(\"file:///temp/\", handler.getBasePath());\r\n    assertEquals(TEST_FILENAME, handler.getFileName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetURLNull",
  "sourceCode" : "/**\r\n * Tests whether a null URL can be set.\r\n */\r\n@Test\r\nvoid testSetURLNull() {\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setURL(ConfigurationAssert.getTestURL(TEST_FILENAME));\r\n    handler.setURL(null);\r\n    final FileLocator locator = handler.getFileLocator();\r\n    assertNull(locator.getBasePath());\r\n    assertNull(locator.getFileName());\r\n    assertNull(locator.getSourceURL());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileHandler.java",
  "methodName" : "testSetURLWithParams",
  "sourceCode" : "/**\r\n * Tests whether a URL with parameters can be set.\r\n */\r\n@Test\r\nvoid testSetURLWithParams() throws Exception {\r\n    final FileHandler handler = new FileHandler();\r\n    final URL url = new URL(\"https://issues.apache.org/bugzilla/show_bug.cgi?id=37886\");\r\n    handler.setURL(url);\r\n    assertEquals(\"https://issues.apache.org/bugzilla/\", handler.getBasePath());\r\n    assertEquals(\"show_bug.cgi\", handler.getFileName());\r\n    assertEquals(url, handler.getURL());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocator.java",
  "methodName" : "testCreateFileLocator",
  "sourceCode" : "/**\r\n * Tests the creation of a file locator.\r\n */\r\n@Test\r\nvoid testCreateFileLocator() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(FILE_NAME).encoding(ENCODING).fileSystem(fileSystem).sourceURL(sourceURL).locationStrategy(locationStrategy).create();\r\n    checkLocator(locator);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocator.java",
  "methodName" : "testCreateFileLocatorFromSource",
  "sourceCode" : "/**\r\n * Tests whether a file locator can be created from a source locator.\r\n */\r\n@Test\r\nvoid testCreateFileLocatorFromSource() {\r\n    final FileLocator locatorSrc = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(\"someFile\").encoding(ENCODING).fileSystem(fileSystem).sourceURL(sourceURL).locationStrategy(locationStrategy).create();\r\n    final FileLocator locator = FileLocatorUtils.fileLocator(locatorSrc).fileName(FILE_NAME).create();\r\n    checkLocator(locator);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocator.java",
  "methodName" : "testCreateFileLocatorUndefined",
  "sourceCode" : "/**\r\n * Tests whether an undefined file locator can be created.\r\n */\r\n@Test\r\nvoid testCreateFileLocatorUndefined() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().create();\r\n    assertNull(locator.getBasePath());\r\n    assertNull(locator.getFileName());\r\n    assertNull(locator.getSourceURL());\r\n    assertNull(locator.getEncoding());\r\n    assertNull(locator.getFileSystem());\r\n    assertNull(locator.getLocationStrategy());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocator.java",
  "methodName" : "testFileLocatorEqualsFalse",
  "sourceCode" : "/**\r\n * Tests the equals() implementation of FileLocator if the expected result is false.\r\n */\r\n@Test\r\nvoid testFileLocatorEqualsFalse() {\r\n    final FileLocator loc1 = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(FILE_NAME).encoding(ENCODING).fileSystem(fileSystem).sourceURL(sourceURL).locationStrategy(locationStrategy).create();\r\n    FileLocator loc2 = FileLocatorUtils.fileLocator(loc1).basePath(BASE_PATH + \"_other\").create();\r\n    ConfigurationAssert.checkEquals(loc1, loc2, false);\r\n    loc2 = FileLocatorUtils.fileLocator(loc1).fileName(FILE_NAME + \"_other\").create();\r\n    ConfigurationAssert.checkEquals(loc1, loc2, false);\r\n    loc2 = FileLocatorUtils.fileLocator(loc1).encoding(ENCODING + \"_other\").create();\r\n    ConfigurationAssert.checkEquals(loc1, loc2, false);\r\n    loc2 = FileLocatorUtils.fileLocator(loc1).fileSystem(mock(FileSystem.class)).create();\r\n    ConfigurationAssert.checkEquals(loc1, loc2, false);\r\n    loc2 = FileLocatorUtils.fileLocator(loc1).sourceURL(ConfigurationAssert.getTestURL(\"test.properties\")).create();\r\n    ConfigurationAssert.checkEquals(loc1, loc2, false);\r\n    loc2 = FileLocatorUtils.fileLocator(loc1).locationStrategy(mock(FileLocationStrategy.class)).create();\r\n    ConfigurationAssert.checkEquals(loc1, loc2, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocator.java",
  "methodName" : "testFileLocatorEqualsNull",
  "sourceCode" : "/**\r\n * Tests equals() with a null object.\r\n */\r\n@Test\r\nvoid testFileLocatorEqualsNull() {\r\n    final FileLocator loc = FileLocatorUtils.fileLocator().fileName(FILE_NAME).create();\r\n    assertNotEquals(null, loc);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocator.java",
  "methodName" : "testFileLocatorEqualsOtherClass",
  "sourceCode" : "/**\r\n * Tests equals() with an object from another class.\r\n */\r\n@Test\r\nvoid testFileLocatorEqualsOtherClass() {\r\n    final FileLocator loc = FileLocatorUtils.fileLocator().fileName(FILE_NAME).create();\r\n    assertNotEquals(loc, this);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocator.java",
  "methodName" : "testFileLocatorEqualsTrue",
  "sourceCode" : "/**\r\n * Tests the equals() implementation of FileLocator if the expected result is true.\r\n */\r\n@Test\r\nvoid testFileLocatorEqualsTrue() {\r\n    FileLocator loc1 = FileLocatorUtils.fileLocator().create();\r\n    ConfigurationAssert.checkEquals(loc1, loc1, true);\r\n    FileLocator loc2 = FileLocatorUtils.fileLocator().create();\r\n    ConfigurationAssert.checkEquals(loc1, loc2, true);\r\n    loc1 = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(FILE_NAME).encoding(ENCODING).fileSystem(fileSystem).sourceURL(sourceURL).locationStrategy(locationStrategy).create();\r\n    loc2 = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(FILE_NAME).encoding(ENCODING).fileSystem(fileSystem).sourceURL(sourceURL).locationStrategy(locationStrategy).create();\r\n    ConfigurationAssert.checkEquals(loc1, loc2, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocator.java",
  "methodName" : "testFileLocatorToString",
  "sourceCode" : "/**\r\n * Tests the string representation of a locator.\r\n */\r\n@Test\r\nvoid testFileLocatorToString() {\r\n    final FileLocator loc = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(FILE_NAME).encoding(ENCODING).fileSystem(fileSystem).sourceURL(sourceURL).locationStrategy(locationStrategy).create();\r\n    final String s = loc.toString();\r\n    assertTrue(s.contains(\"fileName=\" + FILE_NAME));\r\n    assertTrue(s.contains(\"basePath=\" + BASE_PATH));\r\n    assertTrue(s.contains(\"sourceURL=\" + sourceURL));\r\n    assertTrue(s.contains(\"encoding=\" + ENCODING));\r\n    assertTrue(s.contains(\"fileSystem=\" + fileSystem));\r\n    assertTrue(s.contains(\"locationStrategy=\" + locationStrategy));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testConvertFileToURL",
  "sourceCode" : "/**\r\n * Tests a successful conversion from a file to a URL.\r\n */\r\n@Test\r\nvoid testConvertFileToURL() throws ConfigurationException {\r\n    final File file = ConfigurationAssert.getTestFile(FILE_NAME);\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setURL(FileLocatorUtils.convertFileToURL(file));\r\n    checkTestConfiguration(handler);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testConvertToURIException",
  "sourceCode" : "/**\r\n * Tests whether exceptions are handled when converting a URI to a URL.\r\n */\r\n@Test\r\nvoid testConvertToURIException() throws URISyntaxException {\r\n    final URI uri = new URI(\"test://test/path/file.tst\");\r\n    assertNull(FileLocatorUtils.convertURIToURL(uri));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testDefaultFileLocationStrategy",
  "sourceCode" : "/**\r\n * Tests the definition of the default location strategy.\r\n */\r\n@Test\r\nvoid testDefaultFileLocationStrategy() {\r\n    final CombinedLocationStrategy strategy = (CombinedLocationStrategy) FileLocatorUtils.DEFAULT_LOCATION_STRATEGY;\r\n    final Iterator<FileLocationStrategy> it = strategy.getSubStrategies().iterator();\r\n    assertInstanceOf(ProvidedURLLocationStrategy.class, it.next());\r\n    assertInstanceOf(FileSystemLocationStrategy.class, it.next());\r\n    assertInstanceOf(AbsoluteNameLocationStrategy.class, it.next());\r\n    assertInstanceOf(BasePathLocationStrategy.class, it.next());\r\n    FileLocationStrategy sub = it.next();\r\n    HomeDirectoryLocationStrategy subStrategy = assertInstanceOf(HomeDirectoryLocationStrategy.class, sub);\r\n    assertTrue(subStrategy.isEvaluateBasePath());\r\n    sub = it.next();\r\n    subStrategy = assertInstanceOf(HomeDirectoryLocationStrategy.class, sub);\r\n    assertFalse(subStrategy.isEvaluateBasePath());\r\n    assertInstanceOf(ClasspathLocationStrategy.class, it.next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFileFromURLNull",
  "sourceCode" : "/**\r\n * Tests whether fileFromURL() handles null URLs correctly.\r\n */\r\n@Test\r\nvoid testFileFromURLNull() throws Exception {\r\n    assertNull(FileLocatorUtils.fileFromURL(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFileFromURLWithEncodedPercent",
  "sourceCode" : "/**\r\n * Tests whether an encoded \"%\" character in the file name is handled correctly by fileFromURL(). This test is related\r\n * to CONFIGURATION-521.\r\n */\r\n@Test\r\nvoid testFileFromURLWithEncodedPercent() throws MalformedURLException {\r\n    final File file = new File(\"https%3A%2F%2Fwww.apache.org%2F.url\").getAbsoluteFile();\r\n    final URL fileURL = file.toURI().toURL();\r\n    final File file2 = FileLocatorUtils.fileFromURL(fileURL);\r\n    assertEquals(file, file2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFileFromURLWithPlus",
  "sourceCode" : "/**\r\n * Tests whether a \"+\" character in the file name is handled correctly by fileFromURL(). This test is related to\r\n * CONFIGURATION-415.\r\n */\r\n@Test\r\nvoid testFileFromURLWithPlus() throws MalformedURLException {\r\n    final File file = new File(new File(\"target\"), \"foo+bar.txt\").getAbsoluteFile();\r\n    final URL fileURL = file.toURI().toURL();\r\n    final File file2 = FileLocatorUtils.fileFromURL(fileURL);\r\n    assertEquals(file, file2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFromMapNoMap",
  "sourceCode" : "/**\r\n * Tests whether fromMap() can handle a null map.\r\n */\r\n@Test\r\nvoid testFromMapNoMap() {\r\n    final FileLocator fileLocator = FileLocatorUtils.fromMap(null);\r\n    assertEquals(FileLocatorUtils.fileLocator().create(), fileLocator);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFullyInitializedLocatorAlreadyComplete",
  "sourceCode" : "/**\r\n * Tests fullyInitializedLocator() if the locator is already fully initialized.\r\n */\r\n@Test\r\nvoid testFullyInitializedLocatorAlreadyComplete() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(FILE_NAME).create();\r\n    final FileLocator fullLocator = FileLocatorUtils.fullyInitializedLocator(locator);\r\n    assertSame(fullLocator, FileLocatorUtils.fullyInitializedLocator(fullLocator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFullyInitializedLocatorFileName",
  "sourceCode" : "/**\r\n * Tests whether a fully initialized locator can be obtained if a file name is available.\r\n */\r\n@Test\r\nvoid testFullyInitializedLocatorFileName() throws ConfigurationException {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(FILE_NAME).create();\r\n    checkFullyInitializedLocator(FileLocatorUtils.fullyInitializedLocator(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFullyInitializedLocatorLocateFails",
  "sourceCode" : "/**\r\n * Tests fullyInitializedLocator() if a locate() operation fails.\r\n */\r\n@Test\r\nvoid testFullyInitializedLocatorLocateFails() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(\"non existing file\").create();\r\n    assertNull(FileLocatorUtils.fullyInitializedLocator(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFullyInitializedLocatorUndefined",
  "sourceCode" : "/**\r\n * Tries to obtain a fully initialized locator if the source locator is not defined.\r\n */\r\n@Test\r\nvoid testFullyInitializedLocatorUndefined() {\r\n    assertNull(FileLocatorUtils.fullyInitializedLocator(FileLocatorUtils.fileLocator().create()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testFullyInitializedLocatorURL",
  "sourceCode" : "/**\r\n * Tests whether a fully initialized locator can be obtained if a URL is available.\r\n */\r\n@Test\r\nvoid testFullyInitializedLocatorURL() throws ConfigurationException {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().sourceURL(sourceURL).create();\r\n    checkFullyInitializedLocator(FileLocatorUtils.fullyInitializedLocator(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testGetBasePath",
  "sourceCode" : "@Test\r\nvoid testGetBasePath() throws Exception {\r\n    URL url = new URL(\"http://xyz.net/foo/bar.xml\");\r\n    assertEquals(\"http://xyz.net/foo/\", FileLocatorUtils.getBasePath(url));\r\n    url = new URL(\"http://xyz.net/foo/\");\r\n    assertEquals(\"http://xyz.net/foo/\", FileLocatorUtils.getBasePath(url));\r\n    url = new URL(\"http://xyz.net/foo\");\r\n    assertEquals(\"http://xyz.net/\", FileLocatorUtils.getBasePath(url));\r\n    url = new URL(\"http://xyz.net/\");\r\n    assertEquals(\"http://xyz.net/\", FileLocatorUtils.getBasePath(url));\r\n    url = new URL(\"http://xyz.net\");\r\n    assertEquals(\"http://xyz.net\", FileLocatorUtils.getBasePath(url));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testGetFile",
  "sourceCode" : "@Test\r\nvoid testGetFile() throws Exception {\r\n    final File directory = new File(\"target\");\r\n    final File reference = new File(directory, \"test.txt\").getAbsoluteFile();\r\n    assertEquals(FileLocatorUtils.getFile(null, reference.getAbsolutePath()), reference);\r\n    assertEquals(FileLocatorUtils.getFile(directory.getAbsolutePath(), reference.getAbsolutePath()), reference);\r\n    assertEquals(FileLocatorUtils.getFile(directory.getAbsolutePath(), reference.getName()), reference);\r\n    assertEquals(FileLocatorUtils.getFile(directory.toURI().toURL().toString(), reference.getName()), reference);\r\n    assertEquals(FileLocatorUtils.getFile(\"invalid\", reference.toURI().toURL().toString()), reference);\r\n    assertEquals(FileLocatorUtils.getFile(\"jar:file:/C:/myjar.jar!/my-config.xml/someprops.properties\", reference.getAbsolutePath()), reference);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testGetFileName",
  "sourceCode" : "@Test\r\nvoid testGetFileName() throws Exception {\r\n    assertNull(FileLocatorUtils.getFileName(null));\r\n    URL url = new URL(\"http://xyz.net/foo/\");\r\n    assertNull(FileLocatorUtils.getFileName(url));\r\n    url = new URL(\"http://xyz.net/foo/bar.xml\");\r\n    assertEquals(\"bar.xml\", FileLocatorUtils.getFileName(url));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testIsFullyInitializedNoBasePath",
  "sourceCode" : "/**\r\n * Tests whether a missing base path is detected when checking for a fully initialized locator.\r\n */\r\n@Test\r\nvoid testIsFullyInitializedNoBasePath() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().sourceURL(ConfigurationAssert.getTestURL(FILE_NAME)).fileName(FILE_NAME).create();\r\n    assertFalse(FileLocatorUtils.isFullyInitialized(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testIsFullyInitializedNull",
  "sourceCode" : "/**\r\n * Tests isFullyInitialized() for null input.\r\n */\r\n@Test\r\nvoid testIsFullyInitializedNull() {\r\n    assertFalse(FileLocatorUtils.isFullyInitialized(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testIsLocationDefinedFalse",
  "sourceCode" : "/**\r\n * Tests isLocationDefined() if no location is defined.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedFalse() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().encoding(ENCODING).basePath(BASE_PATH).fileSystem(FileLocatorUtils.DEFAULT_FILE_SYSTEM).create();\r\n    assertFalse(FileLocatorUtils.isLocationDefined(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testIsLocationDefinedFileName",
  "sourceCode" : "/**\r\n * Tests isLocationDefined() if a file name is set.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedFileName() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(FILE_NAME).create();\r\n    assertTrue(FileLocatorUtils.isLocationDefined(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testIsLocationDefinedNull",
  "sourceCode" : "/**\r\n * Tests whether isLocationDefined() can handle null input.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedNull() {\r\n    assertFalse(FileLocatorUtils.isLocationDefined(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testIsLocationDefinedURL",
  "sourceCode" : "/**\r\n * Tests isLocationDefined() if a URL is set.\r\n */\r\n@Test\r\nvoid testIsLocationDefinedURL() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().sourceURL(ConfigurationAssert.getTestURL(FILE_NAME)).create();\r\n    assertTrue(FileLocatorUtils.isLocationDefined(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testLocateNullLocator",
  "sourceCode" : "/**\r\n * Tests a locate() operation with a null locator.\r\n */\r\n@Test\r\nvoid testLocateNullLocator() {\r\n    assertNull(FileLocatorUtils.locate(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testLocateOrThrowFailed",
  "sourceCode" : "/**\r\n * Tests whether an exception is thrown for a failed locate() operation.\r\n */\r\n@Test\r\nvoid testLocateOrThrowFailed() {\r\n    final FileLocationStrategy strategy = mock(FileLocationStrategy.class);\r\n    when(strategy.locate(any(), any())).thenReturn(null);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().locationStrategy(strategy).create();\r\n    assertThrows(ConfigurationException.class, () -> FileLocatorUtils.locateOrThrow(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testLocateSuccessWithDefaults",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation that uses defaults for location strategy and file system.\r\n */\r\n@Test\r\nvoid testLocateSuccessWithDefaults() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().sourceURL(sourceURL).create();\r\n    assertSame(sourceURL, FileLocatorUtils.locate(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testLocateSuccessWithStrategyAndFileSystem",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation if the passed in locator contains a strategy and a file system.\r\n */\r\n@Test\r\nvoid testLocateSuccessWithStrategyAndFileSystem() throws ConfigurationException {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final FileLocationStrategy strategy = mock(FileLocationStrategy.class);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileSystem(fs).locationStrategy(strategy).create();\r\n    when(strategy.locate(fs, locator)).thenReturn(sourceURL);\r\n    assertSame(sourceURL, FileLocatorUtils.locateOrThrow(locator));\r\n    verify(strategy).locate(fs, locator);\r\n    verifyNoMoreInteractions(strategy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testLocateSuccessWithStrategyDefaultFileSystem",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation if the passed in locator contains a strategy, but no file system.\r\n */\r\n@Test\r\nvoid testLocateSuccessWithStrategyDefaultFileSystem() throws ConfigurationException {\r\n    final FileLocationStrategy strategy = mock(FileLocationStrategy.class);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().locationStrategy(strategy).create();\r\n    when(strategy.locate(FileLocatorUtils.DEFAULT_FILE_SYSTEM, locator)).thenReturn(sourceURL);\r\n    assertSame(sourceURL, FileLocatorUtils.locateOrThrow(locator));\r\n    verify(strategy).locate(FileLocatorUtils.DEFAULT_FILE_SYSTEM, locator);\r\n    verifyNoMoreInteractions(strategy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testLocateWithNullTCCL",
  "sourceCode" : "@Test\r\nvoid testLocateWithNullTCCL() throws Exception {\r\n    final ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n    try {\r\n        Thread.currentThread().setContextClassLoader(null);\r\n        assertNull(FileLocatorUtils.locate(FileLocatorUtils.fileLocator().basePath(\"abase\").fileName(\"aname\").create()));\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(cl);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testObtainFileSystemNotSetInLocator",
  "sourceCode" : "/**\r\n * Tests whether the default file system is returned if it is not set in a locator.\r\n */\r\n@Test\r\nvoid testObtainFileSystemNotSetInLocator() {\r\n    assertSame(FileLocatorUtils.DEFAULT_FILE_SYSTEM, FileLocatorUtils.getFileSystem(FileLocatorUtils.fileLocator().create()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testObtainFileSystemNullLocator",
  "sourceCode" : "/**\r\n * Tests whether obtainFileSystem() can handle a null locator.\r\n */\r\n@Test\r\nvoid testObtainFileSystemNullLocator() {\r\n    assertSame(FileLocatorUtils.DEFAULT_FILE_SYSTEM, FileLocatorUtils.getFileSystem(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testObtainFileSystemSetInLocator",
  "sourceCode" : "/**\r\n * Tests whether obtainFileSystem() returns the file system stored in the locator.\r\n */\r\n@Test\r\nvoid testObtainFileSystemSetInLocator() {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileSystem(fs).create();\r\n    assertSame(fs, FileLocatorUtils.getFileSystem(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testObtainLocationStrategyNotSetInLocator",
  "sourceCode" : "/**\r\n * Tests whether a location strategy can be obtained if it is not defined by the locator.\r\n */\r\n@Test\r\nvoid testObtainLocationStrategyNotSetInLocator() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().create();\r\n    assertSame(FileLocatorUtils.DEFAULT_LOCATION_STRATEGY, FileLocatorUtils.getLocationStrategy(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testObtainLocationStrategyNullLocator",
  "sourceCode" : "/**\r\n * Tests whether a location strategy can be obtained if a null locator is passed.\r\n */\r\n@Test\r\nvoid testObtainLocationStrategyNullLocator() {\r\n    assertSame(FileLocatorUtils.DEFAULT_LOCATION_STRATEGY, FileLocatorUtils.getLocationStrategy(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testObtainLocationStrategySetInLocator",
  "sourceCode" : "/**\r\n * Tests whether a location strategy can be obtained if it is defined by the locator.\r\n */\r\n@Test\r\nvoid testObtainLocationStrategySetInLocator() {\r\n    final FileLocationStrategy strategy = mock(FileLocationStrategy.class);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().locationStrategy(strategy).create();\r\n    assertSame(strategy, FileLocatorUtils.getLocationStrategy(locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testPutNoLocator",
  "sourceCode" : "/**\r\n * Tests whether put() deals with a null locator.\r\n */\r\n@Test\r\nvoid testPutNoLocator() {\r\n    final Map<String, Object> map = new HashMap<>();\r\n    FileLocatorUtils.put(null, map);\r\n    assertTrue(map.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testPutNoMap",
  "sourceCode" : "/**\r\n * Tries to call put() without a map.\r\n */\r\n@Test\r\nvoid testPutNoMap() {\r\n    final FileLocator fileLocator = FileLocatorUtils.fileLocator().create();\r\n    assertThrows(IllegalArgumentException.class, () -> FileLocatorUtils.put(fileLocator, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileLocatorUtils.java",
  "methodName" : "testStoreFileLocatorInMap",
  "sourceCode" : "/**\r\n * Tests whether a file locator can be stored in a map and read again from there.\r\n */\r\n@Test\r\nvoid testStoreFileLocatorInMap() {\r\n    final FileLocationStrategy strategy = mock(FileLocationStrategy.class);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(BASE_PATH).encoding(ENCODING).fileName(FILE_NAME).fileSystem(fileSystem).locationStrategy(strategy).sourceURL(sourceURL).create();\r\n    final Map<String, Object> map = new HashMap<>();\r\n    FileLocatorUtils.put(locator, map);\r\n    final FileLocator locator2 = FileLocatorUtils.fromMap(map);\r\n    assertEquals(locator, locator2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestFileSystemLocationStrategy.java",
  "methodName" : "testLocate",
  "sourceCode" : "/**\r\n * Tests a locate() operation.\r\n */\r\n@Test\r\nvoid testLocate() {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final URL url = ConfigurationAssert.getTestURL(\"test.xml\");\r\n    final String basePath = \"testBasePath\";\r\n    final String fileName = \"testFileName.txt\";\r\n    when(fs.locateFromURL(basePath, fileName)).thenReturn(url);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(basePath).fileName(fileName).fileSystem(FileLocatorUtils.DEFAULT_FILE_SYSTEM).sourceURL(ConfigurationAssert.getTestURL(\"test.properties\")).create();\r\n    assertSame(url, strategy.locate(fs, locator));\r\n    verify(fs).locateFromURL(basePath, fileName);\r\n    verifyNoMoreInteractions(fs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestHomeDirectoryLocationStrategy.java",
  "methodName" : "testInitDefaults",
  "sourceCode" : "/**\r\n * Tests whether default values are correctly set by the constructor.\r\n */\r\n@Test\r\nvoid testInitDefaults() {\r\n    final HomeDirectoryLocationStrategy strategy = new HomeDirectoryLocationStrategy();\r\n    assertEquals(SystemProperties.getUserHome(), strategy.getHomeDirectory());\r\n    assertFalse(strategy.isEvaluateBasePath());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestHomeDirectoryLocationStrategy.java",
  "methodName" : "testLocateFailedWithBasePath",
  "sourceCode" : "/**\r\n * Tests whether the base is actually evaluated if the flag is set.\r\n */\r\n@Test\r\nvoid testLocateFailedWithBasePath() throws IOException {\r\n    newFile(FILE_NAME, tempFolder);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(FILE_NAME).create();\r\n    final HomeDirectoryLocationStrategy strategy = setUpStrategy(true);\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestHomeDirectoryLocationStrategy.java",
  "methodName" : "testLocateSuccessIgnoreBasePath",
  "sourceCode" : "/**\r\n * Tests whether a file can be located if the base path is ignored.\r\n */\r\n@Test\r\nvoid testLocateSuccessIgnoreBasePath() throws IOException {\r\n    final File file = newFile(FILE_NAME, tempFolder);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(FILE_NAME).create();\r\n    final HomeDirectoryLocationStrategy strategy = setUpStrategy(false);\r\n    final URL url = strategy.locate(fileSystem, locator);\r\n    assertEquals(file.getAbsoluteFile(), FileLocatorUtils.fileFromURL(url).getAbsoluteFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestHomeDirectoryLocationStrategy.java",
  "methodName" : "testLocateSuccessInSubFolder",
  "sourceCode" : "/**\r\n * Tests whether a file in a sub folder can be located.\r\n */\r\n@Test\r\nvoid testLocateSuccessInSubFolder() throws IOException {\r\n    final File sub = newFolder(BASE_PATH, tempFolder);\r\n    final File file = new File(sub, FILE_NAME);\r\n    assertTrue(file.createNewFile());\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(BASE_PATH).fileName(FILE_NAME).create();\r\n    final HomeDirectoryLocationStrategy strategy = setUpStrategy(true);\r\n    final URL url = strategy.locate(fileSystem, locator);\r\n    assertEquals(file.getAbsoluteFile(), FileLocatorUtils.fileFromURL(url).getAbsoluteFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestHomeDirectoryLocationStrategy.java",
  "methodName" : "testLocateSuccessNoBasePath",
  "sourceCode" : "/**\r\n * Tests a locate() operation which evaluates the base path if no base path is set.\r\n */\r\n@Test\r\nvoid testLocateSuccessNoBasePath() throws IOException {\r\n    final File file = newFile(FILE_NAME, tempFolder);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().fileName(FILE_NAME).create();\r\n    final HomeDirectoryLocationStrategy strategy = setUpStrategy(true);\r\n    final URL url = strategy.locate(fileSystem, locator);\r\n    assertEquals(file.getAbsoluteFile(), FileLocatorUtils.fileFromURL(url).getAbsoluteFile());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestHomeDirectoryLocationStrategy.java",
  "methodName" : "testNoFileName",
  "sourceCode" : "/**\r\n * Tests a locate() operation if no file name is specified.\r\n */\r\n@Test\r\nvoid testNoFileName() {\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(BASE_PATH).create();\r\n    final HomeDirectoryLocationStrategy strategy = setUpStrategy(true);\r\n    assertNull(strategy.locate(fileSystem, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestProvidedURLLocationStrategy.java",
  "methodName" : "testLocateFail",
  "sourceCode" : "/**\r\n * Tests a failed locate() operation.\r\n */\r\n@Test\r\nvoid testLocateFail() {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().basePath(\"somePath\").fileName(\"someFile.xml\").create();\r\n    assertNull(strategy.locate(fs, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\io\\TestProvidedURLLocationStrategy.java",
  "methodName" : "testLocateSuccess",
  "sourceCode" : "/**\r\n * Tests a successful locate() operation.\r\n */\r\n@Test\r\nvoid testLocateSuccess() {\r\n    final FileSystem fs = mock(FileSystem.class);\r\n    final URL url = ConfigurationAssert.getTestURL(\"test.xml\");\r\n    final FileLocator locator = FileLocatorUtils.fileLocator().sourceURL(url).create();\r\n    assertSame(url, strategy.locate(fs, locator));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\AbstractTestPListEvents.java",
  "methodName" : "testAddByteArrayPropertyEvent",
  "sourceCode" : "/**\r\n * Tests the events generated by an added byte array property.\r\n */\r\n@Test\r\nvoid testAddByteArrayPropertyEvent() {\r\n    config.addProperty(TEST_PROPBYTE, TEST_DATA);\r\n    listener.checkEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPBYTE, TEST_DATA, true);\r\n    listener.checkEvent(ConfigurationEvent.ADD_PROPERTY, TEST_PROPBYTE, TEST_DATA, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\AbstractTestPListEvents.java",
  "methodName" : "testSetByteArrayPropertyEvent",
  "sourceCode" : "/**\r\n * Tests the events generated by setting a byte array property.\r\n */\r\n@Test\r\nvoid testSetByteArrayPropertyEvent() {\r\n    config.setProperty(TEST_PROPBYTE, TEST_DATA);\r\n    listener.checkEvent(ConfigurationEvent.SET_PROPERTY, TEST_PROPBYTE, TEST_DATA, true);\r\n    listener.checkEvent(ConfigurationEvent.SET_PROPERTY, TEST_PROPBYTE, TEST_DATA, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testAddDataProperty",
  "sourceCode" : "/**\r\n * Ensure that addProperty doesn't alter an array of byte\r\n */\r\n@Test\r\nvoid testAddDataProperty() throws Exception {\r\n    final File saveFile = newFile(tempFolder);\r\n    final byte[] expected = { 1, 2, 3, 4 };\r\n    config = new PropertyListConfiguration();\r\n    config.addProperty(\"foo\", expected);\r\n    saveConfig(saveFile);\r\n    final PropertyListConfiguration config2 = new PropertyListConfiguration();\r\n    load(config2, saveFile);\r\n    final Object array = config2.getProperty(\"foo\");\r\n    assertNotNull(array);\r\n    assertEquals(byte[].class, array.getClass());\r\n    assertArrayEquals(expected, (byte[]) array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testArray",
  "sourceCode" : "@Test\r\nvoid testArray() {\r\n    final List<?> list = assertInstanceOf(List.class, config.getProperty(\"array\"));\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\", \"value3\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testData",
  "sourceCode" : "@Test\r\nvoid testData() {\r\n    final byte[] bytes = assertInstanceOf(byte[].class, config.getProperty(\"data\"));\r\n    assertArrayEquals(\"foo bar\".getBytes(), bytes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testDate",
  "sourceCode" : "@Test\r\nvoid testDate() throws Exception {\r\n    final Calendar cal = Calendar.getInstance();\r\n    cal.clear();\r\n    cal.set(2002, Calendar.MARCH, 22, 11, 30, 0);\r\n    cal.setTimeZone(TimeZone.getTimeZone(\"GMT+0100\"));\r\n    final Date date = cal.getTime();\r\n    assertEquals(date, config.getProperty(\"date\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testDictionary",
  "sourceCode" : "@Test\r\nvoid testDictionary() {\r\n    assertEquals(\"bar1\", config.getProperty(\"dictionary.foo1\"));\r\n    assertEquals(\"bar2\", config.getProperty(\"dictionary.foo2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testDictionaryArray",
  "sourceCode" : "@Test\r\nvoid testDictionaryArray() {\r\n    final String key = \"dictionary-array\";\r\n    final Object array = config.getProperty(key);\r\n    // root array\r\n    assertNotNull(array);\r\n    assertInstanceOf(List.class, array);\r\n    final List<?> list = config.getList(key);\r\n    assertEquals(2, list.size());\r\n    // 1st dictionary\r\n    final Configuration conf1 = assertInstanceOf(Configuration.class, list.get(0));\r\n    assertFalse(conf1.isEmpty());\r\n    assertEquals(\"bar\", conf1.getProperty(\"foo\"));\r\n    // 2nd dictionary\r\n    final Configuration conf2 = assertInstanceOf(Configuration.class, list.get(1));\r\n    assertFalse(conf2.isEmpty());\r\n    assertEquals(\"value\", conf2.getProperty(\"key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testEmptyArray",
  "sourceCode" : "@Test\r\nvoid testEmptyArray() {\r\n    final String key = \"empty-array\";\r\n    assertNotNull(config.getProperty(key));\r\n    final List<?> list = (List<?>) config.getProperty(key);\r\n    assertTrue(list.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testFormatDate",
  "sourceCode" : "/**\r\n * Tests formatting a date.\r\n */\r\n@Test\r\nvoid testFormatDate() {\r\n    final Calendar cal = Calendar.getInstance();\r\n    cal.clear();\r\n    cal.set(2007, Calendar.OCTOBER, 29, 23, 4, 30);\r\n    cal.setTimeZone(TimeZone.getTimeZone(\"GMT-0230\"));\r\n    assertEquals(\"<*D2007-10-29 23:04:30 -0230>\", PropertyListConfiguration.formatDate(cal));\r\n    cal.clear();\r\n    cal.set(2007, Calendar.OCTOBER, 30, 22, 2, 15);\r\n    cal.setTimeZone(TimeZone.getTimeZone(\"GMT+1111\"));\r\n    assertEquals(\"<*D2007-10-30 22:02:15 +1111>\", PropertyListConfiguration.formatDate(cal));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testInitCopy",
  "sourceCode" : "@Test\r\nvoid testInitCopy() {\r\n    final PropertyListConfiguration copy = new PropertyListConfiguration(config);\r\n    assertFalse(copy.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testLoad",
  "sourceCode" : "@Test\r\nvoid testLoad() {\r\n    assertFalse(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testLoadWithError",
  "sourceCode" : "@Test\r\nvoid testLoadWithError() {\r\n    config = new PropertyListConfiguration();\r\n    final FileHandler fileHandler = new FileHandler(config);\r\n    final StringReader reader = new StringReader(\"\");\r\n    final ConfigurationException e = assertThrows(ConfigurationException.class, () -> fileHandler.load(reader));\r\n    assertNotNull(e.getMessage());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testNestedArrays",
  "sourceCode" : "@Test\r\nvoid testNestedArrays() {\r\n    final String key = \"nested-arrays\";\r\n    final Object array = config.getProperty(key);\r\n    // root array\r\n    assertNotNull(array);\r\n    assertInstanceOf(List.class, array);\r\n    final List<?> list = config.getList(key);\r\n    assertEquals(2, list.size());\r\n    // 1st array\r\n    final List<?> list1 = assertInstanceOf(List.class, list.get(0));\r\n    assertEquals(Arrays.asList(\"a\", \"b\"), list1);\r\n    // 2nd array\r\n    final List<?> list2 = assertInstanceOf(List.class, list.get(1));\r\n    assertEquals(Arrays.asList(\"c\", \"d\"), list2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testNestedDictionaries",
  "sourceCode" : "@Test\r\nvoid testNestedDictionaries() {\r\n    assertEquals(\"value\", config.getString(\"nested-dictionaries.foo.bar.key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testParseDateInvalidChar",
  "sourceCode" : "/**\r\n * Tests parsing a date that contains an invalid separator character.\r\n */\r\n@Test\r\nvoid testParseDateInvalidChar() {\r\n    assertThrows(ParseException.class, () -> PropertyListConfiguration.parseDate(\"<*D2002+03-22 11:30:00 +0100>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testParseDateNoNumber",
  "sourceCode" : "/**\r\n * Tests parsing a date with an invalid numeric value.\r\n */\r\n@Test\r\nvoid testParseDateNoNumber() {\r\n    assertThrows(ParseException.class, () -> PropertyListConfiguration.parseDate(\"<*D2002-03-22 1c:30:00 +0100>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testParseDateNull",
  "sourceCode" : "/**\r\n * Tries parsing a null date. This should cause an exception.n\r\n */\r\n@Test\r\nvoid testParseDateNull() {\r\n    assertThrows(ParseException.class, () -> PropertyListConfiguration.parseDate(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testParseDateTooShort",
  "sourceCode" : "/**\r\n * Tests parsing a date that is not long enough.\r\n */\r\n@Test\r\nvoid testParseDateTooShort() {\r\n    assertThrows(ParseException.class, () -> PropertyListConfiguration.parseDate(\"<*D2002-03-22 11:3>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testQuotedString",
  "sourceCode" : "@Test\r\nvoid testQuotedString() {\r\n    assertEquals(\"string2\", config.getProperty(\"quoted-string\"));\r\n    assertEquals(\"this is a string\", config.getProperty(\"quoted-string2\"));\r\n    assertEquals(\"this is a \\\"complex\\\" string {(=,;)}\", config.getProperty(\"complex-string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testQuoteString",
  "sourceCode" : "@Test\r\nvoid testQuoteString() {\r\n    assertNull(config.quoteString(null));\r\n    assertEquals(\"abcd\", config.quoteString(\"abcd\"));\r\n    assertEquals(\"\\\"ab cd\\\"\", config.quoteString(\"ab cd\"));\r\n    assertEquals(\"\\\"foo\\\\\\\"bar\\\"\", config.quoteString(\"foo\\\"bar\"));\r\n    assertEquals(\"\\\"foo;bar\\\"\", config.quoteString(\"foo;bar\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "@Test\r\nvoid testSave() throws Exception {\r\n    final File savedFile = newFile(\"testsave.plist\", tempFolder);\r\n    // save the configuration\r\n    saveConfig(savedFile);\r\n    assertTrue(savedFile.exists());\r\n    // read the configuration and compare the properties\r\n    final PropertyListConfiguration checkConfig = new PropertyListConfiguration();\r\n    load(checkConfig, savedFile);\r\n    final Iterator<String> it = config.getKeys();\r\n    while (it.hasNext()) {\r\n        final String key = it.next();\r\n        assertTrue(checkConfig.containsKey(key), \"The saved configuration doesn't contain the key '\" + key + \"'\");\r\n        final Object value = checkConfig.getProperty(key);\r\n        if (value instanceof byte[]) {\r\n            final byte[] array = (byte[]) value;\r\n            assertArrayEquals((byte[]) config.getProperty(key), array, \"Value of the '\" + key + \"' property\");\r\n        } else if (value instanceof List) {\r\n            final List<?> list1 = (List<?>) config.getProperty(key);\r\n            final List<?> list2 = (List<?>) value;\r\n            assertEquals(list1.size(), list2.size(), \"The size of the list for the key '\" + key + \"' doesn't match\");\r\n            for (int i = 0; i < list2.size(); i++) {\r\n                final Object value1 = list1.get(i);\r\n                final Object value2 = list2.get(i);\r\n                if (value1 instanceof Configuration) {\r\n                    final ConfigurationComparator comparator = new StrictConfigurationComparator();\r\n                    assertTrue(comparator.compare((Configuration) value1, (Configuration) value2), \"The dictionnary at index \" + i + \" for the key '\" + key + \"' doesn't match\");\r\n                } else {\r\n                    assertEquals(value1, value2, \"Element at index \" + i + \" for the key '\" + key + \"'\");\r\n                }\r\n            }\r\n            assertEquals(config.getProperty(key), list1, \"Value of the '\" + key + \"' property\");\r\n        } else {\r\n            assertEquals(config.getProperty(key), checkConfig.getProperty(key), \"Value of the '\" + key + \"' property\");\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testSaveEmptyDictionary",
  "sourceCode" : "@Test\r\nvoid testSaveEmptyDictionary() throws Exception {\r\n    final File savedFile = newFile(\"testsave.plist\", tempFolder);\r\n    // save the configuration\r\n    saveConfig(savedFile);\r\n    assertTrue(savedFile.exists());\r\n    // read the configuration and compare the properties\r\n    final PropertyListConfiguration checkConfig = new PropertyListConfiguration();\r\n    load(checkConfig, savedFile);\r\n    assertFalse(getNamedChildren(config, \"empty-dictionary\").isEmpty());\r\n    assertFalse(getNamedChildren(checkConfig, \"empty-dictionary\").isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testSetDataProperty",
  "sourceCode" : "/**\r\n * Ensure that setProperty doesn't alter an array of byte since it's a first class type in plist file\r\n */\r\n@Test\r\nvoid testSetDataProperty() throws Exception {\r\n    final File saveFile = newFile(tempFolder);\r\n    final byte[] expected = { 1, 2, 3, 4 };\r\n    config = new PropertyListConfiguration();\r\n    config.setProperty(\"foo\", expected);\r\n    saveConfig(saveFile);\r\n    final PropertyListConfiguration config2 = new PropertyListConfiguration();\r\n    load(config2, saveFile);\r\n    final Object array = config2.getProperty(\"foo\");\r\n    assertNotNull(array);\r\n    assertEquals(byte[].class, array.getClass());\r\n    assertArrayEquals(expected, (byte[]) array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListConfiguration.java",
  "methodName" : "testString",
  "sourceCode" : "@Test\r\nvoid testString() {\r\n    assertEquals(\"string1\", config.getProperty(\"simple-string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListParser.java",
  "methodName" : "testFilterData",
  "sourceCode" : "@Test\r\nvoid testFilterData() throws Exception {\r\n    final byte[] expected = { 0x20, 0x20 };\r\n    assertArrayEquals(null, parser.filterData(null));\r\n    assertArrayEquals(expected, parser.filterData(\"<2020>\"));\r\n    assertArrayEquals(expected, parser.filterData(\"2020\"));\r\n    assertArrayEquals(expected, parser.filterData(\"20 20\"));\r\n    assertArrayEquals(new byte[] { 9, 0x20 }, parser.filterData(\"920\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListParser.java",
  "methodName" : "testParseDate",
  "sourceCode" : "@Test\r\nvoid testParseDate() throws Exception {\r\n    final Calendar calendar = Calendar.getInstance();\r\n    calendar.set(Calendar.YEAR, 2002);\r\n    calendar.set(Calendar.MONTH, Calendar.MARCH);\r\n    calendar.set(Calendar.DAY_OF_MONTH, 22);\r\n    calendar.set(Calendar.HOUR_OF_DAY, 11);\r\n    calendar.set(Calendar.MINUTE, 30);\r\n    calendar.set(Calendar.SECOND, 0);\r\n    calendar.set(Calendar.MILLISECOND, 0);\r\n    calendar.setTimeZone(new SimpleTimeZone(60 * 60 * 1000, \"Apache/Jakarta\"));\r\n    assertEquals(calendar.getTime(), parser.parseDate(\"<*D2002-03-22 11:30:00 +0100>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListParser.java",
  "methodName" : "testRemoveQuotes",
  "sourceCode" : "@Test\r\nvoid testRemoveQuotes() {\r\n    assertEquals(\"abc\", parser.removeQuotes(\"abc\"));\r\n    assertEquals(\"abc\", parser.removeQuotes(\"\\\"abc\\\"\"));\r\n    assertEquals(\"\", parser.removeQuotes(\"\\\"\\\"\"));\r\n    assertEquals(\"\", parser.removeQuotes(\"\"));\r\n    assertNull(parser.removeQuotes(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestPropertyListParser.java",
  "methodName" : "testUnescapeQuotes",
  "sourceCode" : "@Test\r\nvoid testUnescapeQuotes() {\r\n    assertEquals(\"aaa\\\"bbb\\\"ccc\", parser.unescapeQuotes(\"aaa\\\"bbb\\\"ccc\"));\r\n    assertEquals(\"aaa\\\"bbb\\\"ccc\", parser.unescapeQuotes(\"aaa\\\\\\\"bbb\\\\\\\"ccc\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testAddArray",
  "sourceCode" : "/**\r\n * Tests whether an array can be added correctly. This test is related to CONFIGURATION-427.\r\n */\r\n@Test\r\nvoid testAddArray() throws ConfigurationException {\r\n    final Object[] elems = { \"arrayElem1\", \"arrayElem2\", \"arrayElem3\" };\r\n    config = new XMLPropertyListConfiguration();\r\n    config.addProperty(\"array\", elems);\r\n    checkArrayProperty(Arrays.asList(elems));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testAddDataProperty",
  "sourceCode" : "/**\r\n * Ensure that addProperty doesn't alter an array of byte\r\n */\r\n@Test\r\nvoid testAddDataProperty() throws Exception {\r\n    final File savedFile = newFile(tempFolder);\r\n    final byte[] expected = { 1, 2, 3, 4 };\r\n    config = new XMLPropertyListConfiguration();\r\n    config.addProperty(\"foo\", expected);\r\n    save(savedFile);\r\n    final XMLPropertyListConfiguration config2 = new XMLPropertyListConfiguration();\r\n    load(config2, savedFile);\r\n    final Object array = config2.getProperty(\"foo\");\r\n    assertNotNull(array);\r\n    assertEquals(byte[].class, array.getClass());\r\n    assertArrayEquals(expected, (byte[]) array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testAddList",
  "sourceCode" : "/**\r\n * Tests whether a list can be added correctly. This test is related to CONFIGURATION-427.\r\n */\r\n@Test\r\nvoid testAddList() throws ConfigurationException {\r\n    final List<String> elems = Arrays.asList(\"element1\", \"element2\", \"anotherElement\");\r\n    config = new XMLPropertyListConfiguration();\r\n    config.addProperty(\"array\", elems);\r\n    checkArrayProperty(elems);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testArray",
  "sourceCode" : "@Test\r\nvoid testArray() {\r\n    final Object array = config.getProperty(\"array\");\r\n    assertInstanceOf(List.class, array);\r\n    final List<?> list = config.getList(\"array\");\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\", \"value3\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testBoolean",
  "sourceCode" : "@Test\r\nvoid testBoolean() throws Exception {\r\n    assertTrue(config.getBoolean(\"boolean1\"));\r\n    assertFalse(config.getBoolean(\"boolean2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testDate",
  "sourceCode" : "@Test\r\nvoid testDate() throws Exception {\r\n    final Calendar calendar = Calendar.getInstance();\r\n    calendar.clear();\r\n    calendar.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n    calendar.set(2005, Calendar.JANUARY, 1, 12, 0, 0);\r\n    assertEquals(calendar.getTime(), config.getProperty(\"date\"));\r\n    calendar.setTimeZone(TimeZone.getTimeZone(\"CET\"));\r\n    calendar.set(2002, Calendar.MARCH, 22, 11, 30, 0);\r\n    assertEquals(calendar.getTime(), config.getProperty(\"date-gnustep\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testDictionary",
  "sourceCode" : "@Test\r\nvoid testDictionary() {\r\n    assertEquals(\"value1\", config.getProperty(\"dictionary.key1\"));\r\n    assertEquals(\"value2\", config.getProperty(\"dictionary.key2\"));\r\n    assertEquals(\"value3\", config.getProperty(\"dictionary.key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testDictionaryArray",
  "sourceCode" : "@Test\r\nvoid testDictionaryArray() {\r\n    final String key = \"dictionary-array\";\r\n    final Object array = config.getProperty(key);\r\n    // root array\r\n    assertNotNull(array);\r\n    assertInstanceOf(List.class, array);\r\n    final List<?> list = config.getList(key);\r\n    assertEquals(2, list.size());\r\n    // 1st dictionary\r\n    final Configuration conf1 = assertInstanceOf(Configuration.class, list.get(0));\r\n    assertFalse(conf1.isEmpty());\r\n    assertEquals(\"bar\", conf1.getProperty(\"foo\"));\r\n    // 2nd dictionary\r\n    final Configuration conf2 = assertInstanceOf(Configuration.class, list.get(1));\r\n    assertFalse(conf2.isEmpty());\r\n    assertEquals(\"value\", conf2.getProperty(\"key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testInitCopy",
  "sourceCode" : "@Test\r\nvoid testInitCopy() {\r\n    final XMLPropertyListConfiguration copy = new XMLPropertyListConfiguration(config);\r\n    final StrictConfigurationComparator comp = new StrictConfigurationComparator();\r\n    assertTrue(comp.compare(config, copy));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testInteger",
  "sourceCode" : "@Test\r\nvoid testInteger() throws Exception {\r\n    assertEquals(12345678900L, config.getLong(\"integer\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testLoadNoDict",
  "sourceCode" : "/**\r\n * Tests whether a configuration can be loaded that does not start with a {@code dict} element. This test case is\r\n * related to CONFIGURATION-405.\r\n */\r\n@Test\r\nvoid testLoadNoDict() throws ConfigurationException {\r\n    final XMLPropertyListConfiguration plist = new XMLPropertyListConfiguration();\r\n    load(plist, ConfigurationAssert.getTestFile(\"test2.plist.xml\"));\r\n    assertFalse(plist.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testLoadNoDictConstr",
  "sourceCode" : "/**\r\n * Tests whether a configuration that does not start with a {@code dict} element can be loaded from a constructor. This\r\n * test case is related to CONFIGURATION-405.\r\n */\r\n@Test\r\nvoid testLoadNoDictConstr() throws ConfigurationException {\r\n    final XMLPropertyListConfiguration plist = new XMLPropertyListConfiguration();\r\n    load(plist, ConfigurationAssert.getTestFile(\"test2.plist.xml\"));\r\n    assertFalse(plist.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testNested",
  "sourceCode" : "@Test\r\nvoid testNested() {\r\n    assertEquals(\"value\", config.getString(\"nested.node1.node2.node3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testNestedArray",
  "sourceCode" : "@Test\r\nvoid testNestedArray() {\r\n    final String key = \"nested-array\";\r\n    final Object array = config.getProperty(key);\r\n    // root array\r\n    assertNotNull(array);\r\n    assertInstanceOf(List.class, array);\r\n    final List<?> list = config.getList(key);\r\n    assertEquals(2, list.size());\r\n    // 1st array\r\n    final List<?> list1 = assertInstanceOf(List.class, list.get(0));\r\n    assertEquals(Arrays.asList(\"a\", \"b\"), list1);\r\n    // 2nd array\r\n    final List<?> list2 = assertInstanceOf(List.class, list.get(1));\r\n    assertEquals(Arrays.asList(\"c\", \"d\"), list2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testReal",
  "sourceCode" : "@Test\r\nvoid testReal() throws Exception {\r\n    assertEquals(-12.345, config.getDouble(\"real\"), 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "@Test\r\nvoid testSave() throws Exception {\r\n    final File savedFile = newFile(tempFolder);\r\n    // add an array of strings to the configuration\r\n    /*\r\n         * config.addProperty(\"string\", \"value1\"); List list = new ArrayList(); for (int i = 1; i < 5; i++) { list.add(\"value\" +\r\n         * i); } config.addProperty(\"newarray\", list);\r\n         */\r\n    // todo : investigate why the array structure of 'newarray' is lost in the saved file\r\n    // add a map of strings\r\n    /*\r\n         * Map map = new HashMap(); map.put(\"foo\", \"bar\"); map.put(\"int\", new Integer(123)); config.addProperty(\"newmap\", map);\r\n         */\r\n    // todo : a Map added to a HierarchicalConfiguration should be decomposed as list of nodes\r\n    // save the configuration\r\n    save(savedFile);\r\n    assertTrue(savedFile.exists());\r\n    // read the configuration and compare the properties\r\n    final XMLPropertyListConfiguration checkConfig = new XMLPropertyListConfiguration();\r\n    load(checkConfig, savedFile);\r\n    final Iterator<String> it = config.getKeys();\r\n    while (it.hasNext()) {\r\n        final String key = it.next();\r\n        assertTrue(checkConfig.containsKey(key), \"The saved configuration doesn't contain the key '\" + key + \"'\");\r\n        final Object value = checkConfig.getProperty(key);\r\n        if (value instanceof byte[]) {\r\n            final byte[] array = (byte[]) value;\r\n            assertArrayEquals((byte[]) config.getProperty(key), array, \"Value of the '\" + key + \"' property\");\r\n        } else if (value instanceof List) {\r\n            final List<?> list1 = (List<?>) config.getProperty(key);\r\n            final List<?> list2 = (List<?>) value;\r\n            assertEquals(list1.size(), list2.size(), \"The size of the list for the key '\" + key + \"' doesn't match\");\r\n            for (int i = 0; i < list2.size(); i++) {\r\n                final Object value1 = list1.get(i);\r\n                final Object value2 = list2.get(i);\r\n                if (value1 instanceof Configuration) {\r\n                    final ConfigurationComparator comparator = new StrictConfigurationComparator();\r\n                    assertTrue(comparator.compare((Configuration) value1, (Configuration) value2), \"The dictionnary at index \" + i + \" for the key '\" + key + \"' doesn't match\");\r\n                } else {\r\n                    assertEquals(value1, value2, \"Element at index \" + i + \" for the key '\" + key + \"'\");\r\n                }\r\n            }\r\n            assertEquals(config.getProperty(key), list1, \"Value of the '\" + key + \"' property\");\r\n        } else {\r\n            assertEquals(config.getProperty(key), checkConfig.getProperty(key), \"Value of the '\" + key + \"' property\");\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSaveEmptyDictionary",
  "sourceCode" : "@Test\r\nvoid testSaveEmptyDictionary() throws Exception {\r\n    final File savedFile = newFile(tempFolder);\r\n    // save the configuration\r\n    save(savedFile);\r\n    assertTrue(savedFile.exists());\r\n    // read the configuration and compare the properties\r\n    final XMLPropertyListConfiguration checkConfig = new XMLPropertyListConfiguration();\r\n    load(checkConfig, savedFile);\r\n    assertNull(config.getProperty(\"empty-dictionary\"));\r\n    assertNull(checkConfig.getProperty(\"empty-dictionary\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSaveNoEncoding",
  "sourceCode" : "/**\r\n * Tests the header of a saved file if no encoding is specified.\r\n */\r\n@Test\r\nvoid testSaveNoEncoding() throws ConfigurationException {\r\n    final StringWriter writer = new StringWriter();\r\n    new FileHandler(config).save(writer);\r\n    assertTrue(writer.toString().contains(\"<?xml version=\\\"1.0\\\"?>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSaveWithEncoding",
  "sourceCode" : "/**\r\n * Tests whether the encoding is written when saving a configuration.\r\n */\r\n@Test\r\nvoid testSaveWithEncoding() throws ConfigurationException {\r\n    final String encoding = StandardCharsets.UTF_8.name();\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.setEncoding(encoding);\r\n    final StringWriter writer = new StringWriter();\r\n    handler.save(writer);\r\n    assertTrue(writer.toString().contains(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + encoding + \"\\\"?>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSetArray",
  "sourceCode" : "/**\r\n * Tests whether an array can be set correctly. This test is related to CONFIGURATION-750.\r\n */\r\n@Test\r\nvoid testSetArray() throws ConfigurationException {\r\n    final Object[] elems = { \"arrayElem1\", \"arrayElem2\", \"arrayElem3\" };\r\n    config = new XMLPropertyListConfiguration();\r\n    config.setProperty(\"array\", elems);\r\n    checkArrayProperty(Arrays.asList(elems));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSetDataProperty",
  "sourceCode" : "/**\r\n * Ensure that setProperty doesn't alter an array of byte since it's a first class type in plist file\r\n */\r\n@Test\r\nvoid testSetDataProperty() throws Exception {\r\n    final File savedFile = newFile(tempFolder);\r\n    final byte[] expected = { 1, 2, 3, 4 };\r\n    config = new XMLPropertyListConfiguration();\r\n    config.setProperty(\"foo\", expected);\r\n    save(savedFile);\r\n    final XMLPropertyListConfiguration config2 = new XMLPropertyListConfiguration();\r\n    load(config2, savedFile);\r\n    final Object array = config2.getProperty(\"foo\");\r\n    assertNotNull(array);\r\n    assertEquals(byte[].class, array.getClass());\r\n    assertArrayEquals(expected, (byte[]) array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSetDatePropertyInvalid",
  "sourceCode" : "/**\r\n * Tests a configuration file which contains an invalid date property value. This test is related to CONFIGURATION-501.\r\n */\r\n@Test\r\nvoid testSetDatePropertyInvalid() throws ConfigurationException {\r\n    config.clear();\r\n    load(config, ConfigurationAssert.getTestFile(\"test_invalid_date.plist.xml\"));\r\n    assertEquals(\"value1\", config.getString(\"string\"));\r\n    assertFalse(config.containsKey(\"date\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSetList",
  "sourceCode" : "/**\r\n * Tests whether a list can be set correctly. This test is related to CONFIGURATION-750.\r\n */\r\n@Test\r\nvoid testSetList() throws ConfigurationException {\r\n    final List<String> elems = Arrays.asList(\"element1\", \"element2\", \"anotherElement\");\r\n    config = new XMLPropertyListConfiguration();\r\n    config.setProperty(\"array\", elems);\r\n    checkArrayProperty(elems);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testString",
  "sourceCode" : "@Test\r\nvoid testString() throws Exception {\r\n    assertEquals(\"value1\", config.getString(\"string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testSubset",
  "sourceCode" : "@Test\r\nvoid testSubset() {\r\n    final Configuration subset = config.subset(\"dictionary\");\r\n    final Iterator<String> keys = subset.getKeys();\r\n    String key = keys.next();\r\n    assertEquals(\"key1\", key);\r\n    assertEquals(\"value1\", subset.getString(key));\r\n    key = keys.next();\r\n    assertEquals(\"key2\", key);\r\n    assertEquals(\"value2\", subset.getString(key));\r\n    key = keys.next();\r\n    assertEquals(\"key3\", key);\r\n    assertEquals(\"value3\", subset.getString(key));\r\n    assertFalse(keys.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\plist\\TestXMLPropertyListConfiguration.java",
  "methodName" : "testWriteCalledDirectly",
  "sourceCode" : "/**\r\n * Tests a direct invocation of the write() method. This test is related to CONFIGURATION-641.\r\n */\r\n@Test\r\nvoid testWriteCalledDirectly() throws IOException {\r\n    config = new XMLPropertyListConfiguration();\r\n    config.addProperty(\"foo\", \"bar\");\r\n    try (Writer out = new FileWriter(newFile(tempFolder))) {\r\n        final ConfigurationException e = assertThrows(ConfigurationException.class, () -> config.write(out));\r\n        assertTrue(e.getMessage().contains(\"FileHandler\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestCombinedReloadingController.java",
  "methodName" : "testCheckForReloadingFalse",
  "sourceCode" : "/**\r\n * Tests a check for a reloading operation which results in false.\r\n */\r\n@Test\r\nvoid testCheckForReloadingFalse() {\r\n    final CombinedReloadingController ctrl = setUpController();\r\n    for (final ReloadingController rc : subControllers) {\r\n        when(rc.checkForReloading(null)).thenReturn(Boolean.FALSE);\r\n    }\r\n    assertFalse(ctrl.checkForReloading(\"someParam\"));\r\n    for (final ReloadingController rc : subControllers) {\r\n        verify(rc).checkForReloading(null);\r\n        verifyNoMoreInteractions(rc);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestCombinedReloadingController.java",
  "methodName" : "testCheckForReloadingTrue",
  "sourceCode" : "/**\r\n * Tests a check for a reloading operation which results in true.\r\n */\r\n@Test\r\nvoid testCheckForReloadingTrue() {\r\n    final CombinedReloadingController ctrl = setUpController();\r\n    when(subControllers[0].checkForReloading(null)).thenReturn(Boolean.FALSE);\r\n    when(subControllers[1].checkForReloading(null)).thenReturn(Boolean.TRUE);\r\n    when(subControllers[2].checkForReloading(null)).thenReturn(Boolean.FALSE);\r\n    assertTrue(ctrl.checkForReloading(\"someData\"));\r\n    for (final ReloadingController rc : subControllers) {\r\n        verify(rc).checkForReloading(null);\r\n        verifyNoMoreInteractions(rc);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestCombinedReloadingController.java",
  "methodName" : "testGetSubControllers",
  "sourceCode" : "/**\r\n * Tests whether the sub controllers can be accessed.\r\n */\r\n@Test\r\nvoid testGetSubControllers() {\r\n    final CombinedReloadingController ctrl = setUpController();\r\n    final Collection<ReloadingController> subs = ctrl.getSubControllers();\r\n    assertIterableEquals(Arrays.asList(subControllers), subs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestCombinedReloadingController.java",
  "methodName" : "testGetSubControllersModify",
  "sourceCode" : "/**\r\n * Tests that the list of sub controllers cannot be manipulated.\r\n */\r\n@Test\r\nvoid testGetSubControllersModify() {\r\n    final Collection<ReloadingController> subs = setUpController().getSubControllers();\r\n    assertThrows(UnsupportedOperationException.class, subs::clear);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestCombinedReloadingController.java",
  "methodName" : "testInitNull",
  "sourceCode" : "/**\r\n * Tries to create an instance without a collection.\r\n */\r\n@Test\r\nvoid testInitNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> new CombinedReloadingController(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestCombinedReloadingController.java",
  "methodName" : "testInitNullEntries",
  "sourceCode" : "/**\r\n * Tries to create an instance with a collection containing a null entry.\r\n */\r\n@Test\r\nvoid testInitNullEntries() {\r\n    initSubControllers();\r\n    final Collection<ReloadingController> ctrls = new ArrayList<>(Arrays.asList(subControllers));\r\n    ctrls.add(null);\r\n    assertThrows(IllegalArgumentException.class, () -> new CombinedReloadingController(ctrls));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestCombinedReloadingController.java",
  "methodName" : "testResetInitialReloadingState",
  "sourceCode" : "/**\r\n * Tests whether the sub controller's reloading state can be reset unconditionally.\r\n */\r\n@Test\r\nvoid testResetInitialReloadingState() {\r\n    final CombinedReloadingController ctrl = setUpController();\r\n    ctrl.resetInitialReloadingState();\r\n    for (final ReloadingController rc : subControllers) {\r\n        verify(rc).resetReloadingState();\r\n        verifyNoMoreInteractions(rc);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestCombinedReloadingController.java",
  "methodName" : "testResetReloadingState",
  "sourceCode" : "/**\r\n * Tests whether the reloading state can be reset.\r\n */\r\n@Test\r\nvoid testResetReloadingState() {\r\n    final CombinedReloadingController ctrl = setUpController();\r\n    when(subControllers[0].checkForReloading(null)).thenReturn(Boolean.TRUE);\r\n    when(subControllers[1].checkForReloading(null)).thenReturn(Boolean.FALSE);\r\n    when(subControllers[2].checkForReloading(null)).thenReturn(Boolean.FALSE);\r\n    ctrl.checkForReloading(null);\r\n    ctrl.resetReloadingState();\r\n    for (final ReloadingController rc : subControllers) {\r\n        verify(rc).checkForReloading(null);\r\n        verify(rc).resetReloadingState();\r\n        verifyNoMoreInteractions(rc);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testDefaultRefreshDelay",
  "sourceCode" : "/**\r\n * Tests the default refresh delay.\r\n */\r\n@Test\r\nvoid testDefaultRefreshDelay() {\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetector();\r\n    assertEquals(5000, detector.getRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testGetFileJarURL",
  "sourceCode" : "/**\r\n * Tests whether a jar URL is handled correctly.\r\n */\r\n@Test\r\nvoid testGetFileJarURL() throws Exception {\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetector();\r\n    final URL url = new URL(\"jar:\" + new File(\"conf/resources.jar\").getAbsoluteFile().toURI().toURL() + \"!/test-jar.xml\");\r\n    detector.getFileHandler().setURL(url);\r\n    final File file = detector.getFile();\r\n    assertNotNull(file);\r\n    assertEquals(\"resources.jar\", file.getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testInitWithFileHandler",
  "sourceCode" : "/**\r\n * The detector to be tested.\r\n */\r\n/**\r\n * Tests whether an instance can be created with a file handler.\r\n */\r\n@Test\r\nvoid testInitWithFileHandler() {\r\n    final FileHandler handler = new FileHandler();\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetector(handler);\r\n    assertSame(handler, detector.getFileHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testIsReloadingRequiredFileDoesNotExist",
  "sourceCode" : "/**\r\n * Tests whether a non-existing file is handled correctly.\r\n */\r\n@Test\r\nvoid testIsReloadingRequiredFileDoesNotExist() {\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetector();\r\n    detector.getFileHandler().setFile(new File(\"NonExistingFile.txt\"));\r\n    detector.reloadingPerformed();\r\n    assertFalse(detector.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testIsReloadingRequiredNoLocation",
  "sourceCode" : "/**\r\n * Tests isReloadingRequired() if no location has been set.\r\n */\r\n@Test\r\nvoid testIsReloadingRequiredNoLocation() {\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetector();\r\n    assertFalse(detector.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testIsReloadingRequiredTrue",
  "sourceCode" : "/**\r\n * Tests whether a changed file is detected.\r\n */\r\n@Test\r\nvoid testIsReloadingRequiredTrue() throws Exception {\r\n    final File f = mock(File.class);\r\n    when(f.exists()).thenReturn(Boolean.TRUE);\r\n    when(f.lastModified()).thenReturn(LAST_MODIFIED, LAST_MODIFIED + 1);\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetectorTestImpl(f);\r\n    assertFalse(detector.isReloadingRequired());\r\n    assertTrue(detector.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testLocationAfterInit",
  "sourceCode" : "/**\r\n * Tests that a newly created instance does not have a location.\r\n */\r\n@Test\r\nvoid testLocationAfterInit() {\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetector();\r\n    assertFalse(detector.getFileHandler().isLocationDefined());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testRefreshDelay",
  "sourceCode" : "/**\r\n * Tests whether the refresh delay is taken into account.\r\n */\r\n@Test\r\nvoid testRefreshDelay() throws Exception {\r\n    final File f = mock(File.class);\r\n    when(f.exists()).thenReturn(Boolean.TRUE);\r\n    when(f.lastModified()).thenReturn(LAST_MODIFIED, LAST_MODIFIED);\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetectorTestImpl(f, 60 * 60 * 1000L);\r\n    detector.reloadingPerformed();\r\n    assertFalse(detector.isReloadingRequired());\r\n    assertFalse(detector.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testRefreshIsReloadingRequiredTrue",
  "sourceCode" : "/**\r\n * Tests whether a changed file is detected after initialization and invoking refresh.\r\n */\r\n@Test\r\nvoid testRefreshIsReloadingRequiredTrue() throws Exception {\r\n    final File f = mock(File.class);\r\n    when(f.exists()).thenReturn(Boolean.TRUE);\r\n    when(f.lastModified()).thenReturn(LAST_MODIFIED, LAST_MODIFIED + 1);\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetectorTestImpl(f);\r\n    detector.refresh();\r\n    assertTrue(detector.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testRefreshReloadingAndReset",
  "sourceCode" : "/**\r\n * Tests a refresh cycle with a detected reload operation and a notification that reloading was performed.\r\n */\r\n@Test\r\nvoid testRefreshReloadingAndReset() throws Exception {\r\n    final File f = mock(File.class);\r\n    when(f.exists()).thenReturn(Boolean.TRUE);\r\n    when(f.lastModified()).thenReturn(// 2 times\r\n    LAST_MODIFIED, // 2 times\r\n    LAST_MODIFIED, // 3 times\r\n    LAST_MODIFIED + 1, // 3 times\r\n    LAST_MODIFIED + 1, // 3 times\r\n    LAST_MODIFIED + 1, LAST_MODIFIED + 2);\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetectorTestImpl(f);\r\n    detector.refresh();\r\n    assertFalse(detector.isReloadingRequired());\r\n    assertTrue(detector.isReloadingRequired());\r\n    detector.reloadingPerformed();\r\n    assertFalse(detector.isReloadingRequired());\r\n    assertTrue(detector.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestFileHandlerReloadingDetector.java",
  "methodName" : "testReloadingAndReset",
  "sourceCode" : "/**\r\n * Tests a cycle with a detected reload operation and a notification that reloading was performed.\r\n */\r\n@Test\r\nvoid testReloadingAndReset() throws Exception {\r\n    final File f = mock(File.class);\r\n    when(f.exists()).thenReturn(Boolean.TRUE);\r\n    when(f.lastModified()).thenReturn(LAST_MODIFIED, // 3 times\r\n    LAST_MODIFIED + 1, // 3 times\r\n    LAST_MODIFIED + 1, // 3 times\r\n    LAST_MODIFIED + 1, LAST_MODIFIED + 2);\r\n    final FileHandlerReloadingDetector detector = new FileHandlerReloadingDetectorTestImpl(f);\r\n    assertFalse(detector.isReloadingRequired());\r\n    assertTrue(detector.isReloadingRequired());\r\n    detector.reloadingPerformed();\r\n    assertFalse(detector.isReloadingRequired());\r\n    assertTrue(detector.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestManagedReloadingDetector.java",
  "methodName" : "testRefresh",
  "sourceCode" : "/**\r\n * Tests the refresh() method.\r\n */\r\n@Test\r\nvoid testRefresh() {\r\n    strategy.refresh();\r\n    assertTrue(strategy.isReloadingRequired());\r\n    assertTrue(strategy.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestManagedReloadingDetector.java",
  "methodName" : "testReloadingPerformed",
  "sourceCode" : "/**\r\n * Tests whether the reloading state can be reset again.\r\n */\r\n@Test\r\nvoid testReloadingPerformed() {\r\n    strategy.refresh();\r\n    strategy.reloadingPerformed();\r\n    assertFalse(strategy.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestManagedReloadingDetector.java",
  "methodName" : "testReloadingRequiredInitial",
  "sourceCode" : "/**\r\n * Tests the result of isReloadingRequired() for a newly created instance.\r\n */\r\n@Test\r\nvoid testReloadingRequiredInitial() {\r\n    assertFalse(strategy.isReloadingRequired());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testDefaultExecutor",
  "sourceCode" : "/**\r\n * Tests whether a default executor service is created if necessary.\r\n */\r\n@Test\r\nvoid testDefaultExecutor() {\r\n    final PeriodicReloadingTrigger trigger = new PeriodicReloadingTrigger(controller, CTRL_PARAM, PERIOD, UNIT);\r\n    assertNotNull(trigger.getExecutorService());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testInitNoController",
  "sourceCode" : "/**\r\n * Tries to create an instance without a controller.\r\n */\r\n@Test\r\nvoid testInitNoController() {\r\n    assertThrows(IllegalArgumentException.class, () -> new PeriodicReloadingTrigger(null, CTRL_PARAM, PERIOD, UNIT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testIsRunningAfterInit",
  "sourceCode" : "/**\r\n * Tests that a newly created trigger is not running.\r\n */\r\n@Test\r\nvoid testIsRunningAfterInit() {\r\n    assertFalse(createTrigger().isRunning());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testShutdown",
  "sourceCode" : "/**\r\n * Tests a shutdown operation.\r\n */\r\n@Test\r\nvoid testShutdown() {\r\n    final ScheduledFuture<Void> future = createFutureMock();\r\n    whenScheduled().thenReturn(future);\r\n    when(future.cancel(false)).thenReturn(Boolean.TRUE);\r\n    final PeriodicReloadingTrigger trigger = createTrigger();\r\n    trigger.start();\r\n    trigger.shutdown();\r\n    verifyScheduled();\r\n    verify(future).cancel(false);\r\n    verify(executor).shutdown();\r\n    verifyNoMoreInteractions(future, controller, executor);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testShutdownNoExecutor",
  "sourceCode" : "/**\r\n * Tests a shutdown operation which excludes the executor service.\r\n */\r\n@Test\r\nvoid testShutdownNoExecutor() {\r\n    createTrigger().shutdown(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testStart",
  "sourceCode" : "/**\r\n * Tests whether the trigger can be started.\r\n */\r\n@Test\r\nvoid testStart() {\r\n    final ScheduledFuture<Void> future = createFutureMock();\r\n    final MutableObject<Runnable> refTask = new MutableObject<>();\r\n    whenScheduled().thenAnswer(invocation -> {\r\n        refTask.setValue(invocation.getArgument(0, Runnable.class));\r\n        return future;\r\n    });\r\n    when(controller.checkForReloading(CTRL_PARAM)).thenReturn(Boolean.FALSE);\r\n    final PeriodicReloadingTrigger trigger = createTrigger();\r\n    trigger.start();\r\n    assertTrue(trigger.isRunning());\r\n    refTask.getValue().run();\r\n    verifyScheduled();\r\n    verify(controller).checkForReloading(CTRL_PARAM);\r\n    verifyNoMoreInteractions(future, controller, executor);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testStartTwice",
  "sourceCode" : "/**\r\n * Tests whether start() is a noop if the trigger is already running.\r\n */\r\n@Test\r\nvoid testStartTwice() {\r\n    final ScheduledFuture<Void> future = createFutureMock();\r\n    whenScheduled().thenReturn(future);\r\n    final PeriodicReloadingTrigger trigger = createTrigger();\r\n    trigger.start();\r\n    trigger.start();\r\n    verifyScheduled();\r\n    verifyNoMoreInteractions(future, controller, executor);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testStop",
  "sourceCode" : "/**\r\n * Tests whether a running trigger can be stopped.\r\n */\r\n@Test\r\nvoid testStop() {\r\n    final ScheduledFuture<Void> future = createFutureMock();\r\n    whenScheduled().thenReturn(future);\r\n    when(future.cancel(false)).thenReturn(Boolean.TRUE);\r\n    final PeriodicReloadingTrigger trigger = createTrigger();\r\n    trigger.start();\r\n    trigger.stop();\r\n    assertFalse(trigger.isRunning());\r\n    verifyScheduled();\r\n    verify(future).cancel(false);\r\n    verifyNoMoreInteractions(future, controller, executor);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestPeriodicReloadingTrigger.java",
  "methodName" : "testStopNotRunning",
  "sourceCode" : "/**\r\n * Tests stop() if the trigger is not running.\r\n */\r\n@Test\r\nvoid testStopNotRunning() {\r\n    createTrigger().stop();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestReloadingController.java",
  "methodName" : "testCheckForReloadingFalse",
  "sourceCode" : "/**\r\n * Tests a reloading check with a negative result.\r\n */\r\n@Test\r\nvoid testCheckForReloadingFalse() {\r\n    final EventListener<ReloadingEvent> l = createListenerMock();\r\n    when(detector.isReloadingRequired()).thenReturn(Boolean.FALSE);\r\n    final ReloadingController ctrl = createController();\r\n    ctrl.addEventListener(ReloadingEvent.ANY, l);\r\n    assertFalse(ctrl.checkForReloading(null));\r\n    assertFalse(ctrl.isInReloadingState());\r\n    verify(detector).isReloadingRequired();\r\n    verifyNoMoreInteractions(detector, l);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestReloadingController.java",
  "methodName" : "testCheckForReloadingInReloadingState",
  "sourceCode" : "/**\r\n * Tests that no further checks are performed when already in reloading state.\r\n */\r\n@Test\r\nvoid testCheckForReloadingInReloadingState() {\r\n    final EventListener<ReloadingEvent> l = createListenerMock();\r\n    when(detector.isReloadingRequired()).thenReturn(Boolean.TRUE);\r\n    // No need to setup the event; the event is not captured\r\n    final ReloadingController ctrl = createController();\r\n    ctrl.addEventListener(ReloadingEvent.ANY, l);\r\n    assertTrue(ctrl.checkForReloading(1));\r\n    assertTrue(ctrl.checkForReloading(2));\r\n    verify(detector).isReloadingRequired();\r\n    verifyEvent(l);\r\n    verifyNoMoreInteractions(detector, l);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestReloadingController.java",
  "methodName" : "testCheckForReloadingTrue",
  "sourceCode" : "/**\r\n * Tests a reloading check with a positive result.\r\n */\r\n@Test\r\nvoid testCheckForReloadingTrue() {\r\n    final EventListener<ReloadingEvent> l = createListenerMock();\r\n    final EventListener<ReloadingEvent> lRemoved = createListenerMock();\r\n    final MutableObject<ReloadingEvent> evRef = new MutableObject<>();\r\n    setupEvent(l, evRef);\r\n    when(detector.isReloadingRequired()).thenReturn(Boolean.TRUE);\r\n    final ReloadingController ctrl = createController();\r\n    ctrl.addEventListener(ReloadingEvent.ANY, lRemoved);\r\n    ctrl.addEventListener(ReloadingEvent.ANY, l);\r\n    assertTrue(ctrl.removeEventListener(ReloadingEvent.ANY, lRemoved));\r\n    final Object testData = \"Some test data\";\r\n    assertTrue(ctrl.checkForReloading(testData));\r\n    assertTrue(ctrl.isInReloadingState());\r\n    assertSame(ctrl, evRef.getValue().getSource());\r\n    assertSame(ctrl, evRef.getValue().getController());\r\n    assertEquals(testData, evRef.getValue().getData());\r\n    verifyEvent(l);\r\n    verify(detector).isReloadingRequired();\r\n    verifyNoMoreInteractions(l, lRemoved, detector);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestReloadingController.java",
  "methodName" : "testInitNoDetector",
  "sourceCode" : "/**\r\n * Tries to create an instance without a detector.\r\n */\r\n@Test\r\nvoid testInitNoDetector() {\r\n    assertThrows(IllegalArgumentException.class, () -> new ReloadingController(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestReloadingController.java",
  "methodName" : "testReloadingEventType",
  "sourceCode" : "/**\r\n * Tests the event type of the reloading event.\r\n */\r\n@Test\r\nvoid testReloadingEventType() {\r\n    assertEquals(Event.ANY, ReloadingEvent.ANY.getSuperType());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestReloadingController.java",
  "methodName" : "testReloadingStateAfterInit",
  "sourceCode" : "/**\r\n * Tests that a newly created instance is not in reloading state.\r\n */\r\n@Test\r\nvoid testReloadingStateAfterInit() {\r\n    assertFalse(createController().isInReloadingState());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestReloadingController.java",
  "methodName" : "testResetReloadingNotInReloadingState",
  "sourceCode" : "/**\r\n * Tests that resetReloadingState() has no effect if the controller is not in reloading state.\r\n */\r\n@Test\r\nvoid testResetReloadingNotInReloadingState() {\r\n    createController().resetReloadingState();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestReloadingController.java",
  "methodName" : "testResetReloadingState",
  "sourceCode" : "/**\r\n * Tests that the reloading state can be reset.\r\n */\r\n@Test\r\nvoid testResetReloadingState() {\r\n    when(detector.isReloadingRequired()).thenReturn(Boolean.TRUE);\r\n    final ReloadingController ctrl = createController();\r\n    ctrl.checkForReloading(null);\r\n    ctrl.resetReloadingState();\r\n    assertFalse(ctrl.isInReloadingState());\r\n    verify(detector).isReloadingRequired();\r\n    verify(detector).reloadingPerformed();\r\n    verifyNoMoreInteractions(detector);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestVFSFileHandlerReloadingDetector.java",
  "methodName" : "testGetRefreshDelay",
  "sourceCode" : "/**\r\n * Tests whether the refresh delay is correctly passed to the base class.\r\n */\r\n@Test\r\nvoid testGetRefreshDelay() throws Exception {\r\n    final long delay = 20130325L;\r\n    final VFSFileHandlerReloadingDetector strategy = new VFSFileHandlerReloadingDetector(null, delay);\r\n    assertNotNull(strategy.getFileHandler());\r\n    assertEquals(delay, strategy.getRefreshDelay());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestVFSFileHandlerReloadingDetector.java",
  "methodName" : "testLastModificationDateExisting",
  "sourceCode" : "/**\r\n * Tests whether the last modification date of an existing file can be obtained.\r\n */\r\n@Test\r\nvoid testLastModificationDateExisting() throws IOException {\r\n    final File file = newFile(tempFolder);\r\n    writeTestFile(file, \"value1\");\r\n    final VFSFileHandlerReloadingDetector strategy = new VFSFileHandlerReloadingDetector();\r\n    strategy.getFileHandler().setFile(file);\r\n    strategy.getFileHandler().setFileSystem(new VFSFileSystem());\r\n    final long modificationDate = strategy.getLastModificationDate();\r\n    // Workaround OpenJDK 8 and 9 bug JDK-8177809\r\n    // https://bugs.openjdk.java.net/browse/JDK-8177809\r\n    final long expectedMillis = Files.getLastModifiedTime(file.toPath()).toMillis();\r\n    assertEquals(expectedMillis, modificationDate);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestVFSFileHandlerReloadingDetector.java",
  "methodName" : "testLastModificationDateFileSystemEx",
  "sourceCode" : "/**\r\n * Tests whether a file system exception is handled when accessing the file object.\r\n */\r\n@Test\r\nvoid testLastModificationDateFileSystemEx() throws FileSystemException {\r\n    final FileObject fo = mock(FileObject.class);\r\n    final FileName name = mock(FileName.class);\r\n    when(fo.exists()).thenReturn(Boolean.TRUE);\r\n    when(fo.getContent()).thenThrow(new FileSystemException(\"error\"));\r\n    when(fo.getName()).thenReturn(name);\r\n    when(name.getURI()).thenReturn(\"someURI\");\r\n    final VFSFileHandlerReloadingDetector strategy = new VFSFileHandlerReloadingDetector() {\r\n\r\n        @Override\r\n        protected FileObject getFileObject() {\r\n            return fo;\r\n        }\r\n    };\r\n    assertEquals(0, strategy.getLastModificationDate());\r\n    verify(fo).exists();\r\n    verify(fo).getContent();\r\n    verify(fo).getName();\r\n    verify(name).getURI();\r\n    verifyNoMoreInteractions(fo, name);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestVFSFileHandlerReloadingDetector.java",
  "methodName" : "testLastModificationDateNonExisting",
  "sourceCode" : "/**\r\n * Tests whether a non existing file is handled correctly.\r\n */\r\n@Test\r\nvoid testLastModificationDateNonExisting() {\r\n    final File file = ConfigurationAssert.getOutFile(\"NonExistingFile.xml\");\r\n    final FileHandler handler = new FileHandler();\r\n    handler.setFileSystem(new VFSFileSystem());\r\n    handler.setFile(file);\r\n    final VFSFileHandlerReloadingDetector strategy = new VFSFileHandlerReloadingDetector(handler);\r\n    assertEquals(0, strategy.getLastModificationDate());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestVFSFileHandlerReloadingDetector.java",
  "methodName" : "testLastModificationDateUndefinedHandler",
  "sourceCode" : "/**\r\n * Tests whether an undefined file handler is handler correctly.\r\n */\r\n@Test\r\nvoid testLastModificationDateUndefinedHandler() {\r\n    final VFSFileHandlerReloadingDetector strategy = new VFSFileHandlerReloadingDetector();\r\n    assertEquals(0, strategy.getLastModificationDate());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\reloading\\TestVFSFileHandlerReloadingDetector.java",
  "methodName" : "testLastModificationDateUnresolvableURI",
  "sourceCode" : "/**\r\n * Tests a URI which cannot be resolved.\r\n */\r\n@Test\r\nvoid testLastModificationDateUnresolvableURI() {\r\n    final VFSFileHandlerReloadingDetector strategy = new VFSFileHandlerReloadingDetector() {\r\n\r\n        @Override\r\n        protected String resolveFileURI() {\r\n            return null;\r\n        }\r\n    };\r\n    strategy.getFileHandler().setFileSystem(new VFSFileSystem());\r\n    strategy.getFileHandler().setFileName(\"test.xml\");\r\n    assertThrows(ConfigurationRuntimeException.class, strategy::getLastModificationDate);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testAfterPropertiesSet",
  "sourceCode" : "@Test\r\nvoid testAfterPropertiesSet() throws Exception {\r\n    assertThrows(IllegalArgumentException.class, configurationFactory::afterPropertiesSet);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testGetConfigurationDefensiveCopy",
  "sourceCode" : "@Test\r\nvoid testGetConfigurationDefensiveCopy() {\r\n    final Configuration[] configs = { new PropertiesConfiguration(), new XMLConfiguration() };\r\n    configurationFactory.setConfigurations(configs);\r\n    final Configuration[] configsGet = configurationFactory.getConfigurations();\r\n    configsGet[0] = null;\r\n    assertArrayEquals(configs, configurationFactory.getConfigurations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testGetLocationsDefensiveCopy",
  "sourceCode" : "@Test\r\nvoid testGetLocationsDefensiveCopy() {\r\n    final Resource[] locations = { new ClassPathResource(\"f1\"), new ClassPathResource(\"f2\") };\r\n    configurationFactory.setLocations(locations);\r\n    final Resource[] locationsGet = configurationFactory.getLocations();\r\n    locationsGet[1] = null;\r\n    assertArrayEquals(locations, configurationFactory.getLocations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testGetObject",
  "sourceCode" : "@Test\r\nvoid testGetObject() throws Exception {\r\n    configurationFactory.setConfigurations(new BaseConfiguration());\r\n    assertNull(configurationFactory.getObject());\r\n    configurationFactory.afterPropertiesSet();\r\n    assertNotNull(configurationFactory.getObject());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testInitialConfiguration",
  "sourceCode" : "@Test\r\nvoid testInitialConfiguration() throws Exception {\r\n    configurationFactory = new ConfigurationPropertiesFactoryBean(new BaseConfiguration());\r\n    configurationFactory.afterPropertiesSet();\r\n    assertNotNull(configurationFactory.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testLoadResources",
  "sourceCode" : "@Test\r\nvoid testLoadResources() throws Exception {\r\n    configurationFactory.setLocations(new ClassPathResource(\"testConfigurationFactoryBean.file\"));\r\n    configurationFactory.setConfigurations(new BaseConfiguration());\r\n    configurationFactory.afterPropertiesSet();\r\n    final Properties props = configurationFactory.getObject();\r\n    assertEquals(\"duke\", props.getProperty(\"java\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testMergeConfigurations",
  "sourceCode" : "@Test\r\nvoid testMergeConfigurations() throws Exception {\r\n    final Configuration one = new BaseConfiguration();\r\n    one.setProperty(\"foo\", \"bar\");\r\n    // @formatter:off\r\n    final String properties = \"## some header \\n\" + \"foo = bar1\\n\" + \"bar = foo\\n\";\r\n    // @formatter:on\r\n    final PropertiesConfiguration two = new PropertiesConfiguration();\r\n    final PropertiesConfigurationLayout layout = new PropertiesConfigurationLayout();\r\n    layout.load(two, new StringReader(properties));\r\n    configurationFactory.setConfigurations(one, two);\r\n    configurationFactory.afterPropertiesSet();\r\n    final Properties props = configurationFactory.getObject();\r\n    assertEquals(\"foo\", props.getProperty(\"bar\"));\r\n    assertEquals(\"bar\", props.getProperty(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testSetConfigurationsDefensiveCopy",
  "sourceCode" : "@Test\r\nvoid testSetConfigurationsDefensiveCopy() {\r\n    final Configuration[] configs = { new PropertiesConfiguration(), new XMLConfiguration() };\r\n    final Configuration[] configsUpdate = configs.clone();\r\n    configurationFactory.setConfigurations(configsUpdate);\r\n    configsUpdate[0] = null;\r\n    assertArrayEquals(configs, configurationFactory.getConfigurations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testSetLocationsDefensiveCopy",
  "sourceCode" : "@Test\r\nvoid testSetLocationsDefensiveCopy() {\r\n    final Resource[] locations = { new ClassPathResource(\"f1\"), new ClassPathResource(\"f2\") };\r\n    final Resource[] locationsUpdate = locations.clone();\r\n    configurationFactory.setLocations(locationsUpdate);\r\n    locationsUpdate[0] = new ClassPathResource(\"other\");\r\n    assertArrayEquals(locations, configurationFactory.getLocations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertiesFactoryBean.java",
  "methodName" : "testSetLocationsNull",
  "sourceCode" : "@Test\r\nvoid testSetLocationsNull() {\r\n    configurationFactory.setLocations(null);\r\n    assertNull(configurationFactory.getLocations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertySource.java",
  "methodName" : "testEmptyStringValueInjection",
  "sourceCode" : "@Test\r\nvoid testEmptyStringValueInjection() {\r\n    assertEquals(\"\", emptyPropertyValue);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertySource.java",
  "methodName" : "testListValueInjection",
  "sourceCode" : "@Test\r\nvoid testListValueInjection() {\r\n    assertArrayEquals(TEST_LIST_VALUE, listValue);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertySource.java",
  "methodName" : "testNullValueInjection",
  "sourceCode" : "@Test\r\nvoid testNullValueInjection() {\r\n    assertFalse(booleanNullValueDefaultFalse);\r\n    assertTrue(booleanNullValueDefaultTrue);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\spring\\TestConfigurationPropertySource.java",
  "methodName" : "testSystemPropertyValueInjection",
  "sourceCode" : "@Test\r\nvoid testSystemPropertyValueInjection() {\r\n    assertEquals(TEST_SYSTEM_VALUE, systemPropertyValue);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\sync\\TestReadWriteSynchronizer.java",
  "methodName" : "testInitLock",
  "sourceCode" : "/**\r\n * Tests whether a lock passed to the constructor is used.\r\n */\r\n@Test\r\nvoid testInitLock() {\r\n    final ReadWriteLock lock = mock(ReadWriteLock.class);\r\n    final Lock readLock = mock(Lock.class);\r\n    when(lock.readLock()).thenReturn(readLock);\r\n    final ReadWriteSynchronizer sync = new ReadWriteSynchronizer(lock);\r\n    sync.beginRead();\r\n    verify(lock).readLock();\r\n    verify(readLock).lock();\r\n    verifyNoMoreInteractions(lock, readLock);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\sync\\TestReadWriteSynchronizer.java",
  "methodName" : "testReentrance",
  "sourceCode" : "/**\r\n * Tests whether the synchronizer is reentrant. This is important for some combined operations on a configuration.\r\n */\r\n@Test\r\nvoid testReentrance() {\r\n    final Synchronizer sync = new ReadWriteSynchronizer();\r\n    sync.beginWrite();\r\n    sync.beginRead();\r\n    sync.beginRead();\r\n    sync.endRead();\r\n    sync.endRead();\r\n    sync.beginWrite();\r\n    sync.endWrite();\r\n    sync.endWrite();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\sync\\TestReadWriteSynchronizer.java",
  "methodName" : "testSynchronizerInAction",
  "sourceCode" : "/**\r\n * Performs a test of the synchronizer based on the classic example of account objects. Money is transferred between two\r\n * accounts. If everything goes well, the total amount of money stays constant over time.\r\n */\r\n@Test\r\nvoid testSynchronizerInAction() throws InterruptedException {\r\n    final int numberOfUpdates = 10000;\r\n    final int numberOfReads = numberOfUpdates / 2;\r\n    final int readThreadCount = 3;\r\n    final int updateThreadCount = 2;\r\n    final Synchronizer sync = new ReadWriteSynchronizer();\r\n    final Account account1 = new Account();\r\n    final Account account2 = new Account();\r\n    account1.change(TOTAL_MONEY / 2);\r\n    account2.change(TOTAL_MONEY / 2);\r\n    final UpdateThread[] updateThreads = new UpdateThread[updateThreadCount];\r\n    for (int i = 0; i < updateThreads.length; i++) {\r\n        updateThreads[i] = new UpdateThread(sync, numberOfUpdates, account1, account2);\r\n        updateThreads[i].start();\r\n    }\r\n    final ReaderThread[] readerThreads = new ReaderThread[readThreadCount];\r\n    for (int i = 0; i < readerThreads.length; i++) {\r\n        readerThreads[i] = new ReaderThread(sync, numberOfReads, account1, account2);\r\n        readerThreads[i].start();\r\n    }\r\n    for (final UpdateThread t : updateThreads) {\r\n        t.join();\r\n    }\r\n    for (final ReaderThread t : readerThreads) {\r\n        t.join();\r\n        assertEquals(0, t.getErrors());\r\n    }\r\n    sync.beginRead();\r\n    assertEquals(TOTAL_MONEY, sumUpAccounts(account1, account2));\r\n    sync.endRead();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "givenNullIteratorTestContains",
  "sourceCode" : "@Test\r\npublic void givenNullIteratorTestContains() {\r\n    final AbstractConfiguration config = getConfiguration();\r\n    assertThrows(NullPointerException.class, () -> config.contains(null, \"value1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "givenNullValueTestContains",
  "sourceCode" : "@Test\r\npublic void givenNullValueTestContains() {\r\n    final AbstractConfiguration config = getConfiguration();\r\n    final Iterator<String> keys = config.getKeys();\r\n    assertFalse(config.contains(keys, null));\r\n    assertFalse(config.contains(keys, \"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Test\r\npublic void testAddPropertyDirect() {\r\n    final AbstractConfiguration config = getConfiguration();\r\n    config.addPropertyDirect(\"key3\", \"value3\");\r\n    assertEquals(\"value3\", config.getProperty(\"key3\"));\r\n    config.addPropertyDirect(\"key3\", \"value4\");\r\n    config.addPropertyDirect(\"key3\", \"value5\");\r\n    final List<Object> list = config.getList(\"key3\");\r\n    assertNotNull(list);\r\n    final List<Object> expected = new ArrayList<>();\r\n    expected.add(\"value3\");\r\n    expected.add(\"value4\");\r\n    expected.add(\"value5\");\r\n    assertEquals(expected, list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Test\r\npublic void testClearProperty() {\r\n    final Configuration config = getConfiguration();\r\n    config.clearProperty(\"key2\");\r\n    assertFalse(config.containsKey(\"key2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testContains",
  "sourceCode" : "@Test\r\nvoid testContains() {\r\n    final AbstractConfiguration config = getConfiguration();\r\n    assertTrue(config.contains(config.getKeys(), \"value1\"));\r\n    assertFalse(config.contains(config.getKeys(), \"value99999\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testContainsKey",
  "sourceCode" : "@Test\r\nvoid testContainsKey() {\r\n    final Configuration config = getConfiguration();\r\n    assertTrue(config.containsKey(\"key1\"));\r\n    assertFalse(config.containsKey(\"key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Test\r\npublic void testContainsValue() {\r\n    final Configuration config = getConfiguration();\r\n    assertFalse(config.containsValue(null));\r\n    assertFalse(config.containsValue(\"\"));\r\n    assertTrue(config.containsValue(\"value1\"));\r\n    assertFalse(config.containsValue(\"value99999\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testGetBigIntegerConversion",
  "sourceCode" : "/**\r\n * Tests the exception message triggered by the conversion to BigInteger. This test is related to CONFIGURATION-357.\r\n */\r\n@Test\r\nvoid testGetBigIntegerConversion() {\r\n    final Configuration config = getConfiguration();\r\n    final ConversionException cex = assertThrows(ConversionException.class, () -> config.getBigInteger(\"key1\"));\r\n    assertTrue(cex.getMessage().contains(\"'key1'\"));\r\n    assertTrue(cex.getMessage().contains(BigInteger.class.getName()));\r\n    assertTrue(cex.getMessage().contains(config.getString(\"key1\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "@Test\r\nvoid testGetKeys() {\r\n    final Configuration config = getConfiguration();\r\n    final Iterator<String> keys = config.getKeys();\r\n    final Set<String> expectedKeys = new HashSet<>(Arrays.asList(\"key1\", \"key2\", \"list\", \"listesc\"));\r\n    assertNotNull(keys);\r\n    assertTrue(keys.hasNext());\r\n    final Set<String> actualKeys = new HashSet<>();\r\n    while (keys.hasNext()) {\r\n        actualKeys.add(keys.next());\r\n    }\r\n    assertEquals(actualKeys, expectedKeys, \"keys\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() {\r\n    final Configuration config = getConfiguration();\r\n    assertEquals(\"value1\", config.getProperty(\"key1\"));\r\n    assertEquals(\"value2\", config.getProperty(\"key2\"));\r\n    assertNull(config.getProperty(\"key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testIsEmpty",
  "sourceCode" : "@Test\r\nvoid testIsEmpty() {\r\n    final Configuration config = getConfiguration();\r\n    assertFalse(config.isEmpty());\r\n    assertTrue(getEmptyConfiguration().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testList",
  "sourceCode" : "@Test\r\nvoid testList() {\r\n    final Configuration config = getConfiguration();\r\n    final List<?> list = config.getList(\"list\");\r\n    assertNotNull(config.getProperty(\"list\"));\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testListEscaped",
  "sourceCode" : "/**\r\n * Tests whether the escape character for list delimiters is recocknized and removed.\r\n */\r\n@Test\r\nvoid testListEscaped() {\r\n    assertEquals(\"value1,value2\", getConfiguration().getString(\"listesc\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testSetLogger",
  "sourceCode" : "/**\r\n * Tests accessing the configuration's logger.\r\n */\r\n@Test\r\nvoid testSetLogger() {\r\n    final AbstractConfiguration config = getEmptyConfiguration();\r\n    assertNotNull(config.getLogger());\r\n    final ConfigurationLogger log = new ConfigurationLogger(config.getClass());\r\n    config.setLogger(log);\r\n    assertSame(log, config.getLogger());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testSize",
  "sourceCode" : "@Test\r\nvoid testSize() {\r\n    assertEquals(4, getConfiguration().size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfiguration.java",
  "methodName" : "testSizeEmpty",
  "sourceCode" : "@Test\r\nvoid testSizeEmpty() {\r\n    assertEquals(0, getEmptyConfiguration().size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testAddPropertyList",
  "sourceCode" : "/**\r\n * Tests adding list properties. The single elements of the list should be added.\r\n */\r\n@Test\r\nvoid testAddPropertyList() {\r\n    checkAddListProperty(new TestConfigurationImpl(new PropertiesConfiguration()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testAddPropertyListNoDelimiterParsing",
  "sourceCode" : "/**\r\n * Tests adding list properties if delimiter parsing is disabled.\r\n */\r\n@Test\r\nvoid testAddPropertyListNoDelimiterParsing() {\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    checkAddListProperty(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testAppend",
  "sourceCode" : "/**\r\n * Tests the append() method.\r\n */\r\n@Test\r\nvoid testAppend() {\r\n    final AbstractConfiguration config = setUpDestConfig();\r\n    final Configuration srcConfig = setUpSourceConfig();\r\n    config.append(srcConfig);\r\n    for (int i = 0; i < PROP_COUNT; i++) {\r\n        final String key = KEY_PREFIX + i;\r\n        if (srcConfig.containsKey(key)) {\r\n            final List<Object> values = config.getList(key);\r\n            assertEquals(Arrays.asList(\"value\" + i, \"src\" + i), values, \"Wrong values for \" + key);\r\n        } else {\r\n            assertEquals(\"value\" + i, config.getProperty(key), \"Value modified: \" + key);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testAppendDelimiterHandling",
  "sourceCode" : "/**\r\n * Tests whether the list delimiter is correctly handled if a configuration is appended.\r\n */\r\n@Test\r\nvoid testAppendDelimiterHandling() {\r\n    final BaseConfiguration srcConfig = new BaseConfiguration();\r\n    final BaseConfiguration dstConfig = new BaseConfiguration();\r\n    dstConfig.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    srcConfig.setProperty(KEY_PREFIX, \"C:\\\\Temp\\\\,D:\\\\Data\");\r\n    dstConfig.append(srcConfig);\r\n    assertEquals(srcConfig.getString(KEY_PREFIX), dstConfig.getString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testAppendEvents",
  "sourceCode" : "/**\r\n * Tests the events generated by an append() operation.\r\n */\r\n@Test\r\nvoid testAppendEvents() {\r\n    final AbstractConfiguration config = setUpDestConfig();\r\n    final Configuration srcConfig = setUpSourceConfig();\r\n    final CollectingConfigurationListener l = new CollectingConfigurationListener();\r\n    config.addEventListener(ConfigurationEvent.ANY, l);\r\n    config.append(srcConfig);\r\n    checkCopyEvents(l, srcConfig, ConfigurationEvent.ADD_PROPERTY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testAppendNull",
  "sourceCode" : "/**\r\n * Tests appending a null configuration. This should be a noop.\r\n */\r\n@Test\r\nvoid testAppendNull() {\r\n    final AbstractConfiguration config = setUpDestConfig();\r\n    config.append(null);\r\n    ConfigurationAssert.assertConfigurationEquals(setUpDestConfig(), config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testAppendWithLists",
  "sourceCode" : "/**\r\n * Tests the append() method when properties with multiple values and escaped list delimiters are involved.\r\n */\r\n@Test\r\nvoid testAppendWithLists() {\r\n    final AbstractConfiguration config = setUpDestConfig();\r\n    config.append(setUpSourceConfig());\r\n    checkListProperties(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testClearIteratorNoRemove",
  "sourceCode" : "/**\r\n * Tests the clear() implementation of AbstractConfiguration if the iterator returned by getKeys() does not support the\r\n * remove() operation.\r\n */\r\n@Test\r\nvoid testClearIteratorNoRemove() {\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new BaseConfiguration()) {\r\n\r\n        // return an iterator that does not support remove operations\r\n        @Override\r\n        protected Iterator<String> getKeysInternal() {\r\n            final Collection<String> keyCol = new ArrayList<>();\r\n            ConfigurationAssert.appendKeys(getUnderlyingConfiguration(), keyCol);\r\n            final String[] keys = keyCol.toArray(new String[keyCol.size()]);\r\n            return Arrays.asList(keys).iterator();\r\n        }\r\n    };\r\n    for (int i = 0; i < 20; i++) {\r\n        config.addProperty(\"key\" + i, \"value\" + i);\r\n    }\r\n    config.clear();\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testCopy",
  "sourceCode" : "/**\r\n * Tests the copy() method.\r\n */\r\n@Test\r\nvoid testCopy() {\r\n    final AbstractConfiguration config = setUpDestConfig();\r\n    final Configuration srcConfig = setUpSourceConfig();\r\n    config.copy(srcConfig);\r\n    for (int i = 0; i < PROP_COUNT; i++) {\r\n        final String key = KEY_PREFIX + i;\r\n        if (srcConfig.containsKey(key)) {\r\n            assertEquals(srcConfig.getProperty(key), config.getProperty(key), \"Value not replaced: \" + key);\r\n        } else {\r\n            assertEquals(\"value\" + i, config.getProperty(key), \"Value modified: \" + key);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testCopyDelimiterHandling",
  "sourceCode" : "/**\r\n * Tests whether list delimiters are correctly handled when copying a configuration.\r\n */\r\n@Test\r\nvoid testCopyDelimiterHandling() {\r\n    final BaseConfiguration srcConfig = new BaseConfiguration();\r\n    final BaseConfiguration dstConfig = new BaseConfiguration();\r\n    dstConfig.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    srcConfig.setProperty(KEY_PREFIX, \"C:\\\\Temp\\\\,D:\\\\Data\");\r\n    dstConfig.copy(srcConfig);\r\n    assertEquals(srcConfig.getString(KEY_PREFIX), dstConfig.getString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testCopyEvents",
  "sourceCode" : "/**\r\n * Tests the events generated by a copy() operation.\r\n */\r\n@Test\r\nvoid testCopyEvents() {\r\n    final AbstractConfiguration config = setUpDestConfig();\r\n    final Configuration srcConfig = setUpSourceConfig();\r\n    final CollectingConfigurationListener l = new CollectingConfigurationListener();\r\n    config.addEventListener(ConfigurationEvent.ANY, l);\r\n    config.copy(srcConfig);\r\n    checkCopyEvents(l, srcConfig, ConfigurationEvent.SET_PROPERTY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testCopyNull",
  "sourceCode" : "/**\r\n * Tests copying a null configuration. This should be a noop.\r\n */\r\n@Test\r\nvoid testCopyNull() {\r\n    final AbstractConfiguration config = setUpDestConfig();\r\n    config.copy(null);\r\n    ConfigurationAssert.assertConfigurationEquals(setUpDestConfig(), config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testCopyWithLists",
  "sourceCode" : "/**\r\n * Tests the copy() method if properties with multiple values and escaped list delimiters are involved.\r\n */\r\n@Test\r\nvoid testCopyWithLists() {\r\n    final Configuration srcConfig = setUpSourceConfig();\r\n    final AbstractConfiguration config = setUpDestConfig();\r\n    config.copy(srcConfig);\r\n    checkListProperties(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testCyclicInterpolation",
  "sourceCode" : "/**\r\n * Tests an interpolation that leads to a cycle. This should throw an exception.\r\n */\r\n@Test\r\nvoid testCyclicInterpolation() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(\"animal\", \"${animal_attr} ${species}\");\r\n    config.addProperty(\"animal_attr\", \"quick brown\");\r\n    config.addProperty(\"species\", \"${animal}\");\r\n    config.addProperty(KEY_PREFIX, \"This is a ${animal}\");\r\n    assertThrows(IllegalStateException.class, () -> config.getString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testDefaultConversionHandler",
  "sourceCode" : "/**\r\n * Tests whether a configuration instance has a default conversion hander.\r\n */\r\n@Test\r\nvoid testDefaultConversionHandler() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertEquals(DefaultConversionHandler.class, config.getConversionHandler().getClass());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testDefaultConversionHandlerSharedInstance",
  "sourceCode" : "/**\r\n * Tests that the default conversion handler is shared between all configuration instances.\r\n */\r\n@Test\r\nvoid testDefaultConversionHandlerSharedInstance() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final PropertiesConfiguration config2 = new PropertiesConfiguration();\r\n    assertSame(config.getConversionHandler(), config2.getConversionHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testDefaultListDelimiterHandler",
  "sourceCode" : "/**\r\n * Tests the default list delimiter hander.\r\n */\r\n@Test\r\nvoid testDefaultListDelimiterHandler() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    assertInstanceOf(DisabledListDelimiterHandler.class, config.getListDelimiterHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGet",
  "sourceCode" : "/**\r\n * Tests the generic get() method.\r\n */\r\n@Test\r\nvoid testGet() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final Integer value = 20130816;\r\n    config.addProperty(KEY_PREFIX, value.toString());\r\n    assertEquals(value, config.get(Integer.class, KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetArray",
  "sourceCode" : "/**\r\n * Tests whether conversion to an array is possible.\r\n */\r\n@Test\r\nvoid testGetArray() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final Integer[] expected = new Integer[PROP_COUNT];\r\n    for (int i = 0; i < PROP_COUNT; i++) {\r\n        config.addProperty(KEY_PREFIX, String.valueOf(i));\r\n        expected[i] = Integer.valueOf(i);\r\n    }\r\n    final Integer[] result = config.get(Integer[].class, KEY_PREFIX);\r\n    assertArrayEquals(expected, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetArrayDefaultValueNotAnArray",
  "sourceCode" : "/**\r\n * Tests getArray() if the default value is not an array.\r\n */\r\n@Test\r\nvoid testGetArrayDefaultValueNotAnArray() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertThrows(IllegalArgumentException.class, () -> config.getArray(Integer.class, KEY_PREFIX, this));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetArrayDefaultValueWrongComponentClass",
  "sourceCode" : "/**\r\n * Tests getArray() if the default value is an array with a different component type.\r\n */\r\n@Test\r\nvoid testGetArrayDefaultValueWrongComponentClass() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertThrows(IllegalArgumentException.class, () -> config.getArray(Integer.class, KEY_PREFIX, new short[1]));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetArrayPrimitive",
  "sourceCode" : "/**\r\n * Tests a conversion to an array of primitive types.\r\n */\r\n@Test\r\nvoid testGetArrayPrimitive() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final short[] expected = new short[PROP_COUNT];\r\n    for (int i = 0; i < PROP_COUNT; i++) {\r\n        config.addProperty(KEY_PREFIX, String.valueOf(i));\r\n        expected[i] = (short) i;\r\n    }\r\n    final short[] result = config.get(short[].class, KEY_PREFIX, ArrayUtils.EMPTY_SHORT_ARRAY);\r\n    assertArrayEquals(expected, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetArrayUnknownNoDefault",
  "sourceCode" : "/**\r\n * Tests get() for an unknown array property if no default value is provided.\r\n */\r\n@Test\r\nvoid testGetArrayUnknownNoDefault() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertNull(config.get(Integer[].class, KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetArrayUnknownWithDefault",
  "sourceCode" : "/**\r\n * Tests get() for an unknown array property if a default value is provided.\r\n */\r\n@Test\r\nvoid testGetArrayUnknownWithDefault() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final int[] defValue = { 1, 2, 3 };\r\n    assertArrayEquals(defValue, config.get(int[].class, KEY_PREFIX, defValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetCollection",
  "sourceCode" : "/**\r\n * Tests a conversion to a collection.\r\n */\r\n@Test\r\nvoid testGetCollection() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final List<Integer> expected = prepareListTest(config);\r\n    final List<Integer> result = new ArrayList<>(PROP_COUNT);\r\n    assertSame(result, config.getCollection(Integer.class, KEY_PREFIX, result));\r\n    assertEquals(expected, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetCollectionNullTarget",
  "sourceCode" : "/**\r\n * Tests getCollection() if no target collection is provided.\r\n */\r\n@Test\r\nvoid testGetCollectionNullTarget() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final List<Integer> expected = prepareListTest(config);\r\n    final Collection<Integer> result = config.getCollection(Integer.class, KEY_PREFIX, null, new ArrayList<>());\r\n    assertEquals(expected, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetCollectionSingleValue",
  "sourceCode" : "/**\r\n * Tests whether a single value property can be converted to a collection.\r\n */\r\n@Test\r\nvoid testGetCollectionSingleValue() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(KEY_PREFIX, \"1\");\r\n    final List<Integer> result = new ArrayList<>(1);\r\n    config.getCollection(Integer.class, KEY_PREFIX, result);\r\n    assertEquals(Arrays.asList(1), result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetCollectionUnknownNoDefault",
  "sourceCode" : "/**\r\n * Tests getCollection() for an unknown property if no default value is provided.\r\n */\r\n@Test\r\nvoid testGetCollectionUnknownNoDefault() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final List<Integer> result = new ArrayList<>();\r\n    assertNull(config.getCollection(Integer.class, KEY_PREFIX, result));\r\n    assertTrue(result.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetCollectionUnknownWithDefault",
  "sourceCode" : "/**\r\n * Tests getCollection() for an unknown property if a default collection is provided.\r\n */\r\n@Test\r\nvoid testGetCollectionUnknownWithDefault() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final List<Integer> defValue = Arrays.asList(1, 2, 4, 8, 16, 32);\r\n    final Collection<Integer> result = config.getCollection(Integer.class, KEY_PREFIX, null, defValue);\r\n    assertEquals(defValue, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetEncodedStringNoDecoder",
  "sourceCode" : "/**\r\n * Tries to query an encoded string without a decoder.\r\n */\r\n@Test\r\nvoid testGetEncodedStringNoDecoder() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertThrows(IllegalArgumentException.class, () -> config.getEncodedString(KEY_PREFIX, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetEncodedStringNoDefaultDecoderDefined",
  "sourceCode" : "/**\r\n * Tries to query an encoded string with the default decoder if this property is not defined.\r\n */\r\n@Test\r\nvoid testGetEncodedStringNoDefaultDecoderDefined() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertThrows(IllegalStateException.class, () -> config.getEncodedString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetEncodedStringNoValue",
  "sourceCode" : "/**\r\n * Tests whether undefined keys are handled when querying encoded strings.\r\n */\r\n@Test\r\nvoid testGetEncodedStringNoValue() {\r\n    final ConfigurationDecoder decoder = mock(ConfigurationDecoder.class);\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertNull(config.getEncodedString(KEY_PREFIX, decoder));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetEncodedStringValue",
  "sourceCode" : "/**\r\n * Tests whether an encoded value can be retrieved.\r\n */\r\n@Test\r\nvoid testGetEncodedStringValue() {\r\n    final ConfigurationDecoder decoder = mock(ConfigurationDecoder.class);\r\n    final String value = \"original value\";\r\n    final String decodedValue = \"decoded value\";\r\n    when(decoder.decode(value)).thenReturn(decodedValue);\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(KEY_PREFIX, value);\r\n    assertEquals(decodedValue, config.getEncodedString(KEY_PREFIX, decoder));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetEncodedStringWithDefaultDecoder",
  "sourceCode" : "/**\r\n * Tests whether a default decoder can be set which is queried for encoded strings.\r\n */\r\n@Test\r\nvoid testGetEncodedStringWithDefaultDecoder() {\r\n    final ConfigurationDecoder decoder = mock(ConfigurationDecoder.class);\r\n    final String value = \"original value\";\r\n    final String decodedValue = \"decoded value\";\r\n    when(decoder.decode(value)).thenReturn(decodedValue);\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.setConfigurationDecoder(decoder);\r\n    config.addProperty(KEY_PREFIX, value);\r\n    assertEquals(decodedValue, config.getEncodedString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetList",
  "sourceCode" : "/**\r\n * Tests a conversion to a list.\r\n */\r\n@Test\r\nvoid testGetList() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final List<Integer> expected = prepareListTest(config);\r\n    final List<Integer> result = config.getList(Integer.class, KEY_PREFIX);\r\n    assertEquals(expected, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetListNonString",
  "sourceCode" : "/**\r\n * Tests getList() for single non-string values.\r\n */\r\n@Test\r\nvoid testGetListNonString() {\r\n    checkGetListScalar(Integer.valueOf(42));\r\n    checkGetListScalar(Long.valueOf(42));\r\n    checkGetListScalar(Short.valueOf((short) 42));\r\n    checkGetListScalar(Byte.valueOf((byte) 42));\r\n    checkGetListScalar(Float.valueOf(42));\r\n    checkGetListScalar(Double.valueOf(42));\r\n    checkGetListScalar(Boolean.TRUE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetListUnknownNoDefault",
  "sourceCode" : "/**\r\n * Tests a conversion to a list if the property is unknown and no default value is provided.\r\n */\r\n@Test\r\nvoid testGetListUnknownNoDefault() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertNull(config.getList(Integer.class, KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetListUnknownWithDefault",
  "sourceCode" : "/**\r\n * Tests a conversion to a list if the property is unknown and a default list is provided.\r\n */\r\n@Test\r\nvoid testGetListUnknownWithDefault() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final List<Integer> defValue = Arrays.asList(1, 2, 3);\r\n    assertEquals(defValue, config.getList(Integer.class, KEY_PREFIX, defValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetStringArrayNonString",
  "sourceCode" : "/**\r\n * Tests getStringArray() for single son-string values.\r\n */\r\n@Test\r\nvoid testGetStringArrayNonString() {\r\n    checkGetStringArrayScalar(Integer.valueOf(42));\r\n    checkGetStringArrayScalar(Long.valueOf(42));\r\n    checkGetStringArrayScalar(Short.valueOf((short) 42));\r\n    checkGetStringArrayScalar(Byte.valueOf((byte) 42));\r\n    checkGetStringArrayScalar(Float.valueOf(42));\r\n    checkGetStringArrayScalar(Double.valueOf(42));\r\n    checkGetStringArrayScalar(Boolean.TRUE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetStringArrayUnknown",
  "sourceCode" : "/**\r\n * Tests getStringArray() if the key cannot be found.\r\n */\r\n@Test\r\nvoid testGetStringArrayUnknown() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    final String[] array = config.getStringArray(KEY_PREFIX);\r\n    assertEquals(0, array.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetUnknownNoDefaultValue",
  "sourceCode" : "/**\r\n * Tests get() for an unknown property if no default value is provided.\r\n */\r\n@Test\r\nvoid testGetUnknownNoDefaultValue() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    assertNull(config.get(Integer.class, KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetUnknownWithDefaultValue",
  "sourceCode" : "/**\r\n * Tests get() for an unknown property if a default value is provided.\r\n */\r\n@Test\r\nvoid testGetUnknownWithDefaultValue() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final Integer defaultValue = 2121;\r\n    assertEquals(defaultValue, config.get(Integer.class, KEY_PREFIX, defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetUnknownWithThrowExceptionOnMissing",
  "sourceCode" : "/**\r\n * Tests get() for an unknown property if the throwExceptionOnMissing flag is set.\r\n */\r\n@Test\r\nvoid testGetUnknownWithThrowExceptionOnMissing() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.setThrowExceptionOnMissing(true);\r\n    assertThrows(NoSuchElementException.class, () -> config.get(Integer.class, KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testGetUnownWithDefaultValueThrowExceptionOnMissing",
  "sourceCode" : "/**\r\n * Tests get() for an unknown property with a default value and the throwExceptionOnMissing flag. Because of the default\r\n * value no exception should be thrown.\r\n */\r\n@Test\r\nvoid testGetUnownWithDefaultValueThrowExceptionOnMissing() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.setThrowExceptionOnMissing(true);\r\n    final Integer defaultValue = 2121;\r\n    assertEquals(defaultValue, config.get(Integer.class, KEY_PREFIX, defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInstallInterpolatorNull",
  "sourceCode" : "/**\r\n * Tests whether a new {@code ConfigurationInterpolator} can be installed without providing custom lookups.\r\n */\r\n@Test\r\nvoid testInstallInterpolatorNull() {\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    config.installInterpolator(null, null);\r\n    assertTrue(config.getInterpolator().getLookups().isEmpty());\r\n    final List<Lookup> defLookups = config.getInterpolator().getDefaultLookups();\r\n    assertEquals(1, defLookups.size());\r\n    assertInstanceOf(ConfigurationLookup.class, defLookups.get(0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolateArray",
  "sourceCode" : "/**\r\n * Tests whether a property can reference an array using interpolation. This is related to CONFIGURATION-633.\r\n */\r\n@Test\r\nvoid testInterpolateArray() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final String[] values = { \"some\", \"test\", \"values\" };\r\n    final String keyArray = \"testArray\";\r\n    config.addProperty(keyArray, values);\r\n    config.addProperty(KEY_PREFIX, \"${\" + keyArray + \"}\");\r\n    assertArrayEquals(values, config.getStringArray(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolateEnvironmentVariables",
  "sourceCode" : "/**\r\n * Tests whether environment variables can be interpolated.\r\n */\r\n@Test\r\nvoid testInterpolateEnvironmentVariables() {\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    InterpolationTestHelper.testInterpolationEnvironment(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolateEscape",
  "sourceCode" : "/**\r\n * Tests escaping the variable marker, so that no interpolation will be performed.\r\n */\r\n@Test\r\nvoid testInterpolateEscape() {\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    config.addProperty(\"mypath\", \"$${DB2UNIVERSAL_JDBC_DRIVER_PATH}/db2jcc.jar\\\\,$${DB2UNIVERSAL_JDBC_DRIVER_PATH}/db2jcc_license_cu.jar\");\r\n    assertEquals(\"${DB2UNIVERSAL_JDBC_DRIVER_PATH}/db2jcc.jar,${DB2UNIVERSAL_JDBC_DRIVER_PATH}/db2jcc_license_cu.jar\", config.getString(\"mypath\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolateList",
  "sourceCode" : "/**\r\n * Tests whether a property can reference a list using interpolation. This is related to CONFIGURATION-633.\r\n */\r\n@Test\r\nvoid testInterpolateList() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final List<String> values = Arrays.asList(\"some\", \"test\", \"values\");\r\n    final String keyList = \"testList\";\r\n    config.addProperty(keyList, values);\r\n    config.addProperty(KEY_PREFIX, \"${\" + keyList + \"}\");\r\n    assertEquals(values, config.getList(String.class, KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolateRecursive",
  "sourceCode" : "/**\r\n * Tests complex interpolation where the variables' values contain in turn other variables.\r\n */\r\n@Test\r\nvoid testInterpolateRecursive() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(\"animal\", \"${animal_attr} fox\");\r\n    config.addProperty(\"target\", \"${target_attr} dog\");\r\n    config.addProperty(\"animal_attr\", \"quick brown\");\r\n    config.addProperty(\"target_attr\", \"lazy\");\r\n    config.addProperty(KEY_PREFIX, SUBST_TXT);\r\n    assertEquals(\"The quick brown fox jumps over the lazy dog.\", config.getString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolateString",
  "sourceCode" : "/**\r\n * Tests the interpolation features.\r\n */\r\n@Test\r\nvoid testInterpolateString() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(\"animal\", \"quick brown fox\");\r\n    config.addProperty(\"target\", \"lazy dog\");\r\n    config.addProperty(KEY_PREFIX, SUBST_TXT);\r\n    assertEquals(\"The quick brown fox jumps over the lazy dog.\", config.getString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolateStringWithListVariable",
  "sourceCode" : "/**\r\n * Tests that variables with list values in interpolated string are resolved with the first element\r\n * in the list.\r\n */\r\n@Test\r\nvoid testInterpolateStringWithListVariable() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final List<String> values = Arrays.asList(\"some\", \"test\", \"values\");\r\n    final String keyList = \"testList\";\r\n    config.addProperty(keyList, values);\r\n    config.addProperty(KEY_PREFIX, \"result = ${\" + keyList + \"}\");\r\n    assertEquals(\"result = some\", config.getString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolationNoInterpolator",
  "sourceCode" : "/**\r\n * Tests interpolate() if the configuration does not have a {@code ConfigurationInterpolator}.\r\n */\r\n@Test\r\nvoid testInterpolationNoInterpolator() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(\"animal\", \"quick brown fox\");\r\n    config.addProperty(\"target\", \"lazy dog\");\r\n    config.addProperty(KEY_PREFIX, SUBST_TXT);\r\n    config.setInterpolator(null);\r\n    assertEquals(SUBST_TXT, config.getString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testInterpolationUnknownVariable",
  "sourceCode" : "/**\r\n * Tests interpolation if a variable is unknown. Then the variable won't be substituted.\r\n */\r\n@Test\r\nvoid testInterpolationUnknownVariable() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(\"animal\", \"quick brown fox\");\r\n    config.addProperty(KEY_PREFIX, SUBST_TXT);\r\n    assertEquals(\"The quick brown fox jumps over the ${target}.\", config.getString(KEY_PREFIX));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testNestedVariableInterpolation",
  "sourceCode" : "/**\r\n * Tests whether interpolation works in variable names.\r\n */\r\n@Test\r\nvoid testNestedVariableInterpolation() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.getInterpolator().setEnableSubstitutionInVariables(true);\r\n    config.addProperty(\"java.version\", \"1.4\");\r\n    config.addProperty(\"jre-1.4\", \"C:\\\\java\\\\1.4\");\r\n    config.addProperty(\"jre.path\", \"${jre-${java.version}}\");\r\n    assertEquals(\"C:\\\\java\\\\1.4\", config.getString(\"jre.path\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetDefaultConversionHandler",
  "sourceCode" : "/**\r\n * Tests whether the conversion handler can be changed.\r\n */\r\n@Test\r\nvoid testSetDefaultConversionHandler() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final ConversionHandler handler = new DefaultConversionHandler();\r\n    config.setConversionHandler(handler);\r\n    assertSame(handler, config.getConversionHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetDefaultConversionHandlerNull",
  "sourceCode" : "/**\r\n * Tries to set a null value for the conversion handler.\r\n */\r\n@Test\r\nvoid testSetDefaultConversionHandlerNull() {\r\n    final PropertiesConfiguration configuration = new PropertiesConfiguration();\r\n    assertThrows(IllegalArgumentException.class, () -> configuration.setConversionHandler(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetDefaultLookupsExistingInterpolator",
  "sourceCode" : "/**\r\n * Tests whether default lookups can be added to an already existing {@code ConfigurationInterpolator}.\r\n */\r\n@Test\r\nvoid testSetDefaultLookupsExistingInterpolator() {\r\n    final Lookup look = mock(Lookup.class);\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    config.getInterpolator().addDefaultLookup(new ConfigurationLookup(new PropertiesConfiguration()));\r\n    config.setDefaultLookups(Collections.singleton(look));\r\n    final List<Lookup> lookups = config.getInterpolator().getDefaultLookups();\r\n    assertEquals(3, lookups.size());\r\n    assertSame(look, lookups.get(1));\r\n    assertInstanceOf(ConfigurationLookup.class, lookups.get(2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetDefaultLookupsNoInterpolator",
  "sourceCode" : "/**\r\n * Tests whether default lookups can be added if not {@code ConfigurationInterpolator} exists yet.\r\n */\r\n@Test\r\nvoid testSetDefaultLookupsNoInterpolator() {\r\n    final Lookup look = mock(Lookup.class);\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    config.setInterpolator(null);\r\n    config.setDefaultLookups(Collections.singleton(look));\r\n    final List<Lookup> lookups = config.getInterpolator().getDefaultLookups();\r\n    assertEquals(2, lookups.size());\r\n    assertSame(look, lookups.get(0));\r\n    assertInstanceOf(ConfigurationLookup.class, lookups.get(1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetListDelimiterHandlerNull",
  "sourceCode" : "/**\r\n * Tries to set a null list delimiter handler.\r\n */\r\n@Test\r\nvoid testSetListDelimiterHandlerNull() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    assertThrows(IllegalArgumentException.class, () -> config.setListDelimiterHandler(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetParentInterpolatorExistingInterpolator",
  "sourceCode" : "/**\r\n * Tests whether a parent {@code ConfigurationInterpolator} can be set if already a {@code ConfigurationInterpolator} is\r\n * available.\r\n */\r\n@Test\r\nvoid testSetParentInterpolatorExistingInterpolator() {\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    final ConfigurationInterpolator ci = config.getInterpolator();\r\n    config.setParentInterpolator(parent);\r\n    assertSame(parent, config.getInterpolator().getParentInterpolator());\r\n    assertSame(ci, config.getInterpolator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetParentInterpolatorNoInterpolator",
  "sourceCode" : "/**\r\n * Tests whether a parent {@code ConfigurationInterpolator} can be set if currently no {@code ConfigurationInterpolator}\r\n * is available.\r\n */\r\n@Test\r\nvoid testSetParentInterpolatorNoInterpolator() {\r\n    final ConfigurationInterpolator parent = mock(ConfigurationInterpolator.class);\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    config.setInterpolator(null);\r\n    config.setParentInterpolator(parent);\r\n    assertSame(parent, config.getInterpolator().getParentInterpolator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetPrefixLookupsExistingInterpolator",
  "sourceCode" : "/**\r\n * Tests whether prefix lookups can be added to an existing {@code ConfigurationInterpolator}.\r\n */\r\n@Test\r\nvoid testSetPrefixLookupsExistingInterpolator() {\r\n    final Lookup look = mock(Lookup.class);\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    final int count = config.getInterpolator().getLookups().size();\r\n    final Map<String, Lookup> lookups = new HashMap<>();\r\n    lookups.put(\"test\", look);\r\n    config.setPrefixLookups(lookups);\r\n    final Map<String, Lookup> lookups2 = config.getInterpolator().getLookups();\r\n    assertEquals(count + 1, lookups2.size());\r\n    assertSame(look, lookups2.get(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSetPrefixLookupsNoInterpolator",
  "sourceCode" : "/**\r\n * Tests whether prefix lookups can be added if no {@code ConfigurationInterpolator} exists yet.\r\n */\r\n@Test\r\nvoid testSetPrefixLookupsNoInterpolator() {\r\n    final Lookup look = mock(Lookup.class);\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    config.setInterpolator(null);\r\n    config.setPrefixLookups(Collections.singletonMap(\"test\", look));\r\n    final Map<String, Lookup> lookups = config.getInterpolator().getLookups();\r\n    assertEquals(1, lookups.size());\r\n    assertSame(look, lookups.get(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationBasicFeatures.java",
  "methodName" : "testSizeInternal",
  "sourceCode" : "/**\r\n * Tests the default implementation of sizeInternal().\r\n */\r\n@Test\r\nvoid testSizeInternal() {\r\n    final AbstractConfiguration config = new TestConfigurationImpl(new PropertiesConfiguration());\r\n    for (int i = 0; i < PROP_COUNT; i++) {\r\n        config.addProperty(KEY_PREFIX + i, \"value\" + i);\r\n    }\r\n    assertEquals(PROP_COUNT, config.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testAddPropertySynchronized",
  "sourceCode" : "/**\r\n * Tests the correct synchronization of addProperty().\r\n */\r\n@Test\r\nvoid testAddPropertySynchronized() {\r\n    config.addProperty(PROP, \"of course\");\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testAppendSynchronized",
  "sourceCode" : "/**\r\n * Tests whether the append() method uses synchronization.\r\n */\r\n@Test\r\nvoid testAppendSynchronized() {\r\n    final Configuration config2 = prepareConfigurationMockForCopy();\r\n    config.append(config2);\r\n    verifyConfigurationMockAfterCopy(config2);\r\n    verifyNoMoreInteractions(config2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testClearPropertySynchronized",
  "sourceCode" : "/**\r\n * Tests the correct synchronization of clearProperty().\r\n */\r\n@Test\r\nvoid testClearPropertySynchronized() {\r\n    config.clearProperty(PROP);\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testClearSynchronized",
  "sourceCode" : "/**\r\n * Tests the correct synchronization of clear().\r\n */\r\n@Test\r\nvoid testClearSynchronized() {\r\n    config.clear();\r\n    sync.verifyStart(Methods.BEGIN_WRITE);\r\n    sync.verifyEnd(Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testContainsKeySychronized",
  "sourceCode" : "/**\r\n * Tests whether containsKey() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testContainsKeySychronized() {\r\n    assertTrue(config.containsKey(PROP));\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testCopySynchronized",
  "sourceCode" : "/**\r\n * Tests whether the copy() method uses synchronization.\r\n */\r\n@Test\r\nvoid testCopySynchronized() {\r\n    final Configuration config2 = prepareConfigurationMockForCopy();\r\n    config.copy(config2);\r\n    verifyConfigurationMockAfterCopy(config2);\r\n    verifyNoMoreInteractions(config2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testDefaultSynchronizer",
  "sourceCode" : "/**\r\n * Tests the Synchronizer used by default.\r\n */\r\n@Test\r\nvoid testDefaultSynchronizer() {\r\n    assertSame(NoOpSynchronizer.INSTANCE, new PropertiesConfiguration().getSynchronizer());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testGetKeysPrefixSynchronized",
  "sourceCode" : "/**\r\n * Tests whether getKeys(String prefix) is correctly synchronized.\r\n */\r\n@Test\r\nvoid testGetKeysPrefixSynchronized() {\r\n    config.getKeys(\"test\");\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testGetKeysSynchronized",
  "sourceCode" : "/**\r\n * Tests whether getKeys() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testGetKeysSynchronized() {\r\n    assertTrue(config.getKeys().hasNext());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testGetPropertySynchronized",
  "sourceCode" : "/**\r\n * Tests whether read access to properties is synchronized.\r\n */\r\n@Test\r\nvoid testGetPropertySynchronized() {\r\n    assertEquals(\"true\", config.getProperty(PROP));\r\n    assertTrue(config.getBoolean(PROP));\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ, Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testIsEmptySynchronized",
  "sourceCode" : "/**\r\n * Tests whether isEmpty() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testIsEmptySynchronized() {\r\n    assertFalse(config.isEmpty());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testLockNull",
  "sourceCode" : "/**\r\n * Tests lock() with a null argument.\r\n */\r\n@Test\r\nvoid testLockNull() {\r\n    assertThrows(NullPointerException.class, () -> config.lock(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testLockRead",
  "sourceCode" : "/**\r\n * Tests whether a read lock can be obtained.\r\n */\r\n@Test\r\nvoid testLockRead() {\r\n    config.lock(LockMode.READ);\r\n    sync.verify(Methods.BEGIN_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testLockWrite",
  "sourceCode" : "/**\r\n * Tests whether a write lock can be obtained.\r\n */\r\n@Test\r\nvoid testLockWrite() {\r\n    config.lock(LockMode.WRITE);\r\n    sync.verify(Methods.BEGIN_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testSetPropertySynchronized",
  "sourceCode" : "/**\r\n * Tests the correct synchronization of setProperty().\r\n */\r\n@Test\r\nvoid testSetPropertySynchronized() {\r\n    config.setProperty(PROP, \"yes\");\r\n    sync.verifyStart(Methods.BEGIN_WRITE);\r\n    sync.verifyEnd(Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testSizeSynchronized",
  "sourceCode" : "/**\r\n * Tests whether size() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testSizeSynchronized() {\r\n    assertFalse(config.isEmpty());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testSubsetSynchronized",
  "sourceCode" : "/**\r\n * Tests synchronization of subset().\r\n */\r\n@Test\r\nvoid testSubsetSynchronized() {\r\n    final AbstractConfiguration subset = (AbstractConfiguration) config.subset(\"configuration\");\r\n    sync.verify();\r\n    assertEquals(NoOpSynchronizer.INSTANCE, subset.getSynchronizer());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testUnlockRead",
  "sourceCode" : "/**\r\n * Tests whether a read lock can be released.\r\n */\r\n@Test\r\nvoid testUnlockRead() {\r\n    config.unlock(LockMode.READ);\r\n    sync.verify(Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractConfigurationSynchronization.java",
  "methodName" : "testUnlockWrite",
  "sourceCode" : "/**\r\n * Tests whether a write lock can be released.\r\n */\r\n@Test\r\nvoid testUnlockWrite() {\r\n    config.unlock(LockMode.WRITE);\r\n    sync.verify(Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testAddNodes",
  "sourceCode" : "@Test\r\nvoid testAddNodes() {\r\n    final Collection<ImmutableNode> nodes = new ArrayList<>();\r\n    nodes.add(NodeStructureHelper.createFieldNode(\"birthDate\"));\r\n    nodes.add(NodeStructureHelper.createFieldNode(\"lastLogin\"));\r\n    nodes.add(NodeStructureHelper.createFieldNode(\"language\"));\r\n    config.addNodes(\"tables.table(0).fields\", nodes);\r\n    assertEquals(7, config.getMaxIndex(\"tables.table(0).fields.field\"));\r\n    assertEquals(\"birthDate\", config.getString(\"tables.table(0).fields.field(5).name\"));\r\n    assertEquals(\"lastLogin\", config.getString(\"tables.table(0).fields.field(6).name\"));\r\n    assertEquals(\"language\", config.getString(\"tables.table(0).fields.field(7).name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testAddNodesCopy",
  "sourceCode" : "/**\r\n * Tests copying nodes from one configuration to another one.\r\n */\r\n@Test\r\nvoid testAddNodesCopy() {\r\n    final AbstractHierarchicalConfigurationTestImpl configDest = new AbstractHierarchicalConfigurationTestImpl(new InMemoryNodeModel());\r\n    configDest.addProperty(\"test\", \"TEST\");\r\n    final Collection<ImmutableNode> nodes = getRootNode().getChildren();\r\n    assertEquals(1, nodes.size());\r\n    configDest.addNodes(\"newNodes\", nodes);\r\n    for (int i = 0; i < NodeStructureHelper.tablesLength(); i++) {\r\n        final String keyTab = \"newNodes.tables.table(\" + i + \").\";\r\n        assertEquals(NodeStructureHelper.table(i), configDest.getString(keyTab + \"name\"), \"Table \" + i + \" not found\");\r\n        for (int j = 0; j < NodeStructureHelper.fieldsLength(i); j++) {\r\n            assertEquals(NodeStructureHelper.field(i, j), configDest.getString(keyTab + \"fields.field(\" + j + \").name\"), \"Invalid field \" + j + \" in table \" + i);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testAddNodesForNonExistingKey",
  "sourceCode" : "/**\r\n * Tests the addNodes() method if the provided key does not exist. In this case, a new node (or even a completely new\r\n * branch) is created.\r\n */\r\n@Test\r\nvoid testAddNodesForNonExistingKey() {\r\n    final Collection<ImmutableNode> nodes = new ArrayList<>();\r\n    final ImmutableNode newNode = new ImmutableNode.Builder().name(\"usr\").value(\"scott\").addAttribute(\"pwd\", \"tiger\").create();\r\n    nodes.add(newNode);\r\n    config.addNodes(\"database.connection.settings\", nodes);\r\n    assertEquals(\"scott\", config.getString(\"database.connection.settings.usr\"));\r\n    assertEquals(\"tiger\", config.getString(\"database.connection.settings.usr[@pwd]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testAddNodesWithAttributeKey",
  "sourceCode" : "/**\r\n * Tests the addNodes() method when the new nodes should be added to an attribute node. This is not allowed.\r\n */\r\n@Test\r\nvoid testAddNodesWithAttributeKey() {\r\n    final Collection<ImmutableNode> nodes = new ArrayList<>();\r\n    nodes.add(NodeStructureHelper.createNode(\"testNode\", \"yes\"));\r\n    assertThrows(IllegalArgumentException.class, () -> config.addNodes(\"database.connection[@settings]\", nodes));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testAddProperty",
  "sourceCode" : "@Test\r\nvoid testAddProperty() {\r\n    config.addProperty(\"tables.table(0).fields.field(-1).name\", \"phone\");\r\n    Object prop = config.getProperty(\"tables.table(0).fields.field.name\");\r\n    Collection<?> collection = assertInstanceOf(Collection.class, prop);\r\n    assertEquals(6, collection.size());\r\n    config.addProperty(\"tables.table(0).fields.field.name\", \"fax\");\r\n    prop = config.getProperty(\"tables.table.fields.field(5).name\");\r\n    final List<?> list = assertInstanceOf(List.class, prop);\r\n    assertEquals(\"phone\", list.get(0));\r\n    assertEquals(\"fax\", list.get(1));\r\n    config.addProperty(\"tables.table(-1).name\", \"config\");\r\n    prop = config.getProperty(\"tables.table.name\");\r\n    collection = assertInstanceOf(Collection.class, prop);\r\n    assertEquals(3, collection.size());\r\n    config.addProperty(\"tables.table(2).fields.field(0).name\", \"cid\");\r\n    config.addProperty(\"tables.table(2).fields.field(-1).name\", \"confName\");\r\n    prop = config.getProperty(\"tables.table(2).fields.field.name\");\r\n    collection = assertInstanceOf(Collection.class, prop);\r\n    assertEquals(2, collection.size());\r\n    assertEquals(\"confName\", config.getProperty(\"tables.table(2).fields.field(1).name\"));\r\n    config.addProperty(\"connection.user\", \"scott\");\r\n    config.addProperty(\"connection.passwd\", \"tiger\");\r\n    assertEquals(\"tiger\", config.getProperty(\"connection.passwd\"));\r\n    final DefaultConfigurationKey key = createConfigurationKey();\r\n    key.append(\"tables\").append(\"table\").appendIndex(0);\r\n    key.appendAttribute(\"tableType\");\r\n    config.addProperty(key.toString(), \"system\");\r\n    assertEquals(\"system\", config.getProperty(key.toString()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testAddPropertyInvalidKey",
  "sourceCode" : "@Test\r\nvoid testAddPropertyInvalidKey() {\r\n    assertThrows(IllegalArgumentException.class, () -> config.addProperty(\".\", \"InvalidKey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testAddPropertyWithListHandling",
  "sourceCode" : "/**\r\n * Tests whether list handling works correctly when adding properties.\r\n */\r\n@Test\r\nvoid testAddPropertyWithListHandling() {\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    final String key = \"list.delimiter.value\";\r\n    config.addProperty(key + \".escaped\", \"3\\\\,1415\");\r\n    config.addProperty(key + \".elements\", \"3,1415\");\r\n    assertEquals(\"3,1415\", config.getString(key + \".escaped\"));\r\n    assertEquals(\"3\", config.getString(key + \".elements\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testClear",
  "sourceCode" : "@Test\r\nvoid testClear() {\r\n    config.setProperty(null, \"value\");\r\n    config.addProperty(\"[@attr]\", \"defined\");\r\n    config.clear();\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Test\r\nvoid testClearProperty() {\r\n    config.clearProperty(\"tables.table(0).fields.field(0).name\");\r\n    assertEquals(\"uname\", config.getProperty(\"tables.table(0).fields.field(0).name\"));\r\n    config.clearProperty(\"tables.table(0).name\");\r\n    assertFalse(config.containsKey(\"tables.table(0).name\"));\r\n    assertEquals(\"firstName\", config.getProperty(\"tables.table(0).fields.field(1).name\"));\r\n    assertEquals(\"documents\", config.getProperty(\"tables.table.name\"));\r\n    config.clearProperty(\"tables.table\");\r\n    assertEquals(\"documents\", config.getProperty(\"tables.table.name\"));\r\n    config.addProperty(\"test\", \"first\");\r\n    config.addProperty(\"test.level\", \"second\");\r\n    config.clearProperty(\"test\");\r\n    assertEquals(\"second\", config.getString(\"test.level\"));\r\n    assertFalse(config.containsKey(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testClearTree",
  "sourceCode" : "@Test\r\nvoid testClearTree() {\r\n    Object prop = config.getProperty(\"tables.table(0).fields.field.name\");\r\n    assertNotNull(prop);\r\n    config.clearTree(\"tables.table(0).fields.field(3)\");\r\n    prop = config.getProperty(\"tables.table(0).fields.field.name\");\r\n    Collection<?> collection = assertInstanceOf(Collection.class, prop);\r\n    assertEquals(4, collection.size());\r\n    config.clearTree(\"tables.table(0).fields\");\r\n    assertNull(config.getProperty(\"tables.table(0).fields.field.name\"));\r\n    prop = config.getProperty(\"tables.table.fields.field.name\");\r\n    collection = assertInstanceOf(Collection.class, prop);\r\n    assertEquals(NodeStructureHelper.fieldsLength(1), collection.size());\r\n    config.clearTree(\"tables.table(1)\");\r\n    assertNull(config.getProperty(\"tables.table.fields.field.name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testClearTreeComplex",
  "sourceCode" : "/**\r\n * Tests removing more complex node structures.\r\n */\r\n@Test\r\nvoid testClearTreeComplex() {\r\n    final int count = 5;\r\n    // create the structure\r\n    for (int idx = 0; idx < count; idx++) {\r\n        config.addProperty(\"indexList.index(-1)[@default]\", Boolean.FALSE);\r\n        config.addProperty(\"indexList.index[@name]\", \"test\" + idx);\r\n        config.addProperty(\"indexList.index.dir\", \"testDir\" + idx);\r\n    }\r\n    assertEquals(count - 1, config.getMaxIndex(\"indexList.index[@name]\"));\r\n    // Remove a sub tree\r\n    boolean found = false;\r\n    for (int idx = 0; true; idx++) {\r\n        final String name = config.getString(\"indexList.index(\" + idx + \")[@name]\");\r\n        if (name == null) {\r\n            break;\r\n        }\r\n        if (\"test3\".equals(name)) {\r\n            assertEquals(\"testDir3\", config.getString(\"indexList.index(\" + idx + \").dir\"));\r\n            config.clearTree(\"indexList.index(\" + idx + \")\");\r\n            found = true;\r\n        }\r\n    }\r\n    assertTrue(found);\r\n    assertEquals(count - 2, config.getMaxIndex(\"indexList.index[@name]\"));\r\n    assertEquals(count - 2, config.getMaxIndex(\"indexList.index.dir\"));\r\n    // Verify\r\n    for (int idx = 0; true; idx++) {\r\n        final String name = config.getString(\"indexList.index(\" + idx + \")[@name]\");\r\n        if (name == null) {\r\n            break;\r\n        }\r\n        assertNotEquals(\"test3\", name);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testClearTreeHierarchy",
  "sourceCode" : "/**\r\n * Tests the clearTree() method on a hierarchical structure of nodes. This is a test case for CONFIGURATION-293.\r\n */\r\n@Test\r\nvoid testClearTreeHierarchy() {\r\n    config.addProperty(\"a.b.c\", \"c\");\r\n    config.addProperty(\"a.b.c.d\", \"d\");\r\n    config.addProperty(\"a.b.c.d.e\", \"e\");\r\n    config.clearTree(\"a.b.c\");\r\n    assertFalse(config.containsKey(\"a.b.c\"));\r\n    assertFalse(config.containsKey(\"a.b.c.d\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "@Test\r\nvoid testClone() {\r\n    final Configuration copy = (Configuration) config.clone();\r\n    assertInstanceOf(AbstractHierarchicalConfiguration.class, copy);\r\n    checkContent(copy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testCloneInterpolation",
  "sourceCode" : "/**\r\n * Tests whether interpolation works as expected after cloning.\r\n */\r\n@Test\r\nvoid testCloneInterpolation() {\r\n    final String keyAnswer = \"answer\";\r\n    final String keyValue = \"value\";\r\n    config.addProperty(keyAnswer, \"The answer is ${\" + keyValue + \"}.\");\r\n    config.addProperty(keyValue, 42);\r\n    final Configuration clone = (Configuration) config.clone();\r\n    clone.setProperty(keyValue, 43);\r\n    assertEquals(\"The answer is 42.\", config.getString(keyAnswer));\r\n    assertEquals(\"The answer is 43.\", clone.getString(keyAnswer));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testCloneWithEventListeners",
  "sourceCode" : "/**\r\n * Tests whether registered event handlers are handled correctly when a configuration is cloned. They should not be\r\n * registered at the clone.\r\n */\r\n@Test\r\nvoid testCloneWithEventListeners() {\r\n    final EventListener<ConfigurationEvent> l = new EventListenerTestImpl(null);\r\n    config.addEventListener(ConfigurationEvent.ANY, l);\r\n    final AbstractHierarchicalConfiguration<?> copy = (AbstractHierarchicalConfiguration<?>) config.clone();\r\n    assertFalse(copy.getEventListeners(ConfigurationEvent.ANY).contains(l));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testContainsKey",
  "sourceCode" : "@Test\r\nvoid testContainsKey() {\r\n    assertTrue(config.containsKey(\"tables.table(0).name\"));\r\n    assertTrue(config.containsKey(\"tables.table(1).name\"));\r\n    assertFalse(config.containsKey(\"tables.table(2).name\"));\r\n    assertTrue(config.containsKey(\"tables.table(0).fields.field.name\"));\r\n    assertFalse(config.containsKey(\"tables.table(0).fields.field\"));\r\n    config.clearTree(\"tables.table(0).fields\");\r\n    assertFalse(config.containsKey(\"tables.table(0).fields.field.name\"));\r\n    assertTrue(config.containsKey(\"tables.table.fields.field.name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Test\r\nvoid testContainsValue() {\r\n    assertFalse(config.containsValue(null));\r\n    assertFalse(config.containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "@Test\r\nvoid testGetKeys() {\r\n    final List<String> keys = new ArrayList<>();\r\n    for (final Iterator<String> it = config.getKeys(); it.hasNext(); ) {\r\n        keys.add(it.next());\r\n    }\r\n    assertEquals(Arrays.asList(\"tables.table.name\", \"tables.table.fields.field.name\"), keys);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetKeysAttribute",
  "sourceCode" : "/**\r\n * Tests whether attribute keys are contained in the iteration of keys.\r\n */\r\n@Test\r\nvoid testGetKeysAttribute() {\r\n    config.addProperty(\"tables.table(0)[@type]\", \"system\");\r\n    final Set<String> keys = new HashSet<>();\r\n    for (final Iterator<String> it = config.getKeys(); it.hasNext(); ) {\r\n        keys.add(it.next());\r\n    }\r\n    assertTrue(keys.contains(\"tables.table[@type]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetKeysAttributePrefix",
  "sourceCode" : "/**\r\n * Tests whether a prefix that points to an attribute is correctly handled.\r\n */\r\n@Test\r\nvoid testGetKeysAttributePrefix() {\r\n    config.addProperty(\"tables.table(0)[@type]\", \"system\");\r\n    final Iterator<String> itKeys = config.getKeys(\"tables.table[@type]\");\r\n    assertEquals(\"tables.table[@type]\", itKeys.next());\r\n    assertFalse(itKeys.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetKeysOrder",
  "sourceCode" : "/**\r\n * Tests whether keys are returned in a defined order.\r\n */\r\n@Test\r\nvoid testGetKeysOrder() {\r\n    config.addProperty(\"order.key1\", \"value1\");\r\n    config.addProperty(\"order.key2\", \"value2\");\r\n    config.addProperty(\"order.key3\", \"value3\");\r\n    final Iterator<String> it = config.getKeys(\"order\");\r\n    assertEquals(\"order.key1\", it.next());\r\n    assertEquals(\"order.key2\", it.next());\r\n    assertEquals(\"order.key3\", it.next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetKeysString",
  "sourceCode" : "@Test\r\nvoid testGetKeysString() {\r\n    // add some more properties to make it more interesting\r\n    config.addProperty(\"tables.table(0).fields.field(1).type\", \"VARCHAR\");\r\n    config.addProperty(\"tables.table(0)[@type]\", \"system\");\r\n    config.addProperty(\"tables.table(0).size\", \"42\");\r\n    config.addProperty(\"tables.table(0).fields.field(0).size\", \"128\");\r\n    config.addProperty(\"connections.connection.param.url\", \"url1\");\r\n    config.addProperty(\"connections.connection.param.user\", \"me\");\r\n    config.addProperty(\"connections.connection.param.pwd\", \"secret\");\r\n    config.addProperty(\"connections.connection(-1).param.url\", \"url2\");\r\n    config.addProperty(\"connections.connection(1).param.user\", \"guest\");\r\n    checkKeys(\"tables.table(1)\", new String[] { \"name\", \"fields.field.name\" });\r\n    checkKeys(\"tables.table(0)\", new String[] { \"name\", \"fields.field.name\", \"tables.table(0)[@type]\", \"size\", \"fields.field.type\", \"fields.field.size\" });\r\n    checkKeys(\"connections.connection(0).param\", new String[] { \"url\", \"user\", \"pwd\" });\r\n    checkKeys(\"connections.connection(1).param\", new String[] { \"url\", \"user\" });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetKeysWithKeyAsPrefix",
  "sourceCode" : "/**\r\n * Tests getKeys() with a prefix when the prefix matches exactly a key.\r\n */\r\n@Test\r\nvoid testGetKeysWithKeyAsPrefix() {\r\n    config.addProperty(\"order.key1\", \"value1\");\r\n    config.addProperty(\"order.key2\", \"value2\");\r\n    final Iterator<String> it = config.getKeys(\"order.key1\");\r\n    assertTrue(it.hasNext());\r\n    assertEquals(\"order.key1\", it.next());\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetKeysWithKeyAsPrefixMultiple",
  "sourceCode" : "/**\r\n * Tests getKeys() with a prefix when the prefix matches exactly a key, and there are multiple keys starting with this\r\n * prefix.\r\n */\r\n@Test\r\nvoid testGetKeysWithKeyAsPrefixMultiple() {\r\n    config.addProperty(\"order.key1\", \"value1\");\r\n    config.addProperty(\"order.key1.test\", \"value2\");\r\n    config.addProperty(\"order.key1.test.complex\", \"value2\");\r\n    final Iterator<String> it = config.getKeys(\"order.key1\");\r\n    assertEquals(\"order.key1\", it.next());\r\n    assertEquals(\"order.key1.test\", it.next());\r\n    assertEquals(\"order.key1.test.complex\", it.next());\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetMaxIndex",
  "sourceCode" : "@Test\r\nvoid testGetMaxIndex() {\r\n    assertEquals(NodeStructureHelper.fieldsLength(0) - 1, config.getMaxIndex(\"tables.table(0).fields.field\"));\r\n    assertEquals(NodeStructureHelper.fieldsLength(1) - 1, config.getMaxIndex(\"tables.table(1).fields.field\"));\r\n    assertEquals(1, config.getMaxIndex(\"tables.table\"));\r\n    assertEquals(1, config.getMaxIndex(\"tables.table.name\"));\r\n    assertEquals(0, config.getMaxIndex(\"tables.table(0).name\"));\r\n    assertEquals(0, config.getMaxIndex(\"tables.table(1).fields.field(1)\"));\r\n    assertEquals(-1, config.getMaxIndex(\"tables.table(2).fields\"));\r\n    final int maxIdx = config.getMaxIndex(\"tables.table(0).fields.field.name\");\r\n    for (int i = 0; i <= maxIdx; i++) {\r\n        final DefaultConfigurationKey key = new DefaultConfigurationKey(DefaultExpressionEngine.INSTANCE, \"tables.table(0).fields\");\r\n        key.append(\"field\").appendIndex(i).append(\"name\");\r\n        assertNotNull(config.getProperty(key.toString()));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetNodeModel",
  "sourceCode" : "/**\r\n * Tests whether the configuration's node model can be correctly accessed.\r\n */\r\n@Test\r\nvoid testGetNodeModel() {\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    config.setSynchronizer(sync);\r\n    final NodeModel<ImmutableNode> model = config.getNodeModel();\r\n    assertInstanceOf(InMemoryNodeModel.class, model);\r\n    final ImmutableNode rootNode = model.getNodeHandler().getRootNode();\r\n    assertEquals(1, rootNode.getChildren().size());\r\n    assertTrue(rootNode.getChildren().contains(NodeStructureHelper.ROOT_TABLES_TREE));\r\n    sync.verify(SynchronizerTestImpl.Methods.BEGIN_READ, SynchronizerTestImpl.Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() {\r\n    checkGetProperty(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testGetPropertyKeyWithBrackets",
  "sourceCode" : "/**\r\n * Tests whether keys that contains brackets can be used.\r\n */\r\n@Test\r\nvoid testGetPropertyKeyWithBrackets() {\r\n    final String key = \"test.directory.platform(x86)\";\r\n    config.addProperty(key, \"C:\\\\Temp\");\r\n    assertEquals(\"C:\\\\Temp\", config.getString(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInitCopyNull",
  "sourceCode" : "/**\r\n * Tests the copy constructor when a null reference is passed.\r\n */\r\n@Test\r\nvoid testInitCopyNull() {\r\n    final BaseHierarchicalConfiguration copy = new BaseHierarchicalConfiguration((BaseHierarchicalConfiguration) null);\r\n    assertTrue(copy.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolatedConfiguration",
  "sourceCode" : "/**\r\n * Tests obtaining a configuration with all variables substituted.\r\n */\r\n@Test\r\nvoid testInterpolatedConfiguration() {\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    final AbstractHierarchicalConfiguration<?> c = (AbstractHierarchicalConfiguration<?>) InterpolationTestHelper.testInterpolatedConfiguration(config);\r\n    // tests whether the hierarchical structure has been maintained\r\n    checkGetProperty(c);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolation",
  "sourceCode" : "/**\r\n * Tests interpolation facilities.\r\n */\r\n@Test\r\nvoid testInterpolation() {\r\n    config.addProperty(\"base.dir\", \"/home/foo\");\r\n    config.addProperty(\"test.absolute.dir.dir1\", \"${base.dir}/path1\");\r\n    config.addProperty(\"test.absolute.dir.dir2\", \"${base.dir}/path2\");\r\n    config.addProperty(\"test.absolute.dir.dir3\", \"${base.dir}/path3\");\r\n    final Configuration sub = config.subset(\"test.absolute.dir\");\r\n    for (int i = 1; i < 4; i++) {\r\n        assertEquals(\"/home/foo/path\" + i, config.getString(\"test.absolute.dir.dir\" + i));\r\n        assertEquals(\"/home/foo/path\" + i, sub.getString(\"dir\" + i));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationBasic",
  "sourceCode" : "/**\r\n * Basic interpolation tests.\r\n */\r\n@Test\r\nvoid testInterpolationBasic() {\r\n    InterpolationTestHelper.testInterpolation(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationConstants",
  "sourceCode" : "/**\r\n * Tests interpolation with constant values.\r\n */\r\n@Test\r\nvoid testInterpolationConstants() {\r\n    InterpolationTestHelper.testInterpolationConstants(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationEscaped",
  "sourceCode" : "/**\r\n * Tests escaping variables.\r\n */\r\n@Test\r\nvoid testInterpolationEscaped() {\r\n    InterpolationTestHelper.testInterpolationEscaped(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationLocalhost",
  "sourceCode" : "/**\r\n * Tests interpolation with localhost values.\r\n */\r\n@Test\r\nvoid testInterpolationLocalhost() {\r\n    InterpolationTestHelper.testInterpolationLocalhost(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationLoop",
  "sourceCode" : "/**\r\n * Tests an invalid interpolation that causes an endless loop.\r\n */\r\n@Test\r\nvoid testInterpolationLoop() {\r\n    InterpolationTestHelper.testInterpolationLoop(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationMultipleLevels",
  "sourceCode" : "/**\r\n * Tests multiple levels of interpolation.\r\n */\r\n@Test\r\nvoid testInterpolationMultipleLevels() {\r\n    InterpolationTestHelper.testMultipleInterpolation(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationSubset",
  "sourceCode" : "/**\r\n * Tests interpolation with a subset.\r\n */\r\n@Test\r\nvoid testInterpolationSubset() {\r\n    InterpolationTestHelper.testInterpolationSubset(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationSubsetMultipleLayers",
  "sourceCode" : "/**\r\n * Tests whether interpolation with a subset configuration works over multiple layers.\r\n */\r\n@Test\r\nvoid testInterpolationSubsetMultipleLayers() {\r\n    config.clear();\r\n    config.addProperty(\"var\", \"value\");\r\n    config.addProperty(\"prop2.prop[@attr]\", \"${var}\");\r\n    final Configuration sub1 = config.subset(\"prop2\");\r\n    final Configuration sub2 = sub1.subset(\"prop\");\r\n    assertEquals(\"value\", sub2.getString(\"[@attr]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationSystemProperties",
  "sourceCode" : "/**\r\n * Tests interpolation with system properties.\r\n */\r\n@Test\r\nvoid testInterpolationSystemProperties() {\r\n    InterpolationTestHelper.testInterpolationSystemProperties(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolationUnknownProperty",
  "sourceCode" : "/**\r\n * Tests interpolation of a variable, which cannot be resolved.\r\n */\r\n@Test\r\nvoid testInterpolationUnknownProperty() {\r\n    InterpolationTestHelper.testInterpolationUnknownProperty(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testInterpolator",
  "sourceCode" : "/**\r\n * Tests manipulating the interpolator.\r\n */\r\n@Test\r\nvoid testInterpolator() {\r\n    InterpolationTestHelper.testGetInterpolator(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testIsEmptyFalse",
  "sourceCode" : "@Test\r\nvoid testIsEmptyFalse() {\r\n    assertFalse(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testIsEmptyNodesWithNoValues",
  "sourceCode" : "/**\r\n * Tests isEmpty() if the structure contains some nodes without values.\r\n */\r\n@Test\r\nvoid testIsEmptyNodesWithNoValues() {\r\n    final ImmutableNode.Builder rootBuilder = new ImmutableNode.Builder(1);\r\n    final ImmutableNode.Builder nodeBuilder = new ImmutableNode.Builder(1);\r\n    nodeBuilder.addChild(NodeStructureHelper.createNode(\"child\", null));\r\n    rootBuilder.addChild(nodeBuilder.create());\r\n    config = new AbstractHierarchicalConfigurationTestImpl(new InMemoryNodeModel(rootBuilder.create()));\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testIsEmptyRootOnly",
  "sourceCode" : "/**\r\n * Tests isEmpty() if only the root node exists.\r\n */\r\n@Test\r\nvoid testIsEmptyRootOnly() {\r\n    config = new AbstractHierarchicalConfigurationTestImpl(new InMemoryNodeModel());\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testNodeKeyCacheHit",
  "sourceCode" : "/**\r\n * Tests nodeKey() if the key is directly found in the cache.\r\n */\r\n@Test\r\nvoid testNodeKeyCacheHit() {\r\n    final Map<ImmutableNode, String> cache = new HashMap<>();\r\n    final String key = \"someResultKey\";\r\n    cache.put(getRootNode(), key);\r\n    assertEquals(key, config.nodeKey(getRootNode(), cache, config.getModel().getNodeHandler()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testNodeKeyCachePopulated",
  "sourceCode" : "/**\r\n * Tests whether the cache map is filled while generating node keys.\r\n */\r\n@Test\r\nvoid testNodeKeyCachePopulated() {\r\n    final Map<ImmutableNode, String> cache = new HashMap<>();\r\n    final ImmutableNode nodeTabName = NodeStructureHelper.nodeForKey(getRootNode(), \"tables/table(0)/name\");\r\n    final NodeHandler<ImmutableNode> handler = config.getModel().getNodeHandler();\r\n    config.nodeKey(nodeTabName, cache, handler);\r\n    assertEquals(4, cache.size());\r\n    assertEquals(\"tables(0).table(0).name(0)\", cache.get(nodeTabName));\r\n    assertEquals(\"tables(0).table(0)\", cache.get(handler.getParent(nodeTabName)));\r\n    assertEquals(\"tables(0)\", cache.get(handler.getParent(handler.getParent(nodeTabName))));\r\n    assertEquals(\"\", cache.get(getRootNode()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testNodeKeyCacheUsage",
  "sourceCode" : "/**\r\n * Tests whether the cache is used by nodeKey().\r\n */\r\n@Test\r\nvoid testNodeKeyCacheUsage() {\r\n    final Map<ImmutableNode, String> cache = new HashMap<>();\r\n    final ImmutableNode nodeTabName = NodeStructureHelper.nodeForKey(getRootNode(), \"tables/table(0)/name\");\r\n    final NodeHandler<ImmutableNode> handler = config.getModel().getNodeHandler();\r\n    cache.put(handler.getParent(nodeTabName), \"somePrefix\");\r\n    assertEquals(\"somePrefix.name(0)\", config.nodeKey(nodeTabName, cache, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testNodeKeyEmptyCache",
  "sourceCode" : "/**\r\n * Tests whether a correct node key is generated if no data is contained in the cache.\r\n */\r\n@Test\r\nvoid testNodeKeyEmptyCache() {\r\n    final Map<ImmutableNode, String> cache = new HashMap<>();\r\n    final ImmutableNode nodeTabName = NodeStructureHelper.nodeForKey(getRootNode(), \"tables/table(0)/name\");\r\n    final ImmutableNode nodeFldName = NodeStructureHelper.nodeForKey(getRootNode(), \"tables/table(0)/fields/field(1)/name\");\r\n    assertEquals(\"tables(0).table(0).name(0)\", config.nodeKey(nodeTabName, cache, config.getModel().getNodeHandler()));\r\n    assertEquals(\"tables(0).table(0).fields(0).field(1).name(0)\", config.nodeKey(nodeFldName, cache, config.getModel().getNodeHandler()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testNodeKeyRootNode",
  "sourceCode" : "/**\r\n * Tests whether a node key for the root node can be generated.\r\n */\r\n@Test\r\nvoid testNodeKeyRootNode() {\r\n    final Map<ImmutableNode, String> cache = new HashMap<>();\r\n    assertEquals(\"\", config.nodeKey(getRootNode(), cache, config.getModel().getNodeHandler()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testResolveNodeKey",
  "sourceCode" : "/**\r\n * Tests whether node keys can be resolved.\r\n */\r\n@Test\r\nvoid testResolveNodeKey() {\r\n    final List<ImmutableNode> nodes = config.resolveNodeKey(getRootNode(), \"tables.table.name\", config.getModel().getNodeHandler());\r\n    assertEquals(NodeStructureHelper.tablesLength(), nodes.size());\r\n    for (int i = 0; i < NodeStructureHelper.tablesLength(); i++) {\r\n        assertEquals(NodeStructureHelper.table(i), nodes.get(i).getValue(), \"Wrong node value at \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testResolveNodeKeyAttribute",
  "sourceCode" : "/**\r\n * Tests whether attribute keys are filtered out when resolving node keys.\r\n */\r\n@Test\r\nvoid testResolveNodeKeyAttribute() {\r\n    final String attrKey = \"tables.table(0)[@type]\";\r\n    config.addProperty(attrKey, \"system\");\r\n    assertTrue(config.resolveNodeKey(getRootNode(), attrKey, config.getModel().getNodeHandler()).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testSetExpressionEngine",
  "sourceCode" : "/**\r\n * Tests setting a custom expression engine, which uses a slightly different syntax.\r\n */\r\n@Test\r\nvoid testSetExpressionEngine() {\r\n    config.setExpressionEngine(null);\r\n    assertNotNull(config.getExpressionEngine());\r\n    assertSame(DefaultExpressionEngine.INSTANCE, config.getExpressionEngine());\r\n    config.setExpressionEngine(createAlternativeExpressionEngine());\r\n    checkAlternativeSyntax();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testSetProperty",
  "sourceCode" : "@Test\r\nvoid testSetProperty() {\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    config.setProperty(\"tables.table(0).name\", \"resources\");\r\n    assertEquals(\"resources\", config.getString(\"tables.table(0).name\"));\r\n    config.setProperty(\"tables.table.name\", \"tab1,tab2\");\r\n    assertEquals(\"tab1\", config.getString(\"tables.table(0).name\"));\r\n    assertEquals(\"tab2\", config.getString(\"tables.table(1).name\"));\r\n    config.setProperty(\"test.items.item\", new int[] { 2, 4, 8, 16 });\r\n    assertEquals(3, config.getMaxIndex(\"test.items.item\"));\r\n    assertEquals(8, config.getInt(\"test.items.item(2)\"));\r\n    config.setProperty(\"test.items.item(2)\", Integer.valueOf(6));\r\n    assertEquals(6, config.getInt(\"test.items.item(2)\"));\r\n    config.setProperty(\"test.items.item(2)\", new int[] { 7, 9, 11 });\r\n    assertEquals(5, config.getMaxIndex(\"test.items.item\"));\r\n    config.setProperty(\"test\", Boolean.TRUE);\r\n    config.setProperty(\"test.items\", \"01/01/05\");\r\n    assertEquals(5, config.getMaxIndex(\"test.items.item\"));\r\n    assertTrue(config.getBoolean(\"test\"));\r\n    assertEquals(\"01/01/05\", config.getProperty(\"test.items\"));\r\n    config.setProperty(\"test.items.item\", Integer.valueOf(42));\r\n    assertEquals(0, config.getMaxIndex(\"test.items.item\"));\r\n    assertEquals(42, config.getInt(\"test.items.item\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestAbstractHierarchicalConfiguration.java",
  "methodName" : "testSize",
  "sourceCode" : "/**\r\n * Tests whether the correct size is calculated.\r\n */\r\n@Test\r\nvoid testSize() {\r\n    assertEquals(2, config.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testAddProperty",
  "sourceCode" : "@Test\r\nvoid testAddProperty() throws Exception {\r\n    Collection<Object> props = new ArrayList<>();\r\n    props.add(\"one\");\r\n    props.add(\"two,three,four\");\r\n    props.add(new String[] { \"5.1\", \"5.2\", \"5.3,5.4\", \"5.5\" });\r\n    props.add(\"six\");\r\n    config.addProperty(\"complex.property\", props);\r\n    Object val = config.getProperty(\"complex.property\");\r\n    Collection<?> col = assertInstanceOf(Collection.class, val);\r\n    assertEquals(10, col.size());\r\n    props = new ArrayList<>();\r\n    props.add(\"quick\");\r\n    props.add(\"brown\");\r\n    props.add(\"fox,jumps\");\r\n    final Object[] data = { \"The\", props, \"over,the\", \"lazy\", \"dog.\" };\r\n    config.setProperty(\"complex.property\", data);\r\n    val = config.getProperty(\"complex.property\");\r\n    col = assertInstanceOf(Collection.class, val);\r\n    final Iterator<?> it = col.iterator();\r\n    final StringTokenizer tok = new StringTokenizer(\"The quick brown fox jumps over the lazy dog.\", \" \");\r\n    while (tok.hasMoreTokens()) {\r\n        assertTrue(it.hasNext());\r\n        assertEquals(tok.nextToken(), it.next());\r\n    }\r\n    assertFalse(it.hasNext());\r\n    config.setProperty(\"complex.property\", null);\r\n    assertFalse(config.containsKey(\"complex.property\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests cloning a BaseConfiguration.\r\n */\r\n@Test\r\nvoid testClone() {\r\n    for (int i = 0; i < 10; i++) {\r\n        config.addProperty(\"key\" + i, Integer.valueOf(i));\r\n    }\r\n    final BaseConfiguration config2 = (BaseConfiguration) config.clone();\r\n    for (final Iterator<String> it = config.getKeys(); it.hasNext(); ) {\r\n        final String key = it.next();\r\n        assertTrue(config2.containsKey(key), \"Key not found: \" + key);\r\n        assertEquals(config.getProperty(key), config2.getProperty(key), \"Wrong value for key \" + key);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testCloneInterpolation",
  "sourceCode" : "/**\r\n * Tests whether interpolation works as expected after cloning.\r\n */\r\n@Test\r\nvoid testCloneInterpolation() {\r\n    final String keyAnswer = \"answer\";\r\n    config.addProperty(keyAnswer, \"The answer is ${\" + KEY_NUMBER + \"}.\");\r\n    config.addProperty(KEY_NUMBER, 42);\r\n    final BaseConfiguration clone = (BaseConfiguration) config.clone();\r\n    clone.setProperty(KEY_NUMBER, 43);\r\n    assertEquals(\"The answer is 42.\", config.getString(keyAnswer));\r\n    assertEquals(\"The answer is 43.\", clone.getString(keyAnswer));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testCloneListProperty",
  "sourceCode" : "/**\r\n * Tests the clone() method if a list property is involved.\r\n */\r\n@Test\r\nvoid testCloneListProperty() {\r\n    final String key = \"list\";\r\n    config.addProperty(key, \"value1\");\r\n    config.addProperty(key, \"value2\");\r\n    final BaseConfiguration config2 = (BaseConfiguration) config.clone();\r\n    config2.addProperty(key, \"value3\");\r\n    assertEquals(2, config.getList(key).size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testCloneModify",
  "sourceCode" : "/**\r\n * Tests whether a cloned configuration is decoupled from its original.\r\n */\r\n@Test\r\nvoid testCloneModify() {\r\n    final EventListener<ConfigurationEvent> l = new EventListenerTestImpl(config);\r\n    config.addEventListener(ConfigurationEvent.ANY, l);\r\n    config.addProperty(\"original\", Boolean.TRUE);\r\n    final BaseConfiguration config2 = (BaseConfiguration) config.clone();\r\n    config2.addProperty(\"clone\", Boolean.TRUE);\r\n    assertFalse(config.containsKey(\"clone\"));\r\n    config2.setProperty(\"original\", Boolean.FALSE);\r\n    assertTrue(config.getBoolean(\"original\"));\r\n    assertTrue(config2.getEventListeners(ConfigurationEvent.ANY).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testCommaSeparatedString",
  "sourceCode" : "@Test\r\nvoid testCommaSeparatedString() {\r\n    final String prop = \"hey, that's a test\";\r\n    config.setProperty(\"prop.string\", prop);\r\n    final List<Object> list = config.getList(\"prop.string\");\r\n    assertEquals(Arrays.asList(\"hey\", \"that's a test\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testCommaSeparatedStringEscaped",
  "sourceCode" : "@Test\r\nvoid testCommaSeparatedStringEscaped() {\r\n    final String prop2 = \"hey\\\\, that's a test\";\r\n    config.setProperty(\"prop.string\", prop2);\r\n    assertEquals(\"hey, that's a test\", config.getString(\"prop.string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Test\r\nvoid testContainsValue() {\r\n    assertFalse(config.containsValue(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBigDecimal",
  "sourceCode" : "@Test\r\nvoid testGetBigDecimal() {\r\n    config.setProperty(\"numberBigD\", \"123.456\");\r\n    final BigDecimal number = new BigDecimal(\"123.456\");\r\n    final BigDecimal defaultValue = new BigDecimal(\"654.321\");\r\n    assertEquals(number, config.getBigDecimal(\"numberBigD\"));\r\n    assertEquals(number, config.getBigDecimal(\"numberBigD\", defaultValue));\r\n    assertEquals(defaultValue, config.getBigDecimal(\"numberNotInConfig\", defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBigDecimalIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetBigDecimalIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getBigDecimal(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBigDecimalUnknown",
  "sourceCode" : "@Test\r\nvoid testGetBigDecimalUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getBigDecimal(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBigInteger",
  "sourceCode" : "@Test\r\nvoid testGetBigInteger() {\r\n    config.setProperty(\"numberBigI\", \"1234567890\");\r\n    final BigInteger number = new BigInteger(\"1234567890\");\r\n    final BigInteger defaultValue = new BigInteger(\"654321\");\r\n    assertEquals(number, config.getBigInteger(\"numberBigI\"));\r\n    assertEquals(number, config.getBigInteger(\"numberBigI\", defaultValue));\r\n    assertEquals(defaultValue, config.getBigInteger(\"numberNotInConfig\", defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBigIntegerIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetBigIntegerIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getBigInteger(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBigIntegerUnknown",
  "sourceCode" : "@Test\r\nvoid testGetBigIntegerUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getBigInteger(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBinaryValue",
  "sourceCode" : "@Test\r\nvoid testGetBinaryValue() {\r\n    config.setProperty(\"number\", \"0b11111111\");\r\n    assertEquals((byte) 0xFF, config.getByte(\"number\"));\r\n    config.setProperty(\"number\", \"0b1111111111111111\");\r\n    assertEquals((short) 0xFFFF, config.getShort(\"number\"));\r\n    config.setProperty(\"number\", \"0b11111111111111111111111111111111\");\r\n    assertEquals(0xFFFFFFFF, config.getInt(\"number\"));\r\n    config.setProperty(\"number\", \"0b1111111111111111111111111111111111111111111111111111111111111111\");\r\n    assertEquals(0xFFFFFFFFFFFFFFFFL, config.getLong(\"number\"));\r\n    assertEquals(0xFFFFFFFFFFFFFFFFL, config.getBigInteger(\"number\").longValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBoolean",
  "sourceCode" : "@Test\r\nvoid testGetBoolean() {\r\n    config.setProperty(\"boolA\", Boolean.TRUE);\r\n    final boolean boolT = true;\r\n    final boolean boolF = false;\r\n    assertEquals(boolT, config.getBoolean(\"boolA\"));\r\n    assertEquals(boolT, config.getBoolean(\"boolA\", boolF));\r\n    assertEquals(boolF, config.getBoolean(\"boolNotInConfig\", boolF));\r\n    assertEquals(Boolean.valueOf(boolT), config.getBoolean(\"boolA\", Boolean.valueOf(boolF)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBooleanIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetBooleanIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getBoolean(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetBooleanUnknown",
  "sourceCode" : "@Test\r\nvoid testGetBooleanUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getBoolean(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetByte",
  "sourceCode" : "@Test\r\nvoid testGetByte() {\r\n    config.setProperty(\"number\", \"1\");\r\n    final byte oneB = 1;\r\n    final byte twoB = 2;\r\n    assertEquals(oneB, config.getByte(\"number\"));\r\n    assertEquals(oneB, config.getByte(\"number\", twoB));\r\n    assertEquals(twoB, config.getByte(\"numberNotInConfig\", twoB));\r\n    assertEquals(Byte.valueOf(oneB), config.getByte(\"number\", Byte.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetByteIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetByteIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getByte(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetByteUnknown",
  "sourceCode" : "@Test\r\nvoid testGetByteUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getByte(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetDouble",
  "sourceCode" : "@Test\r\nvoid testGetDouble() {\r\n    config.setProperty(\"numberD\", \"1.0\");\r\n    final double oneD = 1;\r\n    final double twoD = 2;\r\n    assertEquals(oneD, config.getDouble(\"numberD\"), 0);\r\n    assertEquals(oneD, config.getDouble(\"numberD\", twoD), 0);\r\n    assertEquals(twoD, config.getDouble(\"numberNotInConfig\", twoD), 0);\r\n    assertEquals(Double.valueOf(oneD), config.getDouble(\"numberD\", Double.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetDoubleIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetDoubleIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getDouble(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetDoubleUnknown",
  "sourceCode" : "@Test\r\nvoid testGetDoubleUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getDouble(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetDuration",
  "sourceCode" : "@Test\r\nvoid testGetDuration() {\r\n    final Duration d = Duration.ofSeconds(1);\r\n    config.setProperty(\"durationD\", d.toString());\r\n    final Duration oneD = Duration.ofSeconds(1);\r\n    final Duration twoD = Duration.ofSeconds(2);\r\n    assertEquals(oneD, config.getDuration(\"durationD\"));\r\n    assertEquals(oneD, config.getDuration(\"durationD\", twoD));\r\n    assertEquals(twoD, config.getDuration(\"numberNotInConfig\", twoD));\r\n    assertEquals(oneD, config.getDuration(\"durationD\", twoD));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetDurationIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetDurationIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getDuration(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetDurationUnknown",
  "sourceCode" : "@Test\r\nvoid testGetDurationUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getDuration(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetEnum",
  "sourceCode" : "@Test\r\nvoid testGetEnum() {\r\n    config.setProperty(\"testEnum\", EnumFixture.SMALLTALK.name());\r\n    config.setProperty(\"testBadEnum\", \"This is not an enum value.\");\r\n    final EnumFixture enum1 = EnumFixture.SMALLTALK;\r\n    final EnumFixture defaultValue = EnumFixture.JAVA;\r\n    //\r\n    assertEquals(enum1, config.getEnum(\"testEnum\", EnumFixture.class));\r\n    assertEquals(enum1, config.getEnum(\"testEnum\", EnumFixture.class, defaultValue));\r\n    assertEquals(defaultValue, config.getEnum(\"stringNotInConfig\", EnumFixture.class, defaultValue));\r\n    //\r\n    assertThrows(ConversionException.class, () -> config.getEnum(\"testBadEnum\", EnumFixture.class));\r\n    //\r\n    assertThrows(ConversionException.class, () -> config.getEnum(\"testBadEnum\", EnumFixture.class, defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetFloat",
  "sourceCode" : "@Test\r\nvoid testGetFloat() {\r\n    config.setProperty(\"numberF\", \"1.0\");\r\n    final float oneF = 1;\r\n    final float twoF = 2;\r\n    assertEquals(oneF, config.getFloat(\"numberF\"), 0);\r\n    assertEquals(oneF, config.getFloat(\"numberF\", twoF), 0);\r\n    assertEquals(twoF, config.getFloat(\"numberNotInConfig\", twoF), 0);\r\n    assertEquals(Float.valueOf(oneF), config.getFloat(\"numberF\", Float.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetFloatIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetFloatIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getFloat(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetFloatUnknown",
  "sourceCode" : "@Test\r\nvoid testGetFloatUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getFloat(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetHexadecimalValue",
  "sourceCode" : "@Test\r\nvoid testGetHexadecimalValue() {\r\n    config.setProperty(\"number\", \"0xFF\");\r\n    assertEquals((byte) 0xFF, config.getByte(\"number\"));\r\n    config.setProperty(\"number\", \"0xFFFF\");\r\n    assertEquals((short) 0xFFFF, config.getShort(\"number\"));\r\n    config.setProperty(\"number\", \"0xFFFFFFFF\");\r\n    assertEquals(0xFFFFFFFF, config.getInt(\"number\"));\r\n    config.setProperty(\"number\", \"0xFFFFFFFFFFFFFFFF\");\r\n    assertEquals(0xFFFFFFFFFFFFFFFFL, config.getLong(\"number\"));\r\n    assertEquals(0xFFFFFFFFFFFFFFFFL, config.getBigInteger(\"number\").longValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetInterpolatedList",
  "sourceCode" : "@Test\r\nvoid testGetInterpolatedList() {\r\n    config.addProperty(\"number\", \"1\");\r\n    config.addProperty(\"array\", \"${number}\");\r\n    config.addProperty(\"array\", \"${number}\");\r\n    final List<String> list = new ArrayList<>();\r\n    list.add(\"1\");\r\n    list.add(\"1\");\r\n    assertEquals(list, config.getList(\"array\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetInterpolatedPrimitives",
  "sourceCode" : "@Test\r\nvoid testGetInterpolatedPrimitives() {\r\n    config.addProperty(\"number\", \"1\");\r\n    config.addProperty(\"value\", \"${number}\");\r\n    config.addProperty(\"boolean\", \"true\");\r\n    config.addProperty(\"booleanValue\", \"${boolean}\");\r\n    // primitive types\r\n    assertTrue(config.getBoolean(\"booleanValue\"));\r\n    assertEquals(1, config.getByte(\"value\"));\r\n    assertEquals(1, config.getShort(\"value\"));\r\n    assertEquals(1, config.getInt(\"value\"));\r\n    assertEquals(1, config.getLong(\"value\"));\r\n    assertEquals(1, config.getFloat(\"value\"), 0);\r\n    assertEquals(1, config.getDouble(\"value\"), 0);\r\n    // primitive wrappers\r\n    assertEquals(Boolean.TRUE, config.getBoolean(\"booleanValue\", null));\r\n    assertEquals(Byte.valueOf(\"1\"), config.getByte(\"value\", null));\r\n    assertEquals(Short.valueOf(\"1\"), config.getShort(\"value\", null));\r\n    assertEquals(Integer.valueOf(\"1\"), config.getInteger(\"value\", null));\r\n    assertEquals(Long.valueOf(\"1\"), config.getLong(\"value\", null));\r\n    assertEquals(Float.valueOf(\"1\"), config.getFloat(\"value\", null));\r\n    assertEquals(Double.valueOf(\"1\"), config.getDouble(\"value\", null));\r\n    assertEquals(new BigInteger(\"1\"), config.getBigInteger(\"value\", null));\r\n    assertEquals(new BigDecimal(\"1\"), config.getBigDecimal(\"value\", null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetInterpolator",
  "sourceCode" : "/**\r\n * Tests accessing and manipulating the interpolator object.\r\n */\r\n@Test\r\nvoid testGetInterpolator() {\r\n    InterpolationTestHelper.testGetInterpolator(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetList",
  "sourceCode" : "@Test\r\nvoid testGetList() {\r\n    config.addProperty(\"number\", \"1\");\r\n    config.addProperty(\"number\", \"2\");\r\n    final List<Object> list = config.getList(\"number\");\r\n    assertEquals(Arrays.asList(\"1\", \"2\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetLong",
  "sourceCode" : "@Test\r\nvoid testGetLong() {\r\n    config.setProperty(\"numberL\", \"1\");\r\n    final long oneL = 1;\r\n    final long twoL = 2;\r\n    assertEquals(oneL, config.getLong(\"numberL\"));\r\n    assertEquals(oneL, config.getLong(\"numberL\", twoL));\r\n    assertEquals(twoL, config.getLong(\"numberNotInConfig\", twoL));\r\n    assertEquals(Long.valueOf(oneL), config.getLong(\"numberL\", Long.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetLongIncompatibleTypes",
  "sourceCode" : "@Test\r\nvoid testGetLongIncompatibleTypes() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getLong(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetLongUnknown",
  "sourceCode" : "@Test\r\nvoid testGetLongUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getLong(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() {\r\n    /* should be empty and return null */\r\n    assertNull(config.getProperty(\"foo\"));\r\n    /* add a real value, and get it two different ways */\r\n    config.setProperty(\"number\", \"1\");\r\n    assertEquals(\"1\", config.getProperty(\"number\"));\r\n    assertEquals(\"1\", config.getString(\"number\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetShort",
  "sourceCode" : "@Test\r\nvoid testGetShort() {\r\n    config.setProperty(\"numberS\", \"1\");\r\n    final short oneS = 1;\r\n    final short twoS = 2;\r\n    assertEquals(oneS, config.getShort(\"numberS\"));\r\n    assertEquals(oneS, config.getShort(\"numberS\", twoS));\r\n    assertEquals(twoS, config.getShort(\"numberNotInConfig\", twoS));\r\n    assertEquals(Short.valueOf(oneS), config.getShort(\"numberS\", Short.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetShortIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetShortIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getShort(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetShortUnknown",
  "sourceCode" : "@Test\r\nvoid testGetShortUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getShort(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetString",
  "sourceCode" : "@Test\r\nvoid testGetString() {\r\n    config.setProperty(\"testString\", \"The quick brown fox\");\r\n    final String string = \"The quick brown fox\";\r\n    final String defaultValue = \"jumps over the lazy dog\";\r\n    assertEquals(string, config.getString(\"testString\"));\r\n    assertEquals(string, config.getString(\"testString\", defaultValue));\r\n    assertEquals(defaultValue, config.getString(\"stringNotInConfig\", defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetStringForListValue",
  "sourceCode" : "/**\r\n * Tests that the first scalar of a list is returned.\r\n */\r\n@Test\r\nvoid testGetStringForListValue() {\r\n    config.addProperty(\"number\", \"1\");\r\n    config.addProperty(\"number\", \"2\");\r\n    assertEquals(\"1\", config.getString(\"number\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testGetStringUnknown",
  "sourceCode" : "@Test\r\nvoid testGetStringUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getString(\"stringNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInstallInterpolator",
  "sourceCode" : "/**\r\n * Tests whether a {@code ConfigurationInterpolator} can be created and installed.\r\n */\r\n@Test\r\nvoid testInstallInterpolator() {\r\n    final Lookup prefixLookup = mock(Lookup.class);\r\n    final Lookup defLookup = mock(Lookup.class);\r\n    final Map<String, Lookup> prefixLookups = new HashMap<>();\r\n    prefixLookups.put(\"test\", prefixLookup);\r\n    final List<Lookup> defLookups = new ArrayList<>();\r\n    defLookups.add(defLookup);\r\n    config.installInterpolator(prefixLookups, defLookups);\r\n    final ConfigurationInterpolator interpolator = config.getInterpolator();\r\n    assertEquals(prefixLookups, interpolator.getLookups());\r\n    final List<Lookup> defLookups2 = interpolator.getDefaultLookups();\r\n    assertEquals(2, defLookups2.size());\r\n    assertSame(defLookup, defLookups2.get(0));\r\n    final String var = \"testVariable\";\r\n    final Object value = 42;\r\n    config.addProperty(var, value);\r\n    assertEquals(value, defLookups2.get(1).lookup(var));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolatedConfiguration",
  "sourceCode" : "/**\r\n * Tests obtaining a configuration with all variables replaced by their actual values.\r\n */\r\n@Test\r\nvoid testInterpolatedConfiguration() {\r\n    InterpolationTestHelper.testInterpolatedConfiguration(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolation",
  "sourceCode" : "@Test\r\nvoid testInterpolation() {\r\n    InterpolationTestHelper.testInterpolation(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolationConstants",
  "sourceCode" : "/**\r\n * Tests interpolation of constant values.\r\n */\r\n@Test\r\nvoid testInterpolationConstants() {\r\n    InterpolationTestHelper.testInterpolationConstants(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolationEnvironment",
  "sourceCode" : "/**\r\n * Tests interpolation of environment properties.\r\n */\r\n@Test\r\nvoid testInterpolationEnvironment() {\r\n    InterpolationTestHelper.testInterpolationEnvironment(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolationEscaped",
  "sourceCode" : "/**\r\n * Tests whether a variable can be escaped, so that it won't be interpolated.\r\n */\r\n@Test\r\nvoid testInterpolationEscaped() {\r\n    InterpolationTestHelper.testInterpolationEscaped(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolationLocalhost",
  "sourceCode" : "/**\r\n * Tests interpolation with localhost values.\r\n */\r\n@Test\r\nvoid testInterpolationLocalhost() {\r\n    InterpolationTestHelper.testInterpolationLocalhost(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolationLoop",
  "sourceCode" : "@Test\r\nvoid testInterpolationLoop() {\r\n    InterpolationTestHelper.testInterpolationLoop(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolationSubset",
  "sourceCode" : "/**\r\n * Tests interpolation when a subset configuration is involved.\r\n */\r\n@Test\r\nvoid testInterpolationSubset() {\r\n    InterpolationTestHelper.testInterpolationSubset(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolationSystemProperties",
  "sourceCode" : "/**\r\n * Tests interpolation of system properties.\r\n */\r\n@Test\r\nvoid testInterpolationSystemProperties() {\r\n    InterpolationTestHelper.testInterpolationSystemProperties(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testInterpolationUnknownProperty",
  "sourceCode" : "/**\r\n * Tests interpolation when the referred property is not found.\r\n */\r\n@Test\r\nvoid testInterpolationUnknownProperty() {\r\n    InterpolationTestHelper.testInterpolationUnknownProperty(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testMultipleInterpolation",
  "sourceCode" : "@Test\r\nvoid testMultipleInterpolation() {\r\n    InterpolationTestHelper.testMultipleInterpolation(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testNoInterpolator",
  "sourceCode" : "/**\r\n * Tests whether property access is possible without a {@code ConfigurationInterpolator}.\r\n */\r\n@Test\r\nvoid testNoInterpolator() {\r\n    config.setProperty(\"test\", \"${value}\");\r\n    config.setInterpolator(null);\r\n    assertEquals(\"${value}\", config.getString(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testNumberConversions",
  "sourceCode" : "/**\r\n * Tests if conversion between number types is possible.\r\n */\r\n@Test\r\nvoid testNumberConversions() {\r\n    config.setProperty(KEY_NUMBER, Integer.valueOf(42));\r\n    assertEquals(42, config.getInt(KEY_NUMBER));\r\n    assertEquals(42L, config.getLong(KEY_NUMBER));\r\n    assertEquals((byte) 42, config.getByte(KEY_NUMBER));\r\n    assertEquals(42.0f, config.getFloat(KEY_NUMBER), 0.01f);\r\n    assertEquals(42.0, config.getDouble(KEY_NUMBER), 0.001);\r\n    assertEquals(Long.valueOf(42L), config.getLong(KEY_NUMBER, null));\r\n    assertEquals(new BigInteger(\"42\"), config.getBigInteger(KEY_NUMBER));\r\n    assertEquals(new BigDecimal(\"42.0\"), config.getBigDecimal(KEY_NUMBER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testPropertyAccess",
  "sourceCode" : "@Test\r\nvoid testPropertyAccess() {\r\n    config.clearProperty(\"prop.properties\");\r\n    config.setProperty(\"prop.properties\", \"\");\r\n    assertEquals(new Properties(), config.getProperties(\"prop.properties\"));\r\n    config.clearProperty(\"prop.properties\");\r\n    config.setProperty(\"prop.properties\", \"foo=bar, baz=moo, seal=clubber\");\r\n    final Properties p = new Properties();\r\n    p.setProperty(\"foo\", \"bar\");\r\n    p.setProperty(\"baz\", \"moo\");\r\n    p.setProperty(\"seal\", \"clubber\");\r\n    assertEquals(p, config.getProperties(\"prop.properties\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testSetInterpolator",
  "sourceCode" : "/**\r\n * Tests whether a {@code ConfigurationInterpolator} can be set.\r\n */\r\n@Test\r\nvoid testSetInterpolator() {\r\n    final ConfigurationInterpolator interpolator = mock(ConfigurationInterpolator.class);\r\n    config.setInterpolator(interpolator);\r\n    assertSame(interpolator, config.getInterpolator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testSize",
  "sourceCode" : "/**\r\n * Tests the specific size() implementation.\r\n */\r\n@Test\r\nvoid testSize() {\r\n    final int count = 16;\r\n    for (int i = 0; i < count; i++) {\r\n        config.addProperty(\"key\" + i, \"value\" + i);\r\n    }\r\n    assertEquals(count, config.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testSubset",
  "sourceCode" : "@Test\r\nvoid testSubset() {\r\n    /*\r\n         * test subset : assure we don't reprocess the data elements when generating the subset\r\n         */\r\n    final String prop = \"hey, that's a test\";\r\n    final String prop2 = \"hey\\\\, that's a test\";\r\n    config.setProperty(\"prop.string\", prop2);\r\n    config.setProperty(\"property.string\", \"hello\");\r\n    Configuration subEprop = config.subset(\"prop\");\r\n    assertEquals(prop, subEprop.getString(\"string\"));\r\n    assertEquals(1, subEprop.getList(\"string\").size());\r\n    Iterator<String> it = subEprop.getKeys();\r\n    it.next();\r\n    assertFalse(it.hasNext());\r\n    subEprop = config.subset(\"prop.\");\r\n    it = subEprop.getKeys();\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfiguration.java",
  "methodName" : "testThrowExceptionOnMissing",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionOnMissing() {\r\n    assertTrue(config.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfigurationXMLReader.java",
  "methodName" : "testParse",
  "sourceCode" : "@Test\r\nvoid testParse() throws Exception {\r\n    checkDocument(configReader, \"config\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfigurationXMLReader.java",
  "methodName" : "testParseIOException",
  "sourceCode" : "@Test\r\nvoid testParseIOException() {\r\n    final BaseConfigurationXMLReader reader = new BaseConfigurationXMLReader();\r\n    assertThrows(IOException.class, () -> reader.parse(\"document\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfigurationXMLReader.java",
  "methodName" : "testParseSAXException",
  "sourceCode" : "@Test\r\nvoid testParseSAXException() {\r\n    configReader.setContentHandler(new TestContentHandler());\r\n    assertThrows(SAXException.class, () -> configReader.parse(\"systemID\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseConfigurationXMLReader.java",
  "methodName" : "testSetRootName",
  "sourceCode" : "@Test\r\nvoid testSetRootName() throws Exception {\r\n    final BaseConfigurationXMLReader reader = new BaseConfigurationXMLReader(config);\r\n    reader.setRootName(\"apache\");\r\n    checkDocument(reader, \"apache\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testAddNodesSynchronized",
  "sourceCode" : "/**\r\n * Tests whether addNodes() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testAddNodesSynchronized() {\r\n    final ImmutableNode node = NodeStructureHelper.createNode(\"newNode\", \"true\");\r\n    config.addNodes(\"test.addNodes\", Collections.singleton(node));\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testChildConfigurationsAtSynchronized",
  "sourceCode" : "/**\r\n * Tests whether childConfigurationsAt() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testChildConfigurationsAtSynchronized() {\r\n    final List<HierarchicalConfiguration<ImmutableNode>> subs = config.childConfigurationsAt(\"clear\");\r\n    assertFalse(subs.isEmpty());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testClearTreeSynchronized",
  "sourceCode" : "/**\r\n * Tests whether clearTree() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testClearTreeSynchronized() {\r\n    config.clearTree(\"clear\");\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testCloneCopySubnodeData",
  "sourceCode" : "/**\r\n * Tests whether a clone() operation also copies the data used to manage SubnodeConfiguration objects.\r\n */\r\n@Test\r\nvoid testCloneCopySubnodeData() {\r\n    final BaseHierarchicalConfiguration conf2 = new BaseHierarchicalConfiguration(config);\r\n    final HierarchicalConfiguration<ImmutableNode> sub = conf2.configurationAt(\"element2.subelement\", true);\r\n    // clone retains the type\r\n    @SuppressWarnings(\"unchecked\")\r\n    final HierarchicalConfiguration<ImmutableNode> copy = (HierarchicalConfiguration<ImmutableNode>) conf2.clone();\r\n    final HierarchicalConfiguration<ImmutableNode> sub2 = copy.configurationAt(\"element2.subelement\", true);\r\n    // This must not cause a validate operation on sub1, but on sub2\r\n    copy.clearTree(\"element2\");\r\n    assertTrue(isDetached(sub2));\r\n    assertFalse(isDetached(sub));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testCloneSynchronized",
  "sourceCode" : "/**\r\n * Tests whether clone() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testCloneSynchronized() {\r\n    final BaseHierarchicalConfiguration clone = (BaseHierarchicalConfiguration) config.clone();\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    assertNotSame(config.getSynchronizer(), clone.getSynchronizer());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testConfigurationAtSynchronized",
  "sourceCode" : "/**\r\n * Tests whether synchronization is performed when constructing a SubnodeConfiguration.\r\n */\r\n@Test\r\nvoid testConfigurationAtSynchronized() {\r\n    final HierarchicalConfiguration<ImmutableNode> sub = config.configurationAt(\"element2\");\r\n    assertEquals(\"I'm complex!\", sub.getString(\"subelement.subsubelement\"));\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ, Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testConfigurationsAtSynchronized",
  "sourceCode" : "/**\r\n * Tests whether synchronization is performed when constructing multiple SubnodeConfiguration objects.\r\n */\r\n@Test\r\nvoid testConfigurationsAtSynchronized() {\r\n    final List<HierarchicalConfiguration<ImmutableNode>> subs = config.configurationsAt(\"list.item\");\r\n    assertFalse(subs.isEmpty());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testCopyConstructorSynchronized",
  "sourceCode" : "/**\r\n * Tests whether synchronization is performed when copying a configuration.\r\n */\r\n@Test\r\nvoid testCopyConstructorSynchronized() {\r\n    final BaseHierarchicalConfiguration copy = new BaseHierarchicalConfiguration(config);\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    assertNotSame(sync, copy.getSynchronizer());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testGetMaxIndexSynchronized",
  "sourceCode" : "/**\r\n * Tests whether getMaxIndex() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testGetMaxIndexSynchronized() {\r\n    assertTrue(config.getMaxIndex(\"list.item\") > 0);\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testGetRootElementNameSynchronized",
  "sourceCode" : "/**\r\n * Tests whether getRootElementName() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testGetRootElementNameSynchronized() {\r\n    assertEquals(\"testconfig\", config.getRootElementName());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testReadOnlyAccessToSubConfigurations",
  "sourceCode" : "/**\r\n * Tests that access to an initialized configuration's sub configurations is possible without a special synchronizer.\r\n */\r\n@Test\r\nvoid testReadOnlyAccessToSubConfigurations() throws ConfigurationException {\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = new FileBasedConfigurationBuilder<>(XMLConfiguration.class);\r\n    builder.configure(new Parameters().fileBased().setFile(testFile));\r\n    config = builder.getConfiguration();\r\n    final CountDownLatch startLatch = new CountDownLatch(1);\r\n    final Collection<SubNodeAccessThread> threads = new ArrayList<>();\r\n    for (int i = 0; i < 4; i++) {\r\n        final SubNodeAccessThread t = new SubNodeAccessThread(config, startLatch, \"element2\", \"subelement.subsubelement\");\r\n        t.start();\r\n        threads.add(t);\r\n    }\r\n    for (int i = 0; i < 4; i++) {\r\n        final SubNodeAccessThread t = new SubNodeAccessThread(config, startLatch, \"element2.subelement\", \"subsubelement\");\r\n        t.start();\r\n        threads.add(t);\r\n    }\r\n    startLatch.countDown();\r\n    for (final SubNodeAccessThread t : threads) {\r\n        t.verify();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testSubnodeUpdate",
  "sourceCode" : "/**\r\n * Tests whether updates on nodes are communicated to all SubnodeConfigurations of a configuration.\r\n */\r\n@Test\r\nvoid testSubnodeUpdate() {\r\n    config.addProperty(\"element2.test\", Boolean.TRUE);\r\n    final HierarchicalConfiguration<ImmutableNode> sub = config.configurationAt(\"element2\", true);\r\n    final HierarchicalConfiguration<ImmutableNode> subsub = sub.configurationAt(\"subelement\", true);\r\n    config.clearTree(\"element2.subelement\");\r\n    assertFalse(isDetached(sub));\r\n    assertTrue(isDetached(subsub));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testSubnodeUpdateBySubnode",
  "sourceCode" : "/**\r\n * Tests whether updates caused by a SubnodeConfiguration are communicated to all other SubnodeConfigurations.\r\n */\r\n@Test\r\nvoid testSubnodeUpdateBySubnode() {\r\n    final HierarchicalConfiguration<ImmutableNode> sub = config.configurationAt(\"element2\", true);\r\n    final HierarchicalConfiguration<ImmutableNode> subsub = sub.configurationAt(\"subelement\", true);\r\n    final HierarchicalConfiguration<ImmutableNode> sub2 = config.configurationAt(\"element2.subelement\", true);\r\n    sub.clearTree(\"subelement\");\r\n    assertTrue(isDetached(sub2));\r\n    assertTrue(isDetached(subsub));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseHierarchicalConfigurationSynchronization.java",
  "methodName" : "testSubsetSynchronized",
  "sourceCode" : "/**\r\n * Tests whether subset() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testSubsetSynchronized() {\r\n    final Configuration subset = config.subset(\"test\");\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    assertSame(sync, subset.getSynchronizer());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testCommaSeparatedString",
  "sourceCode" : "@Test\r\nvoid testCommaSeparatedString() {\r\n    final String prop = \"hey, that's a test\";\r\n    config.setProperty(\"prop.string\", prop);\r\n    final List<Object> list = config.getList(\"prop.string\");\r\n    assertEquals(Arrays.asList(\"hey\", \"that's a test\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testCommaSeparatedStringEscaped",
  "sourceCode" : "@Test\r\nvoid testCommaSeparatedStringEscaped() {\r\n    final String prop2 = \"hey\\\\, that's a test\";\r\n    config.clearProperty(\"prop.string\");\r\n    config.setProperty(\"prop.string\", prop2);\r\n    assertEquals(\"hey, that's a test\", config.getString(\"prop.string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBigDecimal",
  "sourceCode" : "@Test\r\nvoid testGetBigDecimal() {\r\n    config.setProperty(\"numberBigD\", \"123.456\");\r\n    final BigDecimal number = new BigDecimal(\"123.456\");\r\n    final BigDecimal defaultValue = new BigDecimal(\"654.321\");\r\n    assertEquals(number, config.getBigDecimal(\"numberBigD\"));\r\n    assertEquals(number, config.getBigDecimal(\"numberBigD\", defaultValue));\r\n    assertEquals(defaultValue, config.getBigDecimal(\"numberNotInConfig\", defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBigDecimalIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetBigDecimalIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getBigDecimal(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBigDecimalUnknown",
  "sourceCode" : "@Test\r\nvoid testGetBigDecimalUnknown() {\r\n    assertNull(config.getBigDecimal(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBigInteger",
  "sourceCode" : "@Test\r\nvoid testGetBigInteger() {\r\n    config.setProperty(\"numberBigI\", \"1234567890\");\r\n    final BigInteger number = new BigInteger(\"1234567890\");\r\n    final BigInteger defaultValue = new BigInteger(\"654321\");\r\n    assertEquals(number, config.getBigInteger(\"numberBigI\"));\r\n    assertEquals(number, config.getBigInteger(\"numberBigI\", defaultValue));\r\n    assertEquals(defaultValue, config.getBigInteger(\"numberNotInConfig\", defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBigIntegerIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetBigIntegerIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getBigInteger(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBigIntegerUnknown",
  "sourceCode" : "@Test\r\nvoid testGetBigIntegerUnknown() {\r\n    assertNull(config.getBigInteger(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBoolean",
  "sourceCode" : "@Test\r\nvoid testGetBoolean() {\r\n    config.setProperty(\"boolA\", Boolean.TRUE);\r\n    final boolean boolT = true;\r\n    final boolean boolF = false;\r\n    assertEquals(boolT, config.getBoolean(\"boolA\"));\r\n    assertEquals(boolT, config.getBoolean(\"boolA\", boolF));\r\n    assertEquals(boolF, config.getBoolean(\"boolNotInConfig\", boolF));\r\n    assertEquals(Boolean.valueOf(boolT), config.getBoolean(\"boolA\", Boolean.valueOf(boolF)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBooleanIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetBooleanIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getBoolean(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetBooleanUnknown",
  "sourceCode" : "@Test\r\nvoid testGetBooleanUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getBoolean(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetByte",
  "sourceCode" : "@Test\r\nvoid testGetByte() {\r\n    config.setProperty(\"number\", \"1\");\r\n    final byte oneB = 1;\r\n    final byte twoB = 2;\r\n    assertEquals(oneB, config.getByte(\"number\"));\r\n    assertEquals(oneB, config.getByte(\"number\", twoB));\r\n    assertEquals(twoB, config.getByte(\"numberNotInConfig\", twoB));\r\n    assertEquals(Byte.valueOf(oneB), config.getByte(\"number\", Byte.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetByteIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetByteIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getByte(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetByteUnknown",
  "sourceCode" : "@Test\r\nvoid testGetByteUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getByte(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetDouble",
  "sourceCode" : "@Test\r\nvoid testGetDouble() {\r\n    config.setProperty(\"numberD\", \"1.0\");\r\n    final double oneD = 1;\r\n    final double twoD = 2;\r\n    assertEquals(oneD, config.getDouble(\"numberD\"), 0);\r\n    assertEquals(oneD, config.getDouble(\"numberD\", twoD), 0);\r\n    assertEquals(twoD, config.getDouble(\"numberNotInConfig\", twoD), 0);\r\n    assertEquals(Double.valueOf(oneD), config.getDouble(\"numberD\", Double.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetDoubleIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetDoubleIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getDouble(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetDoubleUnknown",
  "sourceCode" : "@Test\r\nvoid testGetDoubleUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getDouble(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetFloat",
  "sourceCode" : "@Test\r\nvoid testGetFloat() {\r\n    config.setProperty(\"numberF\", \"1.0\");\r\n    final float oneF = 1;\r\n    final float twoF = 2;\r\n    assertEquals(oneF, config.getFloat(\"numberF\"), 0);\r\n    assertEquals(oneF, config.getFloat(\"numberF\", twoF), 0);\r\n    assertEquals(twoF, config.getFloat(\"numberNotInConfig\", twoF), 0);\r\n    assertEquals(Float.valueOf(oneF), config.getFloat(\"numberF\", Float.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetFloatIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetFloatIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getFloat(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetFloatUnknown",
  "sourceCode" : "@Test\r\nvoid testGetFloatUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getFloat(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetList",
  "sourceCode" : "@Test\r\nvoid testGetList() {\r\n    config.addProperty(\"number\", \"1\");\r\n    config.addProperty(\"number\", \"2\");\r\n    final List<Object> list = config.getList(\"number\");\r\n    assertEquals(Arrays.asList(\"1\", \"2\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetListAsScalar",
  "sourceCode" : "@Test\r\nvoid testGetListAsScalar() {\r\n    config.addProperty(\"number\", \"1\");\r\n    config.addProperty(\"number\", \"2\");\r\n    assertEquals(\"1\", config.getString(\"number\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetLong",
  "sourceCode" : "@Test\r\nvoid testGetLong() {\r\n    config.setProperty(\"numberL\", \"1\");\r\n    final long oneL = 1;\r\n    final long twoL = 2;\r\n    assertEquals(oneL, config.getLong(\"numberL\"));\r\n    assertEquals(oneL, config.getLong(\"numberL\", twoL));\r\n    assertEquals(twoL, config.getLong(\"numberNotInConfig\", twoL));\r\n    assertEquals(Long.valueOf(oneL), config.getLong(\"numberL\", Long.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetLongIncompatibleTypes",
  "sourceCode" : "@Test\r\nvoid testGetLongIncompatibleTypes() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getLong(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetLongUnknown",
  "sourceCode" : "@Test\r\nvoid testGetLongUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getLong(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() {\r\n    /* should be empty and return null */\r\n    assertNull(config.getProperty(\"foo\"));\r\n    /* add a real value, and get it two different ways */\r\n    config.setProperty(\"number\", \"1\");\r\n    assertEquals(\"1\", config.getProperty(\"number\"));\r\n    assertEquals(\"1\", config.getString(\"number\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetShort",
  "sourceCode" : "@Test\r\nvoid testGetShort() {\r\n    config.setProperty(\"numberS\", \"1\");\r\n    final short oneS = 1;\r\n    final short twoS = 2;\r\n    assertEquals(oneS, config.getShort(\"numberS\"));\r\n    assertEquals(oneS, config.getShort(\"numberS\", twoS));\r\n    assertEquals(twoS, config.getShort(\"numberNotInConfig\", twoS));\r\n    assertEquals(Short.valueOf(oneS), config.getShort(\"numberS\", Short.valueOf(\"2\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetShortIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetShortIncompatibleType() {\r\n    config.setProperty(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getShort(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetShortUnknown",
  "sourceCode" : "@Test\r\nvoid testGetShortUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getShort(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetString",
  "sourceCode" : "@Test\r\nvoid testGetString() {\r\n    config.setProperty(\"testString\", \"The quick brown fox\");\r\n    final String string = \"The quick brown fox\";\r\n    final String defaultValue = \"jumps over the lazy dog\";\r\n    assertEquals(string, config.getString(\"testString\"));\r\n    assertEquals(string, config.getString(\"testString\", defaultValue));\r\n    assertEquals(defaultValue, config.getString(\"stringNotInConfig\", defaultValue));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testGetStringUnknown",
  "sourceCode" : "@Test\r\nvoid testGetStringUnknown() {\r\n    assertNull(config.getString(\"stringNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testInterpolation",
  "sourceCode" : "@Test\r\nvoid testInterpolation() throws Exception {\r\n    config.setProperty(\"applicationRoot\", \"/home/applicationRoot\");\r\n    config.setProperty(\"db\", \"${applicationRoot}/db/hypersonic\");\r\n    final String unInterpolatedValue = \"${applicationRoot2}/db/hypersonic\";\r\n    config.setProperty(\"dbFailedInterpolate\", unInterpolatedValue);\r\n    final String dbProp = \"/home/applicationRoot/db/hypersonic\";\r\n    // construct a new config, using config as the defaults config for it.\r\n    final BaseConfiguration superProp = config;\r\n    assertEquals(dbProp, superProp.getString(\"db\"));\r\n    assertEquals(unInterpolatedValue, superProp.getString(\"dbFailedInterpolate\"));\r\n    superProp.setProperty(\"arrayInt\", \"${applicationRoot}/1\");\r\n    final String[] arrayInt = superProp.getStringArray(\"arrayInt\");\r\n    assertEquals(\"/home/applicationRoot/1\", arrayInt[0]);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testInterpolationLoop",
  "sourceCode" : "@Test\r\nvoid testInterpolationLoop() throws Exception {\r\n    config.setProperty(\"test.a\", \"${test.b}\");\r\n    config.setProperty(\"test.b\", \"${test.a}\");\r\n    assertThrows(IllegalStateException.class, () -> config.getString(\"test.a\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testMultipleInterpolation",
  "sourceCode" : "@Test\r\nvoid testMultipleInterpolation() throws Exception {\r\n    config.setProperty(\"test.base-level\", \"/base-level\");\r\n    config.setProperty(\"test.first-level\", \"${test.base-level}/first-level\");\r\n    config.setProperty(\"test.second-level\", \"${test.first-level}/second-level\");\r\n    config.setProperty(\"test.third-level\", \"${test.second-level}/third-level\");\r\n    final String expectedValue = \"/base-level/first-level/second-level/third-level\";\r\n    assertEquals(expectedValue, config.getString(\"test.third-level\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testPropertyAccess",
  "sourceCode" : "@Test\r\nvoid testPropertyAccess() {\r\n    config.clearProperty(\"prop.properties\");\r\n    config.setProperty(\"prop.properties\", \"\");\r\n    assertEquals(new Properties(), config.getProperties(\"prop.properties\"));\r\n    config.clearProperty(\"prop.properties\");\r\n    config.setProperty(\"prop.properties\", \"foo=bar, baz=moo, seal=clubber\");\r\n    final Properties p = new Properties();\r\n    p.setProperty(\"foo\", \"bar\");\r\n    p.setProperty(\"baz\", \"moo\");\r\n    p.setProperty(\"seal\", \"clubber\");\r\n    assertEquals(p, config.getProperties(\"prop.properties\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testSubset",
  "sourceCode" : "@Test\r\nvoid testSubset() {\r\n    /*\r\n         * test subset : assure we don't reprocess the data elements when generating the subset\r\n         */\r\n    final String prop = \"hey, that's a test\";\r\n    final String prop2 = \"hey\\\\, that's a test\";\r\n    config.setProperty(\"prop.string\", prop2);\r\n    config.setProperty(\"property.string\", \"hello\");\r\n    Configuration subEprop = config.subset(\"prop\");\r\n    assertEquals(prop, subEprop.getString(\"string\"));\r\n    assertEquals(1, subEprop.getList(\"string\").size());\r\n    Iterator<String> it = subEprop.getKeys();\r\n    it.next();\r\n    assertFalse(it.hasNext());\r\n    subEprop = config.subset(\"prop.\");\r\n    it = subEprop.getKeys();\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestBaseNullConfiguration.java",
  "methodName" : "testThrowExceptionOnMissing",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionOnMissing() {\r\n    assertFalse(config.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCatalogResolver.java",
  "methodName" : "testDebug",
  "sourceCode" : "@Test\r\nvoid testDebug() throws Exception {\r\n    resolver.setDebug(true);\r\n    // There is no really good way to check this except to do something\r\n    // that causes debug output.\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCatalogResolver.java",
  "methodName" : "testLogger",
  "sourceCode" : "@Test\r\nvoid testLogger() throws Exception {\r\n    final ConfigurationLogger log = new ConfigurationLogger(this.getClass());\r\n    resolver.setLogger(log);\r\n    assertNotNull(resolver.getLogger());\r\n    assertSame(log, resolver.getLogger());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCatalogResolver.java",
  "methodName" : "testPublic",
  "sourceCode" : "@Test\r\nvoid testPublic() {\r\n    assertDoesNotThrow(() -> load(PUBLIC_FILE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCatalogResolver.java",
  "methodName" : "testRewriteSystem",
  "sourceCode" : "@Test\r\nvoid testRewriteSystem() {\r\n    assertDoesNotThrow(() -> load(REWRITE_SYSTEM_FILE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCatalogResolver.java",
  "methodName" : "testSchemaResolver",
  "sourceCode" : "/**\r\n * Tests that the schema can be resolved and that XMLConfiguration will validate the file using the schema.\r\n */\r\n@Test\r\nvoid testSchemaResolver() {\r\n    assertDoesNotThrow(() -> load(REWRITE_SCHEMA_FILE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAccessPropertyEmpty",
  "sourceCode" : "/**\r\n * Tests accessing properties if no configurations have been added.\r\n */\r\n@Test\r\nvoid testAccessPropertyEmpty() {\r\n    assertFalse(config.containsKey(TEST_KEY));\r\n    assertNull(config.getString(\"test.comment\"));\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAccessPropertyMulti",
  "sourceCode" : "/**\r\n * Tests accessing properties if multiple configurations have been added.\r\n */\r\n@Test\r\nvoid testAccessPropertyMulti() {\r\n    config.addConfiguration(setUpTestConfiguration());\r\n    config.addConfiguration(setUpTestConfiguration(), null, \"prefix1\");\r\n    config.addConfiguration(setUpTestConfiguration(), null, \"prefix2\");\r\n    assertTrue(config.getBoolean(TEST_KEY));\r\n    assertTrue(config.getBoolean(\"prefix1.\" + TEST_KEY));\r\n    assertTrue(config.getBoolean(\"prefix2.\" + TEST_KEY));\r\n    assertFalse(config.isEmpty());\r\n    listener.checkEvent(3, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAddConfiguration",
  "sourceCode" : "/**\r\n * Tests adding a configuration (without further information).\r\n */\r\n@Test\r\nvoid testAddConfiguration() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c);\r\n    checkAddConfig(c);\r\n    assertEquals(1, config.getNumberOfConfigurations());\r\n    assertTrue(config.getConfigurationNames().isEmpty());\r\n    assertSame(c, config.getConfiguration(0));\r\n    assertTrue(config.getBoolean(TEST_KEY));\r\n    listener.checkEvent(1, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAddConfigurationAt",
  "sourceCode" : "/**\r\n * Tests adding a configuration and specifying an at position.\r\n */\r\n@Test\r\nvoid testAddConfigurationAt() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c, null, \"my\");\r\n    checkAddConfig(c);\r\n    assertTrue(config.getBoolean(\"my.\" + TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAddConfigurationComplexAt",
  "sourceCode" : "/**\r\n * Tests adding a configuration with a complex at position. Here the at path contains a dot, which must be escaped.\r\n */\r\n@Test\r\nvoid testAddConfigurationComplexAt() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c, null, \"This..is.a.complex\");\r\n    checkAddConfig(c);\r\n    assertTrue(config.getBoolean(\"This..is.a.complex.\" + TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAddConfigurationSynchronized",
  "sourceCode" : "/**\r\n * Tests whether adding a new configuration is synchronized.\r\n */\r\n@Test\r\nvoid testAddConfigurationSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    config.addConfiguration(new BaseHierarchicalConfiguration());\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAddConfigurationWithName",
  "sourceCode" : "/**\r\n * Tests adding a configuration with a name.\r\n */\r\n@Test\r\nvoid testAddConfigurationWithName() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c, TEST_NAME);\r\n    checkAddConfig(c);\r\n    assertEquals(1, config.getNumberOfConfigurations());\r\n    assertSame(c, config.getConfiguration(0));\r\n    assertSame(c, config.getConfiguration(TEST_NAME));\r\n    final Set<String> names = config.getConfigurationNames();\r\n    assertEquals(1, names.size());\r\n    assertTrue(names.contains(TEST_NAME));\r\n    assertTrue(config.getBoolean(TEST_KEY));\r\n    listener.checkEvent(1, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAddConfigurationWithNameTwice",
  "sourceCode" : "/**\r\n * Tests adding a configuration with a name when this name already exists. This should cause an exception.\r\n */\r\n@Test\r\nvoid testAddConfigurationWithNameTwice() {\r\n    config.addConfiguration(setUpTestConfiguration(), TEST_NAME);\r\n    final Configuration configuration = setUpTestConfiguration();\r\n    assertThrows(ConfigurationRuntimeException.class, () -> config.addConfiguration(configuration, TEST_NAME, \"prefix\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testAddNullConfiguration",
  "sourceCode" : "/**\r\n * Tests adding a null configuration. This should cause an exception to be thrown.\r\n */\r\n@Test\r\nvoid testAddNullConfiguration() {\r\n    assertThrows(IllegalArgumentException.class, () -> config.addConfiguration(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testClear",
  "sourceCode" : "/**\r\n * Tests clearing a combined configuration. This should remove all contained configurations.\r\n */\r\n@Test\r\nvoid testClear() {\r\n    config.addConfiguration(setUpTestConfiguration(), TEST_NAME, \"test\");\r\n    config.addConfiguration(setUpTestConfiguration());\r\n    config.clear();\r\n    assertEquals(0, config.getNumberOfConfigurations());\r\n    assertTrue(config.getConfigurationNames().isEmpty());\r\n    assertTrue(config.isEmpty());\r\n    listener.checkEvent(3, 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testClearRemoveChildListener",
  "sourceCode" : "/**\r\n * Tests whether the combined configuration removes itself as change listener from the child configurations on a clear\r\n * operation. This test is related to CONFIGURATION-572.\r\n */\r\n@Test\r\nvoid testClearRemoveChildListener() {\r\n    final AbstractConfiguration child = setUpTestConfiguration();\r\n    config.addConfiguration(child);\r\n    config.clear();\r\n    for (final EventListener<?> listener : child.getEventListeners(ConfigurationEvent.ANY)) {\r\n        assertNotEquals(config, listener);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests cloning a combined configuration.\r\n */\r\n@Test\r\nvoid testClone() {\r\n    config.addConfiguration(setUpTestConfiguration());\r\n    config.addConfiguration(setUpTestConfiguration(), TEST_NAME, \"conf2\");\r\n    config.addConfiguration(new PropertiesConfiguration(), \"props\");\r\n    final CombinedConfiguration cc2 = (CombinedConfiguration) config.clone();\r\n    assertNotNull(cc2.getModel().getNodeHandler().getRootNode());\r\n    assertEquals(config.getNumberOfConfigurations(), cc2.getNumberOfConfigurations());\r\n    assertSame(config.getNodeCombiner(), cc2.getNodeCombiner());\r\n    assertEquals(config.getConfigurationNames().size(), cc2.getConfigurationNames().size());\r\n    assertTrue(Collections.disjoint(cc2.getEventListeners(ConfigurationEvent.ANY), config.getEventListeners(ConfigurationEvent.ANY)));\r\n    final StrictConfigurationComparator comp = new StrictConfigurationComparator();\r\n    for (int i = 0; i < config.getNumberOfConfigurations(); i++) {\r\n        assertNotSame(config.getConfiguration(i), cc2.getConfiguration(i), \"Configuration at \" + i + \" was not cloned\");\r\n        assertEquals(config.getConfiguration(i).getClass(), cc2.getConfiguration(i).getClass(), \"Wrong config class at \" + i);\r\n        assertTrue(comp.compare(config.getConfiguration(i), cc2.getConfiguration(i)), \"Configs not equal at \" + i);\r\n    }\r\n    assertTrue(comp.compare(config, cc2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testCloneModify",
  "sourceCode" : "/**\r\n * Tests if the cloned configuration is decoupled from the original.\r\n */\r\n@Test\r\nvoid testCloneModify() {\r\n    config.addConfiguration(setUpTestConfiguration(), TEST_NAME);\r\n    final CombinedConfiguration cc2 = (CombinedConfiguration) config.clone();\r\n    assertTrue(cc2.getConfigurationNames().contains(TEST_NAME));\r\n    cc2.removeConfiguration(TEST_NAME);\r\n    assertFalse(config.getConfigurationNames().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testCloneSynchronized",
  "sourceCode" : "/**\r\n * Tests whether cloning of a configuration is correctly synchronized.\r\n */\r\n@Test\r\nvoid testCloneSynchronized() {\r\n    setUpSourceTest();\r\n    // Causes the root node to be constructed\r\n    config.lock(LockMode.READ);\r\n    config.unlock(LockMode.READ);\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    config.setSynchronizer(sync);\r\n    config.clone();\r\n    // clone() of base class is wrapped by another read lock\r\n    sync.verifyStart(Methods.BEGIN_READ, Methods.BEGIN_READ);\r\n    sync.verifyEnd(Methods.END_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testCombinedCopyToXML",
  "sourceCode" : "/**\r\n * Tests whether a combined configuration can be copied to an XML configuration. This test is related to\r\n * CONFIGURATION-445.\r\n */\r\n@Test\r\nvoid testCombinedCopyToXML() throws ConfigurationException {\r\n    final XMLConfiguration x1 = new XMLConfiguration();\r\n    x1.addProperty(\"key1\", \"value1\");\r\n    x1.addProperty(\"key1[@override]\", \"USER1\");\r\n    x1.addProperty(\"key2\", \"value2\");\r\n    x1.addProperty(\"key2[@override]\", \"USER2\");\r\n    final XMLConfiguration x2 = new XMLConfiguration();\r\n    x2.addProperty(\"key2\", \"value2.2\");\r\n    x2.addProperty(\"key2[@override]\", \"USER2\");\r\n    config.setNodeCombiner(new OverrideCombiner());\r\n    config.addConfiguration(x2);\r\n    config.addConfiguration(x1);\r\n    XMLConfiguration x3 = new XMLConfiguration(config);\r\n    assertEquals(\"value2.2\", x3.getString(\"key2\"));\r\n    assertEquals(\"USER2\", x3.getString(\"key2[@override]\"));\r\n    final StringWriter w = new StringWriter();\r\n    new FileHandler(x3).save(w);\r\n    final String s = w.toString();\r\n    x3 = new XMLConfiguration();\r\n    new FileHandler(x3).load(new StringReader(s));\r\n    assertEquals(\"value2.2\", x3.getString(\"key2\"));\r\n    assertEquals(\"USER2\", x3.getString(\"key2[@override]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testConcurrentAccess",
  "sourceCode" : "/**\r\n * Tests concurrent read and write access on a combined configuration. There are multiple reader threads and a single\r\n * writer thread. It is checked that no inconsistencies occur.\r\n */\r\n@Test\r\nvoid testConcurrentAccess() throws ConfigurationException, InterruptedException {\r\n    // populate the test combined configuration\r\n    setUpSourceTest();\r\n    final XMLConfiguration xmlConf = new XMLConfiguration();\r\n    new FileHandler(xmlConf).load(ConfigurationAssert.getTestFile(\"test.xml\"));\r\n    config.addConfiguration(xmlConf);\r\n    final PropertiesConfiguration propConf = new PropertiesConfiguration();\r\n    new FileHandler(propConf).load(ConfigurationAssert.getTestFile(\"test.properties\"));\r\n    for (int i = 0; i < 8; i++) {\r\n        config.addConfiguration(new BaseHierarchicalConfiguration());\r\n    }\r\n    config.getConfiguration(0).addProperty(KEY_CONCURRENT, TEST_NAME);\r\n    // Set a single synchronizer for all involved configurations\r\n    final Synchronizer sync = new ReadWriteSynchronizer();\r\n    config.setSynchronizer(sync);\r\n    for (final Configuration c : config.getConfigurations()) {\r\n        c.setSynchronizer(sync);\r\n    }\r\n    // setup test threads\r\n    final int numberOfReaders = 3;\r\n    final int readCount = 5000;\r\n    final int writeCount = 3000;\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final AtomicInteger errorCount = new AtomicInteger();\r\n    final Collection<Thread> threads = new ArrayList<>(numberOfReaders + 1);\r\n    final Thread writeThread = new WriteThread(config, latch, errorCount, writeCount);\r\n    writeThread.start();\r\n    threads.add(writeThread);\r\n    for (int i = 0; i < numberOfReaders; i++) {\r\n        final Thread readThread = new ReadThread(config, latch, errorCount, readCount);\r\n        readThread.start();\r\n        threads.add(readThread);\r\n    }\r\n    // perform test\r\n    latch.countDown();\r\n    for (final Thread t : threads) {\r\n        t.join();\r\n    }\r\n    assertEquals(0, errorCount.get());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testConfigurationsAt",
  "sourceCode" : "/**\r\n * Tests whether sub configurations can be created from a key.\r\n */\r\n@Test\r\nvoid testConfigurationsAt() {\r\n    checkConfigurationsAt(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testConfigurationsAtWithUpdates",
  "sourceCode" : "/**\r\n * Tests whether sub configurations can be created which are attached.\r\n */\r\n@Test\r\nvoid testConfigurationsAtWithUpdates() {\r\n    checkConfigurationsAt(true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testConversionExpressionEngine",
  "sourceCode" : "/**\r\n * Tests using a conversion expression engine for child configurations with strange keys. This test is related to\r\n * CONFIGURATION-336.\r\n */\r\n@Test\r\nvoid testConversionExpressionEngine() {\r\n    final PropertiesConfiguration child = new PropertiesConfiguration();\r\n    child.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    child.addProperty(\"test(a)\", \"1,2,3\");\r\n    config.addConfiguration(child);\r\n    final DefaultExpressionEngine engineQuery = new DefaultExpressionEngine(new DefaultExpressionEngineSymbols.Builder(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS).setIndexStart(\"<\").setIndexEnd(\">\").create());\r\n    config.setExpressionEngine(engineQuery);\r\n    final DefaultExpressionEngine engineConvert = new DefaultExpressionEngine(new DefaultExpressionEngineSymbols.Builder(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS).setIndexStart(\"[\").setIndexEnd(\"]\").create());\r\n    config.setConversionExpressionEngine(engineConvert);\r\n    assertEquals(\"1\", config.getString(\"test(a)<0>\"));\r\n    assertEquals(\"2\", config.getString(\"test(a)<1>\"));\r\n    assertEquals(\"3\", config.getString(\"test(a)<2>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testEscapeListDelimiters",
  "sourceCode" : "/**\r\n * Tests whether escaped list delimiters are treated correctly.\r\n */\r\n@Test\r\nvoid testEscapeListDelimiters() {\r\n    final PropertiesConfiguration sub = new PropertiesConfiguration();\r\n    sub.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    sub.addProperty(\"test.pi\", \"3\\\\,1415\");\r\n    config.addConfiguration(sub);\r\n    assertEquals(\"3,1415\", config.getString(\"test.pi\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetConfigurationByIdxSynchronized",
  "sourceCode" : "/**\r\n * Tests whether access to a configuration by index is correctly synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationByIdxSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertNotNull(config.getConfiguration(0));\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetConfigurationByNameSynchronized",
  "sourceCode" : "/**\r\n * Tests whether access to a configuration by name is correctly synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationByNameSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertNotNull(config.getConfiguration(CHILD1));\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetConfigurationNameList",
  "sourceCode" : "@Test\r\nvoid testGetConfigurationNameList() throws Exception {\r\n    config.addConfiguration(setUpTestConfiguration());\r\n    config.addConfiguration(setUpTestConfiguration(), TEST_NAME, \"conf2\");\r\n    final AbstractConfiguration pc = new PropertiesConfiguration();\r\n    config.addConfiguration(pc, \"props\");\r\n    final List<String> list = config.getConfigurationNameList();\r\n    assertNotNull(list);\r\n    assertEquals(3, list.size());\r\n    final String name = list.get(1);\r\n    assertNotNull(name);\r\n    assertEquals(TEST_NAME, name);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetConfigurationNameListSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying the name list of child configurations is synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationNameListSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertFalse(config.getConfigurationNameList().isEmpty());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetConfigurationNamesSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying the name set of child configurations is synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationNamesSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertFalse(config.getConfigurationNames().isEmpty());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetConfigurations",
  "sourceCode" : "@Test\r\nvoid testGetConfigurations() throws Exception {\r\n    config.addConfiguration(setUpTestConfiguration());\r\n    config.addConfiguration(setUpTestConfiguration(), TEST_NAME, \"conf2\");\r\n    final AbstractConfiguration pc = new PropertiesConfiguration();\r\n    config.addConfiguration(pc, \"props\");\r\n    final List<Configuration> list = config.getConfigurations();\r\n    assertNotNull(list);\r\n    assertEquals(3, list.size());\r\n    final Configuration c = list.get(2);\r\n    assertSame(pc, c);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetConfigurationsSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying the list of child configurations is synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationsSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertFalse(config.getConfigurations().isEmpty());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetConversionExpressionEngineSynchronized",
  "sourceCode" : "/**\r\n * Tests whether read access to the conversion expression engine is synchronized.\r\n */\r\n@Test\r\nvoid testGetConversionExpressionEngineSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertNull(config.getConversionExpressionEngine());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "/**\r\n * Tests CONFIGURATION-799.\r\n */\r\n@Test\r\nvoid testGetKeys() {\r\n    // Set up\r\n    final BaseConfiguration conf1 = new BaseConfiguration();\r\n    final String key = \"x1\";\r\n    conf1.addProperty(key, 1);\r\n    assertEquals(1, conf1.getProperty(key));\r\n    final CombinedConfiguration conf2 = new CombinedConfiguration();\r\n    conf2.addConfiguration(conf1, null, \"\");\r\n    assertEquals(conf1, conf2.getConfiguration(0));\r\n    // Actual test\r\n    final Iterator<String> keys = conf2.getKeys();\r\n    assertEquals(key, keys.next());\r\n    assertFalse(keys.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetNodeCombinerSynchronized",
  "sourceCode" : "/**\r\n * Tests whether getNodeCombiner() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testGetNodeCombinerSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertNotNull(config.getNodeCombiner());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetNumberOfConfigurationsSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying the number of child configurations is synchronized.\r\n */\r\n@Test\r\nvoid testGetNumberOfConfigurationsSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertEquals(2, config.getNumberOfConfigurations());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceCombined",
  "sourceCode" : "/**\r\n * Tests the getSource() method when the passed in key belongs to the combined configuration itself.\r\n */\r\n@Test\r\nvoid testGetSourceCombined() {\r\n    setUpSourceTest();\r\n    final String key = \"yet.another.key\";\r\n    config.addProperty(key, Boolean.TRUE);\r\n    assertEquals(config, config.getSource(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceHierarchical",
  "sourceCode" : "/**\r\n * Tests the gestSource() method when the source property is defined in a hierarchical configuration.\r\n */\r\n@Test\r\nvoid testGetSourceHierarchical() {\r\n    setUpSourceTest();\r\n    assertEquals(config.getConfiguration(CHILD1), config.getSource(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceMulti",
  "sourceCode" : "/**\r\n * Tests the getSource() method when the passed in key refers to multiple values, which are all defined in the same\r\n * source configuration.\r\n */\r\n@Test\r\nvoid testGetSourceMulti() {\r\n    setUpSourceTest();\r\n    final String key = \"list.key\";\r\n    config.getConfiguration(CHILD1).addProperty(key, \"1,2,3\");\r\n    assertEquals(config.getConfiguration(CHILD1), config.getSource(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceMultiSources",
  "sourceCode" : "/**\r\n * Tests the getSource() method when the passed in key refers to multiple values defined by different sources. This\r\n * should cause an exception.\r\n */\r\n@Test\r\nvoid testGetSourceMultiSources() {\r\n    setUpSourceTest();\r\n    final String key = \"list.key\";\r\n    config.getConfiguration(CHILD1).addProperty(key, \"1,2,3\");\r\n    config.getConfiguration(CHILD2).addProperty(key, \"a,b,c\");\r\n    assertThrows(IllegalArgumentException.class, () -> config.getSource(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceNonHierarchical",
  "sourceCode" : "/**\r\n * Tests whether the source configuration can be detected for non hierarchical configurations.\r\n */\r\n@Test\r\nvoid testGetSourceNonHierarchical() {\r\n    setUpSourceTest();\r\n    assertEquals(config.getConfiguration(CHILD2), config.getSource(\"another.key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceNull",
  "sourceCode" : "/**\r\n * Tests the getSource() method when a null key is passed in. This should cause an exception.\r\n */\r\n@Test\r\nvoid testGetSourceNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> config.getSource(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourcesMultiSources",
  "sourceCode" : "/**\r\n * Tests whether multiple sources of a key can be retrieved.\r\n */\r\n@Test\r\nvoid testGetSourcesMultiSources() {\r\n    setUpSourceTest();\r\n    final String key = \"list.key\";\r\n    config.getConfiguration(CHILD1).addProperty(key, \"1,2,3\");\r\n    config.getConfiguration(CHILD2).addProperty(key, \"a,b,c\");\r\n    final Set<Configuration> sources = config.getSources(key);\r\n    assertEquals(2, sources.size());\r\n    assertTrue(sources.contains(config.getConfiguration(CHILD1)));\r\n    assertTrue(sources.contains(config.getConfiguration(CHILD2)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourcesUnknownKey",
  "sourceCode" : "/**\r\n * Tests getSources() for a non existing key.\r\n */\r\n@Test\r\nvoid testGetSourcesUnknownKey() {\r\n    setUpSourceTest();\r\n    assertTrue(config.getSources(\"non.existing,key\").isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceSynchronized",
  "sourceCode" : "/**\r\n * Tests whether getSource() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testGetSourceSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    assertNotNull(config.getSource(TEST_KEY));\r\n    sync.verifyStart(Methods.BEGIN_READ);\r\n    sync.verifyEnd(Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceUnknown",
  "sourceCode" : "/**\r\n * Tests the getSource() method when the passed in key is not contained. Result should be null in this case.\r\n */\r\n@Test\r\nvoid testGetSourceUnknown() {\r\n    setUpSourceTest();\r\n    assertNull(config.getSource(\"an.unknown.key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testGetSourceWithCombinedChildConfiguration",
  "sourceCode" : "/**\r\n * Tests getSource() if a child configuration is again a combined configuration.\r\n */\r\n@Test\r\nvoid testGetSourceWithCombinedChildConfiguration() {\r\n    setUpSourceTest();\r\n    final CombinedConfiguration cc = new CombinedConfiguration();\r\n    cc.addConfiguration(config);\r\n    assertEquals(config, cc.getSource(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testInit",
  "sourceCode" : "/**\r\n * Tests accessing a newly created combined configuration.\r\n */\r\n@Test\r\nvoid testInit() {\r\n    assertEquals(0, config.getNumberOfConfigurations());\r\n    assertTrue(config.getConfigurationNames().isEmpty());\r\n    assertInstanceOf(UnionCombiner.class, config.getNodeCombiner());\r\n    assertNull(config.getConfiguration(TEST_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testInvalidateEventBeforeAndAfterChange",
  "sourceCode" : "/**\r\n * Tests whether only a single invalidate event is fired for a change. This test is related to CONFIGURATION-315.\r\n */\r\n@Test\r\nvoid testInvalidateEventBeforeAndAfterChange() {\r\n    ConfigurationEvent event = new ConfigurationEvent(config, ConfigurationEvent.ANY, null, null, true);\r\n    config.onEvent(event);\r\n    assertEquals(1, listener.invalidateEvents);\r\n    event = new ConfigurationEvent(config, ConfigurationEvent.ANY, null, null, false);\r\n    config.onEvent(event);\r\n    assertEquals(1, listener.invalidateEvents);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testInvalidateSynchronized",
  "sourceCode" : "/**\r\n * Tests whether invalidate() performs correct synchronization.\r\n */\r\n@Test\r\nvoid testInvalidateSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    config.invalidate();\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testLockHandlingWithExceptionWhenConstructingRootNode",
  "sourceCode" : "/**\r\n * Tests whether requested locks are freed correctly if an exception occurs while constructing the root node.\r\n */\r\n@Test\r\nvoid testLockHandlingWithExceptionWhenConstructingRootNode() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    final RuntimeException testEx = new ConfigurationRuntimeException(\"Test exception\");\r\n    final BaseHierarchicalConfiguration childEx = new BaseHierarchicalConfiguration() {\r\n\r\n        @Override\r\n        public NodeModel<ImmutableNode> getModel() {\r\n            throw testEx;\r\n        }\r\n    };\r\n    config.addConfiguration(childEx);\r\n    final Exception ex = assertThrows(Exception.class, () -> config.lock(LockMode.READ));\r\n    assertEquals(testEx, ex);\r\n    // 1 x add configuration, then obtain read lock and create root node\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE, Methods.BEGIN_READ, Methods.END_READ, Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testRemoveConfiguration",
  "sourceCode" : "/**\r\n * Tests removing a configuration.\r\n */\r\n@Test\r\nvoid testRemoveConfiguration() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c);\r\n    checkAddConfig(c);\r\n    assertTrue(config.removeConfiguration(c));\r\n    checkRemoveConfig(c);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testRemoveConfigurationAt",
  "sourceCode" : "/**\r\n * Tests removing a configuration by index.\r\n */\r\n@Test\r\nvoid testRemoveConfigurationAt() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c);\r\n    assertSame(c, config.removeConfigurationAt(0));\r\n    checkRemoveConfig(c);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testRemoveConfigurationByName",
  "sourceCode" : "/**\r\n * Tests removing a configuration by name.\r\n */\r\n@Test\r\nvoid testRemoveConfigurationByName() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c, TEST_NAME);\r\n    assertSame(c, config.removeConfiguration(TEST_NAME));\r\n    checkRemoveConfig(c);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testRemoveConfigurationByUnknownName",
  "sourceCode" : "/**\r\n * Tests removing a configuration by name, which is not contained.\r\n */\r\n@Test\r\nvoid testRemoveConfigurationByUnknownName() {\r\n    assertNull(config.removeConfiguration(\"unknownName\"));\r\n    listener.checkEvent(0, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testRemoveNamedConfiguration",
  "sourceCode" : "/**\r\n * Tests removing a configuration with a name.\r\n */\r\n@Test\r\nvoid testRemoveNamedConfiguration() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c, TEST_NAME);\r\n    config.removeConfiguration(c);\r\n    checkRemoveConfig(c);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testRemoveNamedConfigurationAt",
  "sourceCode" : "/**\r\n * Tests removing a named configuration by index.\r\n */\r\n@Test\r\nvoid testRemoveNamedConfigurationAt() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c, TEST_NAME);\r\n    assertSame(c, config.removeConfigurationAt(0));\r\n    checkRemoveConfig(c);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testRemoveNonContainedConfiguration",
  "sourceCode" : "/**\r\n * Tests removing a configuration that was not added prior.\r\n */\r\n@Test\r\nvoid testRemoveNonContainedConfiguration() {\r\n    assertFalse(config.removeConfiguration(setUpTestConfiguration()));\r\n    listener.checkEvent(0, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testSetConversionExpressionEngineSynchronized",
  "sourceCode" : "/**\r\n * Tests whether write access to the conversion expression engine is synchronized.\r\n */\r\n@Test\r\nvoid testSetConversionExpressionEngineSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    config.setConversionExpressionEngine(new DefaultExpressionEngine(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS));\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testSetNodeCombiner",
  "sourceCode" : "/**\r\n * Tests if setting a node combiner causes an invalidation.\r\n */\r\n@Test\r\nvoid testSetNodeCombiner() {\r\n    final NodeCombiner combiner = new UnionCombiner();\r\n    config.setNodeCombiner(combiner);\r\n    assertSame(combiner, config.getNodeCombiner());\r\n    listener.checkEvent(1, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testSetNodeCombinerSynchronized",
  "sourceCode" : "/**\r\n * Tests whether setNodeCombiner() is correctly synchronized.\r\n */\r\n@Test\r\nvoid testSetNodeCombinerSynchronized() {\r\n    final SynchronizerTestImpl sync = setUpSynchronizerTest();\r\n    config.setNodeCombiner(new UnionCombiner());\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n    checkCombinedRootNotConstructed();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testSetNullNodeCombiner",
  "sourceCode" : "/**\r\n * Tests setting a null node combiner. This should cause an exception.\r\n */\r\n@Test\r\nvoid testSetNullNodeCombiner() {\r\n    assertThrows(IllegalArgumentException.class, () -> config.setNodeCombiner(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testSubConfigurationWithUpdates",
  "sourceCode" : "/**\r\n * Tests whether a sub configuration survives updates of its parent.\r\n */\r\n@Test\r\nvoid testSubConfigurationWithUpdates() {\r\n    final AbstractConfiguration srcConfig = setUpSubConfigTest();\r\n    final HierarchicalConfiguration<ImmutableNode> sub = config.configurationAt(SUB_KEY, true);\r\n    assertTrue(sub.getBoolean(TEST_KEY));\r\n    srcConfig.setProperty(TEST_KEY, Boolean.FALSE);\r\n    assertFalse(sub.getBoolean(TEST_KEY));\r\n    assertFalse(config.getBoolean(SUB_KEY + '.' + TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCombinedConfiguration.java",
  "methodName" : "testUpdateContainedConfiguration",
  "sourceCode" : "/**\r\n * Tests if an update of a contained configuration leeds to an invalidation of the combined configuration.\r\n */\r\n@Test\r\nvoid testUpdateContainedConfiguration() {\r\n    final AbstractConfiguration c = setUpTestConfiguration();\r\n    config.addConfiguration(c);\r\n    c.addProperty(\"test.otherTest\", \"yes\");\r\n    assertEquals(\"yes\", config.getString(\"test.otherTest\"));\r\n    listener.checkEvent(2, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testAddConfigurationSynchronized",
  "sourceCode" : "/**\r\n * Tests whether adding a child configuration is synchronized.\r\n */\r\n@Test\r\nvoid testAddConfigurationSynchronized() {\r\n    final SynchronizerTestImpl sync = installSynchronizer();\r\n    cc.addConfiguration(xmlConf);\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testAddFirstRemoveConfigurations",
  "sourceCode" : "@Test\r\nvoid testAddFirstRemoveConfigurations() throws Exception {\r\n    cc.addConfigurationFirst(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.addConfigurationFirst(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.addConfigurationFirst(conf2);\r\n    assertEquals(3, cc.getNumberOfConfigurations());\r\n    cc.removeConfiguration(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.clear();\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testAddingProperty",
  "sourceCode" : "/**\r\n * Tests adding values. Make sure they _DON'T_ override any other properties but add to the existing properties and keep\r\n * sequence\r\n */\r\n@Test\r\nvoid testAddingProperty() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    String[] values = cc.getStringArray(\"test.short\");\r\n    assertArrayEquals(new String[] { \"1\" }, values);\r\n    cc.addProperty(\"test.short\", \"88\");\r\n    values = cc.getStringArray(\"test.short\");\r\n    assertArrayEquals(new String[] { \"1\", \"88\" }, values);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testAddRemoveConfigurations",
  "sourceCode" : "@Test\r\nvoid testAddRemoveConfigurations() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.addConfiguration(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.addConfiguration(conf2);\r\n    assertEquals(3, cc.getNumberOfConfigurations());\r\n    cc.removeConfiguration(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.clear();\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testCantRemoveMemoryConfig",
  "sourceCode" : "@Test\r\nvoid testCantRemoveMemoryConfig() throws Exception {\r\n    cc.clear();\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n    final Configuration internal = cc.getConfiguration(0);\r\n    cc.removeConfiguration(internal);\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testCheckingInMemoryConfiguration",
  "sourceCode" : "@Test\r\nvoid testCheckingInMemoryConfiguration() throws Exception {\r\n    final String testKey = \"testKey\";\r\n    final Configuration defaults = new PropertiesConfiguration();\r\n    defaults.setProperty(testKey, \"testValue\");\r\n    final Configuration testConfiguration = new CompositeConfiguration(defaults);\r\n    assertTrue(testConfiguration.containsKey(testKey));\r\n    assertFalse(testConfiguration.isEmpty());\r\n    boolean foundTestKey = false;\r\n    final Iterator<String> i = testConfiguration.getKeys();\r\n    // assertInstanceOf(IteratorChain.class, i);\r\n    // IteratorChain ic = (IteratorChain)i;\r\n    // assertEquals(2,i.size());\r\n    while (i.hasNext()) {\r\n        final String key = i.next();\r\n        if (key.equals(testKey)) {\r\n            foundTestKey = true;\r\n        }\r\n    }\r\n    assertTrue(foundTestKey);\r\n    testConfiguration.clearProperty(testKey);\r\n    assertFalse(testConfiguration.containsKey(testKey));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testClearingProperty",
  "sourceCode" : "/**\r\n * Tests setting values. These are set in memory mode only!\r\n */\r\n@Test\r\nvoid testClearingProperty() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    cc.clearProperty(\"test.short\");\r\n    assertFalse(cc.containsKey(\"test.short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "@Test\r\nvoid testClone() {\r\n    final CompositeConfiguration cc2 = (CompositeConfiguration) cc.clone();\r\n    assertEquals(cc.getNumberOfConfigurations(), cc2.getNumberOfConfigurations());\r\n    final StrictConfigurationComparator comp = new StrictConfigurationComparator();\r\n    for (int i = 0; i < cc.getNumberOfConfigurations(); i++) {\r\n        assertEquals(cc.getConfiguration(i).getClass(), cc2.getConfiguration(i).getClass(), \"Wrong configuration class at \" + i);\r\n        assertNotSame(cc.getConfiguration(i), cc2.getConfiguration(i));\r\n        assertTrue(comp.compare(cc.getConfiguration(i), cc2.getConfiguration(i)), \"Configurations at \" + i + \" not equal\");\r\n    }\r\n    assertTrue(comp.compare(cc, cc2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testCloneEventListener",
  "sourceCode" : "/**\r\n * Ensures that event listeners are not cloned.\r\n */\r\n@Test\r\nvoid testCloneEventListener() {\r\n    cc.addEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(null));\r\n    final CompositeConfiguration cc2 = (CompositeConfiguration) cc.clone();\r\n    assertTrue(cc2.getEventListeners(ConfigurationEvent.ANY).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testCloneInterpolation",
  "sourceCode" : "/**\r\n * Tests whether interpolation works as expected after cloning.\r\n */\r\n@Test\r\nvoid testCloneInterpolation() {\r\n    final CompositeConfiguration cc2 = (CompositeConfiguration) cc.clone();\r\n    assertNotSame(cc.getInterpolator(), cc2.getInterpolator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testCloneNotSupported",
  "sourceCode" : "/**\r\n * Tests cloning if one of the contained configurations does not support this operation. This should cause an exception.\r\n */\r\n@Test\r\nvoid testCloneNotSupported() {\r\n    cc.addConfiguration(new NonCloneableConfiguration());\r\n    assertThrows(ConfigurationRuntimeException.class, cc::clone);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testDefaultValueWhenKeyMissing",
  "sourceCode" : "/**\r\n * Tests getting a default when the key doesn't exist\r\n */\r\n@Test\r\nvoid testDefaultValueWhenKeyMissing() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    assertEquals(\"default\", cc.getString(\"bogus\", \"default\"));\r\n    assertEquals(1.4, cc.getDouble(\"bogus\", 1.4), 0.0);\r\n    assertEquals(1.4, cc.getDouble(\"bogus\", 1.4), 0.0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testEventAddProperty",
  "sourceCode" : "/**\r\n * Tests whether add property events are triggered.\r\n */\r\n@Test\r\nvoid testEventAddProperty() {\r\n    final EventListenerTestImpl listener = new EventListenerTestImpl(cc);\r\n    cc.addEventListener(ConfigurationEvent.ANY, listener);\r\n    cc.addProperty(\"test\", \"value\");\r\n    listener.checkEvent(ConfigurationEvent.ADD_PROPERTY, \"test\", \"value\", true);\r\n    listener.checkEvent(ConfigurationEvent.ADD_PROPERTY, \"test\", \"value\", false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testEventClearProperty",
  "sourceCode" : "/**\r\n * Tests whether clear property events are triggered.\r\n */\r\n@Test\r\nvoid testEventClearProperty() {\r\n    cc.addConfiguration(conf1);\r\n    final String key = \"configuration.loaded\";\r\n    assertTrue(cc.getBoolean(key));\r\n    final EventListenerTestImpl listener = new EventListenerTestImpl(cc);\r\n    cc.addEventListener(ConfigurationEvent.ANY, listener);\r\n    cc.clearProperty(key);\r\n    assertFalse(cc.containsKey(key));\r\n    listener.checkEvent(ConfigurationEvent.CLEAR_PROPERTY, key, null, true);\r\n    listener.checkEvent(ConfigurationEvent.CLEAR_PROPERTY, key, null, false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testEventSetProperty",
  "sourceCode" : "/**\r\n * Tests whether set property events are triggered.\r\n */\r\n@Test\r\nvoid testEventSetProperty() {\r\n    final EventListenerTestImpl listener = new EventListenerTestImpl(cc);\r\n    cc.addEventListener(ConfigurationEvent.ANY, listener);\r\n    cc.setProperty(\"test\", \"value\");\r\n    listener.checkEvent(ConfigurationEvent.SET_PROPERTY, \"test\", \"value\", true);\r\n    listener.checkEvent(ConfigurationEvent.SET_PROPERTY, \"test\", \"value\", false);\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetConfigurationSynchronized",
  "sourceCode" : "/**\r\n * Tests whether access to a configuration by index is synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationSynchronized() {\r\n    final SynchronizerTestImpl sync = installSynchronizer();\r\n    assertEquals(conf1, cc.getConfiguration(0));\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetInMemoryConfigurationSynchronized",
  "sourceCode" : "/**\r\n * Tests whether access to the in-memory configuration is synchronized.\r\n */\r\n@Test\r\nvoid testGetInMemoryConfigurationSynchronized() {\r\n    final SynchronizerTestImpl sync = installSynchronizer();\r\n    cc.getInMemoryConfiguration();\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetKeys2PreservesOrder",
  "sourceCode" : "/**\r\n * Tests {@code getKeys(String key)} preserves the order\r\n */\r\n@Test\r\nvoid testGetKeys2PreservesOrder() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    final List<String> orderedList = new ArrayList<>();\r\n    for (final Iterator<String> keys = conf1.getKeys(\"test\"); keys.hasNext(); ) {\r\n        orderedList.add(keys.next());\r\n    }\r\n    final List<String> iteratedList = new ArrayList<>();\r\n    for (final Iterator<String> keys = cc.getKeys(\"test\"); keys.hasNext(); ) {\r\n        iteratedList.add(keys.next());\r\n    }\r\n    assertEquals(orderedList, iteratedList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetKeysPreservesOrder",
  "sourceCode" : "/**\r\n * Tests {@code getKeys} preserves the order\r\n */\r\n@Test\r\nvoid testGetKeysPreservesOrder() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    final List<String> orderedList = new ArrayList<>();\r\n    for (final Iterator<String> keys = conf1.getKeys(); keys.hasNext(); ) {\r\n        orderedList.add(keys.next());\r\n    }\r\n    final List<String> iteratedList = new ArrayList<>();\r\n    for (final Iterator<String> keys = cc.getKeys(); keys.hasNext(); ) {\r\n        iteratedList.add(keys.next());\r\n    }\r\n    assertEquals(orderedList, iteratedList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetList",
  "sourceCode" : "@Test\r\nvoid testGetList() {\r\n    final Configuration conf1 = new BaseConfiguration();\r\n    conf1.addProperty(\"array\", \"value1\");\r\n    conf1.addProperty(\"array\", \"value2\");\r\n    final Configuration conf2 = new BaseConfiguration();\r\n    conf2.addProperty(\"array\", \"value3\");\r\n    conf2.addProperty(\"array\", \"value4\");\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    // check the composite 'array' property\r\n    List<Object> list = cc.getList(\"array\");\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\"), list);\r\n    // add an element to the list in the composite configuration\r\n    cc.addProperty(\"array\", \"value5\");\r\n    // test the new list\r\n    list = cc.getList(\"array\");\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\", \"value5\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetListWithInterpolation",
  "sourceCode" : "/**\r\n * Tests querying a list when a tricky interpolation is involved. This is related to CONFIGURATION-339.\r\n */\r\n@Test\r\nvoid testGetListWithInterpolation() {\r\n    prepareInterpolationTest();\r\n    final List<Object> lst = cc.getList(\"bar\");\r\n    assertEquals(Arrays.asList(\"override\"), lst);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetNumberOfConfigurationsSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying the number of child configurations is synchronized.\r\n */\r\n@Test\r\nvoid testGetNumberOfConfigurationsSynchronized() {\r\n    final SynchronizerTestImpl sync = installSynchronizer();\r\n    assertEquals(3, cc.getNumberOfConfigurations());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    assertEquals(\"test.properties\", cc.getString(\"propertyInOrder\"));\r\n    cc.clear();\r\n    cc.addConfiguration(conf2);\r\n    cc.addConfiguration(conf1);\r\n    assertEquals(\"test2.properties\", cc.getString(\"propertyInOrder\"));\r\n    cc.clear();\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfigurationFirst(conf2);\r\n    assertEquals(\"test2.properties\", cc.getString(\"propertyInOrder\"));\r\n    cc.clear();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetPropertyMissing",
  "sourceCode" : "@Test\r\nvoid testGetPropertyMissing() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    final NoSuchElementException nsee = assertThrows(NoSuchElementException.class, () -> cc.getString(\"bogus.property\"));\r\n    assertTrue(nsee.getMessage().contains(\"bogus.property\"));\r\n    assertFalse(cc.getBoolean(\"test.missing.boolean\", false));\r\n    assertTrue(cc.getBoolean(\"test.missing.boolean.true\", true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetPropertyWIncludes",
  "sourceCode" : "@Test\r\nvoid testGetPropertyWIncludes() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    final List<Object> l = cc.getList(\"packages\");\r\n    assertTrue(l.contains(\"packagea\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetSourceInMemory",
  "sourceCode" : "/**\r\n * Tests the getSource() method for a property contained in the in memory configuration.\r\n */\r\n@Test\r\nvoid testGetSourceInMemory() {\r\n    setUpSourceTest();\r\n    cc.addProperty(TEST_PROPERTY, Boolean.TRUE);\r\n    assertSame(cc.getInMemoryConfiguration(), cc.getSource(TEST_PROPERTY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetSourceMultiple",
  "sourceCode" : "/**\r\n * Tests the getSource() method if the property is defined by multiple child configurations. In this case an exception\r\n * should be thrown.\r\n */\r\n@Test\r\nvoid testGetSourceMultiple() {\r\n    setUpSourceTest();\r\n    conf1.addProperty(TEST_PROPERTY, Boolean.TRUE);\r\n    cc.addProperty(TEST_PROPERTY, \"a value\");\r\n    assertThrows(IllegalArgumentException.class, () -> cc.getSource(TEST_PROPERTY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetSourceNull",
  "sourceCode" : "/**\r\n * Tests the getSource() method for a null key. This should cause an exception.\r\n */\r\n@Test\r\nvoid testGetSourceNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> cc.getSource(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetSourceSingle",
  "sourceCode" : "/**\r\n * Tests the getSource() method if the property is defined in a single child configuration.\r\n */\r\n@Test\r\nvoid testGetSourceSingle() {\r\n    setUpSourceTest();\r\n    conf1.addProperty(TEST_PROPERTY, Boolean.TRUE);\r\n    assertSame(conf1, cc.getSource(TEST_PROPERTY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetSourceUnknown",
  "sourceCode" : "/**\r\n * Tests the getSource() method for an unknown property key.\r\n */\r\n@Test\r\nvoid testGetSourceUnknown() {\r\n    setUpSourceTest();\r\n    assertNull(cc.getSource(TEST_PROPERTY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetStringArrayWithInterpolation",
  "sourceCode" : "/**\r\n * Tests querying a string array when a tricky interpolation is involved.\r\n */\r\n@Test\r\nvoid testGetStringArrayWithInterpolation() {\r\n    prepareInterpolationTest();\r\n    final String[] values = cc.getStringArray(\"bar\");\r\n    assertArrayEquals(new String[] { \"override\" }, values);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGetStringWithDefaults",
  "sourceCode" : "@Test\r\nvoid testGetStringWithDefaults() {\r\n    final BaseConfiguration defaults = new BaseConfiguration();\r\n    defaults.addProperty(\"default\", \"default string\");\r\n    final CompositeConfiguration c = new CompositeConfiguration(defaults);\r\n    c.setThrowExceptionOnMissing(cc.isThrowExceptionOnMissing());\r\n    c.addProperty(\"string\", \"test string\");\r\n    assertEquals(\"test string\", c.getString(\"string\"));\r\n    assertThrows(NoSuchElementException.class, () -> c.getString(\"XXX\"));\r\n    // test defaults\r\n    assertEquals(\"test string\", c.getString(\"string\", \"some default value\"));\r\n    assertEquals(\"default string\", c.getString(\"default\"));\r\n    assertEquals(\"default string\", c.getString(\"default\", \"some default value\"));\r\n    assertEquals(\"some default value\", c.getString(\"XXX\", \"some default value\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGettingConfiguration",
  "sourceCode" : "@Test\r\nvoid testGettingConfiguration() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    assertEquals(PropertiesConfiguration.class, cc.getConfiguration(0).getClass());\r\n    assertEquals(XMLConfiguration.class, cc.getConfiguration(1).getClass());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testGettingSubset",
  "sourceCode" : "/**\r\n * Tests retrieving subsets of configurations\r\n */\r\n@Test\r\nvoid testGettingSubset() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    Configuration subset = cc.subset(\"test\");\r\n    assertNotNull(subset);\r\n    assertFalse(subset.isEmpty());\r\n    assertEquals(\"1\", subset.getString(\"short\"));\r\n    cc.setProperty(\"test.short\", \"43\");\r\n    subset = cc.subset(\"test\");\r\n    assertEquals(\"43\", subset.getString(\"short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testInstanciateWithCollection",
  "sourceCode" : "@Test\r\nvoid testInstanciateWithCollection() {\r\n    final Collection<Configuration> configs = new ArrayList<>();\r\n    configs.add(xmlConf);\r\n    configs.add(conf1);\r\n    configs.add(conf2);\r\n    final CompositeConfiguration config = new CompositeConfiguration(configs);\r\n    assertEquals(4, config.getNumberOfConfigurations());\r\n    assertTrue(config.getInMemoryConfiguration().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testInterpolationArrayReference",
  "sourceCode" : "/**\r\n * Tests whether interpolation works if a variable references a property with multiple values. This test is related to\r\n * CONFIGURATION-632.\r\n */\r\n@Test\r\nvoid testInterpolationArrayReference() {\r\n    final Configuration props = new PropertiesConfiguration();\r\n    final String[] values = { \"a\", \"property\", \"with\", \"multiple\", \"values\" };\r\n    props.addProperty(\"keyMultiValues\", values);\r\n    props.addProperty(\"keyReference\", \"${keyMultiValues}\");\r\n    cc.addConfiguration(props);\r\n    assertArrayEquals(values, cc.getStringArray(\"keyReference\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testInterpolationInMultipleConfigs",
  "sourceCode" : "/**\r\n * Tests whether interpolation works if multiple configurations are involved. This test is related to CONFIGURATION-441.\r\n */\r\n@Test\r\nvoid testInterpolationInMultipleConfigs() {\r\n    final Configuration c1 = new PropertiesConfiguration();\r\n    c1.addProperty(\"property.one\", \"one\");\r\n    c1.addProperty(\"property.two\", \"two\");\r\n    final Configuration c2 = new PropertiesConfiguration();\r\n    c2.addProperty(\"property.one.ref\", \"${property.one}\");\r\n    cc.addConfiguration(c1);\r\n    cc.addConfiguration(c2);\r\n    assertEquals(\"one\", cc.getString(\"property.one.ref\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testList",
  "sourceCode" : "/**\r\n * Tests {@code List} parsing.\r\n */\r\n@Test\r\nvoid testList() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    List<Object> packages = cc.getList(\"packages\");\r\n    // we should get 3 packages here\r\n    assertEquals(3, packages.size());\r\n    final List<Object> defaultList = new ArrayList<>();\r\n    defaultList.add(\"1\");\r\n    defaultList.add(\"2\");\r\n    packages = cc.getList(\"packages.which.dont.exist\", defaultList);\r\n    // we should get 2 packages here\r\n    assertEquals(2, packages.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testListInterpolation",
  "sourceCode" : "/**\r\n * Tests whether global interpolation works with lists.\r\n */\r\n@Test\r\nvoid testListInterpolation() {\r\n    final PropertiesConfiguration c1 = new PropertiesConfiguration();\r\n    c1.addProperty(\"c1.value\", \"test1\");\r\n    c1.addProperty(\"c1.value\", \"${c2.value}\");\r\n    cc.addConfiguration(c1);\r\n    final PropertiesConfiguration c2 = new PropertiesConfiguration();\r\n    c2.addProperty(\"c2.value\", \"test2\");\r\n    cc.addConfiguration(c2);\r\n    final List<Object> lst = cc.getList(\"c1.value\");\r\n    assertEquals(Arrays.asList(\"test1\", \"test2\"), lst);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testMultipleTypesOfConfigs",
  "sourceCode" : "/**\r\n * Tests {@code List} parsing.\r\n */\r\n@Test\r\nvoid testMultipleTypesOfConfigs() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    assertEquals(1, cc.getInt(\"test.short\"));\r\n    cc.clear();\r\n    cc.addConfiguration(xmlConf);\r\n    cc.addConfiguration(conf1);\r\n    assertEquals(8, cc.getInt(\"test.short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testPropertyExistsInOnlyOneConfig",
  "sourceCode" : "@Test\r\nvoid testPropertyExistsInOnlyOneConfig() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    assertEquals(\"value\", cc.getString(\"element\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testRemoveConfigurationSynchronized",
  "sourceCode" : "/**\r\n * Tests whether removing a child configuration is synchronized.\r\n */\r\n@Test\r\nvoid testRemoveConfigurationSynchronized() {\r\n    final SynchronizerTestImpl sync = installSynchronizer();\r\n    cc.removeConfiguration(conf1);\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testReplaceInMemoryConfig",
  "sourceCode" : "/**\r\n * Tests whether the in-memory configuration can be replaced by a new child configuration.\r\n */\r\n@Test\r\nvoid testReplaceInMemoryConfig() {\r\n    conf1.setProperty(TEST_PROPERTY, \"conf1\");\r\n    conf2.setProperty(TEST_PROPERTY, \"conf2\");\r\n    cc.addConfiguration(conf1, true);\r\n    cc.addProperty(\"newProperty1\", \"newValue1\");\r\n    cc.addConfiguration(conf2, true);\r\n    cc.addProperty(\"newProperty2\", \"newValue2\");\r\n    assertEquals(\"conf1\", cc.getString(TEST_PROPERTY));\r\n    assertEquals(\"newValue1\", conf1.getString(\"newProperty1\"));\r\n    assertEquals(\"newValue2\", conf2.getString(\"newProperty2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testSetListDelimiter",
  "sourceCode" : "/**\r\n * Tests changing the list delimiter handler.\r\n */\r\n@Test\r\nvoid testSetListDelimiter() {\r\n    cc.setListDelimiterHandler(new DefaultListDelimiterHandler('/'));\r\n    checkSetListDelimiterHandler();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testSetListDelimiterAfterClear",
  "sourceCode" : "/**\r\n * Tests whether the correct list delimiter handler is set after a clear operation.\r\n */\r\n@Test\r\nvoid testSetListDelimiterAfterClear() {\r\n    cc.setListDelimiterHandler(new DefaultListDelimiterHandler('/'));\r\n    cc.clear();\r\n    checkSetListDelimiterHandler();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testSetListDelimiterInMemoryConfigNonBaseConfig",
  "sourceCode" : "/**\r\n * Tests the behavior of setListDelimiterHandler() if the in-memory configuration is not derived from BaseConfiguration.\r\n * This test is related to CONFIGURATION-476.\r\n */\r\n@Test\r\nvoid testSetListDelimiterInMemoryConfigNonBaseConfig() {\r\n    final Configuration inMemoryConfig = mock(Configuration.class);\r\n    cc = new CompositeConfiguration(inMemoryConfig);\r\n    assertDoesNotThrow(() -> cc.setListDelimiterHandler(new DefaultListDelimiterHandler(';')));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testSettingMissingProperty",
  "sourceCode" : "/**\r\n * Tests setting values. These are set in memory mode only!\r\n */\r\n@Test\r\nvoid testSettingMissingProperty() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    cc.setProperty(\"my.new.property\", \"supernew\");\r\n    assertEquals(\"supernew\", cc.getString(\"my.new.property\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testStringArray",
  "sourceCode" : "/**\r\n * Tests {@code String} array parsing.\r\n */\r\n@Test\r\nvoid testStringArray() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    String[] packages = cc.getStringArray(\"packages\");\r\n    // we should get 3 packages here\r\n    assertEquals(3, packages.length);\r\n    packages = cc.getStringArray(\"packages.which.dont.exist\");\r\n    // we should get 0 packages here\r\n    assertEquals(0, packages.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testStringArrayInterpolation",
  "sourceCode" : "@Test\r\nvoid testStringArrayInterpolation() {\r\n    final CompositeConfiguration config = new CompositeConfiguration();\r\n    config.addProperty(\"base\", \"foo\");\r\n    config.addProperty(\"list\", \"${base}.bar1\");\r\n    config.addProperty(\"list\", \"${base}.bar2\");\r\n    config.addProperty(\"list\", \"${base}.bar3\");\r\n    final String[] array = config.getStringArray(\"list\");\r\n    assertArrayEquals(new String[] { \"foo.bar1\", \"foo.bar2\", \"foo.bar3\" }, array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testSubsetCanResolve",
  "sourceCode" : "/**\r\n * Tests subsets and still can resolve elements\r\n */\r\n@Test\r\nvoid testSubsetCanResolve() throws Exception {\r\n    cc = new CompositeConfiguration();\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.addProperty(\"subset.tempfile\", \"${java.io.tmpdir}/file.tmp\");\r\n    cc.addConfiguration(config);\r\n    cc.addConfiguration(ConfigurationConverter.getConfiguration(System.getProperties()));\r\n    final Configuration subset = cc.subset(\"subset\");\r\n    assertEquals(FileUtils.getTempDirectoryPath() + \"/file.tmp\", subset.getString(\"tempfile\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testThrowExceptionOnMissing",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionOnMissing() {\r\n    assertTrue(cc.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestCompositeConfiguration.java",
  "methodName" : "testUseChildConfigAsInMemoryConfig",
  "sourceCode" : "/**\r\n * Tests whether a configuration can act as both regular child configuration and in-memory configuration. This test is\r\n * related to CONFIGURATION-471.\r\n */\r\n@Test\r\nvoid testUseChildConfigAsInMemoryConfig() {\r\n    conf1.setProperty(TEST_PROPERTY, \"conf1\");\r\n    conf2.setProperty(TEST_PROPERTY, \"conf2\");\r\n    cc.addConfiguration(conf1, true);\r\n    cc.addConfiguration(conf2);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    assertEquals(\"conf1\", cc.getString(TEST_PROPERTY));\r\n    cc.addProperty(\"newProperty\", \"newValue\");\r\n    assertEquals(\"newValue\", conf1.getString(\"newProperty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationConverter.java",
  "methodName" : "testConfigurationToMap",
  "sourceCode" : "@Test\r\nvoid testConfigurationToMap() {\r\n    final Configuration config = new BaseConfiguration();\r\n    config.addProperty(\"string\", \"teststring\");\r\n    final Map<Object, Object> map = ConfigurationConverter.getMap(config);\r\n    assertNotNull(map);\r\n    assertEquals(\"teststring\", map.get(\"string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationConverter.java",
  "methodName" : "testConfigurationToPropertiesDefaultListHandling",
  "sourceCode" : "/**\r\n * Tests a conversion to Properties if the default list delimiter handler is used (which does not support list joining).\r\n */\r\n@Test\r\nvoid testConfigurationToPropertiesDefaultListHandling() {\r\n    final BaseConfiguration config = createTestConfiguration();\r\n    final Properties props = ConfigurationConverter.getProperties(config);\r\n    assertNotNull(props);\r\n    assertEquals(\"teststring\", props.getProperty(\"string\"));\r\n    assertEquals(\"teststring\", props.getProperty(\"interpolated\"));\r\n    assertEquals(\"item 1,item 2\", props.getProperty(\"array\"));\r\n    assertEquals(\"teststring,teststring\", props.getProperty(\"interpolated-array\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationConverter.java",
  "methodName" : "testConfigurationToPropertiesListDelimiterHandler",
  "sourceCode" : "/**\r\n * Tests a conversion to Properties if the list delimiter handler supports list joining.\r\n */\r\n@Test\r\nvoid testConfigurationToPropertiesListDelimiterHandler() {\r\n    final BaseConfiguration config = createTestConfiguration();\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(';'));\r\n    final Properties props = ConfigurationConverter.getProperties(config);\r\n    assertEquals(\"item 1;item 2\", props.getProperty(\"array\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationConverter.java",
  "methodName" : "testConfigurationToPropertiesNoAbstractConfiguration",
  "sourceCode" : "/**\r\n * Tests a conversion to Properties if the source configuration does not extend AbstractConfiguration. In this case,\r\n * properties with multiple values have to be handled in a special way.\r\n */\r\n@Test\r\nvoid testConfigurationToPropertiesNoAbstractConfiguration() {\r\n    final Configuration src = mock(Configuration.class);\r\n    final BaseConfiguration config = createTestConfiguration();\r\n    when(src.getKeys()).thenReturn(config.getKeys());\r\n    when(src.getList(any())).thenAnswer(invocation -> {\r\n        final String key = invocation.getArgument(0, String.class);\r\n        return config.getList(key);\r\n    });\r\n    final Properties props = ConfigurationConverter.getProperties(src);\r\n    assertEquals(\"item 1,item 2\", props.getProperty(\"array\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationConverter.java",
  "methodName" : "testConfigurationToPropertiesScalarValue",
  "sourceCode" : "/**\r\n * Tests the conversion of a configuration object to properties if scalar values are involved. This test is related to\r\n * CONFIGURATION-432.\r\n */\r\n@Test\r\nvoid testConfigurationToPropertiesScalarValue() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.addProperty(\"scalar\", Integer.valueOf(42));\r\n    final Properties props = ConfigurationConverter.getProperties(config);\r\n    assertEquals(\"42\", props.getProperty(\"scalar\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationConverter.java",
  "methodName" : "testPropertiesToConfiguration",
  "sourceCode" : "@Test\r\nvoid testPropertiesToConfiguration() {\r\n    final Properties props = new Properties();\r\n    props.setProperty(\"string\", \"teststring\");\r\n    props.setProperty(\"int\", \"123\");\r\n    props.setProperty(\"list\", \"item 1, item 2\");\r\n    final AbstractConfiguration config = (AbstractConfiguration) ConfigurationConverter.getConfiguration(props);\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    assertEquals(\"teststring\", config.getString(\"string\"));\r\n    final List<Object> item1 = config.getList(\"list\");\r\n    assertEquals(\"item 1\", item1.get(0));\r\n    assertEquals(123, config.getInt(\"int\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationLookup.java",
  "methodName" : "testInitNoConfig",
  "sourceCode" : "/**\r\n * Tries to create an instance without a configuration.\r\n */\r\n@Test\r\nvoid testInitNoConfig() {\r\n    assertThrows(IllegalArgumentException.class, () -> new ConfigurationLookup(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationLookup.java",
  "methodName" : "testLookupComplex",
  "sourceCode" : "/**\r\n * Tests lookup() for a complex property value.\r\n */\r\n@Test\r\nvoid testLookupComplex() {\r\n    final int count = 5;\r\n    final Configuration conf = new BaseConfiguration();\r\n    for (int i = 0; i < count; i++) {\r\n        conf.addProperty(VAR, String.valueOf(VALUE) + i);\r\n    }\r\n    final ConfigurationLookup lookup = new ConfigurationLookup(conf);\r\n    final Collection<?> col = (Collection<?>) lookup.lookup(VAR);\r\n    final List<String> expected = new ArrayList<>();\r\n    for (int i = 0; i < count; i++) {\r\n        expected.add(String.valueOf(VALUE) + i);\r\n    }\r\n    assertIterableEquals(expected, col);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationLookup.java",
  "methodName" : "testLookupNotFound",
  "sourceCode" : "/**\r\n * Tests lookup() if the variable cannot be resolved.\r\n */\r\n@Test\r\nvoid testLookupNotFound() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    final ConfigurationLookup lookup = new ConfigurationLookup(conf);\r\n    assertNull(lookup.lookup(VAR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationLookup.java",
  "methodName" : "testLookupNotFoundEx",
  "sourceCode" : "/**\r\n * Tests lookup() if the variable cannot be resolved, and the configuration throws an exception.\r\n */\r\n@Test\r\nvoid testLookupNotFoundEx() {\r\n    final BaseConfiguration conf = new BaseConfiguration();\r\n    conf.setThrowExceptionOnMissing(true);\r\n    final ConfigurationLookup lookup = new ConfigurationLookup(conf);\r\n    assertNull(lookup.lookup(VAR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationLookup.java",
  "methodName" : "testLookupSuccess",
  "sourceCode" : "/**\r\n * Tests whether an existing variable can be resolved.\r\n */\r\n@Test\r\nvoid testLookupSuccess() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    conf.addProperty(VAR, VALUE);\r\n    final ConfigurationLookup lookup = new ConfigurationLookup(conf);\r\n    assertEquals(VALUE, lookup.lookup(VAR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationMap.java",
  "methodName" : "testNullConfig",
  "sourceCode" : "/**\r\n * Attempts to create a ConfigurationMap with null configuration. This should cause an exception.\r\n */\r\n@Test\r\nvoid testNullConfig() {\r\n    assertThrows(NullPointerException.class, () -> new ConfigurationMap(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationMap.java",
  "methodName" : "testPut",
  "sourceCode" : "/**\r\n * Class under test for Object put(Object, Object)\r\n */\r\n@Test\r\nvoid testPut() {\r\n    for (int i = 0; i < properties.length; i++) {\r\n        Object object = map.put(properties[i], values[i]);\r\n        assertNotNull(object);\r\n        assertEquals(values[i], object);\r\n        object = map.get(properties[i]);\r\n        assertNotNull(object);\r\n        assertEquals(values[i], object);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationSet.java",
  "methodName" : "testIterator",
  "sourceCode" : "/**\r\n * Class under test for Iterator iterator()\r\n */\r\n@Test\r\nvoid testIterator() {\r\n    final Iterator<Map.Entry<Object, Object>> iterator = set.iterator();\r\n    while (iterator.hasNext()) {\r\n        final Map.Entry<Object, Object> entry = iterator.next();\r\n        boolean found = false;\r\n        for (int i = 0; i < properties.length; i++) {\r\n            if (entry.getKey().equals(properties[i])) {\r\n                assertEquals(values[i], entry.getValue(), \"Incorrect value for property \" + properties[i]);\r\n                found = true;\r\n            }\r\n        }\r\n        assertTrue(found, \"Could not find property \" + entry.getKey());\r\n        iterator.remove();\r\n    }\r\n    assertTrue(set.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationSet.java",
  "methodName" : "testSize",
  "sourceCode" : "@Test\r\nvoid testSize() {\r\n    assertEquals(properties.length, set.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testAppend",
  "sourceCode" : "@Test\r\nvoid testAppend() {\r\n    // create the source configuration\r\n    final Configuration conf1 = new BaseConfiguration();\r\n    conf1.addProperty(\"key1\", \"value1\");\r\n    conf1.addProperty(\"key2\", \"value2\");\r\n    // create the target configuration\r\n    final Configuration conf2 = new BaseConfiguration();\r\n    conf2.addProperty(\"key1\", \"value3\");\r\n    conf2.addProperty(\"key2\", \"value4\");\r\n    // append the source configuration to the target configuration\r\n    ConfigurationUtils.append(conf1, conf2);\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(\"value3\");\r\n    expected.add(\"value1\");\r\n    assertEquals(expected, conf2.getList(\"key1\"));\r\n    expected = new ArrayList<>();\r\n    expected.add(\"value4\");\r\n    expected.add(\"value2\");\r\n    assertEquals(expected, conf2.getList(\"key2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testAsEventSourceNonSupportedEx",
  "sourceCode" : "/**\r\n * Tests asEventSource() if an exception is expected.\r\n */\r\n@Test\r\nvoid testAsEventSourceNonSupportedEx() {\r\n    assertThrows(ConfigurationRuntimeException.class, () -> ConfigurationUtils.asEventSource(this, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testAsEventSourceSupported",
  "sourceCode" : "/**\r\n * Tests asEventSource() if the passed in object implements this interface.\r\n */\r\n@Test\r\nvoid testAsEventSourceSupported() {\r\n    final XMLConfiguration src = new XMLConfiguration();\r\n    assertSame(src, ConfigurationUtils.asEventSource(src, true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testAsEventSourceUnsupportedMock",
  "sourceCode" : "/**\r\n * Tests asEventSource() if a mock object has to be returned.\r\n */\r\n@Test\r\nvoid testAsEventSourceUnsupportedMock() {\r\n    @SuppressWarnings(\"unchecked\")\r\n    final EventListener<ConfigurationEvent> cl = mock(EventListener.class);\r\n    final EventSource source = ConfigurationUtils.asEventSource(this, true);\r\n    source.addEventListener(ConfigurationEvent.ANY, cl);\r\n    assertFalse(source.removeEventListener(ConfigurationEvent.ANY, cl));\r\n    source.addEventListener(ConfigurationEvent.ANY, null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneConfiguration",
  "sourceCode" : "/**\r\n * Tests cloning a configuration that supports this operation.\r\n */\r\n@Test\r\nvoid testCloneConfiguration() {\r\n    final BaseHierarchicalConfiguration conf = new BaseHierarchicalConfiguration();\r\n    conf.addProperty(\"test\", \"yes\");\r\n    final BaseHierarchicalConfiguration copy = (BaseHierarchicalConfiguration) ConfigurationUtils.cloneConfiguration(conf);\r\n    assertNotSame(conf, copy);\r\n    assertEquals(\"yes\", copy.getString(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneConfigurationNotSupported",
  "sourceCode" : "/**\r\n * Tests cloning a configuration that does not support this operation. This should cause an exception.\r\n */\r\n@Test\r\nvoid testCloneConfigurationNotSupported() {\r\n    final Configuration myNonCloneableConfig = new NonCloneableConfiguration();\r\n    assertThrows(ConfigurationRuntimeException.class, () -> ConfigurationUtils.cloneConfiguration(myNonCloneableConfig));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneConfigurationNull",
  "sourceCode" : "/**\r\n * Tests cloning a <strong>null</strong> configuration.\r\n */\r\n@Test\r\nvoid testCloneConfigurationNull() {\r\n    assertNull(ConfigurationUtils.cloneConfiguration(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneIfPossibleError",
  "sourceCode" : "/**\r\n * Tests whether errors are handled correctly by cloneIfPossible().\r\n */\r\n@Test\r\nvoid testCloneIfPossibleError() {\r\n    final XMLBuilderParametersImpl params = new XMLBuilderParametersImpl() {\r\n\r\n        @Override\r\n        public XMLBuilderParametersImpl clone() {\r\n            throw new ConfigurationRuntimeException();\r\n        }\r\n    };\r\n    assertSame(params, ConfigurationUtils.cloneIfPossible(params));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneIfPossibleNotSupported",
  "sourceCode" : "/**\r\n * Tests cloneIfPossible() if the passed in object does not support cloning.\r\n */\r\n@Test\r\nvoid testCloneIfPossibleNotSupported() {\r\n    final Long value = 20130116221714L;\r\n    assertSame(value, ConfigurationUtils.cloneIfPossible(value));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneIfPossibleNull",
  "sourceCode" : "/**\r\n * Tests whether cloneIfPossible() can handle null parameters.\r\n */\r\n@Test\r\nvoid testCloneIfPossibleNull() {\r\n    assertNull(ConfigurationUtils.cloneIfPossible(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneIfPossibleSupported",
  "sourceCode" : "/**\r\n * Tests whether an object can be cloned which supports cloning.\r\n */\r\n@Test\r\nvoid testCloneIfPossibleSupported() {\r\n    final XMLBuilderParametersImpl params = new XMLBuilderParametersImpl();\r\n    params.setPublicID(\"testID\");\r\n    params.setSchemaValidation(true);\r\n    final XMLBuilderParametersImpl clone = (XMLBuilderParametersImpl) ConfigurationUtils.cloneIfPossible(params);\r\n    assertNotSame(params, clone);\r\n    final Map<String, Object> map = clone.getParameters();\r\n    for (final Map.Entry<String, Object> e : params.getParameters().entrySet()) {\r\n        if (!e.getKey().startsWith(\"config-\")) {\r\n            assertEquals(e.getValue(), map.get(e.getKey()), \"Wrong value for field \" + e.getKey());\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneSynchronizerClone",
  "sourceCode" : "/**\r\n * Tests whether a Synchronizer can be cloned using its clone() method.\r\n */\r\n@Test\r\nvoid testCloneSynchronizerClone() {\r\n    final CloneableSynchronizer sync = new CloneableSynchronizer(false);\r\n    final CloneableSynchronizer sync2 = (CloneableSynchronizer) ConfigurationUtils.cloneSynchronizer(sync);\r\n    assertTrue(sync2.isCloned());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneSynchronizerFailed",
  "sourceCode" : "/**\r\n * Tests cloneSynchronizer() if the argument cannot be cloned.\r\n */\r\n@Test\r\nvoid testCloneSynchronizerFailed() {\r\n    final NonCloneableSynchronizer synchronizer = new NonCloneableSynchronizer();\r\n    assertThrows(ConfigurationRuntimeException.class, () -> ConfigurationUtils.cloneSynchronizer(synchronizer));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneSynchronizerNewInstance",
  "sourceCode" : "/**\r\n * Tests whether a new Synchronizer can be created using reflection.\r\n */\r\n@Test\r\nvoid testCloneSynchronizerNewInstance() {\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    final SynchronizerTestImpl sync2 = (SynchronizerTestImpl) ConfigurationUtils.cloneSynchronizer(sync);\r\n    assertNotNull(sync2);\r\n    assertNotSame(sync, sync2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneSynchronizerNoOp",
  "sourceCode" : "/**\r\n * Tests whether the NoOpSyhnchronizer can be cloned.\r\n */\r\n@Test\r\nvoid testCloneSynchronizerNoOp() {\r\n    assertSame(NoOpSynchronizer.INSTANCE, ConfigurationUtils.cloneSynchronizer(NoOpSynchronizer.INSTANCE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCloneSynchronizerNull",
  "sourceCode" : "/**\r\n * Tries to clone a null Synchronizer.\r\n */\r\n@Test\r\nvoid testCloneSynchronizerNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> ConfigurationUtils.cloneSynchronizer(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertHierarchicalToHierarchical",
  "sourceCode" : "/**\r\n * Tests converting a configuration into a hierarchical one that is already hierarchical.\r\n */\r\n@Test\r\nvoid testConvertHierarchicalToHierarchical() {\r\n    final Configuration conf = new BaseHierarchicalConfiguration();\r\n    conf.addProperty(\"test\", \"yes\");\r\n    assertSame(conf, ConfigurationUtils.convertToHierarchical(conf));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertHierarchicalToHierarchicalEngine",
  "sourceCode" : "/**\r\n * Tests converting an already hierarchical configuration using an expression engine. The new engine should be set.\r\n */\r\n@Test\r\nvoid testConvertHierarchicalToHierarchicalEngine() {\r\n    final BaseHierarchicalConfiguration hc = new BaseHierarchicalConfiguration();\r\n    final ExpressionEngine engine = new DefaultExpressionEngine(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS);\r\n    assertSame(hc, ConfigurationUtils.convertToHierarchical(hc, engine));\r\n    assertSame(engine, hc.getExpressionEngine());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertHierarchicalToHierarchicalNullEngine",
  "sourceCode" : "/**\r\n * Tests converting an already hierarchical configuration using a null expression engine. In this case the expression\r\n * engine of the configuration should not be touched.\r\n */\r\n@Test\r\nvoid testConvertHierarchicalToHierarchicalNullEngine() {\r\n    final BaseHierarchicalConfiguration hc = new BaseHierarchicalConfiguration();\r\n    final ExpressionEngine engine = new DefaultExpressionEngine(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS);\r\n    hc.setExpressionEngine(engine);\r\n    assertSame(hc, ConfigurationUtils.convertToHierarchical(hc, null));\r\n    assertSame(engine, hc.getExpressionEngine());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertNullToHierarchical",
  "sourceCode" : "/**\r\n * Tests converting a null configuration to a hierarchical one. The result should be null, too.\r\n */\r\n@Test\r\nvoid testConvertNullToHierarchical() {\r\n    assertNull(ConfigurationUtils.convertToHierarchical(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertToHierarchical",
  "sourceCode" : "/**\r\n * Tests converting a configuration into a hierarchical one.\r\n */\r\n@Test\r\nvoid testConvertToHierarchical() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    for (int i = 0; i < 10; i++) {\r\n        conf.addProperty(\"test\" + i, \"value\" + i);\r\n        conf.addProperty(\"test.list\", \"item\" + i);\r\n    }\r\n    final BaseHierarchicalConfiguration hc = (BaseHierarchicalConfiguration) ConfigurationUtils.convertToHierarchical(conf);\r\n    for (final Iterator<String> it = conf.getKeys(); it.hasNext(); ) {\r\n        final String key = it.next();\r\n        assertEquals(conf.getProperty(key), hc.getProperty(key), \"Wrong value for key \" + key);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertToHierarchicalDelimiters",
  "sourceCode" : "/**\r\n * Tests converting a configuration into a hierarchical one if some of its properties contain escaped list delimiter\r\n * characters.\r\n */\r\n@Test\r\nvoid testConvertToHierarchicalDelimiters() {\r\n    final BaseConfiguration conf = new BaseConfiguration();\r\n    conf.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    conf.addProperty(\"test.key\", \"1\\\\,2\\\\,3\");\r\n    assertEquals(\"1,2,3\", conf.getString(\"test.key\"));\r\n    final HierarchicalConfiguration<?> hc = ConfigurationUtils.convertToHierarchical(conf);\r\n    assertEquals(\"1,2,3\", hc.getString(\"test.key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertToHierarchicalEngine",
  "sourceCode" : "/**\r\n * Tests converting a configuration to a hierarchical one using a specific expression engine.\r\n */\r\n@Test\r\nvoid testConvertToHierarchicalEngine() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    conf.addProperty(\"test(a)\", Boolean.TRUE);\r\n    conf.addProperty(\"test(b)\", Boolean.FALSE);\r\n    final DefaultExpressionEngine engine = new DefaultExpressionEngine(new DefaultExpressionEngineSymbols.Builder(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS).setIndexStart(\"[\").setIndexEnd(\"]\").create());\r\n    final HierarchicalConfiguration<?> hc = ConfigurationUtils.convertToHierarchical(conf, engine);\r\n    assertTrue(hc.getBoolean(\"test(a)\"));\r\n    assertFalse(hc.getBoolean(\"test(b)\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertToHierarchicalMultiValues",
  "sourceCode" : "/**\r\n * Tests converting a configuration to a hierarchical one that contains a property with multiple values. This test is\r\n * related to CONFIGURATION-346.\r\n */\r\n@Test\r\nvoid testConvertToHierarchicalMultiValues() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    config.addProperty(\"test\", \"1,2,3\");\r\n    final HierarchicalConfiguration<?> hc = ConfigurationUtils.convertToHierarchical(config);\r\n    assertEquals(1, hc.getInt(\"test(0)\"));\r\n    assertEquals(2, hc.getInt(\"test(1)\"));\r\n    assertEquals(3, hc.getInt(\"test(2)\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testConvertToHierarchicalOrderOfProperties",
  "sourceCode" : "/**\r\n * Tests that the structure of the resulting hierarchical configuration does not depend on the order of properties in\r\n * the source configuration. This test is related to CONFIGURATION-604.\r\n */\r\n@Test\r\nvoid testConvertToHierarchicalOrderOfProperties() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    config.addProperty(\"x.y.z\", true);\r\n    config.addProperty(\"x.y\", true);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final HierarchicalConfiguration<ImmutableNode> hc = (HierarchicalConfiguration<ImmutableNode>) ConfigurationUtils.convertToHierarchical(config);\r\n    final ImmutableNode rootNode = hc.getNodeModel().getNodeHandler().getRootNode();\r\n    final ImmutableNode nodeX = rootNode.getChildren().get(0);\r\n    assertEquals(1, nodeX.getChildren().size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testCopy",
  "sourceCode" : "@Test\r\nvoid testCopy() {\r\n    // create the source configuration\r\n    final Configuration conf1 = new BaseConfiguration();\r\n    conf1.addProperty(\"key1\", \"value1\");\r\n    conf1.addProperty(\"key2\", \"value2\");\r\n    // create the target configuration\r\n    final Configuration conf2 = new BaseConfiguration();\r\n    conf2.addProperty(\"key1\", \"value3\");\r\n    conf2.addProperty(\"key2\", \"value4\");\r\n    // copy the source configuration into the target configuration\r\n    ConfigurationUtils.copy(conf1, conf2);\r\n    assertEquals(\"value1\", conf2.getProperty(\"key1\"));\r\n    assertEquals(\"value2\", conf2.getProperty(\"key2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testEnableRuntimeExceptions",
  "sourceCode" : "/**\r\n * Tests whether runtime exceptions can be enabled.\r\n */\r\n@Test\r\nvoid testEnableRuntimeExceptions() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration() {\r\n\r\n        @Override\r\n        protected void addPropertyDirect(final String key, final Object value) {\r\n            // always simulate an exception\r\n            fireError(ConfigurationErrorEvent.WRITE, ConfigurationEvent.ADD_PROPERTY, key, value, new RuntimeException(\"A faked exception!\"));\r\n        }\r\n    };\r\n    config.clearErrorListeners();\r\n    ConfigurationUtils.enableRuntimeExceptions(config);\r\n    assertThrows(ConfigurationRuntimeException.class, () -> config.addProperty(\"test\", \"testValue\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testEnableRuntimeExceptionsInvalid",
  "sourceCode" : "/**\r\n * Tries to enable runtime exceptions for a configuration that does not inherit from EventSource. This should cause an\r\n * exception.\r\n */\r\n@Test\r\nvoid testEnableRuntimeExceptionsInvalid() {\r\n    final Configuration c = mock(Configuration.class);\r\n    assertThrows(IllegalArgumentException.class, () -> ConfigurationUtils.enableRuntimeExceptions(c));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testEnableRuntimeExceptionsNull",
  "sourceCode" : "/**\r\n * Tries to enable runtime exceptions for a null configuration. This should cause an exception.\r\n */\r\n@Test\r\nvoid testEnableRuntimeExceptionsNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> ConfigurationUtils.enableRuntimeExceptions(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testLoadClassCCLNotFound",
  "sourceCode" : "/**\r\n * Tests whether a class can be loaded if it is not found by the CCL.\r\n */\r\n@Test\r\nvoid testLoadClassCCLNotFound() throws ClassNotFoundException {\r\n    Thread.currentThread().setContextClassLoader(new ClassLoader() {\r\n\r\n        @Override\r\n        public Class<?> loadClass(final String name) throws ClassNotFoundException {\r\n            throw new ClassNotFoundException(name);\r\n        }\r\n    });\r\n    assertEquals(CLS_NAME, ConfigurationUtils.loadClass(CLS_NAME).getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testLoadClassCCLNull",
  "sourceCode" : "/**\r\n * Tests whether a class can be loaded if there is no CCL.\r\n */\r\n@Test\r\nvoid testLoadClassCCLNull() throws ClassNotFoundException {\r\n    Thread.currentThread().setContextClassLoader(null);\r\n    assertEquals(CLS_NAME, ConfigurationUtils.loadClass(CLS_NAME).getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testLoadClassFromCCL",
  "sourceCode" : "/**\r\n * Tests whether a class can be loaded from CCL.\r\n */\r\n@Test\r\nvoid testLoadClassFromCCL() throws ClassNotFoundException {\r\n    Thread.currentThread().setContextClassLoader(getClass().getClassLoader());\r\n    assertEquals(CLS_NAME, ConfigurationUtils.loadClass(CLS_NAME).getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testLoadClassNoExFound",
  "sourceCode" : "/**\r\n * Tests loadClassNoEx() if the class can be resolved.\r\n */\r\n@Test\r\nvoid testLoadClassNoExFound() {\r\n    assertEquals(CLS_NAME, ConfigurationUtils.loadClassNoEx(CLS_NAME).getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testLoadClassNoExNotFound",
  "sourceCode" : "/**\r\n * Tests loadClassNoEx() if the class cannot be resolved.\r\n */\r\n@Test\r\nvoid testLoadClassNoExNotFound() {\r\n    assertThrows(ConfigurationRuntimeException.class, () -> ConfigurationUtils.loadClassNoEx(\"a non existing class!\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testLoadClassNotFound",
  "sourceCode" : "/**\r\n * Tests the behavior of loadClass() for a non-existing class.\r\n */\r\n@Test\r\nvoid testLoadClassNotFound() {\r\n    assertThrows(ClassNotFoundException.class, () -> ConfigurationUtils.loadClass(\"a non existing class!\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestConfigurationUtils.java",
  "methodName" : "testToString",
  "sourceCode" : "@Test\r\nvoid testToString() {\r\n    final Configuration config = new BaseConfiguration();\r\n    final String lineSeparator = System.lineSeparator();\r\n    assertEquals(\"\", ConfigurationUtils.toString(config));\r\n    config.setProperty(\"one\", \"1\");\r\n    assertEquals(\"one=1\", ConfigurationUtils.toString(config));\r\n    config.setProperty(\"two\", \"2\");\r\n    assertEquals(\"one=1\" + lineSeparator + \"two=2\", ConfigurationUtils.toString(config));\r\n    config.clearProperty(\"one\");\r\n    assertEquals(\"two=2\", ConfigurationUtils.toString(config));\r\n    config.setProperty(\"one\", \"1\");\r\n    assertEquals(\"two=2\" + lineSeparator + \"one=1\", ConfigurationUtils.toString(config));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "containsValueInternal",
  "sourceCode" : "@Test\r\nvoid containsValueInternal() throws ConfigurationException {\r\n    final DatabaseConfiguration config = helper.setUpConfig();\r\n    config.addPropertyDirect(\"test\", \"test1\");\r\n    assertTrue(config.containsValueInternal(\"test1\"));\r\n    assertFalse(config.containsValue(\"test9999\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testAddNonStringProperty",
  "sourceCode" : "@Test\r\nvoid testAddNonStringProperty() throws ConfigurationException {\r\n    final DatabaseConfiguration config = helper.setUpConfig();\r\n    config.addPropertyDirect(\"boolean\", Boolean.TRUE);\r\n    assertTrue(config.containsKey(\"boolean\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testAddPropertyDirectCommit",
  "sourceCode" : "/**\r\n * Tests whether a commit is performed after a property was added.\r\n */\r\n@Test\r\nvoid testAddPropertyDirectCommit() throws ConfigurationException {\r\n    helper.setAutoCommit(false);\r\n    final DatabaseConfiguration config = helper.setUpConfig();\r\n    config.addPropertyDirect(\"key\", \"value\");\r\n    assertTrue(config.containsKey(\"key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testAddPropertyDirectMultiple",
  "sourceCode" : "@Test\r\nvoid testAddPropertyDirectMultiple() throws ConfigurationException {\r\n    final DatabaseConfiguration config = helper.setUpMultiConfig();\r\n    config.addPropertyDirect(\"key\", \"value\");\r\n    assertTrue(config.containsKey(\"key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testAddPropertyDirectSingle",
  "sourceCode" : "@Test\r\nvoid testAddPropertyDirectSingle() throws ConfigurationException {\r\n    final DatabaseConfiguration config = helper.setUpConfig();\r\n    config.addPropertyDirect(\"key\", \"value\");\r\n    assertTrue(config.containsKey(\"key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testAddPropertyError",
  "sourceCode" : "/**\r\n * Tests handling of errors in addPropertyDirect().\r\n */\r\n@Test\r\nvoid testAddPropertyError() throws ConfigurationException {\r\n    setUpErrorConfig().addProperty(\"key1\", \"value\");\r\n    checkErrorListener(ConfigurationErrorEvent.WRITE, ConfigurationEvent.ADD_PROPERTY, \"key1\", \"value\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testAddWithDelimiter",
  "sourceCode" : "/**\r\n * Tests adding a property containing the list delimiter. When this property is queried multiple values should be\r\n * returned.\r\n */\r\n@Test\r\nvoid testAddWithDelimiter() throws ConfigurationException {\r\n    final DatabaseConfiguration config = setUpConfig();\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(';'));\r\n    config.addProperty(\"keyList\", \"1;2;3\");\r\n    final String[] values = config.getStringArray(\"keyList\");\r\n    assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, values);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearCommit",
  "sourceCode" : "/**\r\n * Tests whether a commit is performed after a clear operation.\r\n */\r\n@Test\r\nvoid testClearCommit() throws ConfigurationException {\r\n    helper.setAutoCommit(false);\r\n    final Configuration config = helper.setUpConfig();\r\n    config.clear();\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearError",
  "sourceCode" : "/**\r\n * Tests handling of errors in clear().\r\n */\r\n@Test\r\nvoid testClearError() throws ConfigurationException {\r\n    setUpErrorConfig().clear();\r\n    checkErrorListener(ConfigurationErrorEvent.WRITE, ConfigurationEvent.CLEAR, null, null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearMultiple",
  "sourceCode" : "@Test\r\nvoid testClearMultiple() throws ConfigurationException {\r\n    final Configuration config = helper.setUpMultiConfig();\r\n    config.clear();\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearPropertyCommit",
  "sourceCode" : "/**\r\n * Tests whether a commit is performed after a property was cleared.\r\n */\r\n@Test\r\nvoid testClearPropertyCommit() throws ConfigurationException {\r\n    helper.setAutoCommit(false);\r\n    final Configuration config = helper.setUpConfig();\r\n    config.clearProperty(\"key1\");\r\n    assertFalse(config.containsKey(\"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearPropertyError",
  "sourceCode" : "/**\r\n * Tests handling of errors in clearProperty().\r\n */\r\n@Test\r\nvoid testClearPropertyError() throws ConfigurationException {\r\n    setUpErrorConfig().clearProperty(\"key1\");\r\n    checkErrorListener(ConfigurationErrorEvent.WRITE, ConfigurationEvent.CLEAR_PROPERTY, \"key1\", null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearPropertyMultiple",
  "sourceCode" : "@Test\r\nvoid testClearPropertyMultiple() throws ConfigurationException {\r\n    final Configuration config = helper.setUpMultiConfig();\r\n    config.clearProperty(\"key1\");\r\n    assertFalse(config.containsKey(\"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearPropertyMultipleOtherConfig",
  "sourceCode" : "/**\r\n * Tests that another configuration is not affected when clearing properties.\r\n */\r\n@Test\r\nvoid testClearPropertyMultipleOtherConfig() throws ConfigurationException {\r\n    final DatabaseConfiguration config = helper.setUpMultiConfig();\r\n    final DatabaseConfiguration config2 = helper.setUpMultiConfig(DatabaseConfiguration.class, CONFIG_NAME2);\r\n    config2.addProperty(\"key1\", \"some test\");\r\n    config.clearProperty(\"key1\");\r\n    assertFalse(config.containsKey(\"key1\"));\r\n    assertTrue(config2.containsKey(\"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearPropertySingle",
  "sourceCode" : "@Test\r\nvoid testClearPropertySingle() throws ConfigurationException {\r\n    final Configuration config = helper.setUpConfig();\r\n    config.clearProperty(\"key1\");\r\n    assertFalse(config.containsKey(\"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearSingle",
  "sourceCode" : "@Test\r\nvoid testClearSingle() throws ConfigurationException {\r\n    final Configuration config = helper.setUpConfig();\r\n    config.clear();\r\n    assertTrue(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testClearSubset",
  "sourceCode" : "@Test\r\nvoid testClearSubset() throws ConfigurationException {\r\n    final Configuration config = setUpConfig();\r\n    final Configuration subset = config.subset(\"key1\");\r\n    subset.clear();\r\n    assertTrue(subset.isEmpty());\r\n    assertFalse(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testContainsKeyError",
  "sourceCode" : "/**\r\n * Tests handling of errors in containsKey().\r\n */\r\n@Test\r\nvoid testContainsKeyError() throws ConfigurationException {\r\n    assertFalse(setUpErrorConfig().containsKey(\"key1\"));\r\n    checkErrorListener(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, \"key1\", null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testContainsKeyMultiple",
  "sourceCode" : "@Test\r\nvoid testContainsKeyMultiple() throws ConfigurationException {\r\n    final Configuration config = helper.setUpMultiConfig();\r\n    assertTrue(config.containsKey(\"key1\"));\r\n    assertTrue(config.containsKey(\"key2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testContainsKeySingle",
  "sourceCode" : "@Test\r\nvoid testContainsKeySingle() throws ConfigurationException {\r\n    final Configuration config = setUpConfig();\r\n    assertTrue(config.containsKey(\"key1\"));\r\n    assertTrue(config.containsKey(\"key2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Test\r\nvoid testContainsValue() throws ConfigurationException {\r\n    final DatabaseConfiguration config = helper.setUpConfig();\r\n    config.addPropertyDirect(\"test\", \"test1\");\r\n    assertTrue(config.containsValue(\"test1\"));\r\n    assertFalse(config.containsValue(\"test9999\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testExtractPropertyValueCLOB",
  "sourceCode" : "/**\r\n * Tests whether a CLOB as a property value is handled correctly.\r\n */\r\n@Test\r\nvoid testExtractPropertyValueCLOB() throws ConfigurationException, SQLException {\r\n    final ResultSet rs = mock(ResultSet.class);\r\n    final Clob clob = mock(Clob.class);\r\n    final String content = \"This is the content of the test CLOB!\";\r\n    when(rs.getObject(DatabaseConfigurationTestHelper.COL_VALUE)).thenReturn(clob);\r\n    when(clob.length()).thenReturn(Long.valueOf(content.length()));\r\n    when(clob.getSubString(1, content.length())).thenReturn(content);\r\n    final DatabaseConfiguration config = helper.setUpConfig();\r\n    assertEquals(content, config.extractPropertyValue(rs));\r\n    verify(rs).getObject(DatabaseConfigurationTestHelper.COL_VALUE);\r\n    verify(clob).length();\r\n    verify(clob).getSubString(1, content.length());\r\n    verifyNoMoreInteractions(rs, clob);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testExtractPropertyValueCLOBEmpty",
  "sourceCode" : "/**\r\n * Tests whether an empty CLOB is correctly handled by extractPropertyValue().\r\n */\r\n@Test\r\nvoid testExtractPropertyValueCLOBEmpty() throws ConfigurationException, SQLException {\r\n    final ResultSet rs = mock(ResultSet.class);\r\n    final Clob clob = mock(Clob.class);\r\n    when(rs.getObject(DatabaseConfigurationTestHelper.COL_VALUE)).thenReturn(clob);\r\n    when(clob.length()).thenReturn(0L);\r\n    final DatabaseConfiguration config = helper.setUpConfig();\r\n    assertEquals(\"\", config.extractPropertyValue(rs));\r\n    verify(rs).getObject(DatabaseConfigurationTestHelper.COL_VALUE);\r\n    verify(clob).length();\r\n    verifyNoMoreInteractions(rs, clob);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "@Test\r\nvoid testGetKeys() throws ConfigurationException {\r\n    final DatabaseBuilderParameters params = helper.setUpDefaultParameters().setTable(\"configurationList\");\r\n    final Configuration config1 = helper.createConfiguration(DatabaseConfiguration.class, params);\r\n    final Iterator<String> i = config1.getKeys();\r\n    assertTrue(i.hasNext());\r\n    final Object key = i.next();\r\n    assertEquals(\"key3\", key.toString());\r\n    assertFalse(i.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetKeysError",
  "sourceCode" : "/**\r\n * Tests handling of errors in getKeys().\r\n */\r\n@Test\r\nvoid testGetKeysError() throws ConfigurationException {\r\n    final Iterator<String> it = setUpErrorConfig().getKeys();\r\n    checkErrorListener(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, null, null);\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetKeysInternalNoDatasource",
  "sourceCode" : "@Test\r\nvoid testGetKeysInternalNoDatasource() throws Exception {\r\n    ConfigurationUtils.toString(new DatabaseConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetKeysMultiple",
  "sourceCode" : "@Test\r\nvoid testGetKeysMultiple() throws ConfigurationException {\r\n    final Configuration config = helper.setUpMultiConfig();\r\n    final Iterator<String> it = config.getKeys();\r\n    assertEquals(\"key1\", it.next());\r\n    assertEquals(\"key2\", it.next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetKeysSingle",
  "sourceCode" : "@Test\r\nvoid testGetKeysSingle() throws ConfigurationException {\r\n    final Configuration config = setUpConfig();\r\n    final Iterator<String> it = config.getKeys();\r\n    assertEquals(\"key1\", it.next());\r\n    assertEquals(\"key2\", it.next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetList",
  "sourceCode" : "@Test\r\nvoid testGetList() throws ConfigurationException {\r\n    final DatabaseBuilderParameters params = helper.setUpDefaultParameters().setTable(\"configurationList\");\r\n    final Configuration config1 = helper.createConfiguration(DatabaseConfiguration.class, params);\r\n    final List<Object> list = config1.getList(\"key3\");\r\n    assertEquals(3, list.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetListWithDelimiter",
  "sourceCode" : "/**\r\n * Tests obtaining a property as list whose value contains the list delimiter. Multiple values should be returned.\r\n */\r\n@Test\r\nvoid testGetListWithDelimiter() throws ConfigurationException {\r\n    final DatabaseConfiguration config = setUpConfig();\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(';'));\r\n    final List<Object> values = config.getList(\"keyMulti\");\r\n    assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), values);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetListWithDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests obtaining a property whose value contains the list delimiter when delimiter parsing is disabled.\r\n */\r\n@Test\r\nvoid testGetListWithDelimiterParsingDisabled() throws ConfigurationException {\r\n    final DatabaseConfiguration config = setUpConfig();\r\n    assertEquals(\"a;b;c\", config.getString(\"keyMulti\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetPropertyDirectMultiple",
  "sourceCode" : "@Test\r\nvoid testGetPropertyDirectMultiple() throws ConfigurationException {\r\n    final Configuration config = helper.setUpMultiConfig();\r\n    assertEquals(\"value1\", config.getProperty(\"key1\"));\r\n    assertEquals(\"value2\", config.getProperty(\"key2\"));\r\n    assertNull(config.getProperty(\"key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetPropertyDirectSingle",
  "sourceCode" : "@Test\r\nvoid testGetPropertyDirectSingle() throws ConfigurationException {\r\n    final Configuration config = setUpConfig();\r\n    assertEquals(\"value1\", config.getProperty(\"key1\"));\r\n    assertEquals(\"value2\", config.getProperty(\"key2\"));\r\n    assertNull(config.getProperty(\"key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testGetPropertyError",
  "sourceCode" : "/**\r\n * Tests handling of errors in getProperty().\r\n */\r\n@Test\r\nvoid testGetPropertyError() throws ConfigurationException {\r\n    setUpErrorConfig().getProperty(\"key1\");\r\n    checkErrorListener(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, \"key1\", null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testIsEmptyError",
  "sourceCode" : "/**\r\n * Tests handling of errors in isEmpty().\r\n */\r\n@Test\r\nvoid testIsEmptyError() throws ConfigurationException {\r\n    assertTrue(setUpErrorConfig().isEmpty());\r\n    checkErrorListener(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, null, null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testIsEmptyMultiple",
  "sourceCode" : "@Test\r\nvoid testIsEmptyMultiple() throws ConfigurationException {\r\n    final Configuration config1 = helper.setUpMultiConfig();\r\n    assertFalse(config1.isEmpty());\r\n    final Configuration config2 = helper.setUpMultiConfig(DatabaseConfiguration.class, \"testIsEmpty\");\r\n    assertTrue(config2.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testIsEmptySingle",
  "sourceCode" : "@Test\r\nvoid testIsEmptySingle() throws ConfigurationException {\r\n    final Configuration config1 = setUpConfig();\r\n    assertFalse(config1.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testLogErrorListener",
  "sourceCode" : "/**\r\n * Tests whether the configuration has already an error listener registered that is used for logging.\r\n */\r\n@Test\r\nvoid testLogErrorListener() throws ConfigurationException {\r\n    final DatabaseConfiguration config = helper.setUpConfig();\r\n    assertEquals(1, config.getEventListeners(ConfigurationErrorEvent.ANY).size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDatabaseConfiguration.java",
  "methodName" : "testSetPropertyWithDelimiter",
  "sourceCode" : "/**\r\n * Tests setProperty() if the property value contains the list delimiter.\r\n */\r\n@Test\r\nvoid testSetPropertyWithDelimiter() throws ConfigurationException {\r\n    final DatabaseConfiguration config = helper.setUpMultiConfig();\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(';'));\r\n    config.setProperty(\"keyList\", \"1;2;3\");\r\n    final String[] values = config.getStringArray(\"keyList\");\r\n    assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, values);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "/**\r\n * Tests whether properties can be cleared.\r\n */\r\n@Test\r\nvoid testClearProperty() {\r\n    final String key = \"test.property\";\r\n    conf.addProperty(key, \"someValue\");\r\n    conf.clearProperty(key);\r\n    assertFalse(conf.containsKey(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testClearPropertyDirect",
  "sourceCode" : "/**\r\n * Tests the implementation of clearPropertyDirect().\r\n */\r\n@Test\r\nvoid testClearPropertyDirect() {\r\n    final String key = \"test.property\";\r\n    conf.addProperty(key, \"someValue\");\r\n    conf.clearPropertyDirect(key);\r\n    assertFalse(conf.containsKey(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testClearPropertyDirectNoAbstractConf",
  "sourceCode" : "/**\r\n * Tests clearPropertyDirect() if the wrapped configuration does not extend AbstractConfiguration.\r\n */\r\n@Test\r\nvoid testClearPropertyDirectNoAbstractConf() {\r\n    final Configuration wrapped = mock(Configuration.class);\r\n    final String key = \"test.property\";\r\n    conf = new DataConfiguration(wrapped);\r\n    conf.clearPropertyDirect(key);\r\n    verify(wrapped).clearProperty(key);\r\n    verifyNoMoreInteractions(wrapped);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testContainsKey",
  "sourceCode" : "@Test\r\nvoid testContainsKey() {\r\n    final Configuration baseconf = new BaseConfiguration();\r\n    final DataConfiguration conf = new DataConfiguration(baseconf);\r\n    assertFalse(conf.containsKey(\"foo\"));\r\n    baseconf.setProperty(\"foo\", \"bar\");\r\n    assertTrue(conf.containsKey(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Test\r\nvoid testContainsValue() {\r\n    final Configuration config = conf.getConfiguration();\r\n    assertFalse(config.containsValue(null));\r\n    assertTrue(config.containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testConversionException",
  "sourceCode" : "@Test\r\nvoid testConversionException() throws Exception {\r\n    conf.addProperty(\"key1\", new Object());\r\n    conf.addProperty(\"key2\", \"xxxxxx\");\r\n    assertThrows(ConversionException.class, () -> conf.getBooleanArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBooleanArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBooleanList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBooleanList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getByteArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getByteArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getByteList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getByteList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getShortArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getShortArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getShortList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getShortList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getIntArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getIntArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getIntegerList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getIntegerList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getLongArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getLongArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getLongList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getLongList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getFloatArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getFloatArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getFloatList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getFloatList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getDoubleArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getDoubleArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getDoubleList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getDoubleList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBigIntegerArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBigIntegerArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBigIntegerList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBigIntegerList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBigDecimalArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBigDecimalArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBigDecimalList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getBigDecimalList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getURLArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getURLArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getURLList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getURLList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getLocaleArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getLocaleArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getLocaleList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getLocaleList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getColorArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getColorArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getColorList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getColorList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getDateArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getDateArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getDate(\"key1\", DATE_PATTERN));\r\n    assertThrows(ConversionException.class, () -> conf.getDate(\"key2\", DATE_PATTERN));\r\n    assertThrows(ConversionException.class, () -> conf.getDateList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getDateList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getCalendar(\"key1\", DATE_PATTERN));\r\n    assertThrows(ConversionException.class, () -> conf.getCalendar(\"key2\", DATE_PATTERN));\r\n    assertThrows(ConversionException.class, () -> conf.getCalendarArray(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getCalendarArray(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.getCalendarList(\"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.getCalendarList(\"key2\"));\r\n    assertThrows(ConversionException.class, () -> conf.get(InetAddress.class, \"key1\"));\r\n    assertThrows(ConversionException.class, () -> conf.get(InternetAddress.class, \"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testConversionExceptionCause",
  "sourceCode" : "/**\r\n * Tests that the cause of a conversion exception is kept.\r\n */\r\n@Test\r\nvoid testConversionExceptionCause() {\r\n    final ConversionException cex = assertThrows(ConversionException.class, () -> conf.get(Integer.TYPE, \"uri.string\"));\r\n    assertInstanceOf(NumberFormatException.class, cex.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetArrayInvalidDefaultType",
  "sourceCode" : "@Test\r\nvoid testGetArrayInvalidDefaultType() {\r\n    assertThrows(IllegalArgumentException.class, () -> conf.getArray(Boolean.class, \"unknownkey\", new URL[] {}));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetBigDecimalArray",
  "sourceCode" : "@Test\r\nvoid testGetBigDecimalArray() {\r\n    // missing list\r\n    final BigDecimal[] defaultValue = { new BigDecimal(\"2\"), new BigDecimal(\"1\") };\r\n    assertArrayEquals(defaultValue, conf.getBigDecimalArray(\"bigdecimal.list\", defaultValue));\r\n    final BigDecimal[] expected = { new BigDecimal(\"1\"), new BigDecimal(\"2\") };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getBigDecimalArray(\"bigdecimal.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getBigDecimalArray(\"bigdecimal.list2\"));\r\n    // list of BigDecimal objects\r\n    assertArrayEquals(expected, conf.getBigDecimalArray(\"bigdecimal.list3\"));\r\n    // array of BigDecimal objects\r\n    assertArrayEquals(expected, conf.getBigDecimalArray(\"bigdecimal.list4\"));\r\n    // list of BigDecimal objects\r\n    assertArrayEquals(expected, conf.getBigDecimalArray(\"bigdecimal.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getBigDecimalArray(\"bigdecimal.list.interpolated\"));\r\n    // single BigDecimal values\r\n    assertArrayEquals(new BigDecimal[] { new BigDecimal(\"1\") }, conf.getBigDecimalArray(\"bigdecimal.string\"));\r\n    assertArrayEquals(new BigDecimal[] { new BigDecimal(\"1\") }, conf.getBigDecimalArray(\"bigdecimal.object\"));\r\n    // empty array\r\n    assertArrayEquals(new BigDecimal[] {}, conf.getBigDecimalArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetBigDecimalList",
  "sourceCode" : "@Test\r\nvoid testGetBigDecimalList() {\r\n    // missing list\r\n    assertNull(conf.getBigDecimalList(\"bigdecimal.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(new BigDecimal(\"1\"));\r\n    expected.add(new BigDecimal(\"2\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getBigDecimalList(\"bigdecimal.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getBigDecimalList(\"bigdecimal.list2\"));\r\n    // list of BigDecimal objects\r\n    assertEquals(expected, conf.getBigDecimalList(\"bigdecimal.list3\"));\r\n    // array of BigDecimal objects\r\n    assertEquals(expected, conf.getBigDecimalList(\"bigdecimal.list4\"));\r\n    // list of BigDecimal objects\r\n    assertEquals(expected, conf.getBigDecimalList(\"bigdecimal.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getBigDecimalList(\"bigdecimal.list.interpolated\"));\r\n    // single BigDecimal values\r\n    expected = new ArrayList<>();\r\n    expected.add(new BigDecimal(\"1\"));\r\n    assertEquals(expected, conf.getBigDecimalList(\"bigdecimal.string\"));\r\n    assertEquals(expected, conf.getBigDecimalList(\"bigdecimal.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getBigDecimalList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetBigIntegerArray",
  "sourceCode" : "@Test\r\nvoid testGetBigIntegerArray() {\r\n    // missing list\r\n    final BigInteger[] defaultValue = { new BigInteger(\"2\"), new BigInteger(\"1\") };\r\n    assertArrayEquals(defaultValue, conf.getBigIntegerArray(\"biginteger.list\", defaultValue));\r\n    final BigInteger[] expected = { new BigInteger(\"1\"), new BigInteger(\"2\") };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getBigIntegerArray(\"biginteger.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getBigIntegerArray(\"biginteger.list2\"));\r\n    // list of BigInteger objects\r\n    assertArrayEquals(expected, conf.getBigIntegerArray(\"biginteger.list3\"));\r\n    // array of BigInteger objects\r\n    assertArrayEquals(expected, conf.getBigIntegerArray(\"biginteger.list4\"));\r\n    // list of BigInteger objects\r\n    assertArrayEquals(expected, conf.getBigIntegerArray(\"biginteger.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getBigIntegerArray(\"biginteger.list.interpolated\"));\r\n    // single BigInteger values\r\n    assertArrayEquals(new BigInteger[] { new BigInteger(\"1\") }, conf.getBigIntegerArray(\"biginteger.string\"));\r\n    assertArrayEquals(new BigInteger[] { new BigInteger(\"1\") }, conf.getBigIntegerArray(\"biginteger.object\"));\r\n    // empty array\r\n    assertArrayEquals(new BigInteger[] {}, conf.getBigIntegerArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetBigIntegerList",
  "sourceCode" : "@Test\r\nvoid testGetBigIntegerList() {\r\n    // missing list\r\n    final List<BigInteger> bigIntegerList = conf.getBigIntegerList(\"biginteger.list\", null);\r\n    assertNull(bigIntegerList);\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(new BigInteger(\"1\"));\r\n    expected.add(new BigInteger(\"2\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getBigIntegerList(\"biginteger.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getBigIntegerList(\"biginteger.list2\"));\r\n    // list of BigInteger objects\r\n    assertEquals(expected, conf.getBigIntegerList(\"biginteger.list3\"));\r\n    // array of BigInteger objects\r\n    assertEquals(expected, conf.getBigIntegerList(\"biginteger.list4\"));\r\n    // list of BigInteger objects\r\n    assertEquals(expected, conf.getBigIntegerList(\"biginteger.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getBigIntegerList(\"biginteger.list.interpolated\"));\r\n    // single BigInteger values\r\n    expected = new ArrayList<>();\r\n    expected.add(new BigInteger(\"1\"));\r\n    assertEquals(expected, conf.getBigIntegerList(\"biginteger.string\"));\r\n    assertEquals(expected, conf.getBigIntegerList(\"biginteger.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getBigIntegerList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetBooleanArray",
  "sourceCode" : "@Test\r\nvoid testGetBooleanArray() {\r\n    // missing list\r\n    final boolean[] defaultValue = { false, true };\r\n    assertArrayEquals(defaultValue, conf.getBooleanArray(\"boolean.list\", defaultValue));\r\n    final boolean[] expected = { true, false };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getBooleanArray(\"boolean.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getBooleanArray(\"boolean.list2\"));\r\n    // list of Boolean objects\r\n    assertArrayEquals(expected, conf.getBooleanArray(\"boolean.list3\"));\r\n    // array of Boolean objects\r\n    assertArrayEquals(expected, conf.getBooleanArray(\"boolean.list4\"));\r\n    // array of boolean primitives\r\n    assertArrayEquals(expected, conf.getBooleanArray(\"boolean.list5\"));\r\n    // list of Boolean objects\r\n    assertArrayEquals(expected, conf.getBooleanArray(\"boolean.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getBooleanArray(\"boolean.list.interpolated\"));\r\n    // single boolean values\r\n    assertArrayEquals(new boolean[] { true }, conf.getBooleanArray(\"boolean.string\"));\r\n    assertArrayEquals(new boolean[] { true }, conf.getBooleanArray(\"boolean.object\"));\r\n    // empty array\r\n    assertArrayEquals(new boolean[] {}, conf.getBooleanArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetBooleanList",
  "sourceCode" : "@Test\r\nvoid testGetBooleanList() {\r\n    // missing list\r\n    assertNull(conf.getBooleanList(\"boolean.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Boolean.TRUE);\r\n    expected.add(Boolean.FALSE);\r\n    // list of strings\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.list2\"));\r\n    // list of Boolean objects\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.list3\"));\r\n    // array of Boolean objects\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.list4\"));\r\n    // array of boolean primitives\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.list5\"));\r\n    // list of Boolean objects\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.list.interpolated\"));\r\n    // single boolean values\r\n    expected = new ArrayList<>();\r\n    expected.add(Boolean.TRUE);\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.string\"));\r\n    assertEquals(expected, conf.getBooleanList(\"boolean.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getBooleanList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetByteArray",
  "sourceCode" : "@Test\r\nvoid testGetByteArray() {\r\n    // missing list\r\n    final byte[] defaultValue = { 1, 2 };\r\n    assertArrayEquals(defaultValue, conf.getByteArray(\"byte.list\", defaultValue));\r\n    final byte[] expected = { 1, 2 };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getByteArray(\"byte.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getByteArray(\"byte.list2\"));\r\n    // list of Byte objects\r\n    assertArrayEquals(expected, conf.getByteArray(\"byte.list3\"));\r\n    // array of Byte objects\r\n    assertArrayEquals(expected, conf.getByteArray(\"byte.list4\"));\r\n    // array of byte primitives\r\n    assertArrayEquals(expected, conf.getByteArray(\"byte.list5\"));\r\n    // list of Byte objects\r\n    assertArrayEquals(expected, conf.getByteArray(\"byte.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getByteArray(\"byte.list.interpolated\"));\r\n    // single byte values\r\n    assertArrayEquals(new byte[] { 1 }, conf.getByteArray(\"byte.string\"));\r\n    assertArrayEquals(new byte[] { 1 }, conf.getByteArray(\"byte.object\"));\r\n    // empty array\r\n    assertArrayEquals(new byte[] {}, conf.getByteArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetByteList",
  "sourceCode" : "@Test\r\nvoid testGetByteList() {\r\n    // missing list\r\n    assertNull(conf.getByteList(\"byte.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Byte.valueOf(\"1\"));\r\n    expected.add(Byte.valueOf(\"2\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getByteList(\"byte.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getByteList(\"byte.list2\"));\r\n    // list of Byte objects\r\n    assertEquals(expected, conf.getByteList(\"byte.list3\"));\r\n    // array of Byte objects\r\n    assertEquals(expected, conf.getByteList(\"byte.list4\"));\r\n    // array of byte primitives\r\n    assertEquals(expected, conf.getByteList(\"byte.list5\"));\r\n    // list of Byte objects\r\n    assertEquals(expected, conf.getByteList(\"byte.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getByteList(\"byte.list.interpolated\"));\r\n    // single byte values\r\n    expected = new ArrayList<>();\r\n    expected.add(Byte.valueOf(\"1\"));\r\n    assertEquals(expected, conf.getByteList(\"byte.string\"));\r\n    assertEquals(expected, conf.getByteList(\"byte.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getByteList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetCalendar",
  "sourceCode" : "@Test\r\nvoid testGetCalendar() throws Exception {\r\n    final DateFormat format = new SimpleDateFormat(DATE_PATTERN);\r\n    // missing Date\r\n    final Calendar defaultValue = Calendar.getInstance();\r\n    defaultValue.setTime(new Date());\r\n    assertEquals(conf.getCalendar(\"calendar\", defaultValue), defaultValue);\r\n    assertNull(conf.getCalendar(\"unknownkey\", DATE_PATTERN));\r\n    conf.setThrowExceptionOnMissing(true);\r\n    assertThrows(NoSuchElementException.class, () -> conf.getCalendar(\"unknownkey\", DATE_PATTERN));\r\n    final Calendar expected = Calendar.getInstance();\r\n    expected.setTime(format.parse(\"2004-01-01\"));\r\n    // Calendar string\r\n    assertEquals(expected, conf.getCalendar(\"calendar.string\"));\r\n    assertEquals(conf.getCalendar(\"calendar.string\", DATE_PATTERN), expected);\r\n    // Calendar object\r\n    assertEquals(expected, conf.getCalendar(\"calendar.object\"));\r\n    // Date object\r\n    assertEquals(expected, conf.getCalendar(\"date.object\"));\r\n    // interpolated value\r\n    assertEquals(expected, conf.getCalendar(\"calendar.string.interpolated\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetCalendarArray",
  "sourceCode" : "@Test\r\nvoid testGetCalendarArray() throws Exception {\r\n    final DateFormat format = new SimpleDateFormat(DATE_PATTERN);\r\n    final Date date1 = format.parse(\"2004-01-01\");\r\n    final Date date2 = format.parse(\"2004-12-31\");\r\n    final Calendar calendar1 = Calendar.getInstance();\r\n    calendar1.setTime(date1);\r\n    final Calendar calendar2 = Calendar.getInstance();\r\n    calendar2.setTime(date2);\r\n    // missing list\r\n    final Calendar[] defaultValue = { calendar2, calendar1 };\r\n    assertArrayEquals(defaultValue, conf.getCalendarArray(\"calendar.list\", defaultValue));\r\n    final Calendar[] expected = { calendar1, calendar2 };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getCalendarArray(\"calendar.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getCalendarArray(\"calendar.list2\"));\r\n    // list of Calendar objects\r\n    assertArrayEquals(expected, conf.getCalendarArray(\"calendar.list3\"));\r\n    // array of Calendar objects\r\n    assertArrayEquals(expected, conf.getCalendarArray(\"calendar.list4\"));\r\n    // list of Date objects\r\n    assertArrayEquals(expected, conf.getCalendarArray(\"calendar.list5\"));\r\n    // list of Calendar objects\r\n    assertArrayEquals(expected, conf.getCalendarArray(\"calendar.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getCalendarArray(\"calendar.list.interpolated\"));\r\n    // single Calendar values\r\n    assertArrayEquals(new Calendar[] { calendar1 }, conf.getCalendarArray(\"calendar.string\"));\r\n    assertArrayEquals(new Calendar[] { calendar1 }, conf.getCalendarArray(\"calendar.object\"));\r\n    // empty array\r\n    assertArrayEquals(new Calendar[] {}, conf.getCalendarArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetCalendarArrayWithFormat",
  "sourceCode" : "@Test\r\nvoid testGetCalendarArrayWithFormat() throws Exception {\r\n    final DateFormat format = new SimpleDateFormat(\"MM/dd/yyyy\");\r\n    final Date date1 = format.parse(\"01/01/2004\");\r\n    final Date date2 = format.parse(\"12/31/2004\");\r\n    final Calendar calendar1 = Calendar.getInstance();\r\n    calendar1.setTime(date1);\r\n    final Calendar calendar2 = Calendar.getInstance();\r\n    calendar2.setTime(date2);\r\n    final Calendar[] expected = { calendar1, calendar2 };\r\n    conf.addProperty(\"calendar.format\", \"01/01/2004\");\r\n    conf.addProperty(\"calendar.format\", \"12/31/2004\");\r\n    assertArrayEquals(expected, conf.getCalendarArray(\"calendar.format\", \"MM/dd/yyyy\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetCalendarList",
  "sourceCode" : "@Test\r\nvoid testGetCalendarList() throws Exception {\r\n    final DateFormat format = new SimpleDateFormat(DATE_PATTERN);\r\n    final Date date1 = format.parse(\"2004-01-01\");\r\n    final Date date2 = format.parse(\"2004-12-31\");\r\n    final Calendar calendar1 = Calendar.getInstance();\r\n    calendar1.setTime(date1);\r\n    final Calendar calendar2 = Calendar.getInstance();\r\n    calendar2.setTime(date2);\r\n    // missing list\r\n    final List<Calendar> nullList = null;\r\n    assertNull(conf.getCalendarList(\"calendar.list\", nullList));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(calendar1);\r\n    expected.add(calendar2);\r\n    // list of strings\r\n    assertEquals(expected, conf.getCalendarList(\"calendar.list1\"));\r\n    assertEquals(conf.getList(Calendar.class, \"calendar.list1\"), expected);\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getCalendarList(\"calendar.list2\"));\r\n    // list of Calendar objects\r\n    assertEquals(expected, conf.getCalendarList(\"calendar.list3\"));\r\n    // array of Calendar objects\r\n    assertEquals(expected, conf.getCalendarList(\"calendar.list4\"));\r\n    // list of Date objects\r\n    assertEquals(expected, conf.getCalendarList(\"calendar.list5\"));\r\n    // list of Calendar objects\r\n    assertEquals(expected, conf.getCalendarList(\"calendar.list6\"));\r\n    // array of strings\r\n    assertEquals(conf.getList(Calendar.class, \"calendar.list7\"), expected);\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getCalendarList(\"calendar.list.interpolated\"));\r\n    // single Calendar values\r\n    expected = new ArrayList<>();\r\n    expected.add(calendar1);\r\n    assertEquals(expected, conf.getCalendarList(\"date.string\"));\r\n    assertEquals(expected, conf.getCalendarList(\"date.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getCalendarList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetColor",
  "sourceCode" : "@Test\r\nvoid testGetColor() {\r\n    // RRGGBB\r\n    conf.setProperty(\"color\", \"FF0000\");\r\n    assertEquals(Color.red, conf.getColor(\"color\"));\r\n    // #RRGGBB\r\n    conf.setProperty(\"color\", \"#00FF00\");\r\n    assertEquals(Color.green, conf.getColor(\"color\"));\r\n    // #RRGGBBAA\r\n    conf.setProperty(\"color\", \"#01030507\");\r\n    final Color color = conf.getColor(\"color\");\r\n    assertNotNull(color);\r\n    assertEquals(1, color.getRed());\r\n    assertEquals(3, color.getGreen());\r\n    assertEquals(5, color.getBlue());\r\n    assertEquals(7, color.getAlpha());\r\n    // interpolated value\r\n    assertEquals(Color.red, conf.getColor(\"color.string.interpolated\"));\r\n    // default value\r\n    assertEquals(Color.cyan, conf.getColor(\"unknownkey\", Color.cyan));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetColorArray",
  "sourceCode" : "@Test\r\nvoid testGetColorArray() throws Exception {\r\n    // missing list\r\n    final Color[] defaultValue = { Color.red, Color.blue };\r\n    assertArrayEquals(defaultValue, conf.getColorArray(\"color.list\", defaultValue));\r\n    final Color[] expected = { Color.red, Color.blue };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getColorArray(\"color.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getColorArray(\"color.list2\"));\r\n    // list of Color objects\r\n    assertArrayEquals(expected, conf.getColorArray(\"color.list3\"));\r\n    // array of Color objects\r\n    assertArrayEquals(expected, conf.getColorArray(\"color.list4\"));\r\n    // list of Color objects\r\n    assertArrayEquals(expected, conf.getColorArray(\"color.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getColorArray(\"color.list.interpolated\"));\r\n    // single Color values\r\n    assertArrayEquals(new Color[] { Color.red }, conf.getColorArray(\"color.string\"));\r\n    assertArrayEquals(new Color[] { Color.red }, conf.getColorArray(\"color.object\"));\r\n    // empty array\r\n    assertArrayEquals(new Color[] {}, conf.getColorArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetColorList",
  "sourceCode" : "@Test\r\nvoid testGetColorList() throws Exception {\r\n    // missing list\r\n    assertNull(conf.getColorList(\"color.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Color.red);\r\n    expected.add(Color.blue);\r\n    // list of strings\r\n    assertEquals(expected, conf.getColorList(\"color.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getColorList(\"color.list2\"));\r\n    // list of Color objects\r\n    assertEquals(expected, conf.getColorList(\"color.list3\"));\r\n    // array of Color objects\r\n    assertEquals(expected, conf.getColorList(\"color.list4\"));\r\n    // list of Color objects\r\n    assertEquals(expected, conf.getColorList(\"color.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getColorList(\"color.list.interpolated\"));\r\n    // single Color values\r\n    expected = new ArrayList<>();\r\n    expected.add(Color.red);\r\n    assertEquals(expected, conf.getColorList(\"color.string\"));\r\n    assertEquals(expected, conf.getColorList(\"color.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getColorList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetConfiguration",
  "sourceCode" : "@Test\r\nvoid testGetConfiguration() {\r\n    final Configuration baseconf = new BaseConfiguration();\r\n    final DataConfiguration conf = new DataConfiguration(baseconf);\r\n    assertEquals(baseconf, conf.getConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetDate",
  "sourceCode" : "@Test\r\nvoid testGetDate() throws Exception {\r\n    final Date expected = expectedDate();\r\n    // missing Date\r\n    final Date defaultValue = new Date();\r\n    assertEquals(conf.getDate(\"date\", defaultValue), defaultValue);\r\n    assertNull(conf.getDate(\"unknownkey\", DATE_PATTERN));\r\n    conf.setThrowExceptionOnMissing(true);\r\n    assertThrows(NoSuchElementException.class, () -> conf.getDate(\"unknownkey\", DATE_PATTERN));\r\n    // Date string\r\n    assertEquals(expected, conf.getDate(\"date.string\"));\r\n    assertEquals(conf.getDate(\"date.string\", DATE_PATTERN), expected);\r\n    // Date object\r\n    assertEquals(expected, conf.getDate(\"date.object\"));\r\n    // Calendar object\r\n    assertEquals(expected, conf.getDate(\"calendar.object\"));\r\n    // interpolated value\r\n    assertEquals(expected, conf.getDate(\"date.string.interpolated\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetDateArray",
  "sourceCode" : "@Test\r\nvoid testGetDateArray() throws Exception {\r\n    final DateFormat format = new SimpleDateFormat(DATE_PATTERN);\r\n    final Date date1 = format.parse(\"2004-01-01\");\r\n    final Date date2 = format.parse(\"2004-12-31\");\r\n    // missing list\r\n    final Date[] defaultValue = { date2, date1 };\r\n    assertArrayEquals(defaultValue, conf.getDateArray(\"date.list\", defaultValue));\r\n    final Date[] expected = { date1, date2 };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getDateArray(\"date.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getDateArray(\"date.list2\"));\r\n    // list of Date objects\r\n    assertArrayEquals(expected, conf.getDateArray(\"date.list3\"));\r\n    // array of Date objects\r\n    assertArrayEquals(expected, conf.getDateArray(\"date.list4\"));\r\n    // list of Calendar objects\r\n    assertArrayEquals(expected, conf.getDateArray(\"date.list5\"));\r\n    // list of Date objects\r\n    assertArrayEquals(expected, conf.getDateArray(\"date.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getDateArray(\"date.list.interpolated\"));\r\n    // single Date values\r\n    assertArrayEquals(new Date[] { date1 }, conf.getDateArray(\"date.string\"));\r\n    assertArrayEquals(new Date[] { date1 }, conf.getDateArray(\"date.object\"));\r\n    // empty array\r\n    assertArrayEquals(new Date[] {}, conf.getDateArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetDateArrayWithFormat",
  "sourceCode" : "@Test\r\nvoid testGetDateArrayWithFormat() throws Exception {\r\n    final DateFormat format = new SimpleDateFormat(\"MM/dd/yyyy\");\r\n    final Date date1 = format.parse(\"01/01/2004\");\r\n    final Date date2 = format.parse(\"12/31/2004\");\r\n    final Date[] expected = { date1, date2 };\r\n    conf.addProperty(\"date.format\", \"01/01/2004\");\r\n    conf.addProperty(\"date.format\", \"12/31/2004\");\r\n    assertArrayEquals(expected, conf.getDateArray(\"date.format\", \"MM/dd/yyyy\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetDateList",
  "sourceCode" : "@Test\r\nvoid testGetDateList() throws Exception {\r\n    final DateFormat format = new SimpleDateFormat(DATE_PATTERN);\r\n    final Date date1 = format.parse(\"2004-01-01\");\r\n    final Date date2 = format.parse(\"2004-12-31\");\r\n    // missing list\r\n    final List<Date> nullList = null;\r\n    assertNull(conf.getDateList(\"date.list\", nullList));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(date1);\r\n    expected.add(date2);\r\n    // list of strings\r\n    assertEquals(expected, conf.getDateList(\"date.list1\"));\r\n    assertEquals(conf.getList(Date.class, \"date.list1\"), expected);\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getDateList(\"date.list2\"));\r\n    // list of Date objects\r\n    assertEquals(expected, conf.getDateList(\"date.list3\"));\r\n    // array of Date objects\r\n    assertEquals(expected, conf.getDateList(\"date.list4\"));\r\n    // list of Calendar objects\r\n    assertEquals(expected, conf.getDateList(\"date.list5\"));\r\n    // list of Date objects\r\n    assertEquals(expected, conf.getDateList(\"date.list6\"));\r\n    // array of strings\r\n    assertEquals(conf.getList(Date.class, \"date.list7\"), expected);\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getDateList(\"date.list.interpolated\"));\r\n    // single Date values\r\n    expected = new ArrayList<>();\r\n    expected.add(date1);\r\n    assertEquals(expected, conf.getDateList(\"date.string\"));\r\n    assertEquals(expected, conf.getDateList(\"date.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getDateList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetDateNoFormatPropertyConversionHandler",
  "sourceCode" : "/**\r\n * Tests a conversion to a Date if no property is set with the date format, and the format is specified in the\r\n * conversion handler.\r\n */\r\n@Test\r\nvoid testGetDateNoFormatPropertyConversionHandler() throws Exception {\r\n    conf.clearProperty(DataConfiguration.DATE_FORMAT_KEY);\r\n    final DefaultConversionHandler handler = new DefaultConversionHandler();\r\n    handler.setDateFormat(DATE_PATTERN);\r\n    conf.setConversionHandler(handler);\r\n    assertEquals(expectedDate(), conf.getDate(\"date.string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetDateNoFormatPropertyDirectlySpecified",
  "sourceCode" : "/**\r\n * Tests a conversion to a Date if no property is set with the date format, and the format is directly passed in.\r\n */\r\n@Test\r\nvoid testGetDateNoFormatPropertyDirectlySpecified() throws Exception {\r\n    conf.clearProperty(DataConfiguration.DATE_FORMAT_KEY);\r\n    assertEquals(expectedDate(), conf.getDate(\"date.string\", DATE_PATTERN));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetDoubleArray",
  "sourceCode" : "@Test\r\nvoid testGetDoubleArray() {\r\n    // missing list\r\n    final double[] defaultValue = { 2, 1 };\r\n    assertArrayEquals(defaultValue, conf.getDoubleArray(\"double.list\", defaultValue), 0);\r\n    final double[] expected = { 1, 2 };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getDoubleArray(\"double.list1\"), 0);\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getDoubleArray(\"double.list2\"), 0);\r\n    // list of Double objects\r\n    assertArrayEquals(expected, conf.getDoubleArray(\"double.list3\"), 0);\r\n    // array of Double objects\r\n    assertArrayEquals(expected, conf.getDoubleArray(\"double.list4\"), 0);\r\n    // array of double primitives\r\n    assertArrayEquals(expected, conf.getDoubleArray(\"double.list5\"), 0);\r\n    // list of Double objects\r\n    assertArrayEquals(expected, conf.getDoubleArray(\"double.list6\"), 0);\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getDoubleArray(\"double.list.interpolated\"), 0);\r\n    // single double values\r\n    assertArrayEquals(new double[] { 1 }, conf.getDoubleArray(\"double.string\"), 0);\r\n    assertArrayEquals(new double[] { 1 }, conf.getDoubleArray(\"double.object\"), 0);\r\n    // empty array\r\n    assertArrayEquals(new double[] {}, conf.getDoubleArray(\"empty\"), 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetDoubleList",
  "sourceCode" : "@Test\r\nvoid testGetDoubleList() {\r\n    // missing list\r\n    assertNull(conf.getDoubleList(\"double.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Double.valueOf(\"1\"));\r\n    expected.add(Double.valueOf(\"2\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getDoubleList(\"double.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getDoubleList(\"double.list2\"));\r\n    // list of Double objects\r\n    assertEquals(expected, conf.getDoubleList(\"double.list3\"));\r\n    // array of Double objects\r\n    assertEquals(expected, conf.getDoubleList(\"double.list4\"));\r\n    // array of double primitives\r\n    assertEquals(expected, conf.getDoubleList(\"double.list5\"));\r\n    // list of Double objects\r\n    assertEquals(expected, conf.getDoubleList(\"double.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getDoubleList(\"double.list.interpolated\"));\r\n    // single double values\r\n    expected = new ArrayList<>();\r\n    expected.add(Double.valueOf(\"1\"));\r\n    assertEquals(expected, conf.getDoubleList(\"double.string\"));\r\n    assertEquals(expected, conf.getDoubleList(\"double.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getDoubleList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetFloatArray",
  "sourceCode" : "@Test\r\nvoid testGetFloatArray() {\r\n    // missing list\r\n    final float[] defaultValue = { 2, 1 };\r\n    assertArrayEquals(defaultValue, conf.getFloatArray(\"float.list\", defaultValue), 0);\r\n    final float[] expected = { 1, 2 };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getFloatArray(\"float.list1\"), 0);\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getFloatArray(\"float.list2\"), 0);\r\n    // list of Float objects\r\n    assertArrayEquals(expected, conf.getFloatArray(\"float.list3\"), 0);\r\n    // array of Float objects\r\n    assertArrayEquals(expected, conf.getFloatArray(\"float.list4\"), 0);\r\n    // array of float primitives\r\n    assertArrayEquals(expected, conf.getFloatArray(\"float.list5\"), 0);\r\n    // list of Float objects\r\n    assertArrayEquals(expected, conf.getFloatArray(\"float.list6\"), 0);\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getFloatArray(\"float.list.interpolated\"), 0);\r\n    // single float values\r\n    assertArrayEquals(new float[] { 1 }, conf.getFloatArray(\"float.string\"), 0);\r\n    assertArrayEquals(new float[] { 1 }, conf.getFloatArray(\"float.object\"), 0);\r\n    // empty array\r\n    assertArrayEquals(new float[] {}, conf.getFloatArray(\"empty\"), 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetFloatList",
  "sourceCode" : "@Test\r\nvoid testGetFloatList() {\r\n    // missing list\r\n    assertNull(conf.getFloatList(\"float.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Float.valueOf(\"1\"));\r\n    expected.add(Float.valueOf(\"2\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getFloatList(\"float.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getFloatList(\"float.list2\"));\r\n    // list of Float objects\r\n    assertEquals(expected, conf.getFloatList(\"float.list3\"));\r\n    // array of Float objects\r\n    assertEquals(expected, conf.getFloatList(\"float.list4\"));\r\n    // array of float primitives\r\n    assertEquals(expected, conf.getFloatList(\"float.list5\"));\r\n    // list of Float objects\r\n    assertEquals(expected, conf.getFloatList(\"float.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getFloatList(\"float.list.interpolated\"));\r\n    // single float values\r\n    expected = new ArrayList<>();\r\n    expected.add(Float.valueOf(\"1\"));\r\n    assertEquals(expected, conf.getFloatList(\"float.string\"));\r\n    assertEquals(expected, conf.getFloatList(\"float.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getFloatList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetInetAddress",
  "sourceCode" : "@Test\r\nvoid testGetInetAddress() throws Exception {\r\n    final InetAddress expected = InetAddress.getByName(\"127.0.0.1\");\r\n    // address as string\r\n    assertEquals(conf.get(InetAddress.class, \"ip.string\"), expected);\r\n    // address object\r\n    assertEquals(conf.get(InetAddress.class, \"ip.object\"), expected);\r\n    // interpolated value\r\n    assertEquals(conf.get(InetAddress.class, \"ip.string.interpolated\"), expected);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetInetAddressInvalidType",
  "sourceCode" : "@Test\r\nvoid testGetInetAddressInvalidType() {\r\n    conf.setProperty(\"ip.unknownhost\", \"foo\");\r\n    assertThrows(ConversionException.class, () -> conf.get(InetAddress.class, \"ip.unknownhost\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetIntegerArray",
  "sourceCode" : "@Test\r\nvoid testGetIntegerArray() {\r\n    // missing list\r\n    final int[] defaultValue = { 2, 1 };\r\n    assertArrayEquals(conf.getIntArray(\"integer.list\", defaultValue), defaultValue);\r\n    final int[] expected = { 1, 2 };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getIntArray(\"integer.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getIntArray(\"integer.list2\"));\r\n    // list of Integer objects\r\n    assertArrayEquals(expected, conf.getIntArray(\"integer.list3\"));\r\n    // array of Integer objects\r\n    assertArrayEquals(expected, conf.getIntArray(\"integer.list4\"));\r\n    // array of int primitives\r\n    assertArrayEquals(expected, conf.getIntArray(\"integer.list5\"));\r\n    // list of Integer objects\r\n    assertArrayEquals(expected, conf.getIntArray(\"integer.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getIntArray(\"integer.list.interpolated\"));\r\n    // single int values\r\n    assertArrayEquals(new int[] { 1 }, conf.getIntArray(\"integer.string\"));\r\n    assertArrayEquals(new int[] { 1 }, conf.getIntArray(\"integer.object\"));\r\n    // empty array\r\n    assertArrayEquals(new int[] {}, conf.getIntArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetIntegerList",
  "sourceCode" : "@Test\r\nvoid testGetIntegerList() {\r\n    // missing list\r\n    assertNull(conf.getIntegerList(\"integer.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Integer.valueOf(\"1\"));\r\n    expected.add(Integer.valueOf(\"2\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getIntegerList(\"integer.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getIntegerList(\"integer.list2\"));\r\n    // list of Integer objects\r\n    assertEquals(expected, conf.getIntegerList(\"integer.list3\"));\r\n    // array of Integer objects\r\n    assertEquals(expected, conf.getIntegerList(\"integer.list4\"));\r\n    // array of int primitives\r\n    assertEquals(expected, conf.getIntegerList(\"integer.list5\"));\r\n    // list of Integer objects\r\n    assertEquals(expected, conf.getIntegerList(\"integer.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getIntegerList(\"integer.list.interpolated\"));\r\n    // single int values\r\n    expected = new ArrayList<>();\r\n    expected.add(Integer.valueOf(\"1\"));\r\n    assertEquals(expected, conf.getIntegerList(\"integer.string\"));\r\n    assertEquals(expected, conf.getIntegerList(\"integer.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getIntegerList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetInternetAddress",
  "sourceCode" : "@Test\r\nvoid testGetInternetAddress() throws Exception {\r\n    final Object expected = new InternetAddress(\"dev@test.org\");\r\n    // address as string\r\n    assertEquals(conf.get(expected.getClass(), \"email.string\"), expected);\r\n    // address object\r\n    assertEquals(conf.get(expected.getClass(), \"email.object\"), expected);\r\n    // interpolated value\r\n    assertEquals(conf.get(expected.getClass(), \"email.string.interpolated\"), expected);\r\n    conf.setProperty(\"email.invalid\", \"dev@test@org\");\r\n    assertThrows(ConversionException.class, () -> conf.get(expected.getClass(), \"email.invalid\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetInternetAddressInvalidType",
  "sourceCode" : "@Test\r\nvoid testGetInternetAddressInvalidType() throws Exception {\r\n    final Object expected = new InternetAddress(\"dev@test.org\");\r\n    conf.setProperty(\"email.invalid\", \"dev@test@org\");\r\n    assertThrows(ConversionException.class, () -> conf.get(expected.getClass(), \"email.invalid\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetInvalidType",
  "sourceCode" : "@Test\r\nvoid testGetInvalidType() {\r\n    assertThrows(ConversionException.class, () -> conf.get(Boolean.class, \"url.object\", null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "@Test\r\nvoid testGetKeys() {\r\n    final Configuration baseconf = new BaseConfiguration();\r\n    final DataConfiguration conf = new DataConfiguration(baseconf);\r\n    baseconf.setProperty(\"foo\", \"bar\");\r\n    final Iterator<String> it = conf.getKeys();\r\n    assertTrue(it.hasNext());\r\n    assertEquals(\"foo\", it.next());\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetLocale",
  "sourceCode" : "@Test\r\nvoid testGetLocale() {\r\n    // language\r\n    conf.setProperty(\"locale\", \"fr\");\r\n    assertEquals(new Locale(\"fr\", \"\"), conf.getLocale(\"locale\"));\r\n    // language + variant\r\n    conf.setProperty(\"locale\", \"fr__POSIX\");\r\n    assertEquals(new Locale(\"fr\", \"\", \"POSIX\"), conf.getLocale(\"locale\"));\r\n    // country\r\n    conf.setProperty(\"locale\", \"_FR\");\r\n    assertEquals(new Locale(\"\", \"FR\"), conf.getLocale(\"locale\"));\r\n    // country + variant\r\n    conf.setProperty(\"locale\", \"_FR_WIN\");\r\n    assertEquals(new Locale(\"\", \"FR\", \"WIN\"), conf.getLocale(\"locale\"));\r\n    // language + country\r\n    conf.setProperty(\"locale\", \"fr_FR\");\r\n    assertEquals(new Locale(\"fr\", \"FR\"), conf.getLocale(\"locale\"));\r\n    // language + country + variant\r\n    conf.setProperty(\"locale\", \"fr_FR_MAC\");\r\n    assertEquals(new Locale(\"fr\", \"FR\", \"MAC\"), conf.getLocale(\"locale\"));\r\n    // default value\r\n    conf.setProperty(\"locale\", \"fr\");\r\n    assertEquals(Locale.FRENCH, conf.getLocale(\"locale\", Locale.GERMAN));\r\n    assertEquals(Locale.GERMAN, conf.getLocale(\"localeNotInConfig\", Locale.GERMAN));\r\n    // interpolated value\r\n    assertEquals(Locale.FRENCH, conf.getLocale(\"locale.string.interpolated\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetLocaleArray",
  "sourceCode" : "@Test\r\nvoid testGetLocaleArray() throws Exception {\r\n    // missing list\r\n    final Locale[] defaultValue = { Locale.GERMAN, Locale.FRENCH };\r\n    assertArrayEquals(conf.getLocaleArray(\"locale.list\", defaultValue), defaultValue);\r\n    final Locale[] expected = { Locale.FRENCH, Locale.GERMAN };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getLocaleArray(\"locale.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getLocaleArray(\"locale.list2\"));\r\n    // list of Locale objects\r\n    assertArrayEquals(expected, conf.getLocaleArray(\"locale.list3\"));\r\n    // array of Locale objects\r\n    assertArrayEquals(expected, conf.getLocaleArray(\"locale.list4\"));\r\n    // list of Locale objects\r\n    assertArrayEquals(expected, conf.getLocaleArray(\"locale.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getLocaleArray(\"locale.list.interpolated\"));\r\n    // single Locale values\r\n    assertArrayEquals(new Locale[] { Locale.FRENCH }, conf.getLocaleArray(\"locale.string\"));\r\n    assertArrayEquals(new Locale[] { Locale.FRENCH }, conf.getLocaleArray(\"locale.object\"));\r\n    // empty array\r\n    assertArrayEquals(new Locale[] {}, conf.getLocaleArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetLocaleList",
  "sourceCode" : "@Test\r\nvoid testGetLocaleList() throws Exception {\r\n    // missing list\r\n    assertNull(conf.getLocaleList(\"locale.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Locale.FRENCH);\r\n    expected.add(Locale.GERMAN);\r\n    // list of strings\r\n    assertEquals(expected, conf.getLocaleList(\"locale.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getLocaleList(\"locale.list2\"));\r\n    // list of Locale objects\r\n    assertEquals(expected, conf.getLocaleList(\"locale.list3\"));\r\n    // array of Locale objects\r\n    assertEquals(expected, conf.getLocaleList(\"locale.list4\"));\r\n    // list of Locale objects\r\n    assertEquals(expected, conf.getLocaleList(\"locale.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getLocaleList(\"locale.list.interpolated\"));\r\n    // single Locale values\r\n    expected = new ArrayList<>();\r\n    expected.add(Locale.FRENCH);\r\n    assertEquals(expected, conf.getLocaleList(\"locale.string\"));\r\n    assertEquals(expected, conf.getLocaleList(\"locale.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getLocaleList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetLongArray",
  "sourceCode" : "@Test\r\nvoid testGetLongArray() {\r\n    // missing list\r\n    final long[] defaultValue = { 2, 1 };\r\n    assertArrayEquals(conf.getLongArray(\"long.list\", defaultValue), defaultValue);\r\n    final long[] expected = { 1, 2 };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getLongArray(\"long.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getLongArray(\"long.list2\"));\r\n    // list of Long objects\r\n    assertArrayEquals(expected, conf.getLongArray(\"long.list3\"));\r\n    // array of Long objects\r\n    assertArrayEquals(expected, conf.getLongArray(\"long.list4\"));\r\n    // array of long primitives\r\n    assertArrayEquals(expected, conf.getLongArray(\"long.list5\"));\r\n    // list of Long objects\r\n    assertArrayEquals(expected, conf.getLongArray(\"long.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getLongArray(\"long.list.interpolated\"));\r\n    // single long values\r\n    assertArrayEquals(new long[] { 1 }, conf.getLongArray(\"long.string\"));\r\n    assertArrayEquals(new long[] { 1 }, conf.getLongArray(\"long.object\"));\r\n    // empty array\r\n    assertArrayEquals(new long[] {}, conf.getLongArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetLongList",
  "sourceCode" : "@Test\r\nvoid testGetLongList() {\r\n    // missing list\r\n    assertNull(conf.getLongList(\"long.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Long.valueOf(\"1\"));\r\n    expected.add(Long.valueOf(\"2\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getLongList(\"long.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getLongList(\"long.list2\"));\r\n    // list of Long objects\r\n    assertEquals(expected, conf.getLongList(\"long.list3\"));\r\n    // array of Long objects\r\n    assertEquals(expected, conf.getLongList(\"long.list4\"));\r\n    // array of long primitives\r\n    assertEquals(expected, conf.getLongList(\"long.list5\"));\r\n    // list of Long objects\r\n    assertEquals(expected, conf.getLongList(\"long.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getLongList(\"long.list.interpolated\"));\r\n    // single long values\r\n    expected = new ArrayList<>();\r\n    expected.add(Long.valueOf(\"1\"));\r\n    assertEquals(expected, conf.getLongList(\"long.string\"));\r\n    assertEquals(expected, conf.getLongList(\"long.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getLongList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetPrimitiveArrayInvalidType",
  "sourceCode" : "@Test\r\nvoid testGetPrimitiveArrayInvalidType() {\r\n    assertThrows(ConversionException.class, () -> conf.getArray(Boolean.TYPE, \"calendar.list4\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetPropertyWithoutConversion",
  "sourceCode" : "/**\r\n * Tests whether a string property can be obtained through get() if no type conversion is required.\r\n */\r\n@Test\r\nvoid testGetPropertyWithoutConversion() {\r\n    final String key = \"test.str\";\r\n    final String value = \"someTestValue\";\r\n    conf.addProperty(key, value);\r\n    assertEquals(value, conf.get(String.class, key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetShortArray",
  "sourceCode" : "@Test\r\nvoid testGetShortArray() {\r\n    // missing list\r\n    final short[] defaultValue = { 2, 1 };\r\n    assertArrayEquals(conf.getShortArray(\"short.list\", defaultValue), defaultValue);\r\n    final short[] expected = { 1, 2 };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getShortArray(\"short.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getShortArray(\"short.list2\"));\r\n    // list of Byte objects\r\n    assertArrayEquals(expected, conf.getShortArray(\"short.list3\"));\r\n    // array of Byte objects\r\n    assertArrayEquals(expected, conf.getShortArray(\"short.list4\"));\r\n    // array of byte primitives\r\n    assertArrayEquals(expected, conf.getShortArray(\"short.list5\"));\r\n    // list of Byte objects\r\n    assertArrayEquals(expected, conf.getShortArray(\"short.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getShortArray(\"short.list.interpolated\"));\r\n    // single byte values\r\n    assertArrayEquals(new short[] { 1 }, conf.getShortArray(\"short.string\"));\r\n    assertArrayEquals(new short[] { 1 }, conf.getShortArray(\"short.object\"));\r\n    // empty array\r\n    assertArrayEquals(new short[] {}, conf.getShortArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetShortList",
  "sourceCode" : "@Test\r\nvoid testGetShortList() {\r\n    // missing list\r\n    assertNull(conf.getShortList(\"short.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(Short.valueOf(\"1\"));\r\n    expected.add(Short.valueOf(\"2\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getShortList(\"short.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getShortList(\"short.list2\"));\r\n    // list of Short objects\r\n    assertEquals(expected, conf.getShortList(\"short.list3\"));\r\n    // array of Short objects\r\n    assertEquals(expected, conf.getShortList(\"short.list4\"));\r\n    // array of short primitives\r\n    assertEquals(expected, conf.getShortList(\"short.list5\"));\r\n    // list of Short objects\r\n    assertEquals(expected, conf.getShortList(\"short.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getShortList(\"short.list.interpolated\"));\r\n    // single short values\r\n    expected = new ArrayList<>();\r\n    expected.add(Short.valueOf(\"1\"));\r\n    assertEquals(expected, conf.getShortList(\"short.string\"));\r\n    assertEquals(expected, conf.getShortList(\"short.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getShortList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetUnknown",
  "sourceCode" : "@Test\r\nvoid testGetUnknown() {\r\n    assertNull(conf.get(Object.class, \"unknownkey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetUnknownException",
  "sourceCode" : "@Test\r\nvoid testGetUnknownException() {\r\n    conf.setThrowExceptionOnMissing(true);\r\n    assertThrows(NoSuchElementException.class, () -> conf.get(Object.class, \"unknownkey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetURI",
  "sourceCode" : "@Test\r\nvoid testGetURI() throws Exception {\r\n    // missing URI\r\n    final URI defaultValue = new URI(\"http://www.google.com\");\r\n    assertEquals(conf.getURI(\"url\", defaultValue), defaultValue);\r\n    final URI expected = new URI(\"http://jakarta.apache.org\");\r\n    // URI string\r\n    assertEquals(expected, conf.getURI(\"uri.string\"));\r\n    // URI object\r\n    assertEquals(expected, conf.getURI(\"uri.object\"));\r\n    // interpolated value\r\n    assertEquals(expected, conf.getURI(\"uri.string.interpolated\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetURIArray",
  "sourceCode" : "@Test\r\nvoid testGetURIArray() throws Exception {\r\n    // missing list\r\n    final URI[] defaultValue = { new URI(\"http://www.apache.org\"), new URI(\"http://jakarta.apache.org\") };\r\n    assertArrayEquals(conf.getURIArray(\"url.list\", defaultValue), defaultValue);\r\n    final URI[] expected = { new URI(\"http://jakarta.apache.org\"), new URI(\"http://www.apache.org\") };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getURIArray(\"uri.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getURIArray(\"uri.list2\"));\r\n    // list of URI objects\r\n    assertArrayEquals(expected, conf.getURIArray(\"uri.list3\"));\r\n    // array of URI objects\r\n    assertArrayEquals(expected, conf.getURIArray(\"uri.list4\"));\r\n    // list of URI objects\r\n    assertArrayEquals(expected, conf.getURIArray(\"uri.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getURIArray(\"uri.list.interpolated\"));\r\n    // single URI values\r\n    assertArrayEquals(new URI[] { new URI(\"http://jakarta.apache.org\") }, conf.getURIArray(\"uri.string\"));\r\n    assertArrayEquals(new URI[] { new URI(\"http://jakarta.apache.org\") }, conf.getURIArray(\"uri.object\"));\r\n    // empty array\r\n    assertArrayEquals(new URI[] {}, conf.getURIArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetURIList",
  "sourceCode" : "@Test\r\nvoid testGetURIList() throws Exception {\r\n    // missing list\r\n    assertNull(conf.getURIList(\"uri.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(new URI(\"http://jakarta.apache.org\"));\r\n    expected.add(new URI(\"http://www.apache.org\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getURIList(\"uri.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getURIList(\"uri.list2\"));\r\n    // list of URI objects\r\n    assertEquals(expected, conf.getURIList(\"uri.list3\"));\r\n    // array of URI objects\r\n    assertEquals(expected, conf.getURIList(\"uri.list4\"));\r\n    // list of URI objects\r\n    assertEquals(expected, conf.getURIList(\"uri.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getURIList(\"uri.list.interpolated\"));\r\n    // single URI values\r\n    expected = new ArrayList<>();\r\n    expected.add(new URI(\"http://jakarta.apache.org\"));\r\n    assertEquals(expected, conf.getURIList(\"uri.string\"));\r\n    assertEquals(expected, conf.getURIList(\"uri.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getURIList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetURL",
  "sourceCode" : "@Test\r\nvoid testGetURL() throws Exception {\r\n    // missing URL\r\n    final URL defaultValue = new URL(\"http://www.google.com\");\r\n    assertEquals(conf.getURL(\"url\", defaultValue), defaultValue);\r\n    final URL expected = new URL(\"http://jakarta.apache.org\");\r\n    // URL string\r\n    assertEquals(expected, conf.getURL(\"url.string\"));\r\n    // URL object\r\n    assertEquals(expected, conf.getURL(\"url.object\"));\r\n    // interpolated value\r\n    assertEquals(expected, conf.getURL(\"url.string.interpolated\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetURLArray",
  "sourceCode" : "@Test\r\nvoid testGetURLArray() throws Exception {\r\n    // missing list\r\n    final URL[] defaultValue = { new URL(\"http://www.apache.org\"), new URL(\"http://jakarta.apache.org\") };\r\n    assertArrayEquals(conf.getURLArray(\"url.list\", defaultValue), defaultValue);\r\n    final URL[] expected = { new URL(\"http://jakarta.apache.org\"), new URL(\"http://www.apache.org\") };\r\n    // list of strings\r\n    assertArrayEquals(expected, conf.getURLArray(\"url.list1\"));\r\n    // list of strings, comma separated\r\n    assertArrayEquals(expected, conf.getURLArray(\"url.list2\"));\r\n    // list of URL objects\r\n    assertArrayEquals(expected, conf.getURLArray(\"url.list3\"));\r\n    // array of URL objects\r\n    assertArrayEquals(expected, conf.getURLArray(\"url.list4\"));\r\n    // list of URL objects\r\n    assertArrayEquals(expected, conf.getURLArray(\"url.list6\"));\r\n    // list of interpolated values\r\n    assertArrayEquals(expected, conf.getURLArray(\"url.list.interpolated\"));\r\n    // single URL values\r\n    assertArrayEquals(new URL[] { new URL(\"http://jakarta.apache.org\") }, conf.getURLArray(\"url.string\"));\r\n    assertArrayEquals(new URL[] { new URL(\"http://jakarta.apache.org\") }, conf.getURLArray(\"url.object\"));\r\n    // empty array\r\n    assertArrayEquals(new URL[] {}, conf.getURLArray(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testGetURLList",
  "sourceCode" : "@Test\r\nvoid testGetURLList() throws Exception {\r\n    // missing list\r\n    assertNull(conf.getURLList(\"url.list\", null));\r\n    List<Object> expected = new ArrayList<>();\r\n    expected.add(new URL(\"http://jakarta.apache.org\"));\r\n    expected.add(new URL(\"http://www.apache.org\"));\r\n    // list of strings\r\n    assertEquals(expected, conf.getURLList(\"url.list1\"));\r\n    // list of strings, comma separated\r\n    assertEquals(expected, conf.getURLList(\"url.list2\"));\r\n    // list of URL objects\r\n    assertEquals(expected, conf.getURLList(\"url.list3\"));\r\n    // array of URL objects\r\n    assertEquals(expected, conf.getURLList(\"url.list4\"));\r\n    // list of URL objects\r\n    assertEquals(expected, conf.getURLList(\"url.list6\"));\r\n    // list of interpolated values\r\n    assertEquals(expected, conf.getURLList(\"url.list.interpolated\"));\r\n    // single URL values\r\n    expected = new ArrayList<>();\r\n    expected.add(new URL(\"http://jakarta.apache.org\"));\r\n    assertEquals(expected, conf.getURLList(\"url.string\"));\r\n    assertEquals(expected, conf.getURLList(\"url.object\"));\r\n    // empty list\r\n    assertEquals(new ArrayList<>(), conf.getURLList(\"empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testIsEmpty",
  "sourceCode" : "@Test\r\nvoid testIsEmpty() {\r\n    final Configuration baseconf = new BaseConfiguration();\r\n    final DataConfiguration conf = new DataConfiguration(baseconf);\r\n    assertTrue(conf.isEmpty());\r\n    baseconf.setProperty(\"foo\", \"bar\");\r\n    assertFalse(conf.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDataConfiguration.java",
  "methodName" : "testNullConfiguration",
  "sourceCode" : "@Test\r\nvoid testNullConfiguration() {\r\n    assertThrows(NullPointerException.class, () -> new DataConfiguration(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDefaultImmutableConfiguration.java",
  "methodName" : "testContainsValueDefaultImplementation",
  "sourceCode" : "@Test\r\nvoid testContainsValueDefaultImplementation() {\r\n    config.map.put(\"test\", \"213123\");\r\n    assertFalse(config.containsValue(\"\"));\r\n    assertFalse(config.containsValue(null));\r\n    assertTrue(config.containsValue(\"213123\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDefaultImmutableConfiguration.java",
  "methodName" : "testGetDuration",
  "sourceCode" : "@Test\r\nvoid testGetDuration() {\r\n    final Duration d = Duration.ofSeconds(1);\r\n    config.map.put(\"durationD\", d.toString());\r\n    final Duration oneD = Duration.ofSeconds(1);\r\n    final Duration twoD = Duration.ofSeconds(2);\r\n    assertEquals(oneD, config.getDuration(\"durationD\"));\r\n    assertEquals(oneD, config.getDuration(\"durationD\", twoD));\r\n    assertEquals(twoD, config.getDuration(\"numberNotInConfig\", twoD));\r\n    assertEquals(oneD, config.getDuration(\"durationD\", twoD));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDefaultImmutableConfiguration.java",
  "methodName" : "testGetDurationIncompatibleType",
  "sourceCode" : "@Test\r\nvoid testGetDurationIncompatibleType() {\r\n    config.map.put(\"test.empty\", \"\");\r\n    assertThrows(ConversionException.class, () -> config.getDuration(\"test.empty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDefaultImmutableConfiguration.java",
  "methodName" : "testGetDurationUnknown",
  "sourceCode" : "@Test\r\nvoid testGetDurationUnknown() {\r\n    assertThrows(NoSuchElementException.class, () -> config.getDuration(\"numberNotInConfig\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testAddConfigurationSynchronized",
  "sourceCode" : "/**\r\n * Tests whether adding a configuration is synchronized.\r\n */\r\n@Test\r\nvoid testAddConfigurationSynchronized() {\r\n    final DynamicCombinedConfiguration config = new DynamicCombinedConfiguration();\r\n    final SynchronizerTestImpl sync = prepareSynchronizerTest(config);\r\n    config.addConfiguration(new PropertiesConfiguration());\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testConcurrentGetAndReload",
  "sourceCode" : "@Test\r\nvoid testConcurrentGetAndReload() throws Exception {\r\n    System.getProperties().remove(\"Id\");\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(parameters.fileBased().setFile(MULTI_TENENT_FILE).setSynchronizer(new ReadWriteSynchronizer()));\r\n    final CombinedConfiguration config = builder.getConfiguration();\r\n    assertEquals(\"50\", config.getString(\"rowsPerPage\"));\r\n    final Thread[] testThreads = new Thread[THREAD_COUNT];\r\n    final int[] failures = new int[THREAD_COUNT];\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i] = new ReloadThread(builder, failures, i, LOOP_COUNT, false, null, \"50\");\r\n        testThreads[i].start();\r\n    }\r\n    int totalFailures = 0;\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i].join();\r\n        totalFailures += failures[i];\r\n    }\r\n    assertEquals(0, totalFailures);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testConcurrentGetAndReload2",
  "sourceCode" : "@Test\r\nvoid testConcurrentGetAndReload2() throws Exception {\r\n    System.getProperties().remove(\"Id\");\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(parameters.fileBased().setFile(MULTI_TENENT_FILE).setSynchronizer(new ReadWriteSynchronizer()));\r\n    final CombinedConfiguration config = builder.getConfiguration();\r\n    assertEquals(\"50\", config.getString(\"rowsPerPage\"));\r\n    final Thread[] testThreads = new Thread[THREAD_COUNT];\r\n    final int[] failures = new int[THREAD_COUNT];\r\n    System.setProperty(\"Id\", \"2002\");\r\n    assertEquals(\"25\", config.getString(\"rowsPerPage\"));\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i] = new ReloadThread(builder, failures, i, LOOP_COUNT, false, null, \"25\");\r\n        testThreads[i].start();\r\n    }\r\n    int totalFailures = 0;\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i].join();\r\n        totalFailures += failures[i];\r\n    }\r\n    System.getProperties().remove(\"Id\");\r\n    assertEquals(0, totalFailures);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testConcurrentGetAndReloadFile",
  "sourceCode" : "@Test\r\nvoid testConcurrentGetAndReloadFile() throws Exception {\r\n    final int threadCount = 25;\r\n    System.getProperties().remove(\"Id\");\r\n    System.setProperty(\"TemporaryFolder\", tempFolder.getAbsolutePath());\r\n    // create a new configuration\r\n    File input = new File(\"target/test-classes/testMultiDynamic_default.xml\");\r\n    final File output = newFile(\"testMultiDynamic_default.xml\", tempFolder);\r\n    output.delete();\r\n    output.getParentFile().mkdir();\r\n    copyFile(input, output);\r\n    final ReloadingCombinedConfigurationBuilder builder = new ReloadingCombinedConfigurationBuilder();\r\n    builder.configure(parameters.combined().setSynchronizer(new ReadWriteSynchronizer()).setDefinitionBuilderParameters(new FileBasedBuilderParametersImpl().setFile(MULTI_DYNAMIC_FILE)).registerChildDefaultsHandler(FileBasedBuilderProperties.class, new CopyObjectDefaultHandler(new FileBasedBuilderParametersImpl().setReloadingRefreshDelay(1L))));\r\n    CombinedConfiguration config = builder.getConfiguration();\r\n    assertEquals(\"ID0001\", config.getString(\"Product/FIIndex/FI[@id='123456781']\"));\r\n    final ReaderThread[] testThreads = new ReaderThread[threadCount];\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i] = new ReaderThread(builder);\r\n        testThreads[i].start();\r\n    }\r\n    builder.getReloadingController().checkForReloading(null);\r\n    Thread.sleep(2000);\r\n    input = new File(\"target/test-classes/testMultiDynamic_default2.xml\");\r\n    copyFile(input, output);\r\n    Thread.sleep(2000);\r\n    assertTrue(builder.getReloadingController().checkForReloading(null));\r\n    config = builder.getConfiguration();\r\n    final String id = config.getString(\"Product/FIIndex/FI[@id='123456782']\");\r\n    assertNotNull(id);\r\n    final String rows = config.getString(\"rowsPerPage\");\r\n    assertEquals(\"25\", rows);\r\n    for (final ReaderThread testThread : testThreads) {\r\n        testThread.shutdown();\r\n        testThread.join();\r\n    }\r\n    for (final ReaderThread testThread : testThreads) {\r\n        assertFalse(testThread.failed());\r\n    }\r\n    assertEquals(\"ID0002\", config.getString(\"Product/FIIndex/FI[@id='123456782']\"));\r\n    output.delete();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testConcurrentGetAndReloadMultipleClients",
  "sourceCode" : "@Test\r\nvoid testConcurrentGetAndReloadMultipleClients() throws Exception {\r\n    System.getProperties().remove(\"Id\");\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(parameters.fileBased().setFile(MULTI_TENENT_FILE).setSynchronizer(new ReadWriteSynchronizer()));\r\n    final CombinedConfiguration config = builder.getConfiguration();\r\n    assertEquals(\"50\", config.getString(\"rowsPerPage\"));\r\n    final Thread[] testThreads = new Thread[THREAD_COUNT];\r\n    final int[] failures = new int[THREAD_COUNT];\r\n    final String[] ids = { null, \"2002\", \"3001\", \"3002\", \"3003\" };\r\n    final String[] expected = { \"50\", \"25\", \"15\", \"25\", \"50\" };\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i] = new ReloadThread(builder, failures, i, LOOP_COUNT, true, ids[i], expected[i]);\r\n        testThreads[i].start();\r\n    }\r\n    int totalFailures = 0;\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i].join();\r\n        totalFailures += failures[i];\r\n    }\r\n    System.getProperties().remove(\"Id\");\r\n    if (totalFailures != 0) {\r\n        System.out.println(\"Failures:\");\r\n        for (int i = 0; i < testThreads.length; ++i) {\r\n            System.out.println(\"Thread \" + i + \" \" + failures[i]);\r\n        }\r\n    }\r\n    assertEquals(0, totalFailures);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testConfiguration",
  "sourceCode" : "@Test\r\nvoid testConfiguration() throws Exception {\r\n    final DynamicCombinedConfiguration config = new DynamicCombinedConfiguration();\r\n    final DefaultListDelimiterHandler listHandler = new DefaultListDelimiterHandler(',');\r\n    config.setListDelimiterHandler(listHandler);\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    config.setExpressionEngine(engine);\r\n    config.setKeyPattern(PATTERN);\r\n    final ConfigurationBuilder<XMLConfiguration> multiBuilder = new MultiFileConfigurationBuilder<>(XMLConfiguration.class).configure(parameters.multiFile().setFilePattern(PATTERN1).setPrefixLookups(ConfigurationInterpolator.getDefaultPrefixLookups()).setManagedBuilderParameters(parameters.xml().setExpressionEngine(engine).setListDelimiterHandler(listHandler)));\r\n    final BuilderConfigurationWrapperFactory wrapFactory = new BuilderConfigurationWrapperFactory();\r\n    config.addConfiguration(wrapFactory.createBuilderConfigurationWrapper(HierarchicalConfiguration.class, multiBuilder), \"Multi\");\r\n    final XMLConfiguration xml = new XMLConfiguration();\r\n    xml.setExpressionEngine(engine);\r\n    final FileHandler handler = new FileHandler(xml);\r\n    handler.setFile(new File(DEFAULT_FILE));\r\n    handler.load();\r\n    config.addConfiguration(xml, \"Default\");\r\n    verify(\"1001\", config, 15);\r\n    verify(\"1002\", config, 25);\r\n    verify(\"1003\", config, 35);\r\n    verify(\"1004\", config, 50);\r\n    assertEquals(\"a,b,c\", config.getString(\"split/list3/@values\"));\r\n    assertEquals(0, config.getMaxIndex(\"split/list3/@values\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", config.getString(\"split/list4/@values\"));\r\n    assertEquals(\"OK-1\", config.getString(\"buttons/name\"));\r\n    assertEquals(3, config.getMaxIndex(\"buttons/name\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", config.getString(\"split/list2\"));\r\n    assertEquals(18, config.size());\r\n    config.addProperty(\"listDelimiterTest\", \"1,2,3\");\r\n    assertEquals(\"1\", config.getString(\"listDelimiterTest\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testGetConfigurationByIdxSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying a configuration by index is synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationByIdxSynchronized() {\r\n    final DynamicCombinedConfiguration config = new DynamicCombinedConfiguration();\r\n    final Configuration child = new PropertiesConfiguration();\r\n    config.addConfiguration(child);\r\n    final SynchronizerTestImpl sync = prepareSynchronizerTest(config);\r\n    assertSame(child, config.getConfiguration(0));\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testGetConfigurationByNameSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying a configuration by name is synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationByNameSynchronized() {\r\n    final DynamicCombinedConfiguration config = new DynamicCombinedConfiguration();\r\n    final SynchronizerTestImpl sync = prepareSynchronizerTest(config);\r\n    assertNull(config.getConfiguration(\"unknown config\"));\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testGetConfigurationNamesSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying the set of configuration names is synchronized.\r\n */\r\n@Test\r\nvoid testGetConfigurationNamesSynchronized() {\r\n    final DynamicCombinedConfiguration config = new DynamicCombinedConfiguration();\r\n    final SynchronizerTestImpl sync = prepareSynchronizerTest(config);\r\n    config.getConfigurationNames();\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testGetNumberOfConfigurationsSynchronized",
  "sourceCode" : "/**\r\n * Tests whether querying the number of configurations is synchronized.\r\n */\r\n@Test\r\nvoid testGetNumberOfConfigurationsSynchronized() {\r\n    final DynamicCombinedConfiguration config = new DynamicCombinedConfiguration();\r\n    final SynchronizerTestImpl sync = prepareSynchronizerTest(config);\r\n    config.getNumberOfConfigurations();\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testRemoveConfigurationSynchronized",
  "sourceCode" : "/**\r\n * Tests whether removing a child configuration is synchronized.\r\n */\r\n@Test\r\nvoid testRemoveConfigurationSynchronized() {\r\n    final DynamicCombinedConfiguration config = new DynamicCombinedConfiguration();\r\n    final String configName = \"testConfig\";\r\n    config.addConfiguration(new PropertiesConfiguration(), configName);\r\n    final SynchronizerTestImpl sync = prepareSynchronizerTest(config);\r\n    config.removeConfiguration(configName);\r\n    sync.verifyContains(Methods.BEGIN_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestDynamicCombinedConfiguration.java",
  "methodName" : "testUpdateConfiguration",
  "sourceCode" : "/**\r\n * Tests whether a configuration can be updated.\r\n */\r\n@Test\r\nvoid testUpdateConfiguration() throws ConfigurationException {\r\n    System.getProperties().remove(\"Id\");\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(parameters.fileBased().setFile(MULTI_TENENT_FILE).setSynchronizer(new ReadWriteSynchronizer()));\r\n    final CombinedConfiguration config = builder.getConfiguration();\r\n    config.getConfiguration(1).setProperty(\"rowsPerPage\", \"25\");\r\n    assertEquals(\"25\", config.getString(\"rowsPerPage\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEnvironmentConfiguration.java",
  "methodName" : "testAddProperty",
  "sourceCode" : "/**\r\n * Tries to add another property. This should cause an exception.\r\n */\r\n@Test\r\nvoid testAddProperty() {\r\n    assertThrows(UnsupportedOperationException.class, () -> config.addProperty(\"JAVA_HOME\", \"C:\\\\java\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEnvironmentConfiguration.java",
  "methodName" : "testClear",
  "sourceCode" : "/**\r\n * Tests removing all properties. This should not be possible.\r\n */\r\n@Test\r\nvoid testClear() {\r\n    assertThrows(UnsupportedOperationException.class, config::clear);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEnvironmentConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "/**\r\n * Tests removing properties. This should not be possible.\r\n */\r\n@Test\r\nvoid testClearProperty() {\r\n    final String key = config.getKeys().next();\r\n    assertThrows(UnsupportedOperationException.class, () -> config.clearProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEnvironmentConfiguration.java",
  "methodName" : "testInit",
  "sourceCode" : "/**\r\n * Tests whether a newly created configuration contains some properties. (We expect that at least some properties are\r\n * set in each environment.)\r\n */\r\n@Test\r\nvoid testInit() {\r\n    boolean found = false;\r\n    assertFalse(config.isEmpty());\r\n    for (final Iterator<String> it = config.getKeys(); it.hasNext(); ) {\r\n        final String key = it.next();\r\n        assertTrue(config.containsKey(key), \"Key not found: \" + key);\r\n        assertNotNull(config.getString(key), \"No value for property \" + key);\r\n        found = true;\r\n    }\r\n    assertTrue(found);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEnvironmentConfiguration.java",
  "methodName" : "testSetProperty",
  "sourceCode" : "/**\r\n * Tries to set the value of a property. This should cause an exception.\r\n */\r\n@Test\r\nvoid testSetProperty() {\r\n    assertThrows(UnsupportedOperationException.class, () -> config.setProperty(\"JAVA_HOME\", \"C:\\\\java\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEqualBehavior.java",
  "methodName" : "testAddingSet",
  "sourceCode" : "/**\r\n * If we add a to an existing key, does it work?\r\n */\r\n@Test\r\nvoid testAddingSet() throws Exception {\r\n    final Configuration simple = setupSimpleConfiguration();\r\n    final Configuration composite = setupCompositeConfiguration();\r\n    final String key = \"existing.property\";\r\n    final String value = \"new value\";\r\n    assertTrue(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    simple.addProperty(key, value);\r\n    composite.addProperty(key, value);\r\n    assertTrue(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    checkSameKey(\"testAddingSet\", key, simple, composite);\r\n    checkEquality(\"testAddingSet\", simple, composite);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEqualBehavior.java",
  "methodName" : "testAddingUnset",
  "sourceCode" : "/**\r\n * If we add a key, does it work?\r\n */\r\n@Test\r\nvoid testAddingUnset() throws Exception {\r\n    final Configuration simple = setupSimpleConfiguration();\r\n    final Configuration composite = setupCompositeConfiguration();\r\n    final String key = \"nonexisting.property\";\r\n    final String value = \"new value\";\r\n    assertFalse(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    simple.addProperty(key, value);\r\n    composite.addProperty(key, value);\r\n    checkSameKey(\"testAddingUnset\", key, simple, composite);\r\n    checkEquality(\"testAddingUnset\", simple, composite);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEqualBehavior.java",
  "methodName" : "testDeletingExisting",
  "sourceCode" : "/**\r\n * If we delete a key, does it vanish? Does it leave all the other keys unchanged? How about an unset key?\r\n */\r\n@Test\r\nvoid testDeletingExisting() throws Exception {\r\n    final Configuration simple = setupSimpleConfiguration();\r\n    final Configuration composite = setupCompositeConfiguration();\r\n    final String key = \"clear.property\";\r\n    assertTrue(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    simple.clearProperty(key);\r\n    composite.clearProperty(key);\r\n    assertFalse(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    checkEquality(\"testDeletingExisting\", simple, composite);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEqualBehavior.java",
  "methodName" : "testDeletingNonExisting",
  "sourceCode" : "@Test\r\nvoid testDeletingNonExisting() throws Exception {\r\n    final Configuration simple = setupSimpleConfiguration();\r\n    final Configuration composite = setupCompositeConfiguration();\r\n    final String key = \"nonexisting.clear.property\";\r\n    assertFalse(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    simple.clearProperty(key);\r\n    composite.clearProperty(key);\r\n    assertFalse(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    checkEquality(\"testDeletingNonExisting\", simple, composite);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEqualBehavior.java",
  "methodName" : "testLoading",
  "sourceCode" : "/**\r\n * Are both configurations equal after loading?\r\n */\r\n@Test\r\nvoid testLoading() throws Exception {\r\n    final Configuration simple = setupSimpleConfiguration();\r\n    final Configuration composite = setupCompositeConfiguration();\r\n    checkEquality(\"testLoading\", simple, composite);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEqualBehavior.java",
  "methodName" : "testSettingExisting",
  "sourceCode" : "@Test\r\nvoid testSettingExisting() throws Exception {\r\n    final Configuration simple = setupSimpleConfiguration();\r\n    final Configuration composite = setupCompositeConfiguration();\r\n    final String key = \"existing.property\";\r\n    final String value = \"new value\";\r\n    assertTrue(simple.containsKey(key));\r\n    assertNotEquals(value, simple.getString(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    simple.setProperty(key, value);\r\n    composite.setProperty(key, value);\r\n    assertTrue(simple.containsKey(key));\r\n    assertEquals(simple.getString(key), value);\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    checkSameKey(\"testSettingExisting\", key, simple, composite);\r\n    checkEquality(\"testSettingExisting\", simple, composite);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEqualBehavior.java",
  "methodName" : "testSettingNonExisting",
  "sourceCode" : "/**\r\n * If we set a key, does it work? How about an existing key? Can we change it?\r\n */\r\n@Test\r\nvoid testSettingNonExisting() throws Exception {\r\n    final Configuration simple = setupSimpleConfiguration();\r\n    final Configuration composite = setupCompositeConfiguration();\r\n    final String key = \"nonexisting.property\";\r\n    final String value = \"new value\";\r\n    assertFalse(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    simple.setProperty(key, value);\r\n    composite.setProperty(key, value);\r\n    assertTrue(simple.containsKey(key));\r\n    assertEquals(simple.containsKey(key), composite.containsKey(key));\r\n    checkSameKey(\"testSettingNonExisting\", key, simple, composite);\r\n    checkEquality(\"testSettingNonExisting\", simple, composite);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestEqualsProperty.java",
  "methodName" : "testEquals",
  "sourceCode" : "@Test\r\nvoid testEquals() throws Exception {\r\n    final PropertiesConfiguration conf = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setFileName(testProperties);\r\n    handler.load();\r\n    final String equals = conf.getString(\"test.equals\");\r\n    assertEquals(\"value=one\", equals);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testChildConfigurationsAtNotFound",
  "sourceCode" : "/**\r\n * Tests the result of childConfigurationsAt() if the key does not point to an existing node.\r\n */\r\n@Test\r\nvoid testChildConfigurationsAtNotFound() {\r\n    assertTrue(config.childConfigurationsAt(\"not.existing.key\").isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testChildConfigurationsAtNoUniqueKey",
  "sourceCode" : "/**\r\n * Tests the result of childConfigurationsAt() if the key selects multiple nodes.\r\n */\r\n@Test\r\nvoid testChildConfigurationsAtNoUniqueKey() {\r\n    assertTrue(config.childConfigurationsAt(\"tables.table\").isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testChildConfigurationsAtNoUpdates",
  "sourceCode" : "/**\r\n * Tests whether sub configurations for the children of a given node can be queried if no updates are propagated.\r\n */\r\n@Test\r\nvoid testChildConfigurationsAtNoUpdates() {\r\n    checkChildConfigurationsAtWithUpdates(false, NodeStructureHelper.table(0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testChildConfigurationsAtWithUpdates",
  "sourceCode" : "/**\r\n * Tests whether sub configurations for the children of a given node can be queried that support updates.\r\n */\r\n@Test\r\nvoid testChildConfigurationsAtWithUpdates() {\r\n    checkChildConfigurationsAtWithUpdates(true, NEW_NAME);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "@Test\r\nvoid testClone() {\r\n    final Configuration copy = (Configuration) config.clone();\r\n    assertInstanceOf(BaseHierarchicalConfiguration.class, copy);\r\n    config.setProperty(\"tables.table(0).name\", \"changed table name\");\r\n    checkContent(copy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtAttributeNode",
  "sourceCode" : "/**\r\n * Tests configurationAt() if the passed in key selects an attribute result.\r\n */\r\n@Test\r\nvoid testConfigurationAtAttributeNode() {\r\n    checkConfigurationAtAttributeNode(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtAttributeNodeWithUpdates",
  "sourceCode" : "/**\r\n * Tests configurationAt() if the passed in key selects an attribute result and the updates flag is set.\r\n */\r\n@Test\r\nvoid testConfigurationAtAttributeNodeWithUpdates() {\r\n    checkConfigurationAtAttributeNode(true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtClearAndDetach",
  "sourceCode" : "/**\r\n * Tests whether a {@code SubnodeConfiguration} can be cleared and its root node can be removed from its parent\r\n * configuration.\r\n */\r\n@Test\r\nvoid testConfigurationAtClearAndDetach() {\r\n    config.addProperty(\"test.sub.test\", \"success\");\r\n    config.addProperty(\"test.other\", \"check\");\r\n    final HierarchicalConfiguration<ImmutableNode> sub = config.configurationAt(\"test.sub\", true);\r\n    sub.clear();\r\n    assertTrue(sub.isEmpty());\r\n    assertNull(config.getString(\"test.sub.test\"));\r\n    sub.setProperty(\"test\", \"failure!\");\r\n    assertNull(config.getString(\"test.sub.test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtMultipleNodes",
  "sourceCode" : "/**\r\n * Tests the configurationAt() method if the passed in key selects multiple nodes. This should cause an exception.\r\n */\r\n@Test\r\nvoid testConfigurationAtMultipleNodes() {\r\n    assertThrows(ConfigurationRuntimeException.class, () -> config.configurationAt(\"tables.table.name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtMultipleNodesWithUpdates",
  "sourceCode" : "/**\r\n * Tests configurationAt() if the passed in key selects multiple nodes and the update flag is set.\r\n */\r\n@Test\r\nvoid testConfigurationAtMultipleNodesWithUpdates() {\r\n    assertThrows(ConfigurationRuntimeException.class, () -> config.configurationAt(\"tables.table.name\", true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtReadAccess",
  "sourceCode" : "/**\r\n * Tests whether a configuration obtained via configurationAt() contains the expected properties.\r\n */\r\n@Test\r\nvoid testConfigurationAtReadAccess() {\r\n    final HierarchicalConfiguration<ImmutableNode> subConfig = config.configurationAt(\"tables.table(1)\");\r\n    assertEquals(NodeStructureHelper.table(1), subConfig.getString(\"name\"));\r\n    final List<Object> lstFlds = subConfig.getList(\"fields.field.name\");\r\n    final List<String> expected = new ArrayList<>();\r\n    for (int i = 0; i < NodeStructureHelper.fieldsLength(1); i++) {\r\n        expected.add(NodeStructureHelper.field(1, i));\r\n    }\r\n    assertEquals(expected, lstFlds);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtUnknownSubTree",
  "sourceCode" : "/**\r\n * Tests the configurationAt() method if the passed in key does not exist.\r\n */\r\n@Test\r\nvoid testConfigurationAtUnknownSubTree() {\r\n    assertThrows(ConfigurationRuntimeException.class, () -> config.configurationAt(\"non.existing.key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtUnknownSubTreeWithUpdates",
  "sourceCode" : "/**\r\n * Tests configurationAt() for a non existing key if the update flag is set.\r\n */\r\n@Test\r\nvoid testConfigurationAtUnknownSubTreeWithUpdates() {\r\n    assertThrows(ConfigurationRuntimeException.class, () -> config.configurationAt(\"non.existing.key\", true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtUpdateParentConnected",
  "sourceCode" : "/**\r\n * Tests an update operation on a parent configuration if the sub configuration is connected.\r\n */\r\n@Test\r\nvoid testConfigurationAtUpdateParentConnected() {\r\n    final HierarchicalConfiguration<ImmutableNode> subConfig = config.configurationAt(\"tables.table(1)\", true);\r\n    config.setProperty(\"tables.table(1).fields.field(2).name\", \"testField\");\r\n    assertEquals(\"testField\", subConfig.getString(\"fields.field(2).name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtUpdateParentIndependent",
  "sourceCode" : "/**\r\n * Tests an update operation on a parent configuration if the sub configuration is independent.\r\n */\r\n@Test\r\nvoid testConfigurationAtUpdateParentIndependent() {\r\n    final HierarchicalConfiguration<ImmutableNode> subConfig = config.configurationAt(\"tables.table(1)\");\r\n    config.setProperty(\"tables.table(1).fields.field(2).name\", \"testField\");\r\n    assertEquals(NodeStructureHelper.field(1, 2), subConfig.getString(\"fields.field(2).name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtUpdateSubConfigConnected",
  "sourceCode" : "/**\r\n * Tests an update operation on a sub configuration which is connected to its parent.\r\n */\r\n@Test\r\nvoid testConfigurationAtUpdateSubConfigConnected() {\r\n    final HierarchicalConfiguration<ImmutableNode> subConfig = config.configurationAt(\"tables.table(1)\", true);\r\n    subConfig.setProperty(\"name\", \"testTable\");\r\n    assertEquals(\"testTable\", config.getString(\"tables.table(1).name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtUpdateSubConfigIndependent",
  "sourceCode" : "/**\r\n * Tests an update operation on a sub configuration which is independent on its parent.\r\n */\r\n@Test\r\nvoid testConfigurationAtUpdateSubConfigIndependent() {\r\n    final HierarchicalConfiguration<ImmutableNode> subConfig = config.configurationAt(\"tables.table(1)\");\r\n    subConfig.setProperty(\"name\", \"testTable\");\r\n    assertEquals(\"testTable\", subConfig.getString(\"name\"));\r\n    assertEquals(NodeStructureHelper.table(1), config.getString(\"tables.table(1).name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationAtWithUpdateInitialized",
  "sourceCode" : "/**\r\n * Tests whether a connected configuration is correctly initialized with properties of its parent.\r\n */\r\n@Test\r\nvoid testConfigurationAtWithUpdateInitialized() {\r\n    final String key = \"tables.table\";\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(';'));\r\n    config.setThrowExceptionOnMissing(true);\r\n    final List<HierarchicalConfiguration<ImmutableNode>> subs = config.configurationsAt(key, true);\r\n    final BaseHierarchicalConfiguration sub = (BaseHierarchicalConfiguration) subs.get(0);\r\n    assertEquals(config.getListDelimiterHandler(), sub.getListDelimiterHandler());\r\n    assertTrue(sub.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationsAtAttributeKey",
  "sourceCode" : "/**\r\n * Tests configurationsAt() if an attribute key is passed in.\r\n */\r\n@Test\r\nvoid testConfigurationsAtAttributeKey() {\r\n    final String attrKey = \"tables.table(0)[@type]\";\r\n    config.addProperty(attrKey, \"user\");\r\n    assertTrue(config.configurationsAt(attrKey).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationsAtEmpty",
  "sourceCode" : "/**\r\n * Tests the configurationsAt() method when the passed in key does not select any sub nodes.\r\n */\r\n@Test\r\nvoid testConfigurationsAtEmpty() {\r\n    assertTrue(config.configurationsAt(\"unknown.key\").isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationsAtNoUpdate",
  "sourceCode" : "/**\r\n * Tests the configurationsAt() method if the sub configurations are not connected.\r\n */\r\n@Test\r\nvoid testConfigurationsAtNoUpdate() {\r\n    checkConfigurationsAtWithUpdate(false, NodeStructureHelper.field(1, 0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testConfigurationsAtWithUpdates",
  "sourceCode" : "/**\r\n * Tests configurationsAt() if the sub configurations are connected.\r\n */\r\n@Test\r\nvoid testConfigurationsAtWithUpdates() {\r\n    checkConfigurationsAtWithUpdate(true, NEW_NAME);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testImmutableChildConfigurationsAt",
  "sourceCode" : "/**\r\n * Tests whether immutable configurations for the children of a given node can be queried.\r\n */\r\n@Test\r\nvoid testImmutableChildConfigurationsAt() {\r\n    final List<ImmutableHierarchicalConfiguration> children = config.immutableChildConfigurationsAt(\"tables.table(0)\");\r\n    assertEquals(2, children.size());\r\n    final ImmutableHierarchicalConfiguration c1 = children.get(0);\r\n    assertEquals(\"name\", c1.getRootElementName());\r\n    assertEquals(NodeStructureHelper.table(0), c1.getString(null));\r\n    final ImmutableHierarchicalConfiguration c2 = children.get(1);\r\n    assertEquals(\"fields\", c2.getRootElementName());\r\n    assertEquals(NodeStructureHelper.field(0, 0), c2.getString(\"field(0).name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testImmutableConfigurationAt",
  "sourceCode" : "/**\r\n * Tests whether an immutable configuration for a sub tree can be obtained.\r\n */\r\n@Test\r\nvoid testImmutableConfigurationAt() {\r\n    final ImmutableHierarchicalConfiguration subConfig = config.immutableConfigurationAt(\"tables.table(1)\");\r\n    assertEquals(NodeStructureHelper.table(1), subConfig.getString(\"name\"));\r\n    final List<Object> lstFlds = subConfig.getList(\"fields.field.name\");\r\n    final List<String> expected = new ArrayList<>();\r\n    for (int i = 0; i < NodeStructureHelper.fieldsLength(1); i++) {\r\n        expected.add(NodeStructureHelper.field(1, i));\r\n    }\r\n    assertEquals(expected, lstFlds);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testImmutableConfigurationAtSupportUpdates",
  "sourceCode" : "/**\r\n * Tests whether the support updates flag is taken into account when creating an immutable sub configuration.\r\n */\r\n@Test\r\nvoid testImmutableConfigurationAtSupportUpdates() {\r\n    final String newTableName = NodeStructureHelper.table(1) + \"_other\";\r\n    final ImmutableHierarchicalConfiguration subConfig = config.immutableConfigurationAt(\"tables.table(1)\", true);\r\n    config.addProperty(\"tables.table(-1).name\", newTableName);\r\n    config.clearTree(\"tables.table(1)\");\r\n    assertEquals(newTableName, subConfig.getString(\"name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testImmutableConfigurationsAt",
  "sourceCode" : "/**\r\n * Tests whether a list of immutable sub configurations can be queried.\r\n */\r\n@Test\r\nvoid testImmutableConfigurationsAt() {\r\n    final List<ImmutableHierarchicalConfiguration> lstFlds = config.immutableConfigurationsAt(\"tables.table(1).fields.field\");\r\n    checkSubConfigurations(lstFlds);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testInitCopy",
  "sourceCode" : "/**\r\n * Tests the copy constructor.\r\n */\r\n@Test\r\nvoid testInitCopy() {\r\n    final BaseHierarchicalConfiguration copy = new BaseHierarchicalConfiguration(config);\r\n    checkContent(copy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testInitCopyNull",
  "sourceCode" : "/**\r\n * Tests the copy constructor when a null reference is passed.\r\n */\r\n@Test\r\nvoid testInitCopyNull() {\r\n    final BaseHierarchicalConfiguration copy = new BaseHierarchicalConfiguration((HierarchicalConfiguration<ImmutableNode>) null);\r\n    assertTrue(copy.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testInitCopyUpdate",
  "sourceCode" : "/**\r\n * Tests whether the nodes of a copied configuration are independent from the source configuration.\r\n */\r\n@Test\r\nvoid testInitCopyUpdate() {\r\n    final BaseHierarchicalConfiguration copy = new BaseHierarchicalConfiguration(config);\r\n    config.setProperty(\"tables.table(0).name\", \"NewTable\");\r\n    checkContent(copy);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testInterpolatedConfiguration",
  "sourceCode" : "/**\r\n * Tests obtaining a configuration with all variables substituted.\r\n */\r\n@Test\r\nvoid testInterpolatedConfiguration() {\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    final BaseHierarchicalConfiguration c = (BaseHierarchicalConfiguration) InterpolationTestHelper.testInterpolatedConfiguration(config);\r\n    // tests whether the hierarchical structure has been maintained\r\n    checkContent(c);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testInterpolatedConfigurationEmpty",
  "sourceCode" : "/**\r\n * Tests whether interpolation works on an empty configuration.\r\n */\r\n@Test\r\nvoid testInterpolatedConfigurationEmpty() {\r\n    config = new BaseHierarchicalConfiguration();\r\n    assertTrue(config.interpolatedConfiguration().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testInterpolationSubset",
  "sourceCode" : "/**\r\n * Tests interpolation with a subset.\r\n */\r\n@Test\r\nvoid testInterpolationSubset() {\r\n    InterpolationTestHelper.testInterpolationSubset(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testInterpolationSubsetMultipleLayers",
  "sourceCode" : "/**\r\n * Tests whether interpolation with a subset configuration works over multiple layers.\r\n */\r\n@Test\r\nvoid testInterpolationSubsetMultipleLayers() {\r\n    config.clear();\r\n    config.addProperty(\"var\", \"value\");\r\n    config.addProperty(\"prop2.prop[@attr]\", \"${var}\");\r\n    final Configuration sub1 = config.subset(\"prop2\");\r\n    final Configuration sub2 = sub1.subset(\"prop\");\r\n    assertEquals(\"value\", sub2.getString(\"[@attr]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testSubset",
  "sourceCode" : "@Test\r\nvoid testSubset() {\r\n    // test the subset on the first table\r\n    Configuration subset = config.subset(\"tables.table(0)\");\r\n    assertEquals(NodeStructureHelper.table(0), subset.getProperty(\"name\"));\r\n    Object prop = subset.getProperty(\"fields.field.name\");\r\n    Collection<?> collection = assertInstanceOf(Collection.class, prop);\r\n    assertEquals(5, collection.size());\r\n    for (int i = 0; i < NodeStructureHelper.fieldsLength(0); i++) {\r\n        final DefaultConfigurationKey key = createConfigurationKey();\r\n        key.append(\"fields\").append(\"field\").appendIndex(i);\r\n        key.append(\"name\");\r\n        assertEquals(NodeStructureHelper.field(0, i), subset.getProperty(key.toString()));\r\n    }\r\n    // test the subset on the second table\r\n    assertTrue(config.subset(\"tables.table(2)\").isEmpty());\r\n    // test the subset on the fields\r\n    subset = config.subset(\"tables.table.fields.field\");\r\n    prop = subset.getProperty(\"name\");\r\n    collection = assertInstanceOf(Collection.class, prop);\r\n    int expectedFieldCount = 0;\r\n    for (int i = 0; i < NodeStructureHelper.tablesLength(); i++) {\r\n        expectedFieldCount += NodeStructureHelper.fieldsLength(i);\r\n    }\r\n    assertEquals(expectedFieldCount, collection.size());\r\n    assertEquals(NodeStructureHelper.field(0, 0), subset.getProperty(\"name(0)\"));\r\n    // test the subset on the field names\r\n    subset = config.subset(\"tables.table.fields.field.name\");\r\n    assertTrue(subset.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testSubsetAttributeResult",
  "sourceCode" : "/**\r\n * Tests subset() if the passed in key selects an attribute.\r\n */\r\n@Test\r\nvoid testSubsetAttributeResult() {\r\n    final String key = \"tables.table(0)[@type]\";\r\n    config.addProperty(key, \"system\");\r\n    final BaseHierarchicalConfiguration subset = (BaseHierarchicalConfiguration) config.subset(key);\r\n    assertTrue(subset.getModel().getNodeHandler().getRootNode().getChildren().isEmpty());\r\n    assertEquals(\"system\", subset.getString(\"[@type]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testSubsetMultipleNodesWithValues",
  "sourceCode" : "/**\r\n * Tests the subset() method if the specified key selects multiple keys. The resulting root node should have a value\r\n * only if exactly one of the selected nodes has a value. Related to CONFIGURATION-295.\r\n */\r\n@Test\r\nvoid testSubsetMultipleNodesWithValues() {\r\n    config.setProperty(\"tables.table(0).fields\", \"My fields\");\r\n    Configuration subset = config.subset(\"tables.table.fields\");\r\n    assertEquals(\"My fields\", subset.getString(\"\"));\r\n    config.setProperty(\"tables.table(1).fields\", \"My other fields\");\r\n    subset = config.subset(\"tables.table.fields\");\r\n    assertNull(subset.getString(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfiguration.java",
  "methodName" : "testSubsetNodeWithValue",
  "sourceCode" : "/**\r\n * Tests the subset() method if the specified node has a value. This value must be available in the subset, too. Related\r\n * to CONFIGURATION-295.\r\n */\r\n@Test\r\nvoid testSubsetNodeWithValue() {\r\n    config.setProperty(\"tables.table(0).fields\", \"My fields\");\r\n    final Configuration subset = config.subset(\"tables.table(0).fields\");\r\n    assertEquals(NodeStructureHelper.field(0, 0), subset.getString(\"field(0).name\"));\r\n    assertEquals(\"My fields\", subset.getString(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalConfigurationXMLReader.java",
  "methodName" : "testParse",
  "sourceCode" : "@Test\r\nvoid testParse() throws Exception {\r\n    final SAXSource source = new SAXSource(parser, new InputSource());\r\n    final DOMResult result = new DOMResult();\r\n    final Transformer trans = TransformerFactory.newInstance().newTransformer();\r\n    trans.transform(source, result);\r\n    final Node root = ((Document) result.getNode()).getDocumentElement();\r\n    final JXPathContext ctx = JXPathContext.newContext(root);\r\n    assertEquals(\"database\", root.getNodeName());\r\n    assertEquals(1, ctx.selectNodes(\"/*\").size());\r\n    assertEquals(2, ctx.selectNodes(\"/tables/table\").size());\r\n    assertEquals(\"users\", ctx.getValue(\"/tables/table[1]/name\"));\r\n    assertEquals(5, ctx.selectNodes(\"/tables/table[1]/fields/field\").size());\r\n    assertEquals(\"system\", ctx.getValue(\"/tables/table[1]/@tableType\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() throws Exception {\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.setFileName(TEST_FILE);\r\n    handler.load();\r\n    configTest(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testLoadBasePath1",
  "sourceCode" : "@Test\r\nvoid testLoadBasePath1() throws Exception {\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.setBasePath(TEST_DIR);\r\n    handler.setFileName(TEST_FILENAME);\r\n    handler.load();\r\n    configTest(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testLoadBasePath2",
  "sourceCode" : "@Test\r\nvoid testLoadBasePath2() throws Exception {\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.setBasePath(new File(TEST_FILE).getAbsoluteFile().toURI().toURL().toString());\r\n    handler.setFileName(TEST_FILENAME);\r\n    handler.load();\r\n    configTest(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testLoadURL",
  "sourceCode" : "@Test\r\nvoid testLoadURL() throws Exception {\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.load(new File(TEST_FILE).getAbsoluteFile().toURI().toURL());\r\n    configTest(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testRootElement",
  "sourceCode" : "/**\r\n * Tests manipulation of the root element's name.\r\n */\r\n@Test\r\nvoid testRootElement() throws Exception {\r\n    assertEquals(\"configuration\", config.getRootElementName());\r\n    config.setRootElementName(\"newRootName\");\r\n    assertEquals(\"newRootName\", config.getRootElementName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "@Test\r\nvoid testSave() throws Exception {\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.setFileName(TEST_FILE3);\r\n    handler.load();\r\n    final File saveFile = newFile(TEST_SAVENAME, tempFolder);\r\n    handler.save(saveFile);\r\n    config = new XMLConfiguration();\r\n    final FileHandler handler2 = new FileHandler(config);\r\n    handler2.load(saveFile.toURI().toURL());\r\n    assertEquals(\"value\", config.getProperty(\"element\"));\r\n    assertEquals(\"I'm complex!\", config.getProperty(\"element2.subelement.subsubelement\"));\r\n    assertEquals(8, config.getInt(\"test.short\"));\r\n    assertEquals(\"one\", config.getString(\"list(0).item(0)[@name]\"));\r\n    assertEquals(\"two\", config.getString(\"list(0).item(1)\"));\r\n    assertEquals(\"six\", config.getString(\"list(1).sublist.item(1)\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testSaveModified",
  "sourceCode" : "/**\r\n * Tests to save a modified configuration.\r\n */\r\n@Test\r\nvoid testSaveModified() throws Exception {\r\n    FileHandler handler = new FileHandler(config);\r\n    handler.setFile(new File(TEST_FILE3));\r\n    handler.load();\r\n    assertTrue(config.getString(\"mean\").startsWith(\"This is\\n A long story...\"));\r\n    assertTrue(config.getString(\"mean\").indexOf(\"And even longer\") > 0);\r\n    config.clearProperty(\"test.entity[@name]\");\r\n    config.setProperty(\"element\", \"new value\");\r\n    config.setProperty(\"test(0)\", \"A <new> value\");\r\n    config.addProperty(\"test(1).int\", Integer.valueOf(9));\r\n    config.addProperty(\"list(1).sublist.item\", \"seven\");\r\n    config.setProperty(\"clear\", \"yes\");\r\n    config.setProperty(\"mean\", \"now it's simple\");\r\n    config.addProperty(\"[@topattr]\", \"available\");\r\n    config.addProperty(\"[@topattr_other]\", \"successfull\");\r\n    final File saveFile = newFile(TEST_SAVENAME, tempFolder);\r\n    handler.save(saveFile);\r\n    config = new XMLConfiguration();\r\n    handler = new FileHandler(config);\r\n    handler.load(saveFile.getAbsolutePath());\r\n    assertFalse(config.containsKey(\"test.entity[@name]\"));\r\n    assertEquals(\"1<2\", config.getProperty(\"test.entity\"));\r\n    assertEquals(\"new value\", config.getString(\"element\"));\r\n    assertEquals(\"A <new> value\", config.getProperty(\"test(0)\"));\r\n    assertEquals((short) 8, config.getShort(\"test(1).short\"));\r\n    assertEquals(9, config.getInt(\"test(1).int\"));\r\n    assertEquals(\"six\", config.getProperty(\"list(1).sublist.item(1)\"));\r\n    assertEquals(\"seven\", config.getProperty(\"list(1).sublist.item(2)\"));\r\n    assertEquals(\"yes\", config.getProperty(\"clear\"));\r\n    assertEquals(\"now it's simple\", config.getString(\"mean\"));\r\n    assertEquals(\"available\", config.getString(\"[@topattr](0)\"));\r\n    assertEquals(\"successfull\", config.getString(\"[@topattr_other]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testSaveNew",
  "sourceCode" : "/**\r\n * Tests to save a newly created configuration.\r\n */\r\n@Test\r\nvoid testSaveNew() throws Exception {\r\n    config.addProperty(\"connection.url\", \"jdbc://mydb:1234\");\r\n    config.addProperty(\"connection.user\", \"scott\");\r\n    config.addProperty(\"connection.passwd\", \"tiger\");\r\n    config.addProperty(\"connection[@type]\", \"system\");\r\n    config.addProperty(\"tables.table.name\", \"tests\");\r\n    config.addProperty(\"tables.table(0).fields.field.name\", \"test_id\");\r\n    config.addProperty(\"tables.table(0).fields.field(-1).name\", \"test_name\");\r\n    config.addProperty(\"tables.table(-1).name\", \"results\");\r\n    config.addProperty(\"tables.table(1).fields.field.name\", \"res_id\");\r\n    config.addProperty(\"tables.table(1).fields.field(0).type\", \"int\");\r\n    config.addProperty(\"tables.table(1).fields.field(-1).name\", \"value\");\r\n    config.addProperty(\"tables.table(1).fields.field(1).type\", \"string\");\r\n    config.addProperty(\"tables.table(1).fields.field(1)[@null]\", \"true\");\r\n    config.setRootElementName(\"myconfig\");\r\n    final File saveFile = newFile(TEST_SAVENAME, tempFolder);\r\n    FileHandler handler = new FileHandler(config);\r\n    handler.setFile(saveFile);\r\n    handler.save();\r\n    config = new XMLConfiguration();\r\n    handler = new FileHandler(config);\r\n    handler.load(saveFile);\r\n    assertEquals(1, config.getMaxIndex(\"tables.table.name\"));\r\n    assertEquals(\"tests\", config.getString(\"tables.table(0).name\"));\r\n    assertEquals(\"test_name\", config.getString(\"tables.table(0).fields.field(1).name\"));\r\n    assertEquals(\"int\", config.getString(\"tables.table(1).fields.field(0).type\"));\r\n    assertTrue(config.getBoolean(\"tables.table(1).fields.field(1)[@null]\"));\r\n    assertEquals(\"tiger\", config.getString(\"connection.passwd\"));\r\n    assertEquals(\"system\", config.getProperty(\"connection[@type]\"));\r\n    assertEquals(\"myconfig\", config.getRootElementName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testSetRootElementNameWhenLoadedFromFile",
  "sourceCode" : "/**\r\n * Tests that it is not allowed to change the root element name when the configuration was loaded from a file.\r\n */\r\n@Test\r\nvoid testSetRootElementNameWhenLoadedFromFile() throws Exception {\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.setFile(new File(TEST_FILE3));\r\n    handler.load();\r\n    assertEquals(\"testconfig\", config.getRootElementName());\r\n    assertThrows(UnsupportedOperationException.class, () -> config.setRootElementName(\"anotherRootElement\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestHierarchicalXMLConfiguration.java",
  "methodName" : "testXmlNodeTypes",
  "sourceCode" : "/**\r\n * Ensure various node types are correctly processed in config.\r\n */\r\n@Test\r\nvoid testXmlNodeTypes() throws Exception {\r\n    // Number of keys expected from test configuration file\r\n    final int keyCount = 5;\r\n    // Load the configuration file\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.load(new File(TEST_FILE2).getAbsoluteFile().toURI().toURL());\r\n    // Validate comment in element ignored\r\n    assertEquals(\"Case1Text\", config.getString(\"case1\"));\r\n    // Validate sibling comment ignored\r\n    assertEquals(\"Case2Text\", config.getString(\"case2.child\"));\r\n    // Validate comment ignored, CDATA processed\r\n    assertEquals(\"Case3Text\", config.getString(\"case3\"));\r\n    // Validate comment and processing instruction ignored\r\n    assertEquals(\"Case4Text\", config.getString(\"case4\"));\r\n    // Validate comment ignored in parent attribute\r\n    assertEquals(\"Case5Text\", config.getString(\"case5[@attr]\"));\r\n    // Validate non-text nodes haven't snuck in as keys\r\n    final Iterator<String> iter = config.getKeys();\r\n    int count = 0;\r\n    while (iter.hasNext()) {\r\n        iter.next();\r\n        count++;\r\n    }\r\n    assertEquals(keyCount, count);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testExceptionHandling",
  "sourceCode" : "/**\r\n * Tests that exceptions thrown by the wrapped configuration are handled correctly.\r\n */\r\n@Test\r\nvoid testExceptionHandling() {\r\n    final PropertiesConfiguration config = new PropertiesConfiguration();\r\n    final String property = \"nonExistingProperty\";\r\n    config.setThrowExceptionOnMissing(true);\r\n    final ImmutableConfiguration ic = ConfigurationUtils.unmodifiableConfiguration(config);\r\n    final NoSuchElementException e = assertThrows(NoSuchElementException.class, () -> ic.getString(property));\r\n    assertTrue(e.getMessage().contains(property));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testImmutableSubset",
  "sourceCode" : "/**\r\n * Tests whether an immutable subset can be queried.\r\n */\r\n@Test\r\nvoid testImmutableSubset() throws ConfigurationException {\r\n    final ImmutableConfiguration conf = ConfigurationUtils.unmodifiableConfiguration(createTestConfig());\r\n    final ImmutableConfiguration subset = conf.immutableSubset(\"test\");\r\n    assertFalse(subset.isEmpty());\r\n    assertEquals(1000000, subset.getLong(\"long\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testUnmodifiableConfigurationAccess",
  "sourceCode" : "/**\r\n * Tests whether data can be accessed from an unmodifiable configuration.\r\n */\r\n@Test\r\nvoid testUnmodifiableConfigurationAccess() throws ConfigurationException {\r\n    final Configuration confOrg = createTestConfig();\r\n    final ImmutableConfiguration conf = ConfigurationUtils.unmodifiableConfiguration(confOrg);\r\n    assertFalse(conf.isEmpty());\r\n    for (final Iterator<String> it = confOrg.getKeys(); it.hasNext(); ) {\r\n        final String key = it.next();\r\n        assertTrue(conf.containsKey(key), \"Key not contained: \" + key);\r\n        assertEquals(confOrg.getProperty(key), conf.getProperty(key), \"Wrong value for \" + key);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testUnmodifiableConfigurationCast",
  "sourceCode" : "/**\r\n * Tests that a cast to a mutable configuration is not possible.\r\n */\r\n@Test\r\nvoid testUnmodifiableConfigurationCast() throws ConfigurationException {\r\n    final ImmutableConfiguration conf = ConfigurationUtils.unmodifiableConfiguration(createTestConfig());\r\n    assertThrows(ClassCastException.class, () -> {\r\n        final Configuration mutableConf = (Configuration) conf;\r\n        mutableConf.clear();\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testUnmodifiableConfigurationIterate",
  "sourceCode" : "/**\r\n * Tests an iteration over the keys of the immutable configuration.\r\n */\r\n@Test\r\nvoid testUnmodifiableConfigurationIterate() throws ConfigurationException {\r\n    final Configuration confOrg = createTestConfig();\r\n    final ImmutableConfiguration conf = ConfigurationUtils.unmodifiableConfiguration(confOrg);\r\n    assertEquals(fetchKeys(confOrg.getKeys()), fetchKeys(conf.getKeys()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testUnmodifiableConfigurationIteratorRemove",
  "sourceCode" : "/**\r\n * Tests that it is not possible to remove keys using the iterator.\r\n */\r\n@Test\r\nvoid testUnmodifiableConfigurationIteratorRemove() throws ConfigurationException {\r\n    final ImmutableConfiguration conf = ConfigurationUtils.unmodifiableConfiguration(createTestConfig());\r\n    final Iterator<String> it = conf.getKeys();\r\n    it.next();\r\n    assertThrows(UnsupportedOperationException.class, it::remove);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testUnmodifiableConfigurationLiveUpdate",
  "sourceCode" : "/**\r\n * Tests whether an update of the original configuration is visible for the immutable view.\r\n */\r\n@Test\r\nvoid testUnmodifiableConfigurationLiveUpdate() throws ConfigurationException {\r\n    final Configuration confOrg = createTestConfig();\r\n    final ImmutableConfiguration conf = ConfigurationUtils.unmodifiableConfiguration(confOrg);\r\n    final String key = \"new.property\";\r\n    final String value = \"new value\";\r\n    confOrg.addProperty(key, value);\r\n    assertEquals(value, conf.getString(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testUnmodifiableConfigurationNull",
  "sourceCode" : "/**\r\n * Tries to create an immutable configuration from a null object.\r\n */\r\n@Test\r\nvoid testUnmodifiableConfigurationNull() {\r\n    assertThrows(NullPointerException.class, () -> ConfigurationUtils.unmodifiableConfiguration(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testUnmodifiableConfigurationOtherTypes",
  "sourceCode" : "/**\r\n * Tests different access methods for properties.\r\n */\r\n@Test\r\nvoid testUnmodifiableConfigurationOtherTypes() throws ConfigurationException {\r\n    final ImmutableConfiguration conf = ConfigurationUtils.unmodifiableConfiguration(createTestConfig());\r\n    assertEquals((byte) 10, conf.getByte(\"test.byte\"));\r\n    assertTrue(conf.getBoolean(\"test.boolean\"));\r\n    assertEquals(10.25, conf.getDouble(\"test.double\"), .05);\r\n    assertEquals(20.25f, conf.getFloat(\"test.float\"), .05);\r\n    assertEquals(10, conf.getInt(\"test.integer\"));\r\n    assertEquals(1000000L, conf.getLong(\"test.long\"));\r\n    assertEquals((short) 1, conf.getShort(\"test.short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestImmutableConfiguration.java",
  "methodName" : "testUnmodifiableHierarchicalConfiguration",
  "sourceCode" : "/**\r\n * Tests whether an unmodifiable hierarchical configuration can be created.\r\n */\r\n@Test\r\nvoid testUnmodifiableHierarchicalConfiguration() {\r\n    final HierarchicalConfiguration<?> conf = new BaseHierarchicalConfiguration();\r\n    final String key = \"test\";\r\n    conf.addProperty(key, Boolean.TRUE);\r\n    final ImmutableHierarchicalConfiguration ihc = ConfigurationUtils.unmodifiableConfiguration(conf);\r\n    assertTrue(ihc.getBoolean(key));\r\n    assertEquals(0, ihc.getMaxIndex(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testCommentLeadingSeparatorUsedInINIInput",
  "sourceCode" : "/**\r\n * Test of read method with changed comment leading separator\r\n */\r\n@Test\r\nvoid testCommentLeadingSeparatorUsedInINIInput() throws Exception {\r\n    final String inputCommentLeadingSeparator = \";\";\r\n    final String input = \"[section]\" + LINE_SEPARATOR + \"key1=a;b;c\" + LINE_SEPARATOR + \"key2=a#b#c\" + LINE_SEPARATOR + \";key3=value3\" + LINE_SEPARATOR + \"#key4=value4\" + LINE_SEPARATOR;\r\n    final INIConfiguration instance = new FileBasedConfigurationBuilder<>(INIConfiguration.class).configure(new Parameters().ini().setCommentLeadingCharsUsedInInput(inputCommentLeadingSeparator)).getConfiguration();\r\n    load(instance, input);\r\n    assertEquals(\"a;b;c\", instance.getString(\"section.key1\"));\r\n    assertEquals(\"a#b#c\", instance.getString(\"section.key2\"));\r\n    assertNull(instance.getString(\"section.;key3\"));\r\n    assertEquals(\"value4\", instance.getString(\"section.#key4\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testEmptySection",
  "sourceCode" : "/**\r\n * Tests correct handling of empty sections \"[ ]\".\r\n */\r\n@Test\r\nvoid testEmptySection() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(\"[]\" + LINE_SEPARATOR + \"key=value\" + LINE_SEPARATOR);\r\n    final String value = config.getString(\" .key\");\r\n    assertEquals(\"value\", value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testExpressionEngineIgnoringCase",
  "sourceCode" : "/**\r\n * Tests whether an expression engine can be used which ignores case.\r\n */\r\n@Test\r\nvoid testExpressionEngineIgnoringCase() throws ConfigurationException {\r\n    final DefaultExpressionEngine engine = new DefaultExpressionEngine(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS, NodeNameMatchers.EQUALS_IGNORE_CASE);\r\n    final INIConfiguration config = new INIConfiguration();\r\n    config.setExpressionEngine(engine);\r\n    load(config, INI_DATA);\r\n    checkContent(config);\r\n    assertEquals(\"foo\", config.getString(\"Section1.var1\"));\r\n    assertEquals(\"foo\", config.getString(\"section1.Var1\"));\r\n    assertEquals(\"foo\", config.getString(\"SECTION1.VAR1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetPropertyNoKey",
  "sourceCode" : "/**\r\n * Tests a property that has no key.\r\n */\r\n@Test\r\nvoid testGetPropertyNoKey() throws ConfigurationException {\r\n    final String data = INI_DATA2 + LINE_SEPARATOR + \"= noKey\" + LINE_SEPARATOR;\r\n    final INIConfiguration config = setUpConfig(data);\r\n    assertEquals(\"noKey\", config.getString(\"section4. \"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetPropertyNoValue",
  "sourceCode" : "/**\r\n * Tests a property that has no value.\r\n */\r\n@Test\r\nvoid testGetPropertyNoValue() throws ConfigurationException {\r\n    final String data = INI_DATA2 + LINE_SEPARATOR + \"noValue =\" + LINE_SEPARATOR;\r\n    final INIConfiguration config = setUpConfig(data);\r\n    assertEquals(\"\", config.getString(\"section4.noValue\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionConnected",
  "sourceCode" : "/**\r\n * Tests whether the sub configuration returned by getSection() is connected to the parent.\r\n */\r\n@Test\r\nvoid testGetSectionConnected() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA);\r\n    final HierarchicalConfiguration<ImmutableNode> section = config.getSection(\"section1\");\r\n    section.setProperty(\"var1\", \"foo2\");\r\n    assertEquals(\"foo2\", config.getString(\"section1.var1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionDuplicate",
  "sourceCode" : "/**\r\n * Tests whether getSection() can deal with duplicate sections.\r\n */\r\n@Test\r\nvoid testGetSectionDuplicate() {\r\n    final INIConfiguration config = new INIConfiguration();\r\n    config.addProperty(\"section.var1\", \"value1\");\r\n    config.addProperty(\"section(-1).var2\", \"value2\");\r\n    final HierarchicalConfiguration<ImmutableNode> section = config.getSection(\"section\");\r\n    final Iterator<String> keys = section.getKeys();\r\n    assertEquals(\"var1\", keys.next());\r\n    assertFalse(keys.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionExisting",
  "sourceCode" : "/**\r\n * Tests querying the properties of an existing section.\r\n */\r\n@Test\r\nvoid testGetSectionExisting() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA);\r\n    final HierarchicalConfiguration<ImmutableNode> section = config.getSection(\"section1\");\r\n    assertEquals(\"foo\", section.getString(\"var1\"));\r\n    assertEquals(\"451\", section.getString(\"var2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionGloabalMultiThreaded",
  "sourceCode" : "/**\r\n * Tests concurrent access to the global section.\r\n */\r\n@Test\r\nvoid testGetSectionGloabalMultiThreaded() throws ConfigurationException, InterruptedException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    config.setSynchronizer(new ReadWriteSynchronizer());\r\n    final int threadCount = 10;\r\n    final GlobalSectionTestThread[] threads = new GlobalSectionTestThread[threadCount];\r\n    for (int i = 0; i < threadCount; i++) {\r\n        threads[i] = new GlobalSectionTestThread(config);\r\n        threads[i].start();\r\n    }\r\n    for (int i = 0; i < threadCount; i++) {\r\n        threads[i].join();\r\n        assertFalse(threads[i].error);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionGlobal",
  "sourceCode" : "/**\r\n * Tests querying the content of the global section.\r\n */\r\n@Test\r\nvoid testGetSectionGlobal() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    final HierarchicalConfiguration<ImmutableNode> section = config.getSection(null);\r\n    assertEquals(\"testGlobal\", section.getString(\"globalVar\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionGlobalNonExisting",
  "sourceCode" : "/**\r\n * Tests querying the content of the global section if there is none.\r\n */\r\n@Test\r\nvoid testGetSectionGlobalNonExisting() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA);\r\n    final HierarchicalConfiguration<ImmutableNode> section = config.getSection(null);\r\n    assertTrue(section.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionMerged",
  "sourceCode" : "/**\r\n * Tests querying the properties of a section that was merged from two sections with the same name.\r\n */\r\n@Test\r\nvoid testGetSectionMerged() throws ConfigurationException {\r\n    final String data = INI_DATA + \"[section1]\" + LINE_SEPARATOR + \"var3 = merged\" + LINE_SEPARATOR;\r\n    final INIConfiguration config = setUpConfig(data);\r\n    final HierarchicalConfiguration<ImmutableNode> section = config.getSection(\"section1\");\r\n    assertEquals(\"foo\", section.getString(\"var1\"));\r\n    assertEquals(\"451\", section.getString(\"var2\"));\r\n    assertEquals(\"merged\", section.getString(\"var3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionNonExisting",
  "sourceCode" : "/**\r\n * Tests querying a non existing section.\r\n */\r\n@Test\r\nvoid testGetSectionNonExisting() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA);\r\n    final HierarchicalConfiguration<ImmutableNode> section = config.getSection(\"Non existing section\");\r\n    assertTrue(section.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionNonExistingManipulate",
  "sourceCode" : "/**\r\n * Tests whether a section that was created by getSection() can be manipulated.\r\n */\r\n@Test\r\nvoid testGetSectionNonExistingManipulate() throws ConfigurationException, IOException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA);\r\n    HierarchicalConfiguration<ImmutableNode> section = config.getSection(\"newSection\");\r\n    section.addProperty(\"test\", \"success\");\r\n    assertEquals(\"success\", config.getString(\"newSection.test\"));\r\n    final StringWriter writer = new StringWriter();\r\n    config.write(writer);\r\n    final INIConfiguration config2 = setUpConfig(writer.toString());\r\n    section = config2.getSection(\"newSection\");\r\n    assertEquals(\"success\", section.getString(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSections",
  "sourceCode" : "/**\r\n * Test of getSections method, of class {@link INIConfiguration}.\r\n */\r\n@Test\r\nvoid testGetSections() {\r\n    final INIConfiguration instance = new INIConfiguration();\r\n    instance.addProperty(\"test1.foo\", \"bar\");\r\n    instance.addProperty(\"test2.foo\", \"abc\");\r\n    final Set<String> expResult = new HashSet<>();\r\n    expResult.add(\"test1\");\r\n    expResult.add(\"test2\");\r\n    final Set<String> result = instance.getSections();\r\n    assertEquals(expResult, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionsAdded",
  "sourceCode" : "/**\r\n * Tests whether a section added later is also found by getSections().\r\n */\r\n@Test\r\nvoid testGetSectionsAdded() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA2);\r\n    config.addProperty(\"section5.test\", Boolean.TRUE);\r\n    checkSectionNames(config, new String[] { \"section4\", \"section5\" });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionsDottedVar",
  "sourceCode" : "/**\r\n * Tests whether variables containing a dot are not misinterpreted as sections. This test is related to\r\n * CONFIGURATION-327.\r\n */\r\n@Test\r\nvoid testGetSectionsDottedVar() throws ConfigurationException {\r\n    final String data = \"dotted.var = 1\" + LINE_SEPARATOR + INI_DATA_GLOBAL;\r\n    final INIConfiguration config = checkSectionNames(data, new String[] { null, \"section1\", \"section2\", \"section3\" });\r\n    assertEquals(1, config.getInt(\"dotted..var\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionsGlobalOnly",
  "sourceCode" : "/**\r\n * Tests whether the sections of a configuration can be queried that contains only a global section.\r\n */\r\n@Test\r\nvoid testGetSectionsGlobalOnly() throws ConfigurationException {\r\n    checkSectionNames(INI_DATA_GLOBAL_ONLY, new String[] { null });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionsNoGlobal",
  "sourceCode" : "/**\r\n * Tests querying the sections if there is no global section.\r\n */\r\n@Test\r\nvoid testGetSectionsNoGlobal() throws ConfigurationException {\r\n    checkSectionNames(INI_DATA, new String[] { \"section1\", \"section2\", \"section3\" });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionsSynchronized",
  "sourceCode" : "/**\r\n * Tests whether synchronization is performed when querying the configuration's sections.\r\n */\r\n@Test\r\nvoid testGetSectionsSynchronized() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA);\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    config.setSynchronizer(sync);\r\n    assertFalse(config.getSections().isEmpty());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionsWithGlobal",
  "sourceCode" : "/**\r\n * Tests querying the sections if a global section if available.\r\n */\r\n@Test\r\nvoid testGetSectionsWithGlobal() throws ConfigurationException {\r\n    checkSectionNames(INI_DATA_GLOBAL, new String[] { null, \"section1\", \"section2\", \"section3\" });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGetSectionsWithInLineComment",
  "sourceCode" : "/**\r\n * Tests whether a section with inline comment is correctly parsed.\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"provideSectionsWithComments\")\r\nvoid testGetSectionsWithInLineComment(final String source, final boolean allowComments, final String[] results) throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(source, allowComments);\r\n    checkSectionNames(config, results);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGlobalProperty",
  "sourceCode" : "/**\r\n * Tests reading a property from the global section.\r\n */\r\n@Test\r\nvoid testGlobalProperty() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    assertEquals(\"testGlobal\", config.getString(\"globalVar\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGlobalSectionConnected",
  "sourceCode" : "/**\r\n * Tests whether the sub configuration for the global section is connected to its parent.\r\n */\r\n@Test\r\nvoid testGlobalSectionConnected() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    final HierarchicalConfiguration<ImmutableNode> sub = config.getSection(null);\r\n    config.setProperty(\"globalVar\", \"changed\");\r\n    assertEquals(\"changed\", sub.getString(\"globalVar\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGlobalSectionNodeHandlerGetChildByIndex",
  "sourceCode" : "/**\r\n * Tests whether the node handler of a global section correctly returns a child by index.\r\n */\r\n@Test\r\nvoid testGlobalSectionNodeHandlerGetChildByIndex() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    final SubnodeConfiguration sub = config.getSection(null);\r\n    final NodeHandler<ImmutableNode> handler = sub.getModel().getNodeHandler();\r\n    final ImmutableNode rootNode = handler.getRootNode();\r\n    final ImmutableNode child = handler.getChild(rootNode, 0);\r\n    assertEquals(\"globalVar\", child.getNodeName());\r\n    assertThrows(IndexOutOfBoundsException.class, () -> handler.getChild(rootNode, 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGlobalSectionNodeHandlerGetChildrenByName",
  "sourceCode" : "/**\r\n * Tests whether the node handler of a global section correctly filters named children.\r\n */\r\n@Test\r\nvoid testGlobalSectionNodeHandlerGetChildrenByName() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    final SubnodeConfiguration sub = config.getSection(null);\r\n    final NodeHandler<ImmutableNode> handler = sub.getModel().getNodeHandler();\r\n    assertTrue(handler.getChildren(sub.getModel().getNodeHandler().getRootNode(), \"section1\").isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGlobalSectionNodeHandlerGetChildrenCount",
  "sourceCode" : "/**\r\n * Tests whether the node handler of a global section correctly determines the number of children.\r\n */\r\n@Test\r\nvoid testGlobalSectionNodeHandlerGetChildrenCount() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    final SubnodeConfiguration sub = config.getSection(null);\r\n    final NodeHandler<ImmutableNode> handler = sub.getModel().getNodeHandler();\r\n    assertEquals(1, handler.getChildrenCount(handler.getRootNode(), null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testGlobalSectionNodeHandlerIndexOfChild",
  "sourceCode" : "/**\r\n * Tests whether the node handler of a global section correctly determines the index of a child.\r\n */\r\n@Test\r\nvoid testGlobalSectionNodeHandlerIndexOfChild() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    final SubnodeConfiguration sub = config.getSection(null);\r\n    final NodeHandler<ImmutableNode> handler = sub.getModel().getNodeHandler();\r\n    final List<ImmutableNode> children = handler.getRootNode().getChildren();\r\n    assertEquals(0, handler.indexOfChild(handler.getRootNode(), children.get(0)));\r\n    assertEquals(-1, handler.indexOfChild(handler.getRootNode(), children.get(1)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testIsCommentLine",
  "sourceCode" : "/**\r\n * Test of isCommentLine method, of class {@link INIConfiguration}.\r\n */\r\n@Test\r\nvoid testIsCommentLine() {\r\n    final INIConfiguration instance = new INIConfiguration();\r\n    assertTrue(instance.isCommentLine(\"#comment1\"));\r\n    assertTrue(instance.isCommentLine(\";comment1\"));\r\n    assertFalse(instance.isCommentLine(\"nocomment=true\"));\r\n    assertFalse(instance.isCommentLine(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testIsSectionLine",
  "sourceCode" : "/**\r\n * Test of isSectionLine method, of class {@link INIConfiguration}.\r\n */\r\n@Test\r\nvoid testIsSectionLine() {\r\n    final INIConfiguration instance = new INIConfiguration();\r\n    assertTrue(instance.isSectionLine(\"[section]\"));\r\n    assertFalse(instance.isSectionLine(\"nosection=true\"));\r\n    assertFalse(instance.isSectionLine(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testKeysOfGlobalSection",
  "sourceCode" : "/**\r\n * Tests whether only properties with values occur in the enumeration of the global section.\r\n */\r\n@Test\r\nvoid testKeysOfGlobalSection() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_GLOBAL);\r\n    final HierarchicalConfiguration<ImmutableNode> sub = config.getSection(null);\r\n    final Iterator<String> keys = sub.getKeys();\r\n    assertEquals(\"globalVar\", keys.next());\r\n    if (keys.hasNext()) {\r\n        final StringBuilder buf = new StringBuilder();\r\n        do {\r\n            buf.append(keys.next()).append(' ');\r\n        } while (keys.hasNext());\r\n        fail(\"Got additional keys: \" + buf);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLineContinuation",
  "sourceCode" : "/**\r\n * Tests a property whose value spans multiple lines.\r\n */\r\n@Test\r\nvoid testLineContinuation() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA3);\r\n    assertEquals(\"one\" + LINE_SEPARATOR + \"two\" + LINE_SEPARATOR + \"three\", config.getString(\"section5.multiLine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLineContinuationAtEnd",
  "sourceCode" : "/**\r\n * Tests a line continuation at the end of the file.\r\n */\r\n@Test\r\nvoid testLineContinuationAtEnd() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA3);\r\n    assertEquals(\"one\" + LINE_SEPARATOR, config.getString(\"section5.continueNoLine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLineContinuationComment",
  "sourceCode" : "/**\r\n * Tests a property whose value spans multiple lines with a comment.\r\n */\r\n@Test\r\nvoid testLineContinuationComment() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA3);\r\n    assertEquals(\"one\" + LINE_SEPARATOR + \"two\", config.getString(\"section5.multiComment\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLineContinuationEmptyLine",
  "sourceCode" : "/**\r\n * Tests a multi-line property value with an empty line.\r\n */\r\n@Test\r\nvoid testLineContinuationEmptyLine() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA3);\r\n    assertEquals(LINE_SEPARATOR + \"line 2\", config.getString(\"section5.noFirstLine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLineContinuationNone",
  "sourceCode" : "/**\r\n * Tests a property value that ends on a backslash, which is no line continuation character.\r\n */\r\n@Test\r\nvoid testLineContinuationNone() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA3);\r\n    assertEquals(\"C:\\\\Temp\\\\\", config.getString(\"section5.singleLine\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLineContinuationQuoted",
  "sourceCode" : "/**\r\n * Tests a property whose value spans multiple lines when quoting is involved. In this case whitespace must not be\r\n * trimmed.\r\n */\r\n@Test\r\nvoid testLineContinuationQuoted() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA3);\r\n    assertEquals(\"one\" + LINE_SEPARATOR + \"  two  \" + LINE_SEPARATOR + \"three\", config.getString(\"section5.multiQuoted\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLineContinuationQuotedComment",
  "sourceCode" : "/**\r\n * Tests a property with a quoted value spanning multiple lines and a comment.\r\n */\r\n@Test\r\nvoid testLineContinuationQuotedComment() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA3);\r\n    assertEquals(\" one \" + LINE_SEPARATOR + \"two\", config.getString(\"section5.multiQuotedComment\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testListDelimiterHandling",
  "sourceCode" : "/**\r\n * Tests whether the configuration deals correctly with list delimiters.\r\n */\r\n@Test\r\nvoid testListDelimiterHandling() throws ConfigurationException {\r\n    final INIConfiguration config = new INIConfiguration();\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    config.addProperty(\"list\", \"a,b,c\");\r\n    config.addProperty(\"listesc\", \"3\\\\,1415\");\r\n    final String output = saveToString(config);\r\n    final INIConfiguration config2 = setUpConfig(output);\r\n    assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), config2.getList(\"list\"));\r\n    assertEquals(\"3,1415\", config2.getString(\"listesc\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testListDelimiterHandlingInList",
  "sourceCode" : "/**\r\n * Tests whether property values are correctly escaped even if they are part of a property with multiple values.\r\n */\r\n@Test\r\nvoid testListDelimiterHandlingInList() throws ConfigurationException {\r\n    final String data = INI_DATA + \"[sectest]\" + LINE_SEPARATOR + \"list = 3\\\\,1415,pi,\\\\\\\\Test\\\\,5\" + LINE_SEPARATOR;\r\n    final INIConfiguration config = setUpConfig(data);\r\n    final INIConfiguration config2 = setUpConfig(saveToString(config));\r\n    final List<Object> list = config2.getList(\"sectest.list\");\r\n    assertEquals(Arrays.asList(\"3,1415\", \"pi\", \"\\\\Test,5\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testListParsingDisabled",
  "sourceCode" : "/**\r\n * Tests whether parsing of lists can be disabled.\r\n */\r\n@Test\r\nvoid testListParsingDisabled() throws ConfigurationException {\r\n    final INIConfiguration config = new INIConfiguration();\r\n    load(config, \"[test]\" + LINE_SEPARATOR + \"nolist=1,2,3\");\r\n    assertEquals(\"1,2,3\", config.getString(\"test.nolist\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLoad",
  "sourceCode" : "/**\r\n * Test of load method, of class {@link INIConfiguration}.\r\n */\r\n@Test\r\nvoid testLoad() throws Exception {\r\n    checkLoad(INI_DATA);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLoadAlternativeSeparator",
  "sourceCode" : "/**\r\n * Tests the load() method when the alternative value separator is used (a ':' for '=').\r\n */\r\n@Test\r\nvoid testLoadAlternativeSeparator() throws Exception {\r\n    checkLoad(INI_DATA.replace('=', ':'));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testLoadFromBuilder",
  "sourceCode" : "/**\r\n * Tests whether an instance can be created using a file-based builder.\r\n */\r\n@Test\r\nvoid testLoadFromBuilder() throws ConfigurationException, IOException {\r\n    final File file = writeTestFile(INI_DATA);\r\n    final FileBasedConfigurationBuilder<INIConfiguration> builder = new FileBasedConfigurationBuilder<>(INIConfiguration.class);\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFile(file));\r\n    final INIConfiguration config = builder.getConfiguration();\r\n    checkContent(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testMergeDuplicateSection",
  "sourceCode" : "/**\r\n * Tests whether a duplicate session is merged.\r\n */\r\n@Test\r\nvoid testMergeDuplicateSection() throws ConfigurationException, IOException {\r\n    // @formatter:off\r\n    final String data = \"[section]\\nvar1 = sec1\\n\\n\" + \"[section]\\nvar2 = sec2\\n\";\r\n    // @formatter:on\r\n    final INIConfiguration config = setUpConfig(data);\r\n    assertEquals(\"sec1\", config.getString(\"section.var1\"));\r\n    assertEquals(\"sec2\", config.getString(\"section.var2\"));\r\n    final HierarchicalConfiguration<ImmutableNode> sub = config.getSection(\"section\");\r\n    assertEquals(\"sec1\", sub.getString(\"var1\"));\r\n    assertEquals(\"sec2\", sub.getString(\"var2\"));\r\n    final StringWriter writer = new StringWriter();\r\n    config.write(writer);\r\n    final String content = writer.toString();\r\n    final int pos = content.indexOf(\"[section]\");\r\n    assertTrue(pos >= 0);\r\n    assertTrue(content.indexOf(\"[section]\", pos + 1) < 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testMultipleSeparators",
  "sourceCode" : "/**\r\n * Tests property definitions containing multiple separators.\r\n */\r\n@Test\r\nvoid testMultipleSeparators() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_SEPARATORS);\r\n    assertEquals(\"value=5\", config.getString(\"section.var5\"));\r\n    assertEquals(\"6=value\", config.getString(\"section.var\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testMultipleSeparatorsQuoted",
  "sourceCode" : "/**\r\n * Tests property definitions containing multiple separators that are quoted.\r\n */\r\n@Test\r\nvoid testMultipleSeparatorsQuoted() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_SEPARATORS);\r\n    assertEquals(\"value7\", config.getString(\"section.var:7\"));\r\n    assertEquals(\"value8\", config.getString(\"section.var:8\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testPropertyWithDelimiter",
  "sourceCode" : "/**\r\n * Tests that loading and saving a configuration that contains keys with delimiter characters works correctly. This test\r\n * is related to CONFIGURATION-622.\r\n */\r\n@Test\r\nvoid testPropertyWithDelimiter() throws ConfigurationException {\r\n    final String data = INI_DATA + \"key.dot = dotValue\";\r\n    final INIConfiguration conf = new INIConfiguration();\r\n    load(conf, data);\r\n    assertEquals(\"dotValue\", conf.getString(\"section3.key..dot\"));\r\n    final String output = saveToString(conf);\r\n    assertTrue(output.contains(\"key.dot = dotValue\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testQuotedValue",
  "sourceCode" : "@Test\r\nvoid testQuotedValue() throws Exception {\r\n    final INIConfiguration config = setUpConfig(INI_DATA2);\r\n    assertEquals(\"quoted value\", config.getString(\"section4.var1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testQuotedValueEmpty",
  "sourceCode" : "/**\r\n * Tests an empty quoted value.\r\n */\r\n@Test\r\nvoid testQuotedValueEmpty() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA2);\r\n    assertEquals(\"\", config.getString(\"section4.var6\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testQuotedValueWithComment",
  "sourceCode" : "@Test\r\nvoid testQuotedValueWithComment() throws Exception {\r\n    final INIConfiguration config = setUpConfig(INI_DATA2);\r\n    assertEquals(\"1;2;3\", config.getString(\"section4.var4\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testQuotedValueWithQuotes",
  "sourceCode" : "@Test\r\nvoid testQuotedValueWithQuotes() throws Exception {\r\n    final INIConfiguration config = setUpConfig(INI_DATA2);\r\n    assertEquals(\"quoted value\\\\nwith \\\"quotes\\\"\", config.getString(\"section4.var2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testQuotedValueWithSingleQuotes",
  "sourceCode" : "@Test\r\nvoid testQuotedValueWithSingleQuotes() throws Exception {\r\n    final INIConfiguration config = setUpConfig(INI_DATA2);\r\n    assertEquals(\"'quoted' \\\"value\\\"\", config.getString(\"section4.var5\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testQuotedValueWithWhitespace",
  "sourceCode" : "/**\r\n * Tests whether whitespace is left unchanged for quoted values.\r\n */\r\n@Test\r\nvoid testQuotedValueWithWhitespace() throws Exception {\r\n    final String content = \"CmdPrompt = \\\" [test@cmd ~]$ \\\"\";\r\n    final INIConfiguration config = setUpConfig(content);\r\n    assertEquals(\" [test@cmd ~]$ \", config.getString(\"CmdPrompt\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testQuotedValueWithWhitespaceAndComment",
  "sourceCode" : "/**\r\n * Tests a quoted value with space and a comment.\r\n */\r\n@Test\r\nvoid testQuotedValueWithWhitespaceAndComment() throws Exception {\r\n    final String content = \"CmdPrompt = \\\" [test@cmd ~]$ \\\" ; a comment\";\r\n    final INIConfiguration config = setUpConfig(content);\r\n    assertEquals(\" [test@cmd ~]$ \", config.getString(\"CmdPrompt\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "/**\r\n * Test of save method, of class {@link INIConfiguration}.\r\n */\r\n@Test\r\nvoid testSave() throws Exception {\r\n    final Writer writer = new StringWriter();\r\n    final INIConfiguration instance = new INIConfiguration();\r\n    instance.addProperty(\"section1.var1\", \"foo\");\r\n    instance.addProperty(\"section1.var2\", \"451\");\r\n    instance.addProperty(\"section2.var1\", \"123.45\");\r\n    instance.addProperty(\"section2.var2\", \"bar\");\r\n    instance.addProperty(\"section3.var1\", \"true\");\r\n    instance.addProperty(\"section3.interpolated\", \"${section3.var1}\");\r\n    instance.addProperty(\"section3.multi\", \"foo\");\r\n    instance.addProperty(\"section3.multi\", \"bar\");\r\n    instance.write(writer);\r\n    assertEquals(INI_DATA, writer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSaveClearedSection",
  "sourceCode" : "/**\r\n * Tests whether a section that has been cleared can be manipulated and saved later.\r\n */\r\n@Test\r\nvoid testSaveClearedSection() throws ConfigurationException, IOException {\r\n    final String data = \"[section]\\ntest = failed\\n\";\r\n    final INIConfiguration config = setUpConfig(data);\r\n    SubnodeConfiguration sub = config.getSection(\"section\");\r\n    assertFalse(sub.isEmpty());\r\n    sub.clear();\r\n    sub.close();\r\n    sub = config.getSection(\"section\");\r\n    sub.setProperty(\"test\", \"success\");\r\n    final StringWriter writer = new StringWriter();\r\n    config.write(writer);\r\n    final HierarchicalConfiguration<?> config2 = setUpConfig(writer.toString());\r\n    assertEquals(\"success\", config2.getString(\"section.test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSaveKeysWithDelimiters",
  "sourceCode" : "/**\r\n * Tests whether a configuration can be saved that contains section keys with delimiter characters. This test is related\r\n * to CONFIGURATION-409.\r\n */\r\n@Test\r\nvoid testSaveKeysWithDelimiters() throws ConfigurationException, IOException {\r\n    INIConfiguration conf = new INIConfiguration();\r\n    final String section = \"Section..with..dots\";\r\n    conf.addProperty(section + \".test1\", \"test1\");\r\n    conf.addProperty(section + \".test2\", \"test2\");\r\n    final StringWriter writer = new StringWriter();\r\n    conf.write(writer);\r\n    conf = new INIConfiguration();\r\n    conf.read(new StringReader(writer.toString()));\r\n    assertEquals(\"test1\", conf.getString(section + \".test1\"));\r\n    assertEquals(\"test2\", conf.getString(section + \".test2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSaveWithDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests whether list delimiter parsing can be disabled.\r\n */\r\n@Test\r\nvoid testSaveWithDelimiterParsingDisabled() throws ConfigurationException {\r\n    final INIConfiguration config = new INIConfiguration();\r\n    final String data = INI_DATA.substring(0, INI_DATA.length() - LINE_SEPARATOR.length()) + \"nolist = 1,2, 3\";\r\n    load(config, data);\r\n    assertEquals(\"1,2, 3\", config.getString(\"section3.nolist\"));\r\n    final String content = saveToString(config);\r\n    final INIConfiguration config2 = new INIConfiguration();\r\n    load(config2, content);\r\n    assertEquals(\"1,2, 3\", config2.getString(\"section3.nolist\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSaveWithGlobalSection",
  "sourceCode" : "/**\r\n * Tests saving a configuration that contains a global section.\r\n */\r\n@Test\r\nvoid testSaveWithGlobalSection() throws ConfigurationException {\r\n    checkSave(INI_DATA_GLOBAL);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSaveWithOnlyGlobalSection",
  "sourceCode" : "/**\r\n * Tests whether a configuration that contains only a global section can be saved correctly.\r\n */\r\n@Test\r\nvoid testSaveWithOnlyGlobalSection() throws ConfigurationException {\r\n    checkSave(INI_DATA_GLOBAL_ONLY);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSeparators",
  "sourceCode" : "/**\r\n * Tests whether the different separators with or without whitespace are recognized.\r\n */\r\n@Test\r\nvoid testSeparators() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(INI_DATA_SEPARATORS);\r\n    for (int i = 1; i <= 4; i++) {\r\n        assertEquals(\"value\" + i, config.getString(\"section.var\" + i));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSeparatorUsedInINIInput",
  "sourceCode" : "/**\r\n * Test of read method with changed separator.\r\n */\r\n@Test\r\nvoid testSeparatorUsedInINIInput() throws Exception {\r\n    final String inputSeparator = \"=\";\r\n    final String input = \"[section]\" + LINE_SEPARATOR + \"k1:v1$key1=value1\" + LINE_SEPARATOR + \"k1:v1,k2:v2$key2=value2\" + LINE_SEPARATOR + \"key3:value3\" + LINE_SEPARATOR + \"key4 = value4\" + LINE_SEPARATOR;\r\n    final INIConfiguration instance = new FileBasedConfigurationBuilder<>(INIConfiguration.class).configure(new Parameters().ini().setSeparatorUsedInInput(inputSeparator)).getConfiguration();\r\n    load(instance, input);\r\n    assertEquals(\"value1\", instance.getString(\"section.k1:v1$key1\"));\r\n    assertEquals(\"value2\", instance.getString(\"section.k1:v1,k2:v2$key2\"));\r\n    assertEquals(\"\", instance.getString(\"section.key3:value3\"));\r\n    assertEquals(\"value4\", instance.getString(\"section.key4\").trim());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testSeparatorUsedInINIOutput",
  "sourceCode" : "/**\r\n * Test of save method with changed separator\r\n */\r\n@Test\r\nvoid testSeparatorUsedInINIOutput() throws Exception {\r\n    final String outputSeparator = \": \";\r\n    final String input = MessageFormat.format(INI_DATA4, \"=\").trim();\r\n    final String expectedOutput = MessageFormat.format(INI_DATA4, outputSeparator).trim();\r\n    final INIConfiguration instance = new FileBasedConfigurationBuilder<>(INIConfiguration.class).configure(new Parameters().ini().setSeparatorUsedInOutput(outputSeparator)).getConfiguration();\r\n    load(instance, input);\r\n    final Writer writer = new StringWriter();\r\n    instance.write(writer);\r\n    final String result = writer.toString().trim();\r\n    assertEquals(expectedOutput, result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testValueWithComment",
  "sourceCode" : "/**\r\n * Test correct handling of in line comments on value line\r\n */\r\n@ParameterizedTest\r\n@MethodSource(\"provideValuesWithComments\")\r\nvoid testValueWithComment(final String source, final String key, final String value) throws Exception {\r\n    final INIConfiguration config = setUpConfig(source);\r\n    assertEquals(value, config.getString(key));\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testValueWithDelimiters",
  "sourceCode" : "/**\r\n * Tests whether the list delimiter character is recognized.\r\n */\r\n@Test\r\nvoid testValueWithDelimiters() throws ConfigurationException {\r\n    final INIConfiguration config = setUpConfig(\"[test]\" + LINE_SEPARATOR + \"list=1,2,3\" + LINE_SEPARATOR);\r\n    final List<Object> list = config.getList(\"test.list\");\r\n    assertEquals(Arrays.asList(\"1\", \"2\", \"3\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testValueWithSemicolon",
  "sourceCode" : "/**\r\n * Tests whether a value which contains a semicolon can be loaded successfully. This test is related to\r\n * CONFIGURATION-434.\r\n */\r\n@Test\r\nvoid testValueWithSemicolon() throws ConfigurationException {\r\n    final String path = \"C:\\\\Program Files\\\\jar\\\\manage.jar;C:\\\\Program Files\\\\jar\\\\guiLauncher.jar\";\r\n    final String content = \"[Environment]\" + LINE_SEPARATOR + \"Application Type=any\" + LINE_SEPARATOR + \"Class Path=\" + path + \"  ;comment\" + LINE_SEPARATOR + \"Path=\" + path + \"\\t; another comment\";\r\n    final INIConfiguration config = setUpConfig(content);\r\n    assertEquals(path, config.getString(\"Environment.Class Path\"));\r\n    assertEquals(path, config.getString(\"Environment.Path\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testWriteEmptySection",
  "sourceCode" : "/**\r\n * Tests whether an empty section can be saved. This is related to CONFIGURATION-671.\r\n */\r\n@Test\r\nvoid testWriteEmptySection() throws ConfigurationException, IOException {\r\n    final String section = \"[EmptySection]\";\r\n    final INIConfiguration config = setUpConfig(section);\r\n    assertEquals(Collections.singleton(\"EmptySection\"), config.getSections());\r\n    final StringWriter writer = new StringWriter();\r\n    config.write(writer);\r\n    assertEquals(section + LINE_SEPARATOR + LINE_SEPARATOR, writer.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestINIConfiguration.java",
  "methodName" : "testWriteValueWithCommentChar",
  "sourceCode" : "@Test\r\nvoid testWriteValueWithCommentChar() throws Exception {\r\n    final INIConfiguration config = new INIConfiguration();\r\n    config.setProperty(\"section.key1\", \"1;2;3\");\r\n    final StringWriter writer = new StringWriter();\r\n    config.write(writer);\r\n    final INIConfiguration config2 = new INIConfiguration();\r\n    config2.read(new StringReader(writer.toString()));\r\n    assertEquals(\"1;2;3\", config2.getString(\"section.key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testBoolean",
  "sourceCode" : "@Test\r\nvoid testBoolean() throws Exception {\r\n    nonStringTestHolder.testBoolean();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testBooleanDefaultValue",
  "sourceCode" : "@Test\r\nvoid testBooleanDefaultValue() throws Exception {\r\n    nonStringTestHolder.testBooleanDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testByte",
  "sourceCode" : "@Test\r\nvoid testByte() throws Exception {\r\n    nonStringTestHolder.testByte();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testChangePrefix",
  "sourceCode" : "@Test\r\nvoid testChangePrefix() {\r\n    assertEquals(\"true\", conf.getString(\"test.boolean\"));\r\n    assertNull(conf.getString(\"boolean\"));\r\n    // change the prefix\r\n    conf.setPrefix(\"test\");\r\n    assertNull(conf.getString(\"test.boolean\"));\r\n    assertEquals(\"true\", conf.getString(\"boolean\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testConstructor",
  "sourceCode" : "@Test\r\nvoid testConstructor() throws Exception {\r\n    // test the constructor accepting a context\r\n    JNDIConfiguration c = new JNDIConfiguration(new InitialContext());\r\n    assertEquals(\"true\", c.getString(\"test.boolean\"));\r\n    // test the constructor accepting a context and a prefix\r\n    c = new JNDIConfiguration(new InitialContext(), \"test\");\r\n    assertEquals(\"true\", c.getString(\"boolean\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testContainsKey",
  "sourceCode" : "@Test\r\nvoid testContainsKey() {\r\n    final String key = \"test.boolean\";\r\n    assertTrue(conf.containsKey(key));\r\n    conf.clearProperty(key);\r\n    assertFalse(conf.containsKey(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testContainsKeyError",
  "sourceCode" : "/**\r\n * Tests handling of errors in the containsKey() method.\r\n */\r\n@Test\r\nvoid testContainsKeyError() {\r\n    assertFalse(setUpErrorConfig().containsKey(\"key\"));\r\n    checkErrorListener(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, \"key\", null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testDouble",
  "sourceCode" : "@Test\r\nvoid testDouble() throws Exception {\r\n    nonStringTestHolder.testDouble();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testDoubleDefaultValue",
  "sourceCode" : "@Test\r\nvoid testDoubleDefaultValue() throws Exception {\r\n    nonStringTestHolder.testDoubleDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testFloat",
  "sourceCode" : "@Test\r\nvoid testFloat() throws Exception {\r\n    nonStringTestHolder.testFloat();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testFloatDefaultValue",
  "sourceCode" : "@Test\r\nvoid testFloatDefaultValue() throws Exception {\r\n    nonStringTestHolder.testFloatDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testGetKeysError",
  "sourceCode" : "/**\r\n * Tests handling of errors in getKeys().\r\n */\r\n@Test\r\nvoid testGetKeysError() {\r\n    assertFalse(setUpErrorConfig().getKeys().hasNext());\r\n    checkErrorListener(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, null, null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testGetKeysNoData",
  "sourceCode" : "/**\r\n * Tests getKeys() if no data is found. This should not cause a problem and not notify the error listeners.\r\n */\r\n@Test\r\nvoid testGetKeysNoData() {\r\n    conf.installException(new NameNotFoundException(\"Test exception\"));\r\n    assertFalse(conf.getKeys().hasNext());\r\n    listener.done();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testGetKeysWithCycles",
  "sourceCode" : "/**\r\n * Tests the getKeys() method when there are cycles in the tree.\r\n */\r\n@Test\r\nvoid testGetKeysWithCycles() throws NamingException {\r\n    final Hashtable<Object, Object> env = new Hashtable<>();\r\n    env.put(MockInitialContextFactory.PROP_CYCLES, Boolean.TRUE);\r\n    final InitialContext initCtx = new InitialContext(env);\r\n    final JNDIConfiguration c = new JNDIConfiguration(initCtx);\r\n    assertDoesNotThrow(() -> c.getKeys(\"cycle\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testGetPropertyError",
  "sourceCode" : "/**\r\n * Tests handling of errors in getProperty().\r\n */\r\n@Test\r\nvoid testGetPropertyError() {\r\n    assertNull(setUpErrorConfig().getProperty(\"key\"));\r\n    checkErrorListener(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, \"key\", null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testInteger",
  "sourceCode" : "@Test\r\nvoid testInteger() throws Exception {\r\n    nonStringTestHolder.testInteger();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testIntegerDefaultValue",
  "sourceCode" : "@Test\r\nvoid testIntegerDefaultValue() throws Exception {\r\n    nonStringTestHolder.testIntegerDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testIsEmptyError",
  "sourceCode" : "/**\r\n * Tests handling of errors in isEmpty().\r\n */\r\n@Test\r\nvoid testIsEmptyError() throws Exception {\r\n    assertTrue(setUpErrorConfig().isEmpty());\r\n    checkErrorListener(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, null, null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testListMissing",
  "sourceCode" : "@Test\r\nvoid testListMissing() throws Exception {\r\n    nonStringTestHolder.testListMissing();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testLogListener",
  "sourceCode" : "/**\r\n * Tests whether a JNDI configuration registers an error log listener.\r\n */\r\n@Test\r\nvoid testLogListener() throws NamingException {\r\n    final JNDIConfiguration c = new JNDIConfiguration();\r\n    assertEquals(1, c.getEventListeners(ConfigurationErrorEvent.ANY).size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testLong",
  "sourceCode" : "@Test\r\nvoid testLong() throws Exception {\r\n    nonStringTestHolder.testLong();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testLongDefaultValue",
  "sourceCode" : "@Test\r\nvoid testLongDefaultValue() throws Exception {\r\n    nonStringTestHolder.testLongDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testProperties",
  "sourceCode" : "@Test\r\nvoid testProperties() throws Exception {\r\n    final Object o = conf.getProperty(\"test.boolean\");\r\n    assertNotNull(o);\r\n    assertEquals(\"true\", o.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testResetRemovedProperties",
  "sourceCode" : "@Test\r\nvoid testResetRemovedProperties() throws Exception {\r\n    assertEquals(\"true\", conf.getString(\"test.boolean\"));\r\n    // remove the property\r\n    conf.clearProperty(\"test.boolean\");\r\n    assertNull(conf.getString(\"test.boolean\"));\r\n    // change the context\r\n    conf.setContext(new InitialContext());\r\n    // get the property\r\n    assertEquals(\"true\", conf.getString(\"test.boolean\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testShort",
  "sourceCode" : "@Test\r\nvoid testShort() throws Exception {\r\n    nonStringTestHolder.testShort();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testShortDefaultValue",
  "sourceCode" : "@Test\r\nvoid testShortDefaultValue() throws Exception {\r\n    nonStringTestHolder.testShortDefaultValue();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIConfiguration.java",
  "methodName" : "testSubset",
  "sourceCode" : "@Test\r\nvoid testSubset() throws Exception {\r\n    nonStringTestHolder.testSubset();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Test\r\nvoid testClearProperty() {\r\n    assertNotNull(conf.getShort(\"test.short\", null));\r\n    conf.clearProperty(\"test.short\");\r\n    assertNull(conf.getShort(\"test.short\", null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testContainsKey",
  "sourceCode" : "@Test\r\nvoid testContainsKey() throws Exception {\r\n    assertTrue(conf.containsKey(\"test.key\"));\r\n    assertFalse(conf.containsKey(\"test.imaginarykey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "@Test\r\nvoid testGetKeys() throws Exception {\r\n    boolean found = false;\r\n    final Iterator<String> it = conf.getKeys();\r\n    assertTrue(it.hasNext());\r\n    while (it.hasNext() && !found) {\r\n        found = \"test.boolean\".equals(it.next());\r\n    }\r\n    assertTrue(found);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testGetKeysWithExistingPrefix",
  "sourceCode" : "@Test\r\nvoid testGetKeysWithExistingPrefix() {\r\n    // test for an existing prefix\r\n    final Iterator<String> it = conf.getKeys(\"test\");\r\n    boolean found = false;\r\n    while (it.hasNext() && !found) {\r\n        found = \"test.boolean\".equals(it.next());\r\n    }\r\n    assertTrue(found);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testGetKeysWithKeyAsPrefix",
  "sourceCode" : "@Test\r\nvoid testGetKeysWithKeyAsPrefix() {\r\n    // test for a prefix matching exactly the key of a property\r\n    final Iterator<String> it = conf.getKeys(\"test.boolean\");\r\n    boolean found = false;\r\n    while (it.hasNext() && !found) {\r\n        found = \"test.boolean\".equals(it.next());\r\n    }\r\n    assertTrue(found);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testGetKeysWithUnknownPrefix",
  "sourceCode" : "@Test\r\nvoid testGetKeysWithUnknownPrefix() {\r\n    // test for a unknown prefix\r\n    final Iterator<String> it = conf.getKeys(\"foo.bar\");\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testGetMissingKey",
  "sourceCode" : "@Test\r\nvoid testGetMissingKey() throws Exception {\r\n    assertThrows(NoSuchElementException.class, () -> conf.getString(\"test.imaginarykey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testGetMissingKeyWithDefault",
  "sourceCode" : "@Test\r\nvoid testGetMissingKeyWithDefault() throws Exception {\r\n    final String result = conf.getString(\"test.imaginarykey\", \"bob\");\r\n    assertEquals(\"bob\", result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testIsEmpty",
  "sourceCode" : "@Test\r\nvoid testIsEmpty() {\r\n    assertFalse(conf.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testMoreGets",
  "sourceCode" : "@Test\r\nvoid testMoreGets() throws Exception {\r\n    final String s = conf.getString(\"test.key\");\r\n    assertEquals(\"jndivalue\", s);\r\n    assertEquals(\"jndivalue2\", conf.getString(\"test.key2\"));\r\n    assertEquals(1, conf.getShort(\"test.short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testSimpleGet",
  "sourceCode" : "@Test\r\nvoid testSimpleGet() throws Exception {\r\n    final String s = conf.getString(\"test.key\");\r\n    assertEquals(\"jndivalue\", s);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJNDIEnvironmentValues.java",
  "methodName" : "testThrowExceptionOnMissing",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionOnMissing() {\r\n    assertTrue(conf.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testCopyConstructor",
  "sourceCode" : "@Test\r\nvoid testCopyConstructor() {\r\n    final BaseHierarchicalConfiguration c = new BaseHierarchicalConfiguration();\r\n    c.addProperty(\"foo\", \"bar\");\r\n    jsonConfiguration = new JSONConfiguration(c);\r\n    assertEquals(\"bar\", jsonConfiguration.getString(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testGetPropertyDictionary",
  "sourceCode" : "@Test\r\nvoid testGetPropertyDictionary() {\r\n    assertEquals(\"Martin D'vloper\", jsonConfiguration.getProperty(\"martin.name\"));\r\n    assertEquals(\"Developer\", jsonConfiguration.getProperty(\"martin.job\"));\r\n    assertEquals(\"Elite\", jsonConfiguration.getProperty(\"martin.skill\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testGetPropertyDictionaryInList",
  "sourceCode" : "@Test\r\nvoid testGetPropertyDictionaryInList() {\r\n    assertEquals(\"UK\", jsonConfiguration.getString(\"capitals(1).country\"));\r\n    assertEquals(\"Washington\", jsonConfiguration.getString(\"capitals(0).capital\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testGetPropertyInteger",
  "sourceCode" : "@Test\r\nvoid testGetPropertyInteger() {\r\n    final Object property = jsonConfiguration.getProperty(\"int1\");\r\n    assertInstanceOf(Integer.class, property);\r\n    assertEquals(37, property);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testGetPropertyNested",
  "sourceCode" : "@Test\r\nvoid testGetPropertyNested() {\r\n    assertEquals(\"value23\", jsonConfiguration.getProperty(\"key2.key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testGetPropertyNestedWithList",
  "sourceCode" : "@Test\r\nvoid testGetPropertyNestedWithList() {\r\n    assertEquals(Arrays.asList(\"col1\", \"col2\"), jsonConfiguration.getProperty(\"key4.key5\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testGetPropertySimple",
  "sourceCode" : "@Test\r\nvoid testGetPropertySimple() {\r\n    assertEquals(\"value1\", jsonConfiguration.getProperty(\"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testGetPropertySubset",
  "sourceCode" : "@Test\r\nvoid testGetPropertySubset() {\r\n    final Configuration subset = jsonConfiguration.subset(\"key4\");\r\n    assertEquals(Arrays.asList(\"col1\", \"col2\"), subset.getProperty(\"key5\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testGetPropertyVeryNestedProperties",
  "sourceCode" : "@Test\r\nvoid testGetPropertyVeryNestedProperties() {\r\n    final Object property = jsonConfiguration.getProperty(\"very.nested.properties\");\r\n    assertEquals(Arrays.asList(\"nested1\", \"nested2\", \"nested3\"), property);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testListOfObjects",
  "sourceCode" : "/**\r\n * Tests CONFIGURATION-793.\r\n */\r\n@Disabled\r\n@Test\r\nvoid testListOfObjects() {\r\n    final Configuration subset = jsonConfiguration.subset(\"capitals\");\r\n    assertNotNull(subset);\r\n    assertEquals(2, subset.size());\r\n    final List<Object> list = jsonConfiguration.getList(\"capitals\");\r\n    assertNotNull(list);\r\n    assertEquals(2, list.size());\r\n    //        assertEquals(list.get(0).get(\"country\"), \"USA\");\r\n    //        assertEquals(list.get(0).get(\"capital\"), \"Washington\");\r\n    //        assertEquals(list.get(1).get(\"country\"), \"UK\");\r\n    //        assertEquals(list.get(1).get(\"capital\"), \"London\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestJSONConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "@Test\r\nvoid testSave() throws IOException, ConfigurationException {\r\n    // save the Configuration as a String...\r\n    final StringWriter sw = new StringWriter();\r\n    jsonConfiguration.write(sw);\r\n    final String output = sw.toString();\r\n    // ..and then try parsing it back\r\n    final ObjectMapper mapper = new ObjectMapper();\r\n    final MapType type = mapper.getTypeFactory().constructMapType(Map.class, String.class, Object.class);\r\n    final Map<String, Object> parsed = mapper.readValue(output, type);\r\n    assertEquals(7, parsed.entrySet().size());\r\n    assertEquals(\"value1\", parsed.get(\"key1\"));\r\n    final Map<?, ?> key2 = (Map<?, ?>) parsed.get(\"key2\");\r\n    assertEquals(\"value23\", key2.get(\"key3\"));\r\n    final List<?> key5 = (List<?>) ((Map<?, ?>) parsed.get(\"key4\")).get(\"key5\");\r\n    assertEquals(Arrays.asList(\"col1\", \"col2\"), key5);\r\n    final List<?> capitals = (List<?>) parsed.get(\"capitals\");\r\n    final Map<?, ?> capUk = (Map<?, ?>) capitals.get(1);\r\n    assertEquals(\"London\", capUk.get(\"capital\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testAddProperty",
  "sourceCode" : "/**\r\n * Tests adding another value to an existing property.\r\n */\r\n@Test\r\nvoid testAddProperty() {\r\n    final MapConfiguration config = (MapConfiguration) getConfiguration();\r\n    config.addProperty(KEY, TRIM_VALUE);\r\n    config.addProperty(KEY, \"anotherValue\");\r\n    final List<Object> values = config.getList(KEY);\r\n    assertEquals(3, values.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "@Test\r\nvoid testClone() {\r\n    final MapConfiguration config = (MapConfiguration) getConfiguration();\r\n    final MapConfiguration copy = (MapConfiguration) config.clone();\r\n    final StrictConfigurationComparator comp = new StrictConfigurationComparator();\r\n    assertTrue(comp.compare(config, copy));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testCloneInterpolation",
  "sourceCode" : "/**\r\n * Tests whether interpolation works as expected after cloning.\r\n */\r\n@Test\r\nvoid testCloneInterpolation() {\r\n    final String keyAnswer = \"answer\";\r\n    final String keyValue = \"value\";\r\n    final MapConfiguration config = (MapConfiguration) getConfiguration();\r\n    config.addProperty(keyAnswer, \"The answer is ${\" + keyValue + \"}.\");\r\n    config.addProperty(keyValue, 42);\r\n    final MapConfiguration clone = (MapConfiguration) config.clone();\r\n    clone.setProperty(keyValue, 43);\r\n    assertEquals(\"The answer is 42.\", config.getString(keyAnswer));\r\n    assertEquals(\"The answer is 43.\", clone.getString(keyAnswer));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testCloneModify",
  "sourceCode" : "/**\r\n * Tests if the cloned configuration is decoupled from the original.\r\n */\r\n@Test\r\nvoid testCloneModify() {\r\n    final MapConfiguration config = (MapConfiguration) getConfiguration();\r\n    config.addEventListener(ConfigurationEvent.ANY, new EventListenerTestImpl(config));\r\n    final MapConfiguration copy = (MapConfiguration) config.clone();\r\n    assertTrue(copy.getEventListeners(ConfigurationEvent.ANY).isEmpty());\r\n    config.addProperty(\"cloneTest\", Boolean.TRUE);\r\n    assertFalse(copy.containsKey(\"cloneTest\"));\r\n    copy.clearProperty(\"key1\");\r\n    assertEquals(\"value1\", config.getString(\"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testGetMap",
  "sourceCode" : "@Test\r\nvoid testGetMap() {\r\n    final Map<String, Object> map = new HashMap<>();\r\n    final MapConfiguration conf = new MapConfiguration(map);\r\n    assertEquals(map, conf.getMap());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testGetPropertyTrim",
  "sourceCode" : "/**\r\n * Tests querying a property when trimming is active.\r\n */\r\n@Test\r\nvoid testGetPropertyTrim() {\r\n    final MapConfiguration config = (MapConfiguration) getConfiguration();\r\n    config.getMap().put(KEY, SPACE_VALUE);\r\n    assertEquals(TRIM_VALUE, config.getProperty(KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testGetPropertyTrimDisabled",
  "sourceCode" : "/**\r\n * Tests querying a property when trimming is disabled.\r\n */\r\n@Test\r\nvoid testGetPropertyTrimDisabled() {\r\n    final MapConfiguration config = (MapConfiguration) getConfiguration();\r\n    config.getMap().put(KEY, SPACE_VALUE);\r\n    config.setTrimmingDisabled(true);\r\n    assertEquals(SPACE_VALUE, config.getProperty(KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testGetPropertyTrimNoSplit",
  "sourceCode" : "/**\r\n * Tests querying a property if trimming is enabled, but list splitting is disabled. In this case no trimming is\r\n * performed (trimming only works if list splitting is enabled).\r\n */\r\n@Test\r\nvoid testGetPropertyTrimNoSplit() {\r\n    final MapConfiguration config = (MapConfiguration) getConfiguration();\r\n    config.getMap().put(KEY, SPACE_VALUE);\r\n    config.setListDelimiterHandler(new DisabledListDelimiterHandler());\r\n    assertEquals(SPACE_VALUE, config.getProperty(KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestMapConfiguration.java",
  "methodName" : "testNullMap",
  "sourceCode" : "@Test\r\nvoid testNullMap() {\r\n    assertThrows(NullPointerException.class, () -> new MapConfiguration((Map) null));\r\n    assertThrows(NullPointerException.class, () -> new MapConfiguration((Properties) null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testAddingProperty",
  "sourceCode" : "/**\r\n * Tests adding values. Make sure they _DON'T_ override any other properties but add to the existing properties and keep\r\n * sequence\r\n */\r\n@Test\r\nvoid testAddingProperty() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    String[] values = cc.getStringArray(\"test.short\");\r\n    assertArrayEquals(new String[] { \"1\" }, values);\r\n    cc.addProperty(\"test.short\", \"88\");\r\n    values = cc.getStringArray(\"test.short\");\r\n    assertArrayEquals(new String[] { \"1\", \"88\" }, values);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testAddRemoveConfigurations",
  "sourceCode" : "@Test\r\nvoid testAddRemoveConfigurations() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.addConfiguration(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.addConfiguration(conf2);\r\n    assertEquals(3, cc.getNumberOfConfigurations());\r\n    cc.removeConfiguration(conf1);\r\n    assertEquals(2, cc.getNumberOfConfigurations());\r\n    cc.clear();\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testCantRemoveMemoryConfig",
  "sourceCode" : "@Test\r\nvoid testCantRemoveMemoryConfig() throws Exception {\r\n    cc.clear();\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n    final Configuration internal = cc.getConfiguration(0);\r\n    cc.removeConfiguration(internal);\r\n    assertEquals(1, cc.getNumberOfConfigurations());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testCheckingInMemoryConfiguration",
  "sourceCode" : "@Test\r\nvoid testCheckingInMemoryConfiguration() throws Exception {\r\n    final String testKey = \"testKey\";\r\n    final Configuration defaults = new PropertiesConfiguration();\r\n    defaults.setProperty(testKey, \"testValue\");\r\n    final Configuration testConfiguration = new CompositeConfiguration(defaults);\r\n    assertTrue(testConfiguration.containsKey(testKey));\r\n    assertFalse(testConfiguration.isEmpty());\r\n    boolean foundTestKey = false;\r\n    final Iterator<String> i = testConfiguration.getKeys();\r\n    while (i.hasNext()) {\r\n        final String key = i.next();\r\n        if (key.equals(testKey)) {\r\n            foundTestKey = true;\r\n        }\r\n    }\r\n    assertTrue(foundTestKey);\r\n    testConfiguration.clearProperty(testKey);\r\n    assertFalse(testConfiguration.containsKey(testKey));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testClearingProperty",
  "sourceCode" : "/**\r\n * Tests setting values. These are set in memory mode only!\r\n */\r\n@Test\r\nvoid testClearingProperty() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    cc.clearProperty(\"test.short\");\r\n    assertFalse(cc.containsKey(\"test.short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testDefaultValueWhenKeyMissing",
  "sourceCode" : "/**\r\n * Tests getting a default when the key doesn't exist\r\n */\r\n@Test\r\nvoid testDefaultValueWhenKeyMissing() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    assertEquals(\"default\", cc.getString(\"bogus\", \"default\"));\r\n    assertEquals(1.4, cc.getDouble(\"bogus\", 1.4), 0.0);\r\n    assertEquals(1.4, cc.getDouble(\"bogus\", 1.4), 0.0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGetKeys2PreservesOrder",
  "sourceCode" : "/**\r\n * Tests {@code getKeys(String key)} preserves the order\r\n */\r\n@Test\r\nvoid testGetKeys2PreservesOrder() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    final List<String> orderedList = new ArrayList<>();\r\n    for (final Iterator<String> keys = conf1.getKeys(\"test\"); keys.hasNext(); ) {\r\n        orderedList.add(keys.next());\r\n    }\r\n    final List<String> iteratedList = new ArrayList<>();\r\n    for (final Iterator<String> keys = cc.getKeys(\"test\"); keys.hasNext(); ) {\r\n        iteratedList.add(keys.next());\r\n    }\r\n    assertEquals(orderedList, iteratedList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGetKeysPreservesOrder",
  "sourceCode" : "/**\r\n * Tests {@code getKeys()} preserves the order\r\n */\r\n@Test\r\nvoid testGetKeysPreservesOrder() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    final List<String> orderedList = new ArrayList<>();\r\n    for (final Iterator<String> keys = conf1.getKeys(); keys.hasNext(); ) {\r\n        orderedList.add(keys.next());\r\n    }\r\n    final List<String> iteratedList = new ArrayList<>();\r\n    for (final Iterator<String> keys = cc.getKeys(); keys.hasNext(); ) {\r\n        iteratedList.add(keys.next());\r\n    }\r\n    assertEquals(orderedList, iteratedList);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGetList",
  "sourceCode" : "@Test\r\nvoid testGetList() {\r\n    final Configuration conf1 = new BaseConfiguration();\r\n    conf1.addProperty(\"array\", \"value1\");\r\n    conf1.addProperty(\"array\", \"value2\");\r\n    final Configuration conf2 = new BaseConfiguration();\r\n    conf2.addProperty(\"array\", \"value3\");\r\n    conf2.addProperty(\"array\", \"value4\");\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    // check the composite 'array' property\r\n    List<Object> list = cc.getList(\"array\");\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\"), list);\r\n    // add an element to the list in the composite configuration\r\n    cc.addProperty(\"array\", \"value5\");\r\n    // test the new list\r\n    list = cc.getList(\"array\");\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\", \"value5\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    assertEquals(\"test.properties\", cc.getString(\"propertyInOrder\"));\r\n    cc.clear();\r\n    cc.addConfiguration(conf2);\r\n    cc.addConfiguration(conf1);\r\n    assertEquals(\"test2.properties\", cc.getString(\"propertyInOrder\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGetPropertyMissing",
  "sourceCode" : "@Test\r\nvoid testGetPropertyMissing() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    assertNull(cc.getString(\"bogus.property\"));\r\n    assertFalse(cc.getBoolean(\"test.missing.boolean\", false));\r\n    assertTrue(cc.getBoolean(\"test.missing.boolean.true\", true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGetPropertyWIncludes",
  "sourceCode" : "@Test\r\nvoid testGetPropertyWIncludes() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    final List<Object> l = cc.getList(\"packages\");\r\n    assertTrue(l.contains(\"packagea\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGetStringWithDefaults",
  "sourceCode" : "@Test\r\nvoid testGetStringWithDefaults() {\r\n    final BaseConfiguration defaults = new BaseConfiguration();\r\n    defaults.addProperty(\"default\", \"default string\");\r\n    final Configuration c = new CompositeConfiguration(defaults);\r\n    c.addProperty(\"string\", \"test string\");\r\n    assertEquals(\"test string\", c.getString(\"string\"));\r\n    assertNull(c.getString(\"XXX\"));\r\n    // test defaults\r\n    assertEquals(\"test string\", c.getString(\"string\", \"some default value\"));\r\n    assertEquals(\"default string\", c.getString(\"default\"));\r\n    assertEquals(\"default string\", c.getString(\"default\", \"some default value\"));\r\n    assertEquals(\"some default value\", c.getString(\"XXX\", \"some default value\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGettingConfiguration",
  "sourceCode" : "@Test\r\nvoid testGettingConfiguration() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    assertEquals(PropertiesConfiguration.class, cc.getConfiguration(0).getClass());\r\n    assertEquals(XMLConfiguration.class, cc.getConfiguration(1).getClass());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGettingSubset",
  "sourceCode" : "/**\r\n * Tests retrieving subsets of configurations\r\n */\r\n@Test\r\nvoid testGettingSubset() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    Configuration subset = cc.subset(\"test\");\r\n    assertNotNull(subset);\r\n    assertFalse(subset.isEmpty());\r\n    assertEquals(\"1\", subset.getString(\"short\"));\r\n    cc.setProperty(\"test.short\", \"43\");\r\n    subset = cc.subset(\"test\");\r\n    assertEquals(\"43\", subset.getString(\"short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testGetVector",
  "sourceCode" : "@Test\r\nvoid testGetVector() {\r\n    final Configuration conf1 = new BaseConfiguration();\r\n    conf1.addProperty(\"array\", \"value1\");\r\n    conf1.addProperty(\"array\", \"value2\");\r\n    final Configuration conf2 = new BaseConfiguration();\r\n    conf2.addProperty(\"array\", \"value3\");\r\n    conf2.addProperty(\"array\", \"value4\");\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(conf2);\r\n    // add an element to the vector in the composite configuration\r\n    cc.addProperty(\"array\", \"value5\");\r\n    final List<Object> list = cc.getList(\"array\");\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\", \"value5\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testList",
  "sourceCode" : "/**\r\n * Tests {@code List} parsing.\r\n */\r\n@Test\r\nvoid testList() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    List<Object> packages = cc.getList(\"packages\");\r\n    // we should get 3 packages here\r\n    assertEquals(3, packages.size());\r\n    final List<Object> defaultList = new ArrayList<>();\r\n    defaultList.add(\"1\");\r\n    defaultList.add(\"2\");\r\n    packages = cc.getList(\"packages.which.dont.exist\", defaultList);\r\n    // we should get 2 packages here\r\n    assertEquals(2, packages.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testMultipleTypesOfConfigs",
  "sourceCode" : "@Test\r\nvoid testMultipleTypesOfConfigs() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    assertEquals(1, cc.getInt(\"test.short\"));\r\n    cc.clear();\r\n    cc.addConfiguration(xmlConf);\r\n    cc.addConfiguration(conf1);\r\n    assertEquals(8, cc.getInt(\"test.short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testPropertyExistsInOnlyOneConfig",
  "sourceCode" : "@Test\r\nvoid testPropertyExistsInOnlyOneConfig() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    assertEquals(\"value\", cc.getString(\"element\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testSettingMissingProperty",
  "sourceCode" : "/**\r\n * Tests setting values. These are set in memory mode only!\r\n */\r\n@Test\r\nvoid testSettingMissingProperty() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    cc.setProperty(\"my.new.property\", \"supernew\");\r\n    assertEquals(\"supernew\", cc.getString(\"my.new.property\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testStringArray",
  "sourceCode" : "/**\r\n * Tests {@code String} array parsing.\r\n */\r\n@Test\r\nvoid testStringArray() throws Exception {\r\n    cc.addConfiguration(conf1);\r\n    cc.addConfiguration(xmlConf);\r\n    String[] packages = cc.getStringArray(\"packages\");\r\n    // we should get 3 packages here\r\n    assertEquals(3, packages.length);\r\n    packages = cc.getStringArray(\"packages.which.dont.exist\");\r\n    // we should get 0 packages here\r\n    assertEquals(0, packages.length);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testSubsetCanResolve",
  "sourceCode" : "/**\r\n * Tests subsets and still can resolve elements\r\n */\r\n@Test\r\nvoid testSubsetCanResolve() throws Exception {\r\n    cc = new CompositeConfiguration();\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.addProperty(\"subset.tempfile\", \"${java.io.tmpdir}/file.tmp\");\r\n    cc.addConfiguration(config);\r\n    cc.addConfiguration(ConfigurationConverter.getConfiguration(System.getProperties()));\r\n    final Configuration subset = cc.subset(\"subset\");\r\n    assertEquals(FileUtils.getTempDirectoryPath() + \"/file.tmp\", subset.getString(\"tempfile\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullCompositeConfiguration.java",
  "methodName" : "testThrowExceptionOnMissing",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionOnMissing() {\r\n    assertFalse(cc.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Test\r\nvoid testClearProperty() {\r\n    assertNotNull(conf.getShort(\"test.short\", null));\r\n    conf.clearProperty(\"test.short\");\r\n    assertNull(conf.getShort(\"test.short\", null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testContainsKey",
  "sourceCode" : "@Test\r\nvoid testContainsKey() throws Exception {\r\n    assertTrue(conf.containsKey(\"test.key\"));\r\n    assertFalse(conf.containsKey(\"test.imaginarykey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "@Test\r\nvoid testGetKeys() throws Exception {\r\n    boolean found = false;\r\n    final Iterator<String> it = conf.getKeys();\r\n    assertTrue(it.hasNext());\r\n    while (it.hasNext() && !found) {\r\n        found = \"test.boolean\".equals(it.next());\r\n    }\r\n    assertTrue(found);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testGetKeysWithExistingPrefix",
  "sourceCode" : "@Test\r\nvoid testGetKeysWithExistingPrefix() {\r\n    // test for an existing prefix\r\n    final Iterator<String> it = conf.getKeys(\"test\");\r\n    boolean found = false;\r\n    while (it.hasNext() && !found) {\r\n        found = \"test.boolean\".equals(it.next());\r\n    }\r\n    assertTrue(found);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testGetKeysWithKeyAsPrefix",
  "sourceCode" : "@Test\r\nvoid testGetKeysWithKeyAsPrefix() {\r\n    // test for a prefix matching exactly the key of a property\r\n    final Iterator<String> it = conf.getKeys(\"test.boolean\");\r\n    boolean found = false;\r\n    while (it.hasNext() && !found) {\r\n        found = \"test.boolean\".equals(it.next());\r\n    }\r\n    assertTrue(found);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testGetKeysWithUnknownPrefix",
  "sourceCode" : "@Test\r\nvoid testGetKeysWithUnknownPrefix() {\r\n    // test for a unknown prefix\r\n    final Iterator<String> it = conf.getKeys(\"foo.bar\");\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testGetMissingKey",
  "sourceCode" : "@Test\r\nvoid testGetMissingKey() throws Exception {\r\n    assertNull(conf.getString(\"test.imaginarykey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testGetMissingKeyWithDefault",
  "sourceCode" : "@Test\r\nvoid testGetMissingKeyWithDefault() throws Exception {\r\n    final String result = conf.getString(\"test.imaginarykey\", \"bob\");\r\n    assertEquals(\"bob\", result);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testIsEmpty",
  "sourceCode" : "@Test\r\nvoid testIsEmpty() {\r\n    assertFalse(conf.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testMoreGets",
  "sourceCode" : "@Test\r\nvoid testMoreGets() throws Exception {\r\n    final String s = conf.getString(\"test.key\");\r\n    assertEquals(\"jndivalue\", s);\r\n    assertEquals(\"jndivalue2\", conf.getString(\"test.key2\"));\r\n    assertEquals(1, conf.getShort(\"test.short\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testSimpleGet",
  "sourceCode" : "@Test\r\nvoid testSimpleGet() throws Exception {\r\n    final String s = conf.getString(\"test.key\");\r\n    assertEquals(\"jndivalue\", s);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestNullJNDIEnvironmentValues.java",
  "methodName" : "testThrowExceptionOnMissing",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionOnMissing() {\r\n    assertFalse(conf.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPatternSubtreeConfiguration.java",
  "methodName" : "testMultiConfiguration",
  "sourceCode" : "/**\r\n * Rigorous Test :-)\r\n */\r\n@Test\r\nvoid testMultiConfiguration() {\r\n    final PatternSubtreeConfigurationWrapper config = new PatternSubtreeConfigurationWrapper(this.conf, PATTERN);\r\n    config.setExpressionEngine(new XPathExpressionEngine());\r\n    System.setProperty(\"Id\", \"1001\");\r\n    assertEquals(15, config.getInt(\"rowsPerPage\"));\r\n    System.setProperty(\"Id\", \"1002\");\r\n    assertEquals(25, config.getInt(\"rowsPerPage\"));\r\n    System.setProperty(\"Id\", \"1003\");\r\n    assertEquals(35, config.getInt(\"rowsPerPage\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPatternSubtreeConfiguration.java",
  "methodName" : "testReadNotFileBased",
  "sourceCode" : "/**\r\n * Tests a read operation if the wrapped configuration does not implement FileBased.\r\n */\r\n@Test\r\nvoid testReadNotFileBased() {\r\n    final HierarchicalConfiguration<ImmutableNode> hc = new BaseHierarchicalConfiguration();\r\n    final PatternSubtreeConfigurationWrapper config = new PatternSubtreeConfigurationWrapper(hc, PATTERN);\r\n    final FileHandler fileHandler = new FileHandler(config);\r\n    assertThrows(ConfigurationException.class, () -> fileHandler.load(CONFIG_FILE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPatternSubtreeConfiguration.java",
  "methodName" : "testSaveNotFileBased",
  "sourceCode" : "/**\r\n * Tests a write operation if the wrapped configuration does not implement FileBased.\r\n */\r\n@Test\r\nvoid testSaveNotFileBased() {\r\n    final HierarchicalConfiguration<ImmutableNode> hc = new BaseHierarchicalConfiguration();\r\n    final PatternSubtreeConfigurationWrapper config = new PatternSubtreeConfigurationWrapper(hc, PATTERN);\r\n    final FileHandler fileHandler = new FileHandler(config);\r\n    final StringWriter writer = new StringWriter();\r\n    assertThrows(ConfigurationException.class, () -> fileHandler.save(writer));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPatternSubtreeConfigurationWrapper.java",
  "methodName" : "testReadNotFileBased",
  "sourceCode" : "/**\r\n * Tests a read operation if the wrapped configuration does not implement FileBased.\r\n */\r\n@Test\r\nvoid testReadNotFileBased() {\r\n    assertThrows(NullPointerException.class, () -> {\r\n        new PatternSubtreeConfigurationWrapper(null, \"\");\r\n    });\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testAppend",
  "sourceCode" : "/**\r\n * Tests if properties can be appended by simply calling load() another time.\r\n */\r\n@Test\r\nvoid testAppend() throws Exception {\r\n    final File file2 = ConfigurationAssert.getTestFile(\"threesome.properties\");\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.load(file2);\r\n    assertEquals(\"aaa\", conf.getString(\"test.threesome.one\"));\r\n    assertEquals(\"true\", conf.getString(\"configuration.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testAppendAndSave",
  "sourceCode" : "/**\r\n * Tests appending a configuration to the test configuration. Again it has to be ensured that the layout object is\r\n * correctly updated.\r\n */\r\n@Test\r\nvoid testAppendAndSave() throws ConfigurationException {\r\n    final Configuration copyConf = setUpCopyConfig();\r\n    conf.append(copyConf);\r\n    checkCopiedConfig(copyConf);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testBackslashEscapingInLists",
  "sourceCode" : "/**\r\n * Tests whether backslashes are correctly handled if lists are parsed. This test is related to CONFIGURATION-418.\r\n */\r\n@Test\r\nvoid testBackslashEscapingInLists() throws Exception {\r\n    checkBackslashList(\"share2\");\r\n    checkBackslashList(\"share1\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testChangingListDelimiter",
  "sourceCode" : "/**\r\n * Tests whether another list delimiter character can be set (by using an alternative list delimiter handler).\r\n */\r\n@Test\r\nvoid testChangingListDelimiter() throws Exception {\r\n    assertEquals(\"a^b^c\", conf.getString(\"test.other.delimiter\"));\r\n    final PropertiesConfiguration pc2 = new PropertiesConfiguration();\r\n    pc2.setListDelimiterHandler(new DefaultListDelimiterHandler('^'));\r\n    load(pc2, TEST_PROPERTIES);\r\n    assertEquals(\"a\", pc2.getString(\"test.other.delimiter\"));\r\n    assertEquals(3, pc2.getList(\"test.other.delimiter\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testClearFooterComment",
  "sourceCode" : "/**\r\n * Tests whether a clear() operation clears the footer comment.\r\n */\r\n@Test\r\nvoid testClearFooterComment() {\r\n    conf.clear();\r\n    assertNull(conf.getFooter());\r\n    assertNull(conf.getHeader());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests whether a properties configuration can be successfully cloned. It is especially checked whether the layout\r\n * object is taken into account.\r\n */\r\n@Test\r\nvoid testClone() throws ConfigurationException {\r\n    final PropertiesConfiguration copy = (PropertiesConfiguration) conf.clone();\r\n    assertNotSame(conf.getLayout(), copy.getLayout());\r\n    assertEquals(1, conf.getEventListeners(ConfigurationEvent.ANY).size());\r\n    assertEquals(1, copy.getEventListeners(ConfigurationEvent.ANY).size());\r\n    assertSame(conf.getLayout(), conf.getEventListeners(ConfigurationEvent.ANY).iterator().next());\r\n    assertSame(copy.getLayout(), copy.getEventListeners(ConfigurationEvent.ANY).iterator().next());\r\n    final StringWriter outConf = new StringWriter();\r\n    new FileHandler(conf).save(outConf);\r\n    final StringWriter outCopy = new StringWriter();\r\n    new FileHandler(copy).save(outCopy);\r\n    assertEquals(outConf.toString(), outCopy.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCloneNullLayout",
  "sourceCode" : "/**\r\n * Tests the clone() method when no layout object exists yet.\r\n */\r\n@Test\r\nvoid testCloneNullLayout() {\r\n    conf = new PropertiesConfiguration();\r\n    final PropertiesConfiguration copy = (PropertiesConfiguration) conf.clone();\r\n    assertNotSame(conf.getLayout(), copy.getLayout());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testComment",
  "sourceCode" : "/**\r\n * Test if the lines starting with # or ! are properly ignored.\r\n */\r\n@Test\r\nvoid testComment() {\r\n    assertFalse(conf.containsKey(\"#comment\"));\r\n    assertFalse(conf.containsKey(\"!comment\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCompress840ArrayList",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 0, 2, 4, 8, 16 })\r\nvoid testCompress840ArrayList(final int size) {\r\n    final ArrayList<Object> object = new ArrayList<>();\r\n    for (int i = 0; i < size; i++) {\r\n        object.add(i);\r\n    }\r\n    final Collection<?> result = testCompress840(object);\r\n    assertNotNull(result);\r\n    assertEquals(size, result.size());\r\n    assertEquals(object, result);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCompress840ArrayListCycle",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 0, 2, 4, 8, 16 })\r\nvoid testCompress840ArrayListCycle(final int size) {\r\n    final ArrayList<Object> object = new ArrayList<>();\r\n    for (int i = 0; i < size; i++) {\r\n        object.add(i);\r\n        object.add(object);\r\n        object.add(new ArrayList<>(object));\r\n    }\r\n    final Collection<?> result = testCompress840(object);\r\n    assertNotNull(result);\r\n    assertEquals(size, result.size());\r\n    object.add(object);\r\n    testCompress840(object);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCompress840BeanContextServicesSupport",
  "sourceCode" : "@Test\r\nvoid testCompress840BeanContextServicesSupport() {\r\n    testCompress840(new BeanContextServicesSupport());\r\n    testCompress840(new BeanContextServicesSupport(new BeanContextServicesSupport()));\r\n    final BeanContextSupport bcs = new BeanContextSupport();\r\n    final BeanContextServicesSupport bcss = new BeanContextServicesSupport();\r\n    bcs.add(FileSystems.getDefault().getPath(\"bar\"));\r\n    bcss.add(bcs);\r\n    testCompress840(bcss);\r\n    bcss.add(FileSystems.getDefault().getPath(\"bar\"));\r\n    testCompress840(bcss);\r\n    bcss.add(bcss);\r\n    testCompress840(bcss);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCompress840BeanContextSupport",
  "sourceCode" : "@Test\r\nvoid testCompress840BeanContextSupport() {\r\n    testCompress840(new BeanContextSupport());\r\n    testCompress840(new BeanContextSupport(new BeanContextSupport()));\r\n    final BeanContextSupport bcs = new BeanContextSupport();\r\n    bcs.add(FileSystems.getDefault().getPath(\"bar\"));\r\n    testCompress840(bcs);\r\n    bcs.add(bcs);\r\n    testCompress840(bcs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCompress840Exception",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 0, 2, 4, 8, 16 })\r\nvoid testCompress840Exception(final int size) {\r\n    final ArrayList<Object> object = new ArrayList<>();\r\n    final Exception bottom = new Exception();\r\n    object.add(bottom);\r\n    Exception top = bottom;\r\n    for (int i = 0; i < size; i++) {\r\n        object.add(i);\r\n        top = new Exception(top);\r\n        object.add(top);\r\n    }\r\n    if (bottom != top) {\r\n        // direct self-causation is not allowed.\r\n        bottom.initCause(top);\r\n    }\r\n    final Collection<?> result = testCompress840(object);\r\n    assertNotNull(result);\r\n    assertEquals(size * 2 + 1, result.size());\r\n    assertEquals(object, result);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCompress840Path",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 0, 2, 4, 8, 16 })\r\nvoid testCompress840Path(final int size) {\r\n    final PriorityQueue<Object> object = new PriorityQueue<>();\r\n    for (int i = 0; i < size; i++) {\r\n        object.add(FileSystems.getDefault().getPath(\"foo\"));\r\n        object.add(FileSystems.getDefault().getPath(\"foo\", \"bar\"));\r\n    }\r\n    testCompress840(object);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCompress840PriorityQueue",
  "sourceCode" : "@ParameterizedTest\r\n@ValueSource(ints = { 0, 2, 4, 8, 16 })\r\nvoid testCompress840PriorityQueue(final int size) {\r\n    final PriorityQueue<Object> object = new PriorityQueue<>();\r\n    for (int i = 0; i < size; i++) {\r\n        object.add(FileSystems.getDefault().getPath(\"foo\"));\r\n    }\r\n    testCompress840(object);\r\n}",
  "annotations" : [ "ParameterizedTest" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testConfiguration",
  "sourceCode" : "@Test\r\nvoid testConfiguration() throws ConfigurationException {\r\n    final Configurations configManager = new Configurations();\r\n    final Configuration config = configManager.properties(\"src/test/resources/config/test.properties\");\r\n    assertTrue(config.containsValue(\"jndivalue2\"));\r\n    assertFalse(config.containsValue(\"notFound\"));\r\n    assertFalse(config.containsValue(null));\r\n    assertFalse(config.containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testCopyAndSave",
  "sourceCode" : "/**\r\n * Tests copying another configuration into the test configuration. This test ensures that the layout object is informed\r\n * about the newly added properties.\r\n */\r\n@Test\r\nvoid testCopyAndSave() throws ConfigurationException {\r\n    final Configuration copyConf = setUpCopyConfig();\r\n    conf.copy(copyConf);\r\n    checkCopiedConfig(copyConf);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testDisableIncludes",
  "sourceCode" : "/**\r\n * Tests whether include files can be disabled.\r\n */\r\n@Test\r\nvoid testDisableIncludes() throws ConfigurationException, IOException {\r\n    final String content = PropertiesConfiguration.getInclude() + \" = nonExistingIncludeFile\" + CR + PROP_NAME + \" = \" + PROP_VALUE + CR;\r\n    final StringReader in = new StringReader(content);\r\n    conf = new PropertiesConfiguration();\r\n    conf.setIncludesAllowed(false);\r\n    conf.read(in);\r\n    assertEquals(PROP_VALUE, conf.getString(PROP_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testDisableListDelimiter",
  "sourceCode" : "@Test\r\nvoid testDisableListDelimiter() throws Exception {\r\n    assertEquals(4, conf.getList(\"test.mixed.array\").size());\r\n    final PropertiesConfiguration pc2 = new PropertiesConfiguration();\r\n    load(pc2, TEST_PROPERTIES);\r\n    assertEquals(2, pc2.getList(\"test.mixed.array\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testEmpty",
  "sourceCode" : "/**\r\n * Tests that empty properties are treated as the empty string (rather than as null).\r\n */\r\n@Test\r\nvoid testEmpty() {\r\n    checkEmpty(\"test.empty\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testEmptyNoSeparator",
  "sourceCode" : "/**\r\n * Tests that properties are detected that do not have a separator and a value.\r\n */\r\n@Test\r\nvoid testEmptyNoSeparator() {\r\n    checkEmpty(\"test.empty2\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testEscapedKey",
  "sourceCode" : "@Test\r\nvoid testEscapedKey() throws Exception {\r\n    conf.clear();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.load(new StringReader(\"\\\\u0066\\\\u006f\\\\u006f=bar\"));\r\n    assertEquals(\"bar\", conf.getString(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testEscapedKeyValueSeparator",
  "sourceCode" : "/**\r\n * Check that key/value separators can be part of a key.\r\n */\r\n@Test\r\nvoid testEscapedKeyValueSeparator() {\r\n    assertEquals(\"foo\", conf.getProperty(\"test.separator=in.key\"));\r\n    assertEquals(\"bar\", conf.getProperty(\"test.separator:in.key\"));\r\n    assertEquals(\"foo\", conf.getProperty(\"test.separator\\tin.key\"));\r\n    assertEquals(\"bar\", conf.getProperty(\"test.separator\\fin.key\"));\r\n    assertEquals(\"foo\", conf.getProperty(\"test.separator in.key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testEscapeQuote",
  "sourceCode" : "/**\r\n * Tests the escaping of quotation marks in a properties value. This test is related to CONFIGURATION-516.\r\n */\r\n@Test\r\nvoid testEscapeQuote() throws ConfigurationException {\r\n    conf.clear();\r\n    final String text = \"\\\"Hello World!\\\"\";\r\n    conf.setProperty(PROP_NAME, text);\r\n    final StringWriter out = new StringWriter();\r\n    new FileHandler(conf).save(out);\r\n    assertTrue(out.toString().contains(text));\r\n    saveTestConfig();\r\n    final PropertiesConfiguration c2 = new PropertiesConfiguration();\r\n    load(c2, TEST_SAVE_PROPERTIES_FILE.getAbsolutePath());\r\n    assertEquals(text, c2.getString(PROP_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testFileWithSharpSymbol",
  "sourceCode" : "/**\r\n * Test the creation of a file containing a '#' in its name.\r\n */\r\n@Test\r\nvoid testFileWithSharpSymbol() throws Exception {\r\n    final File file = newFile(\"sharp#1.properties\", tempFolder);\r\n    final PropertiesConfiguration conf = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setFile(file);\r\n    handler.load();\r\n    handler.save();\r\n    assertTrue(file.exists());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testGetFooterSynchronized",
  "sourceCode" : "/**\r\n * Tests whether read access to the footer comment is synchronized.\r\n */\r\n@Test\r\nvoid testGetFooterSynchronized() {\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    conf.setSynchronizer(sync);\r\n    assertNotNull(conf.getFooter());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testGetHeaderSynchronized",
  "sourceCode" : "/**\r\n * Tests whether read access to the header comment is synchronized.\r\n */\r\n@Test\r\nvoid testGetHeaderSynchronized() {\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    conf.setSynchronizer(sync);\r\n    assertNull(conf.getHeader());\r\n    sync.verify(Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testGetIOFactoryDefault",
  "sourceCode" : "/**\r\n * Tests whether a default IOFactory is set.\r\n */\r\n@Test\r\nvoid testGetIOFactoryDefault() {\r\n    assertNotNull(conf.getIOFactory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testGetLayout",
  "sourceCode" : "/**\r\n * Tests accessing the layout object.\r\n */\r\n@Test\r\nvoid testGetLayout() {\r\n    final PropertiesConfigurationLayout layout = conf.getLayout();\r\n    assertNotNull(layout);\r\n    assertSame(layout, conf.getLayout());\r\n    conf.setLayout(null);\r\n    final PropertiesConfigurationLayout layout2 = conf.getLayout();\r\n    assertNotNull(layout2);\r\n    assertNotSame(layout, layout2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testGetStringWithEscapedChars",
  "sourceCode" : "@Test\r\nvoid testGetStringWithEscapedChars() {\r\n    final String property = conf.getString(\"test.unescape\");\r\n    assertEquals(\"This \\n string \\t contains \\\" escaped \\\\ characters\", property);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testGetStringWithEscapedComma",
  "sourceCode" : "@Test\r\nvoid testGetStringWithEscapedComma() {\r\n    final String property = conf.getString(\"test.unescape.list-separator\");\r\n    assertEquals(\"This string contains , an escaped list separator\", property);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeIncludeLoadAllOnNotFound",
  "sourceCode" : "@Test\r\nvoid testIncludeIncludeLoadAllOnNotFound() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    pc.setIncludeListener(PropertiesConfiguration.NOOP_INCLUDE_LISTENER);\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-include-not-found.properties\");\r\n    handler.load();\r\n    assertEquals(\"valueA\", pc.getString(\"keyA\"));\r\n    assertEquals(\"valueB\", pc.getString(\"keyB\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeIncludeLoadCyclicalReferenceFail",
  "sourceCode" : "@Test\r\nvoid testIncludeIncludeLoadCyclicalReferenceFail() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-include-cyclical-reference.properties\");\r\n    assertThrows(ConfigurationException.class, handler::load);\r\n    assertNull(pc.getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeIncludeLoadCyclicalReferenceIgnore",
  "sourceCode" : "@Test\r\nvoid testIncludeIncludeLoadCyclicalReferenceIgnore() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    pc.setIncludeListener(PropertiesConfiguration.NOOP_INCLUDE_LISTENER);\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-include-cyclical-reference.properties\");\r\n    handler.load();\r\n    assertEquals(\"valueA\", pc.getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeInSubDir",
  "sourceCode" : "/**\r\n * Tests including properties when they are loaded from a nested directory structure.\r\n */\r\n@Test\r\nvoid testIncludeInSubDir() throws ConfigurationException {\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFileName(\"testFactoryPropertiesInclude.xml\"));\r\n    final Configuration config = builder.getConfiguration();\r\n    assertTrue(config.getBoolean(\"deeptest\"));\r\n    assertTrue(config.getBoolean(\"deepinclude\"));\r\n    assertFalse(config.containsKey(\"deeptestinvalid\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeLoadAllOnLoadException",
  "sourceCode" : "@Test\r\nvoid testIncludeLoadAllOnLoadException() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    pc.setIncludeListener(PropertiesConfiguration.NOOP_INCLUDE_LISTENER);\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-load-exception.properties\");\r\n    handler.load();\r\n    assertEquals(\"valueA\", pc.getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeLoadAllOnNotFound",
  "sourceCode" : "@Test\r\nvoid testIncludeLoadAllOnNotFound() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    pc.setIncludeListener(PropertiesConfiguration.NOOP_INCLUDE_LISTENER);\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-not-found.properties\");\r\n    handler.load();\r\n    assertEquals(\"valueA\", pc.getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeLoadCyclicalMultiStepReferenceFail",
  "sourceCode" : "@Test\r\nvoid testIncludeLoadCyclicalMultiStepReferenceFail() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-cyclical-root.properties\");\r\n    assertThrows(ConfigurationException.class, handler::load);\r\n    assertNull(pc.getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeLoadCyclicalMultiStepReferenceIgnore",
  "sourceCode" : "@Test\r\nvoid testIncludeLoadCyclicalMultiStepReferenceIgnore() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    pc.setIncludeListener(PropertiesConfiguration.NOOP_INCLUDE_LISTENER);\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-cyclical-root.properties\");\r\n    handler.load();\r\n    assertEquals(\"valueA\", pc.getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeLoadCyclicalReferenceFail",
  "sourceCode" : "@Test\r\nvoid testIncludeLoadCyclicalReferenceFail() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-cyclical-reference.properties\");\r\n    assertThrows(ConfigurationException.class, handler::load);\r\n    assertNull(pc.getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIncludeLoadCyclicalReferenceIgnore",
  "sourceCode" : "@Test\r\nvoid testIncludeLoadCyclicalReferenceIgnore() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    pc.setIncludeListener(PropertiesConfiguration.NOOP_INCLUDE_LISTENER);\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"include-cyclical-reference.properties\");\r\n    handler.load();\r\n    assertEquals(\"valueA\", pc.getString(\"keyA\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testInitFromNonExistingFile",
  "sourceCode" : "/**\r\n * Tests initializing a properties configuration from a non existing file. There was a bug, which caused properties\r\n * getting lost when later save() is called.\r\n */\r\n@Test\r\nvoid testInitFromNonExistingFile() throws ConfigurationException {\r\n    final String testProperty = \"test.successfull\";\r\n    conf = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setFile(TEST_SAVE_PROPERTIES_FILE);\r\n    conf.addProperty(testProperty, \"true\");\r\n    handler.save();\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testInMemoryCreatedSave",
  "sourceCode" : "@Test\r\nvoid testInMemoryCreatedSave() throws Exception {\r\n    conf = new PropertiesConfiguration();\r\n    // add an array of strings to the configuration\r\n    conf.addProperty(\"string\", \"value1\");\r\n    final List<Object> list = new ArrayList<>();\r\n    for (int i = 1; i < 5; i++) {\r\n        list.add(\"value\" + i);\r\n    }\r\n    conf.addProperty(\"array\", list);\r\n    // save the configuration\r\n    saveTestConfig();\r\n    assertTrue(TEST_SAVE_PROPERTIES_FILE.exists());\r\n    // read the configuration and compare the properties\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testIsCommentLine",
  "sourceCode" : "/**\r\n * Tests whether comment lines are correctly detected.\r\n */\r\n@Test\r\nvoid testIsCommentLine() {\r\n    assertTrue(PropertiesConfiguration.isCommentLine(\"# a comment\"));\r\n    assertTrue(PropertiesConfiguration.isCommentLine(\"! a comment\"));\r\n    assertTrue(PropertiesConfiguration.isCommentLine(\"#a comment\"));\r\n    assertTrue(PropertiesConfiguration.isCommentLine(\"    ! a comment\"));\r\n    assertFalse(PropertiesConfiguration.isCommentLine(\"   a#comment\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testJupRead",
  "sourceCode" : "/**\r\n * Tests that {@link PropertiesConfiguration.JupIOFactory} reads the same keys and values as {@link Properties} based on\r\n * a test file.\r\n */\r\n@Test\r\nvoid testJupRead() throws IOException, ConfigurationException {\r\n    conf.clear();\r\n    conf.setIOFactory(new PropertiesConfiguration.JupIOFactory());\r\n    final String testFilePath = ConfigurationAssert.getTestFile(\"jup-test.properties\").getAbsolutePath();\r\n    load(conf, testFilePath);\r\n    final Properties jup = new Properties();\r\n    try (InputStream in = Files.newInputStream(Paths.get(testFilePath))) {\r\n        jup.load(in);\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    final Set<Object> pcKeys = new HashSet<>(IteratorUtils.toList(conf.getKeys()));\r\n    assertEquals(jup.keySet(), pcKeys);\r\n    for (final Object key : jup.keySet()) {\r\n        final String keyString = key.toString();\r\n        assertEquals(jup.getProperty(keyString), conf.getProperty(keyString), \"Wrong property value for '\" + keyString + \"'\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testJupWrite",
  "sourceCode" : "/**\r\n * Tests that {@link PropertiesConfiguration.JupIOFactory} writes properties in a way that allows {@link Properties} to\r\n * read them exactly like they were set.\r\n */\r\n@Test\r\nvoid testJupWrite() throws IOException, ConfigurationException {\r\n    conf.clear();\r\n    conf.setIOFactory(new PropertiesConfiguration.JupIOFactory());\r\n    final String testFilePath = ConfigurationAssert.getTestFile(\"jup-test.properties\").getAbsolutePath();\r\n    // read the test properties and set them on the PropertiesConfiguration\r\n    final Properties origProps = new Properties();\r\n    try (InputStream in = Files.newInputStream(Paths.get(testFilePath))) {\r\n        origProps.load(in);\r\n    }\r\n    for (final Object key : origProps.keySet()) {\r\n        final String keyString = key.toString();\r\n        conf.setProperty(keyString, origProps.getProperty(keyString));\r\n    }\r\n    // save the configuration\r\n    saveTestConfig();\r\n    assertTrue(TEST_SAVE_PROPERTIES_FILE.exists());\r\n    // load the saved file...\r\n    final Properties testProps = new Properties();\r\n    try (InputStream in = Files.newInputStream(TEST_SAVE_PROPERTIES_FILE.toPath())) {\r\n        testProps.load(in);\r\n    }\r\n    // ... and compare the properties to the originals\r\n    @SuppressWarnings(\"unchecked\")\r\n    final Set<Object> pcKeys = new HashSet<>(IteratorUtils.toList(conf.getKeys()));\r\n    assertEquals(testProps.keySet(), pcKeys);\r\n    for (final Object key : testProps.keySet()) {\r\n        final String keyString = key.toString();\r\n        assertEquals(testProps.getProperty(keyString), conf.getProperty(keyString), \"Wrong property value for '\" + keyString + \"'\");\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testJupWriteUtf8WithoutUnicodeEscapes",
  "sourceCode" : "/**\r\n * Tests that {@link PropertiesConfiguration.JupIOFactory} writes properties in a way that allows {@link Properties} to\r\n * read them exactly like they were set. This test writes in UTF-8 encoding, with Unicode escapes turned off.\r\n */\r\n@Test\r\nvoid testJupWriteUtf8WithoutUnicodeEscapes() throws IOException, ConfigurationException {\r\n    conf.clear();\r\n    conf.setIOFactory(new PropertiesConfiguration.JupIOFactory(false));\r\n    final String testFilePath = ConfigurationAssert.getTestFile(\"jup-test.properties\").getAbsolutePath();\r\n    // read the test properties and set them on the PropertiesConfiguration\r\n    final Properties origProps = new Properties();\r\n    try (InputStream in = Files.newInputStream(Paths.get(testFilePath))) {\r\n        origProps.load(in);\r\n    }\r\n    for (final Object key : origProps.keySet()) {\r\n        final String keyString = key.toString();\r\n        conf.setProperty(keyString, origProps.getProperty(keyString));\r\n    }\r\n    // save the configuration as UTF-8\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setEncoding(StandardCharsets.UTF_8.name());\r\n    handler.save(TEST_SAVE_PROPERTIES_FILE);\r\n    assertTrue(TEST_SAVE_PROPERTIES_FILE.exists());\r\n    // load the saved file...\r\n    final Properties testProps = new Properties();\r\n    try (BufferedReader in = Files.newBufferedReader(TEST_SAVE_PROPERTIES_FILE.toPath(), StandardCharsets.UTF_8)) {\r\n        testProps.load(in);\r\n    }\r\n    // ... and compare the properties to the originals\r\n    @SuppressWarnings(\"unchecked\")\r\n    final Set<Object> pcKeys = new HashSet<>(IteratorUtils.toList(conf.getKeys()));\r\n    assertEquals(testProps.keySet(), pcKeys);\r\n    for (final Object key : testProps.keySet()) {\r\n        final String keyString = key.toString();\r\n        assertEquals(testProps.getProperty(keyString), conf.getProperty(keyString), \"Wrong property value for '\" + keyString + \"'\");\r\n    }\r\n    // ensure that the written properties file contains no Unicode escapes\r\n    for (final String line : Files.readAllLines(TEST_SAVE_PROPERTIES_FILE.toPath())) {\r\n        assertFalse(line.contains(\"\\\\u\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testKeepSeparators",
  "sourceCode" : "/**\r\n * Tests that the property separators are retained when saving the configuration.\r\n */\r\n@Test\r\nvoid testKeepSeparators() throws ConfigurationException, IOException {\r\n    saveTestConfig();\r\n    // @formatter:off\r\n    final Set<String> separatorTests = new HashSet<>(Arrays.asList(\"test.separator.equal = foo\", \"test.separator.colon : foo\", \"test.separator.tab\\tfoo\", \"test.separator.whitespace foo\", \"test.separator.no.space=foo\"));\r\n    // @formatter:on\r\n    final Set<String> foundLines = new HashSet<>();\r\n    try (BufferedReader in = new BufferedReader(new FileReader(TEST_SAVE_PROPERTIES_FILE))) {\r\n        String s;\r\n        while ((s = in.readLine()) != null) {\r\n            for (final String separatorTest : separatorTests) {\r\n                if (separatorTest.equals(s)) {\r\n                    foundLines.add(s);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    assertEquals(separatorTests, foundLines);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testKeyValueSeparators",
  "sourceCode" : "/**\r\n * Test all acceptable key/value separators ('=', ':' or white spaces).\r\n */\r\n@Test\r\nvoid testKeyValueSeparators() {\r\n    assertEquals(\"foo\", conf.getProperty(\"test.separator.equal\"));\r\n    assertEquals(\"foo\", conf.getProperty(\"test.separator.colon\"));\r\n    assertEquals(\"foo\", conf.getProperty(\"test.separator.tab\"));\r\n    assertEquals(\"foo\", conf.getProperty(\"test.separator.formfeed\"));\r\n    assertEquals(\"foo\", conf.getProperty(\"test.separator.whitespace\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLargeKey",
  "sourceCode" : "@Test\r\nvoid testLargeKey() throws Exception {\r\n    conf.clear();\r\n    final String key = String.join(\"\", Collections.nCopies(10000, \"x\"));\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.load(new StringReader(key));\r\n    assertEquals(\"\", conf.getString(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLineSeparator",
  "sourceCode" : "/**\r\n * Tests whether the correct line separator is used.\r\n */\r\n@Test\r\nvoid testLineSeparator() throws ConfigurationException {\r\n    final String eol = System.lineSeparator();\r\n    conf = new PropertiesConfiguration();\r\n    conf.setHeader(\"My header\");\r\n    conf.setProperty(\"prop\", \"value\");\r\n    final StringWriter out = new StringWriter();\r\n    new FileHandler(conf).save(out);\r\n    final String content = out.toString();\r\n    assertEquals(0, content.indexOf(\"# My header\" + eol + eol));\r\n    assertTrue(content.contains(\"prop = value\" + eol));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testList",
  "sourceCode" : "/**\r\n * Tests {@code List} parsing.\r\n */\r\n@Test\r\nvoid testList() throws Exception {\r\n    final List<Object> packages = conf.getList(\"packages\");\r\n    // we should get 3 packages here\r\n    assertEquals(3, packages.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoad",
  "sourceCode" : "@Test\r\nvoid testLoad() throws Exception {\r\n    final String loaded = conf.getString(\"configuration.loaded\");\r\n    assertEquals(\"true\", loaded);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadFromFile",
  "sourceCode" : "@Test\r\nvoid testLoadFromFile() throws Exception {\r\n    final File file = ConfigurationAssert.getTestFile(\"test.properties\");\r\n    conf.clear();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setFile(file);\r\n    handler.load();\r\n    assertEquals(\"true\", conf.getString(\"configuration.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadInclude",
  "sourceCode" : "/**\r\n * test if includes properties get loaded too\r\n */\r\n@Test\r\nvoid testLoadInclude() throws Exception {\r\n    final String loaded = conf.getString(\"include.loaded\");\r\n    assertEquals(\"true\", loaded);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadIncludeFileViaFileSystem",
  "sourceCode" : "/**\r\n * Tests whether the correct file system is used when loading an include file. This test is related to\r\n * CONFIGURATION-609.\r\n */\r\n@Test\r\nvoid testLoadIncludeFileViaFileSystem() throws ConfigurationException {\r\n    conf.clear();\r\n    conf.addProperty(\"include\", \"include.properties\");\r\n    saveTestConfig();\r\n    final FileSystem fs = new DefaultFileSystem() {\r\n\r\n        @Override\r\n        public InputStream getInputStream(final URL url) throws ConfigurationException {\r\n            if (url.toString().endsWith(\"include.properties\")) {\r\n                return new ByteArrayInputStream(\"test.outcome = success\".getBytes(StandardCharsets.UTF_8));\r\n            }\r\n            return super.getInputStream(url);\r\n        }\r\n    };\r\n    final Parameters params = new Parameters();\r\n    final FileBasedConfigurationBuilder<PropertiesConfiguration> builder = new FileBasedConfigurationBuilder<>(PropertiesConfiguration.class);\r\n    builder.configure(params.fileBased().setFile(TEST_SAVE_PROPERTIES_FILE).setBasePath(ConfigurationAssert.OUT_DIR.toURI().toString()).setFileSystem(fs));\r\n    final PropertiesConfiguration configuration = builder.getConfiguration();\r\n    assertEquals(\"success\", configuration.getString(\"test.outcome\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadIncludeFromClassPath",
  "sourceCode" : "/**\r\n * Tests if included files are loaded when the source lies in the class path.\r\n */\r\n@Test\r\nvoid testLoadIncludeFromClassPath() {\r\n    assertEquals(\"true\", conf.getString(\"include.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadIncludeFromReader",
  "sourceCode" : "/**\r\n * Tests whether include files can be resolved if a configuration file is read from a reader.\r\n */\r\n@Test\r\nvoid testLoadIncludeFromReader() throws ConfigurationException {\r\n    final StringReader in = new StringReader(PropertiesConfiguration.getInclude() + \" = \" + ConfigurationAssert.getTestURL(\"include.properties\"));\r\n    conf = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.load(in);\r\n    assertEquals(\"true\", conf.getString(\"include.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadIncludeInterpol",
  "sourceCode" : "/**\r\n * test if includes properties from interpolated file name get loaded\r\n */\r\n@Test\r\nvoid testLoadIncludeInterpol() throws Exception {\r\n    final String loaded = conf.getString(\"include.interpol.loaded\");\r\n    assertEquals(\"true\", loaded);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadIncludeOptional",
  "sourceCode" : "@Test\r\nvoid testLoadIncludeOptional() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"includeoptional.properties\");\r\n    handler.load();\r\n    assertTrue(pc.getBoolean(\"includeoptional.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadUnexistingFile",
  "sourceCode" : "@Test\r\nvoid testLoadUnexistingFile() {\r\n    assertThrows(ConfigurationException.class, () -> load(conf, \"unexisting file\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadViaPropertyWithBasePath",
  "sourceCode" : "@Test\r\nvoid testLoadViaPropertyWithBasePath() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH);\r\n    handler.setFileName(\"test.properties\");\r\n    handler.load();\r\n    assertTrue(pc.getBoolean(\"test.boolean\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testLoadViaPropertyWithBasePath2",
  "sourceCode" : "@Test\r\nvoid testLoadViaPropertyWithBasePath2() throws Exception {\r\n    final PropertiesConfiguration pc = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(pc);\r\n    handler.setBasePath(TEST_BASE_PATH_2);\r\n    handler.setFileName(\"test.properties\");\r\n    handler.load();\r\n    assertTrue(pc.getBoolean(\"test.boolean\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testMixedArray",
  "sourceCode" : "@Test\r\nvoid testMixedArray() {\r\n    final String[] array = conf.getStringArray(\"test.mixed.array\");\r\n    assertArrayEquals(new String[] { \"a\", \"b\", \"c\", \"d\" }, array);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testMultilines",
  "sourceCode" : "@Test\r\nvoid testMultilines() {\r\n    final String property = \"This is a value spread out across several adjacent natural lines by escaping the line terminator with \" + \"a backslash character.\";\r\n    assertEquals(property, conf.getString(\"test.multilines\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testMultipleIncludeFiles",
  "sourceCode" : "/**\r\n * Tests whether multiple include files can be resolved.\r\n */\r\n@Test\r\nvoid testMultipleIncludeFiles() throws ConfigurationException {\r\n    conf = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.load(ConfigurationAssert.getTestFile(\"config/testMultiInclude.properties\"));\r\n    assertEquals(\"topValue\", conf.getString(\"top\"));\r\n    assertEquals(100, conf.getInt(\"property.c\"));\r\n    assertTrue(conf.getBoolean(\"include.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testNewLineEscaping",
  "sourceCode" : "/**\r\n * Tests escaping of an end of line with a backslash.\r\n */\r\n@Test\r\nvoid testNewLineEscaping() {\r\n    final List<Object> list = conf.getList(\"test.path\");\r\n    assertEquals(Arrays.asList(\"C:\\\\path1\\\\\", \"C:\\\\path2\\\\\", \"C:\\\\path3\\\\complex\\\\test\\\\\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testPropertyLoaded",
  "sourceCode" : "/**\r\n * Tests the propertyLoaded() method for a simple property.\r\n */\r\n@Test\r\nvoid testPropertyLoaded() throws ConfigurationException {\r\n    final DummyLayout layout = new DummyLayout();\r\n    conf.setLayout(layout);\r\n    conf.propertyLoaded(\"layoutLoadedProperty\", \"yes\", null);\r\n    assertEquals(0, layout.loadCalls);\r\n    assertEquals(\"yes\", conf.getString(\"layoutLoadedProperty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testPropertyLoadedInclude",
  "sourceCode" : "/**\r\n * Tests the propertyLoaded() method for an include property.\r\n */\r\n@Test\r\nvoid testPropertyLoadedInclude() throws ConfigurationException {\r\n    final DummyLayout layout = new DummyLayout();\r\n    conf.setLayout(layout);\r\n    conf.propertyLoaded(PropertiesConfiguration.getInclude(), \"testClasspath.properties,testEqual.properties\", new ArrayDeque<>());\r\n    assertEquals(2, layout.loadCalls);\r\n    assertFalse(conf.containsKey(PropertiesConfiguration.getInclude()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testPropertyLoadedIncludeNotAllowed",
  "sourceCode" : "/**\r\n * Tests propertyLoaded() for an include property, when includes are disabled.\r\n */\r\n@Test\r\nvoid testPropertyLoadedIncludeNotAllowed() throws ConfigurationException {\r\n    final DummyLayout layout = new DummyLayout();\r\n    conf.setLayout(layout);\r\n    conf.setIncludesAllowed(false);\r\n    conf.propertyLoaded(PropertiesConfiguration.getInclude(), \"testClassPath.properties,testEqual.properties\", null);\r\n    assertEquals(0, layout.loadCalls);\r\n    assertFalse(conf.containsKey(PropertiesConfiguration.getInclude()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testReadCalledDirectly",
  "sourceCode" : "/**\r\n * Tests a direct invocation of the read() method. This is not allowed because certain initializations have not been\r\n * done. This test is related to CONFIGURATION-641.\r\n */\r\n@Test\r\nvoid testReadCalledDirectly() throws IOException {\r\n    conf = new PropertiesConfiguration();\r\n    try (Reader in = new FileReader(ConfigurationAssert.getTestFile(\"test.properties\"))) {\r\n        final ConfigurationException e = assertThrows(ConfigurationException.class, () -> conf.read(in));\r\n        assertTrue(e.getMessage().contains(\"FileHandler\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testReadFooterComment",
  "sourceCode" : "/**\r\n * Tests whether a footer comment is correctly read.\r\n */\r\n@Test\r\nvoid testReadFooterComment() {\r\n    assertEquals(\"\\n# This is a foot comment\\n\", conf.getFooter());\r\n    assertEquals(\"\\nThis is a foot comment\\n\", conf.getLayout().getCanonicalFooterCooment(false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testReference",
  "sourceCode" : "/**\r\n * Tests that references to other properties work\r\n */\r\n@Test\r\nvoid testReference() throws Exception {\r\n    assertEquals(\"baseextra\", conf.getString(\"base.reference\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "@Test\r\nvoid testSave() throws Exception {\r\n    // add an array of strings to the configuration\r\n    conf.addProperty(\"string\", \"value1\");\r\n    final List<Object> list = new ArrayList<>();\r\n    for (int i = 1; i < 5; i++) {\r\n        list.add(\"value\" + i);\r\n    }\r\n    conf.addProperty(\"array\", list);\r\n    // save the configuration\r\n    saveTestConfig();\r\n    assertTrue(TEST_SAVE_PROPERTIES_FILE.exists());\r\n    // read the configuration and compare the properties\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveEscapedEscapingCharacter",
  "sourceCode" : "/**\r\n * Tests whether the escape character for list delimiters can be itself escaped and survives a save operation.\r\n */\r\n@Test\r\nvoid testSaveEscapedEscapingCharacter() throws ConfigurationException {\r\n    conf.addProperty(\"test.dirs\", \"C:\\\\Temp\\\\\\\\,D:\\\\Data\\\\\\\\,E:\\\\Test\\\\\");\r\n    final List<Object> dirs = conf.getList(\"test.dirs\");\r\n    assertEquals(3, dirs.size());\r\n    saveTestConfig();\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveMissingFileName",
  "sourceCode" : "@Test\r\nvoid testSaveMissingFileName() {\r\n    final FileHandler handler = new FileHandler(conf);\r\n    assertThrows(ConfigurationException.class, handler::save);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveToCustomURL",
  "sourceCode" : "@Test\r\nvoid testSaveToCustomURL() throws Exception {\r\n    // save the configuration to a custom URL\r\n    final URL url = new URL(\"foo\", \"\", 0, newFile(\"testsave-custom-url.properties\", tempFolder).getAbsolutePath(), new FileURLStreamHandler());\r\n    final FileHandler handlerSave = new FileHandler(conf);\r\n    handlerSave.save(url);\r\n    // reload the configuration\r\n    final PropertiesConfiguration config2 = new PropertiesConfiguration();\r\n    final FileHandler handlerLoad = new FileHandler(config2);\r\n    handlerLoad.load(url);\r\n    assertEquals(\"true\", config2.getString(\"configuration.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveToHTTPServerFail",
  "sourceCode" : "/**\r\n * Tests saving a file-based configuration to a HTTP server when the server reports a failure. This should cause an\r\n * exception.\r\n */\r\n@Test\r\nvoid testSaveToHTTPServerFail() throws Exception {\r\n    final MockHttpURLStreamHandler handler = new MockHttpURLStreamHandler(HttpURLConnection.HTTP_BAD_REQUEST, TEST_SAVE_PROPERTIES_FILE);\r\n    final URL url = new URL(null, \"http://jakarta.apache.org\", handler);\r\n    final FileHandler fileHandler = new FileHandler(conf);\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> fileHandler.save(url));\r\n    assertInstanceOf(IOException.class, cex.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveToHTTPServerSuccess",
  "sourceCode" : "/**\r\n * Tests saving a file-based configuration to a HTTP server.\r\n */\r\n@Test\r\nvoid testSaveToHTTPServerSuccess() throws Exception {\r\n    final MockHttpURLStreamHandler handler = new MockHttpURLStreamHandler(HttpURLConnection.HTTP_OK, TEST_SAVE_PROPERTIES_FILE);\r\n    final URL url = new URL(null, \"http://jakarta.apache.org\", handler);\r\n    new FileHandler(conf).save(url);\r\n    final MockHttpURLConnection con = handler.getMockConnection();\r\n    assertTrue(con.getDoOutput());\r\n    assertEquals(\"PUT\", con.getRequestMethod());\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveWithBasePath",
  "sourceCode" : "/**\r\n * Tests if the base path is taken into account by the save() method.\r\n */\r\n@Test\r\nvoid testSaveWithBasePath() throws Exception {\r\n    conf.setProperty(\"test\", \"true\");\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setBasePath(TEST_SAVE_PROPERTIES_FILE.getParentFile().toURI().toURL().toString());\r\n    handler.setFileName(TEST_SAVE_PROPERTIES_FILE.getName());\r\n    handler.save();\r\n    assertTrue(TEST_SAVE_PROPERTIES_FILE.exists());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveWithDataConfig",
  "sourceCode" : "/**\r\n * Tests adding properties through a DataConfiguration. This is related to CONFIGURATION-332.\r\n */\r\n@Test\r\nvoid testSaveWithDataConfig() throws ConfigurationException {\r\n    conf = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setFile(TEST_SAVE_PROPERTIES_FILE);\r\n    final DataConfiguration dataConfig = new DataConfiguration(conf);\r\n    dataConfig.setProperty(\"foo\", \"bar\");\r\n    assertEquals(\"bar\", conf.getString(\"foo\"));\r\n    handler.save();\r\n    final PropertiesConfiguration config2 = new PropertiesConfiguration();\r\n    load(config2, TEST_SAVE_PROPERTIES_FILE.getAbsolutePath());\r\n    assertEquals(\"bar\", config2.getString(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveWithDefaultListDelimiterHandler",
  "sourceCode" : "/**\r\n * Tests whether saving works correctly with the default list delimiter handler implementation.\r\n */\r\n@Test\r\nvoid testSaveWithDefaultListDelimiterHandler() throws ConfigurationException {\r\n    conf.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    saveTestConfig();\r\n    final PropertiesConfiguration checkConfig = new PropertiesConfiguration();\r\n    checkConfig.setListDelimiterHandler(conf.getListDelimiterHandler());\r\n    new FileHandler(checkConfig).load(TEST_SAVE_PROPERTIES_FILE);\r\n    ConfigurationAssert.assertConfigurationEquals(conf, checkConfig);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSaveWithDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests saving a configuration if delimiter parsing is disabled.\r\n */\r\n@Test\r\nvoid testSaveWithDelimiterParsingDisabled() throws ConfigurationException {\r\n    conf.clear();\r\n    conf.setListDelimiterHandler(new DisabledListDelimiterHandler());\r\n    conf.addProperty(\"test.list\", \"a,b,c\");\r\n    conf.addProperty(\"test.dirs\", \"C:\\\\Temp\\\\,D:\\\\Data\\\\\");\r\n    saveTestConfig();\r\n    final PropertiesConfiguration checkConfig = new PropertiesConfiguration();\r\n    checkConfig.setListDelimiterHandler(new DisabledListDelimiterHandler());\r\n    new FileHandler(checkConfig).load(TEST_SAVE_PROPERTIES_FILE);\r\n    ConfigurationAssert.assertConfigurationEquals(conf, checkConfig);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSetFooterSynchronized",
  "sourceCode" : "/**\r\n * Tests whether write access to the footer comment is synchronized.\r\n */\r\n@Test\r\nvoid testSetFooterSynchronized() {\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    conf.setSynchronizer(sync);\r\n    conf.setFooter(\"new comment\");\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSetHeaderSynchronized",
  "sourceCode" : "/**\r\n * Tests whether write access to the header comment is synchronized.\r\n */\r\n@Test\r\nvoid testSetHeaderSynchronized() {\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    conf.setSynchronizer(sync);\r\n    conf.setHeader(\"new comment\");\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSetInclude",
  "sourceCode" : "@Test\r\nvoid testSetInclude() throws Exception {\r\n    conf.clear();\r\n    // change the include key\r\n    PropertiesConfiguration.setInclude(\"import\");\r\n    // load the configuration\r\n    load(conf, TEST_PROPERTIES);\r\n    // restore the previous value for the other tests\r\n    PropertiesConfiguration.setInclude(\"include\");\r\n    assertNull(conf.getString(\"include.loaded\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSetIOFactoryNull",
  "sourceCode" : "/**\r\n * Tests setting the IOFactory to null. This should cause an exception.\r\n */\r\n@Test\r\nvoid testSetIOFactoryNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> conf.setIOFactory(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSetIOFactoryReader",
  "sourceCode" : "/**\r\n * Tests setting an IOFactory that uses a specialized reader.\r\n */\r\n@Test\r\nvoid testSetIOFactoryReader() throws ConfigurationException {\r\n    final int propertyCount = 10;\r\n    conf.clear();\r\n    conf.setIOFactory(new PropertiesConfiguration.IOFactory() {\r\n\r\n        @Override\r\n        public PropertiesConfiguration.PropertiesReader createPropertiesReader(final Reader in) {\r\n            return new PropertiesReaderTestImpl(in, propertyCount);\r\n        }\r\n\r\n        @Override\r\n        public PropertiesConfiguration.PropertiesWriter createPropertiesWriter(final Writer out, final ListDelimiterHandler handler) {\r\n            throw new UnsupportedOperationException(\"Unexpected call!\");\r\n        }\r\n    });\r\n    load(conf, TEST_PROPERTIES);\r\n    for (int i = 1; i <= propertyCount; i++) {\r\n        assertEquals(PROP_VALUE + i, conf.getString(PROP_NAME + i), \"Wrong property value at \" + i);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSetIOFactoryWriter",
  "sourceCode" : "/**\r\n * Tests setting an IOFactory that uses a specialized writer.\r\n */\r\n@Test\r\nvoid testSetIOFactoryWriter() throws ConfigurationException, IOException {\r\n    final MutableObject<Writer> propertiesWriter = new MutableObject<>();\r\n    conf.setIOFactory(new PropertiesConfiguration.IOFactory() {\r\n\r\n        @Override\r\n        public PropertiesConfiguration.PropertiesReader createPropertiesReader(final Reader in) {\r\n            throw new UnsupportedOperationException(\"Unexpected call!\");\r\n        }\r\n\r\n        @Override\r\n        public PropertiesConfiguration.PropertiesWriter createPropertiesWriter(final Writer out, final ListDelimiterHandler handler) {\r\n            try {\r\n                final PropertiesWriterTestImpl propWriter = new PropertiesWriterTestImpl(handler);\r\n                propertiesWriter.setValue(propWriter);\r\n                return propWriter;\r\n            } catch (final IOException e) {\r\n                return null;\r\n            }\r\n        }\r\n    });\r\n    new FileHandler(conf).save(new StringWriter());\r\n    propertiesWriter.getValue().close();\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSetPropertyListWithDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests whether a list property is handled correctly if delimiter parsing is disabled. This test is related to\r\n * CONFIGURATION-495.\r\n */\r\n@Test\r\nvoid testSetPropertyListWithDelimiterParsingDisabled() throws ConfigurationException {\r\n    final String prop = \"delimiterListProp\";\r\n    conf.setListDelimiterHandler(DisabledListDelimiterHandler.INSTANCE);\r\n    final List<String> list = Arrays.asList(\"val\", \"val2\", \"val3\");\r\n    conf.setProperty(prop, list);\r\n    saveTestConfig();\r\n    conf.clear();\r\n    load(conf, TEST_SAVE_PROPERTIES_FILE.getAbsolutePath());\r\n    assertEquals(list, conf.getProperty(prop));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testSlashEscaping",
  "sourceCode" : "/**\r\n * Tests whether properties with slashes in their values can be saved. This test is related to CONFIGURATION-408.\r\n */\r\n@Test\r\nvoid testSlashEscaping() throws ConfigurationException {\r\n    conf.setProperty(PROP_NAME, \"http://www.apache.org\");\r\n    final StringWriter writer = new StringWriter();\r\n    new FileHandler(conf).save(writer);\r\n    final String s = writer.toString();\r\n    assertTrue(s.contains(PROP_NAME + \" = http://www.apache.org\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testUnEscapeCharacters",
  "sourceCode" : "/**\r\n * Tests whether special characters in a property value are un-escaped. This test is related to CONFIGURATION-640.\r\n */\r\n@Test\r\nvoid testUnEscapeCharacters() {\r\n    assertEquals(\"#1 =: me!\", conf.getString(\"test.unescape.characters\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testUnescapeJava",
  "sourceCode" : "@Test\r\nvoid testUnescapeJava() {\r\n    assertEquals(\"test\\\\,test\", PropertiesConfiguration.unescapeJava(\"test\\\\,test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfiguration.java",
  "methodName" : "testWriteFooterComment",
  "sourceCode" : "/**\r\n * Tests whether a footer comment is correctly written out.\r\n */\r\n@Test\r\nvoid testWriteFooterComment() throws ConfigurationException, IOException {\r\n    final String footer = \"my footer\";\r\n    conf.clear();\r\n    conf.setProperty(PROP_NAME, PROP_VALUE);\r\n    conf.setFooter(footer);\r\n    final StringWriter out = new StringWriter();\r\n    conf.write(out);\r\n    assertEquals(PROP_NAME + \" = \" + PROP_VALUE + CR + \"# \" + footer + CR, out.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testBlankLines",
  "sourceCode" : "/**\r\n * Tests whether blank lines before a property are correctly detected.\r\n */\r\n@Test\r\nvoid testBlankLines() throws ConfigurationException {\r\n    builder.addProperty(\"prop\", \"value\");\r\n    builder.addComment(null);\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(2, layout.getBlankLinesBefore(TEST_KEY));\r\n    assertEquals(TEST_COMMENT + CRNORM, layout.getCanonicalComment(TEST_KEY, false));\r\n    assertEquals(TEST_VALUE, config.getString(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testBlankLinesWithHeaderComment",
  "sourceCode" : "/**\r\n * Tests whether blank lines before a property are correctly detected if a header comment is present\r\n */\r\n@Test\r\nvoid testBlankLinesWithHeaderComment() throws ConfigurationException {\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(2, layout.getBlankLinesBefore(TEST_KEY));\r\n    assertEquals(TEST_COMMENT, layout.getCanonicalComment(TEST_KEY, false));\r\n    assertEquals(TEST_VALUE, config.getString(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testCombineComments",
  "sourceCode" : "/**\r\n * Tests whether comments are combined for multiple occurrences.\r\n */\r\n@Test\r\nvoid testCombineComments() throws ConfigurationException {\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE + \"2\");\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(TEST_COMMENT + CRNORM + TEST_COMMENT, layout.getCanonicalComment(TEST_KEY, false));\r\n    assertEquals(0, layout.getBlankLinesBefore(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testEventAdd",
  "sourceCode" : "/**\r\n * Tests if a property add event is correctly processed.\r\n */\r\n@Test\r\nvoid testEventAdd() {\r\n    final ConfigurationEvent event = new ConfigurationEvent(this, ConfigurationEvent.ADD_PROPERTY, TEST_KEY, TEST_VALUE, false);\r\n    layout.onEvent(event);\r\n    assertTrue(layout.getKeys().contains(TEST_KEY));\r\n    assertEquals(0, layout.getBlankLinesBefore(TEST_KEY));\r\n    assertTrue(layout.isSingleLine(TEST_KEY));\r\n    assertEquals(\" = \", layout.getSeparator(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testEventAddBefore",
  "sourceCode" : "/**\r\n * Tests if a before update event is correctly ignored.\r\n */\r\n@Test\r\nvoid testEventAddBefore() {\r\n    final ConfigurationEvent event = new ConfigurationEvent(this, ConfigurationEvent.ADD_PROPERTY, TEST_KEY, TEST_VALUE, true);\r\n    layout.onEvent(event);\r\n    assertFalse(layout.getKeys().contains(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testEventAddExisting",
  "sourceCode" : "/**\r\n * Tests if an add event is correctly processed if the affected property is already stored in the layout object.\r\n */\r\n@Test\r\nvoid testEventAddExisting() throws ConfigurationException {\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.load(config, builder.getReader());\r\n    final ConfigurationEvent event = new ConfigurationEvent(this, ConfigurationEvent.ADD_PROPERTY, TEST_KEY, TEST_VALUE, false);\r\n    layout.onEvent(event);\r\n    assertFalse(layout.isSingleLine(TEST_KEY));\r\n    assertEquals(TEST_COMMENT, layout.getCanonicalComment(TEST_KEY, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testEventAddMultiple",
  "sourceCode" : "/**\r\n * Tests adding a property multiple time through an event. The property should then be a multi-line property.\r\n */\r\n@Test\r\nvoid testEventAddMultiple() {\r\n    final ConfigurationEvent event = new ConfigurationEvent(this, ConfigurationEvent.ADD_PROPERTY, TEST_KEY, TEST_VALUE, false);\r\n    layout.onEvent(event);\r\n    layout.onEvent(event);\r\n    assertFalse(layout.isSingleLine(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testEventClearConfig",
  "sourceCode" : "/**\r\n * Tests if a clear event is correctly processed.\r\n */\r\n@Test\r\nvoid testEventClearConfig() throws Exception {\r\n    fillLayout();\r\n    final ConfigurationEvent event = new ConfigurationEvent(this, ConfigurationEvent.CLEAR, null, null, false);\r\n    layout.onEvent(event);\r\n    assertTrue(layout.getKeys().isEmpty());\r\n    assertNull(layout.getHeaderComment());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testEventDelete",
  "sourceCode" : "/**\r\n * Tests if a property delete event is correctly processed.\r\n */\r\n@Test\r\nvoid testEventDelete() {\r\n    ConfigurationEvent event = new ConfigurationEvent(this, ConfigurationEvent.ADD_PROPERTY, TEST_KEY, TEST_VALUE, false);\r\n    layout.onEvent(event);\r\n    event = new ConfigurationEvent(this, ConfigurationEvent.CLEAR_PROPERTY, TEST_KEY, null, false);\r\n    layout.onEvent(event);\r\n    assertFalse(layout.getKeys().contains(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testEventSetNonExisting",
  "sourceCode" : "/**\r\n * Tests if a set property event for a non existing property is correctly handled.\r\n */\r\n@Test\r\nvoid testEventSetNonExisting() {\r\n    final ConfigurationEvent event = new ConfigurationEvent(this, ConfigurationEvent.SET_PROPERTY, TEST_KEY, TEST_VALUE, false);\r\n    layout.onEvent(event);\r\n    assertTrue(layout.getKeys().contains(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testGetNonExistingLayouData",
  "sourceCode" : "/**\r\n * Tests accessing data for a property, which is not stored.\r\n */\r\n@Test\r\nvoid testGetNonExistingLayouData() {\r\n    assertNull(layout.getComment(\"unknown\"));\r\n    assertTrue(layout.isSingleLine(\"unknown\"));\r\n    assertEquals(0, layout.getBlankLinesBefore(\"unknown\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testGetNullLayouttData",
  "sourceCode" : "/**\r\n * Tests accessing a property with a null key. This should throw an exception.\r\n */\r\n@Test\r\nvoid testGetNullLayouttData() {\r\n    assertThrows(IllegalArgumentException.class, () -> layout.setComment(null, TEST_COMMENT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testHeaderComment",
  "sourceCode" : "/**\r\n * Tests if a header comment is detected.\r\n */\r\n@Test\r\nvoid testHeaderComment() throws ConfigurationException {\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(TEST_COMMENT, layout.getCanonicalHeaderComment(false));\r\n    assertNull(layout.getCanonicalComment(TEST_KEY, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testHeaderCommentNull",
  "sourceCode" : "/**\r\n * Tests fetching a canonical header comment when no comment is set.\r\n */\r\n@Test\r\nvoid testHeaderCommentNull() {\r\n    assertNull(layout.getCanonicalHeaderComment(true));\r\n    assertNull(layout.getCanonicalHeaderComment(false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testHeaderCommentWithBlanks",
  "sourceCode" : "/**\r\n * Tests if a header comment containing blank lines is correctly detected.\r\n */\r\n@Test\r\nvoid testHeaderCommentWithBlanks() throws ConfigurationException {\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(TEST_COMMENT + CRNORM + CRNORM + TEST_COMMENT, layout.getCanonicalHeaderComment(false));\r\n    assertNull(layout.getComment(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testHeaderCommentWithBlanksAndPresetHeaderComment",
  "sourceCode" : "/**\r\n * Tests if a header comment containing blank lines is correctly detected and doesn't overflow into the property comment\r\n * in the case that the header comment is already set\r\n */\r\n@Test\r\nvoid testHeaderCommentWithBlanksAndPresetHeaderComment() throws ConfigurationException {\r\n    final String presetHeaderComment = \"preset\" + TEST_COMMENT + CRNORM + CRNORM + TEST_COMMENT;\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.setHeaderComment(presetHeaderComment);\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(presetHeaderComment, layout.getCanonicalHeaderComment(false));\r\n    assertNull(layout.getComment(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testHeaderCommentWithBlanksAndPropComment",
  "sourceCode" : "/**\r\n * Tests if a header comment is correctly detected when it contains blank lines and the first property has a comment,\r\n * too.\r\n */\r\n@Test\r\nvoid testHeaderCommentWithBlanksAndPropComment() throws ConfigurationException {\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(TEST_COMMENT + CRNORM + CRNORM + TEST_COMMENT, layout.getCanonicalHeaderComment(false));\r\n    assertEquals(TEST_COMMENT, layout.getCanonicalComment(TEST_KEY, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testInit",
  "sourceCode" : "/**\r\n * Tests a newly created instance.\r\n */\r\n@Test\r\nvoid testInit() {\r\n    assertTrue(layout.getKeys().isEmpty());\r\n    assertNull(layout.getHeaderComment());\r\n    final Iterator<EventListener<? super ConfigurationEvent>> it = config.getEventListeners(ConfigurationEvent.ANY).iterator();\r\n    assertTrue(it.hasNext());\r\n    assertSame(layout, it.next());\r\n    assertFalse(it.hasNext());\r\n    assertFalse(layout.isForceSingleLine());\r\n    assertNull(layout.getGlobalSeparator());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testInitCopy",
  "sourceCode" : "/**\r\n * Tests the copy constructor.\r\n */\r\n@Test\r\nvoid testInitCopy() {\r\n    fillLayout();\r\n    final PropertiesConfigurationLayout l2 = new PropertiesConfigurationLayout(layout);\r\n    assertEquals(l2.getKeys(), layout.getKeys());\r\n    assertEquals(layout.getHeaderComment(), l2.getHeaderComment());\r\n    assertEquals(layout.getFooterComment(), l2.getFooterComment());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testInitCopyModify",
  "sourceCode" : "/**\r\n * Tests if the copy and the original are independent from each other.\r\n */\r\n@Test\r\nvoid testInitCopyModify() {\r\n    fillLayout();\r\n    final PropertiesConfigurationLayout l2 = new PropertiesConfigurationLayout(layout);\r\n    assertEquals(layout.getComment(TEST_KEY), l2.getComment(TEST_KEY));\r\n    layout.setComment(TEST_KEY, \"A new comment\");\r\n    assertEquals(TEST_COMMENT, l2.getCanonicalComment(TEST_KEY, false));\r\n    l2.setBlankLinesBefore(TEST_KEY, l2.getBlankLinesBefore(TEST_KEY) + 1);\r\n    assertNotEquals(layout.getBlankLinesBefore(TEST_KEY), l2.getBlankLinesBefore(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testInitNull",
  "sourceCode" : "/**\r\n * Tests the copy constructor if no other layout object is passed.\r\n */\r\n@Test\r\nvoid testInitNull() {\r\n    layout = new PropertiesConfigurationLayout(null);\r\n    assertTrue(layout.getKeys().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testIsSingleLine",
  "sourceCode" : "/**\r\n * Tests the single line flag for a simple property definition.\r\n */\r\n@Test\r\nvoid testIsSingleLine() throws ConfigurationException {\r\n    builder.addProperty(TEST_KEY, TEST_VALUE + \",\" + TEST_VALUE + \"2\");\r\n    layout.load(config, builder.getReader());\r\n    assertTrue(layout.isSingleLine(TEST_KEY));\r\n    assertEquals(2, config.getList(TEST_KEY).size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testIsSingleLineMulti",
  "sourceCode" : "/**\r\n * Tests the single line flag if there are multiple property definitions.\r\n */\r\n@Test\r\nvoid testIsSingleLineMulti() throws ConfigurationException {\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    builder.addProperty(\"anotherProp\", \"a value\");\r\n    builder.addProperty(TEST_KEY, TEST_VALUE + \"2\");\r\n    layout.load(config, builder.getReader());\r\n    assertFalse(layout.isSingleLine(TEST_KEY));\r\n    assertEquals(2, config.getList(TEST_KEY).size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testLineWithBlank",
  "sourceCode" : "/**\r\n * Tests whether a line with whitespace is handled correctly. This is related to CONFIGURATION-582.\r\n */\r\n@Test\r\nvoid testLineWithBlank() throws ConfigurationException {\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addLine(\" \");\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(TEST_COMMENT + CRNORM + \" \", layout.getCanonicalComment(TEST_KEY, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testReadAndWrite",
  "sourceCode" : "/**\r\n * Tests whether the output of the layout object is identical to the source file (at least for simple properties files).\r\n */\r\n@Test\r\nvoid testReadAndWrite() throws ConfigurationException {\r\n    builder.addComment(\"This is my test properties file,\");\r\n    builder.addComment(\"which contains a header comment.\");\r\n    builder.addComment(null);\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addProperty(TEST_KEY, TEST_COMMENT);\r\n    builder.addComment(null);\r\n    builder.addComment(null);\r\n    builder.addComment(\"Another comment\");\r\n    builder.addProperty(\"property\", \"and a value\");\r\n    layout.load(config, builder.getReader());\r\n    checkLayoutString(builder.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testReadSimple",
  "sourceCode" : "/**\r\n * Tests reading a simple properties file.\r\n */\r\n@Test\r\nvoid testReadSimple() throws ConfigurationException {\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.load(config, builder.getReader());\r\n    assertNull(layout.getHeaderComment());\r\n    assertEquals(1, layout.getKeys().size());\r\n    assertTrue(layout.getKeys().contains(TEST_KEY));\r\n    assertEquals(TEST_COMMENT, layout.getCanonicalComment(TEST_KEY, false));\r\n    assertEquals(0, layout.getBlankLinesBefore(TEST_KEY));\r\n    assertTrue(layout.isSingleLine(TEST_KEY));\r\n    assertEquals(TEST_VALUE, config.getString(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testRecursiveLoadCall",
  "sourceCode" : "/**\r\n * Tests a recursive load call.\r\n */\r\n@Test\r\nvoid testRecursiveLoadCall() throws ConfigurationException {\r\n    final PropertiesBuilder b = new PropertiesBuilder();\r\n    b.addComment(\"A nested header comment.\");\r\n    b.addComment(\"With multiple lines\");\r\n    b.addComment(null);\r\n    b.addComment(\"Second comment\");\r\n    b.addProperty(TEST_KEY, TEST_VALUE);\r\n    b.addProperty(TEST_KEY + \"2\", TEST_VALUE + \"2\");\r\n    config.builder = b;\r\n    builder.addComment(\"Header comment\");\r\n    builder.addComment(null);\r\n    builder.addComment(TEST_COMMENT);\r\n    builder.addProperty(TEST_KEY, TEST_VALUE);\r\n    builder.addComment(\"Include file\");\r\n    builder.addProperty(PropertiesConfiguration.getInclude(), \"test\");\r\n    layout.load(config, builder.getReader());\r\n    assertEquals(\"Header comment\", layout.getCanonicalHeaderComment(false));\r\n    assertFalse(layout.getKeys().contains(PropertiesConfiguration.getInclude()));\r\n    assertEquals(TEST_COMMENT + CRNORM + \"A nested header comment.\" + CRNORM + \"With multiple lines\" + CRNORM + CRNORM + \"Second comment\", layout.getCanonicalComment(TEST_KEY, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSave",
  "sourceCode" : "/**\r\n * Tests if the content of the layout object is correctly written.\r\n */\r\n@Test\r\nvoid testSave() throws ConfigurationException {\r\n    config.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.setComment(TEST_KEY, TEST_COMMENT);\r\n    config.addProperty(TEST_KEY, TEST_VALUE + \"2\");\r\n    config.addProperty(\"AnotherProperty\", \"AnotherValue\");\r\n    config.addProperty(\"AnotherProperty\", \"3rdValue\");\r\n    layout.setComment(\"AnotherProperty\", \"AnotherComment\");\r\n    layout.setBlankLinesBefore(\"AnotherProperty\", 2);\r\n    layout.setSingleLine(\"AnotherProperty\", true);\r\n    layout.setHeaderComment(\"A header comment\" + CRNORM + \"for my properties\");\r\n    checkLayoutString(\"# A header comment\" + CR + \"# for my properties\" + CR + CR + \"# \" + TEST_COMMENT + CR + TEST_KEY + \" = \" + TEST_VALUE + CR + TEST_KEY + \" = \" + TEST_VALUE + \"2\" + CR + CR + CR + \"# AnotherComment\" + CR + \"AnotherProperty = AnotherValue,3rdValue\" + CR);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSaveCommentForUnexistingProperty",
  "sourceCode" : "/**\r\n * Tests saving when a comment for a non existing property is contained in the layout object. This comment should be\r\n * ignored.\r\n */\r\n@Test\r\nvoid testSaveCommentForUnexistingProperty() throws ConfigurationException {\r\n    fillLayout();\r\n    layout.setComment(\"NonExistingKey\", \"NonExistingComment\");\r\n    final String output = getLayoutString();\r\n    assertFalse(output.contains(\"NonExistingKey\"));\r\n    assertFalse(output.contains(\"NonExistingComment\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSaveEmptyLayout",
  "sourceCode" : "/**\r\n * Tests saving an empty layout object.\r\n */\r\n@Test\r\nvoid testSaveEmptyLayout() throws ConfigurationException {\r\n    checkLayoutString(\"\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSaveForceSingleLine",
  "sourceCode" : "/**\r\n * Tests the force single line flag.\r\n */\r\n@Test\r\nvoid testSaveForceSingleLine() throws ConfigurationException {\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler(';'));\r\n    config.addProperty(TEST_KEY, TEST_VALUE);\r\n    config.addProperty(TEST_KEY, TEST_VALUE + \"2\");\r\n    config.addProperty(\"AnotherProperty\", \"value1;value2;value3\");\r\n    layout.setComment(TEST_KEY, TEST_COMMENT);\r\n    layout.setForceSingleLine(true);\r\n    checkLayoutString(\"# \" + TEST_COMMENT + CR + TEST_KEY + \" = \" + TEST_VALUE + ';' + TEST_VALUE + \"2\" + CR + \"AnotherProperty = value1;value2;value3\" + CR);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSetGlobalSeparator",
  "sourceCode" : "/**\r\n * Tests setting the global separator. This separator should override the separators for all properties.\r\n */\r\n@Test\r\nvoid testSetGlobalSeparator() throws ConfigurationException {\r\n    final String sep = \"=\";\r\n    config.addProperty(TEST_KEY, TEST_VALUE);\r\n    config.addProperty(\"key2\", \"value2\");\r\n    layout.setSeparator(TEST_KEY, \" : \");\r\n    layout.setGlobalSeparator(sep);\r\n    checkLayoutString(TEST_KEY + sep + TEST_VALUE + CR + \"key2\" + sep + \"value2\" + CR);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSetLineSeparator",
  "sourceCode" : "/**\r\n * Tests setting the line separator.\r\n */\r\n@Test\r\nvoid testSetLineSeparator() throws ConfigurationException {\r\n    final String lf = CR + CR;\r\n    config.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.setBlankLinesBefore(TEST_KEY, 2);\r\n    layout.setComment(TEST_KEY, TEST_COMMENT);\r\n    layout.setHeaderComment(\"Header comment\");\r\n    layout.setLineSeparator(lf);\r\n    checkLayoutString(\"# Header comment\" + lf + lf + lf + \"# \" + TEST_COMMENT + lf + TEST_KEY + \" = \" + TEST_VALUE + lf);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSetLineSeparatorInComments",
  "sourceCode" : "/**\r\n * Tests whether the line separator is also taken into account within comments.\r\n */\r\n@Test\r\nvoid testSetLineSeparatorInComments() throws ConfigurationException {\r\n    final String lf = \"<-\\n\";\r\n    config.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.setComment(TEST_KEY, TEST_COMMENT + \"\\nMore comment\");\r\n    layout.setHeaderComment(\"Header\\ncomment\");\r\n    layout.setLineSeparator(lf);\r\n    checkLayoutString(\"# Header\" + lf + \"# comment\" + lf + lf + \"# \" + TEST_COMMENT + lf + \"# More comment\" + lf + TEST_KEY + \" = \" + TEST_VALUE + lf);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSetNullComment",
  "sourceCode" : "/**\r\n * Tests resetting a comment.\r\n */\r\n@Test\r\nvoid testSetNullComment() {\r\n    fillLayout();\r\n    layout.setComment(TEST_KEY, null);\r\n    assertNull(layout.getComment(TEST_KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testSetSeparator",
  "sourceCode" : "/**\r\n * Tests changing the separator for a property.\r\n */\r\n@Test\r\nvoid testSetSeparator() throws ConfigurationException {\r\n    config.addProperty(TEST_KEY, TEST_VALUE);\r\n    layout.setSeparator(TEST_KEY, \":\");\r\n    checkLayoutString(TEST_KEY + \":\" + TEST_VALUE + CR);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testTrimComment",
  "sourceCode" : "/**\r\n * Tests the trimComment method.\r\n */\r\n@Test\r\nvoid testTrimComment() {\r\n    assertEquals(\"This is a comment\" + CR + \"that spans multiple\" + CR + \"lines in a\" + CR + \" complex way.\", PropertiesConfigurationLayout.trimComment(\"   # This is a comment\" + CR + \"that spans multiple\" + CR + \"!lines in a\" + CR + \" complex way.\", false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testTrimCommentFalse",
  "sourceCode" : "/**\r\n * Tests enforcing comment characters in a comment.\r\n */\r\n@Test\r\nvoid testTrimCommentFalse() {\r\n    assertEquals(\"# Comment with\" + CR + \" ! some mixed \" + CR + \"#comment\" + CR + \"# lines\", PropertiesConfigurationLayout.trimComment(\"Comment with\" + CR + \" ! some mixed \" + CR + \"#comment\" + CR + \"lines\", true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesConfigurationLayout.java",
  "methodName" : "testTrimCommentTrainlingCR",
  "sourceCode" : "/**\r\n * Tests trimming a comment with trailing CRs.\r\n */\r\n@Test\r\nvoid testTrimCommentTrainlingCR() {\r\n    assertEquals(\"Comment with\" + CR + \"trailing CR\" + CR, PropertiesConfigurationLayout.trimComment(\"Comment with\" + CR + \"! trailing CR\" + CR, false));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesSequence.java",
  "methodName" : "testConfigurationValuesInSameOrderFromFile",
  "sourceCode" : "@Test\r\nvoid testConfigurationValuesInSameOrderFromFile() throws Exception {\r\n    final String simpleConfigurationFile = ConfigurationAssert.getTestFile(\"testSequence.properties\").getAbsolutePath();\r\n    final String compositeConfigurationFile = ConfigurationAssert.getTestFile(\"testSequenceDigester.xml\").getAbsolutePath();\r\n    final PropertiesConfiguration simpleConfiguration = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(simpleConfiguration);\r\n    handler.setFileName(simpleConfigurationFile);\r\n    handler.load();\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFileName(compositeConfigurationFile));\r\n    final Configuration compositeConfiguration = builder.getConfiguration();\r\n    final Configuration a = simpleConfiguration.subset(\"prefix\");\r\n    final Configuration b = compositeConfiguration.subset(\"prefix\");\r\n    final List<String> keysSimpleConfiguration = ConfigurationAssert.keysToList(a);\r\n    final List<String> keysCompositeConfiguration = ConfigurationAssert.keysToList(b);\r\n    assertFalse(keysSimpleConfiguration.isEmpty());\r\n    assertEquals(keysSimpleConfiguration, keysCompositeConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesSequence.java",
  "methodName" : "testConfigurationValuesInSameOrderWithManualAdd",
  "sourceCode" : "@Test\r\nvoid testConfigurationValuesInSameOrderWithManualAdd() throws Exception {\r\n    final String simpleConfigurationFile = ConfigurationAssert.getTestFile(\"testSequence.properties\").getAbsolutePath();\r\n    final String compositeConfigurationFile = ConfigurationAssert.getTestFile(\"testSequenceDigester.xml\").getAbsolutePath();\r\n    final PropertiesConfiguration simpleConfiguration = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(simpleConfiguration);\r\n    handler.setFileName(simpleConfigurationFile);\r\n    handler.load();\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFileName(compositeConfigurationFile));\r\n    final Configuration compositeConfiguration = builder.getConfiguration();\r\n    simpleConfiguration.setProperty(\"prefix.Co.test\", Boolean.TRUE);\r\n    simpleConfiguration.setProperty(\"prefix.Av.test\", Boolean.TRUE);\r\n    compositeConfiguration.setProperty(\"prefix.Co.test\", Boolean.TRUE);\r\n    compositeConfiguration.setProperty(\"prefix.Av.test\", Boolean.TRUE);\r\n    final Configuration a = simpleConfiguration.subset(\"prefix\");\r\n    final Configuration b = compositeConfiguration.subset(\"prefix\");\r\n    final List<String> keysSimpleConfiguration = ConfigurationAssert.keysToList(a);\r\n    final List<String> keysCompositeConfiguration = ConfigurationAssert.keysToList(b);\r\n    assertFalse(keysSimpleConfiguration.isEmpty());\r\n    assertEquals(keysSimpleConfiguration, keysCompositeConfiguration);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestPropertiesSequence.java",
  "methodName" : "testMappingInSameOrder",
  "sourceCode" : "@Test\r\nvoid testMappingInSameOrder() throws Exception {\r\n    final String simpleConfigurationFile = ConfigurationAssert.getTestFile(\"testSequence.properties\").getAbsolutePath();\r\n    final String compositeConfigurationFile = ConfigurationAssert.getTestFile(\"testSequenceDigester.xml\").getAbsolutePath();\r\n    final PropertiesConfiguration simpleConfiguration = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(simpleConfiguration);\r\n    handler.setFileName(simpleConfigurationFile);\r\n    handler.load();\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFileName(compositeConfigurationFile));\r\n    final Configuration compositeConfiguration = builder.getConfiguration();\r\n    final Configuration mapping = new BaseConfiguration();\r\n    final Configuration mapping2 = new BaseConfiguration();\r\n    for (final Iterator<String> keys = simpleConfiguration.getKeys(); keys.hasNext(); ) {\r\n        final String key = keys.next();\r\n        final String[] keyParts = StringUtils.split(key, \".\");\r\n        if (keyParts.length == 3 && keyParts[0].equals(\"prefix\") && keyParts[2].equals(\"postfix\")) {\r\n            final String serviceKey = keyParts[1];\r\n            if (!mapping.containsKey(serviceKey)) {\r\n                mapping.setProperty(serviceKey, simpleConfiguration.getString(key));\r\n            }\r\n        }\r\n    }\r\n    for (final Iterator<String> keys = compositeConfiguration.getKeys(); keys.hasNext(); ) {\r\n        final String key = keys.next();\r\n        final String[] keyParts = StringUtils.split(key, \".\");\r\n        if (keyParts.length == 3 && keyParts[0].equals(\"prefix\") && keyParts[2].equals(\"postfix\")) {\r\n            final String serviceKey = keyParts[1];\r\n            if (!mapping2.containsKey(serviceKey)) {\r\n                mapping2.setProperty(serviceKey, compositeConfiguration.getString(key));\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestStrictConfigurationComparator.java",
  "methodName" : "testCompare",
  "sourceCode" : "/**\r\n * Tests the comparator.\r\n */\r\n@Test\r\nvoid testCompare() {\r\n    // Identity comparison for empty configuration\r\n    assertTrue(comparator.compare(configuration, configuration));\r\n    configuration.setProperty(\"one\", \"1\");\r\n    configuration.setProperty(\"two\", \"2\");\r\n    configuration.setProperty(\"three\", \"3\");\r\n    // Identify comparison for non-empty configuration\r\n    assertTrue(comparator.compare(configuration, configuration));\r\n    // Create the second configuration\r\n    final Configuration other = new BaseConfiguration();\r\n    assertFalse(comparator.compare(configuration, other));\r\n    other.setProperty(\"one\", \"1\");\r\n    other.setProperty(\"two\", \"2\");\r\n    other.setProperty(\"three\", \"3\");\r\n    // Two identical, non-empty configurations\r\n    assertTrue(comparator.compare(configuration, other));\r\n    other.setProperty(\"four\", \"4\");\r\n    assertFalse(comparator.compare(configuration, other));\r\n    configuration.setProperty(\"four\", \"4\");\r\n    assertTrue(comparator.compare(configuration, other));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestStrictConfigurationComparator.java",
  "methodName" : "testCompareNull",
  "sourceCode" : "@Test\r\nvoid testCompareNull() {\r\n    assertTrue(comparator.compare(null, null));\r\n    assertFalse(comparator.compare(configuration, null));\r\n    assertFalse(comparator.compare(null, configuration));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testAddProperty",
  "sourceCode" : "/**\r\n * Tests adding of properties.\r\n */\r\n@Test\r\nvoid testAddProperty() {\r\n    setUpSubnodeConfig();\r\n    config.addProperty(\"[@table-type]\", \"test\");\r\n    assertEquals(\"test\", parent.getString(\"tables.table(0)[@table-type]\"));\r\n    parent.addProperty(\"tables.table(0).fields.field(-1).name\", \"newField\");\r\n    final List<Object> fields = config.getList(\"fields.field.name\");\r\n    assertEquals(NodeStructureHelper.fieldsLength(0) + 1, fields.size());\r\n    assertEquals(\"newField\", fields.get(fields.size() - 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests whether a clone of a sub configuration can be created.\r\n */\r\n@Test\r\nvoid testClone() {\r\n    setUpSubnodeConfig();\r\n    final SubnodeConfiguration copy = (SubnodeConfiguration) config.clone();\r\n    assertNotSame(config.getModel(), copy.getModel());\r\n    final TrackedNodeModel subModel = (TrackedNodeModel) copy.getModel();\r\n    assertEquals(SELECTOR, subModel.getSelector());\r\n    final InMemoryNodeModel parentModel = (InMemoryNodeModel) parent.getModel();\r\n    assertEquals(parentModel, subModel.getParentModel());\r\n    // Check whether the track count was increased\r\n    parentModel.untrackNode(SELECTOR);\r\n    parentModel.untrackNode(SELECTOR);\r\n    assertTrue(subModel.isReleaseTrackedNodeOnFinalize());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testClose",
  "sourceCode" : "/**\r\n * Tests whether the configuration can be closed.\r\n */\r\n@Test\r\nvoid testClose() {\r\n    final TrackedNodeModel model = mock(TrackedNodeModel.class);\r\n    when(model.getSelector()).thenReturn(SELECTOR);\r\n    final SubnodeConfiguration config = new SubnodeConfiguration(parent, model);\r\n    config.close();\r\n    verify(model).getSelector();\r\n    verify(model).close();\r\n    verifyNoMoreInteractions(model);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testConfiguarationAtNoUpdates",
  "sourceCode" : "/**\r\n * Tests the configurationAt() method if updates are not supported.\r\n */\r\n@Test\r\nvoid testConfiguarationAtNoUpdates() {\r\n    setUpSubnodeConfig();\r\n    final HierarchicalConfiguration<ImmutableNode> sub2 = config.configurationAt(\"fields.field(1)\");\r\n    assertEquals(NodeStructureHelper.field(0, 1), sub2.getString(\"name\"));\r\n    parent.setProperty(\"tables.table(0).fields.field(1).name\", \"otherName\");\r\n    assertEquals(NodeStructureHelper.field(0, 1), sub2.getString(\"name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testConfigurationAtWithUpdateSupport",
  "sourceCode" : "/**\r\n * Tests configurationAt() if updates are supported.\r\n */\r\n@Test\r\nvoid testConfigurationAtWithUpdateSupport() {\r\n    setUpSubnodeConfig();\r\n    final SubnodeConfiguration sub2 = (SubnodeConfiguration) config.configurationAt(\"fields.field(1)\", true);\r\n    assertEquals(NodeStructureHelper.field(0, 1), sub2.getString(\"name\"));\r\n    assertEquals(config, sub2.getParent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "/**\r\n * Tests listing the defined keys.\r\n */\r\n@Test\r\nvoid testGetKeys() {\r\n    setUpSubnodeConfig();\r\n    final Set<String> keys = new HashSet<>(ConfigurationAssert.keysToList(config));\r\n    assertEquals(new HashSet<>(Arrays.asList(\"name\", \"fields.field.name\")), keys);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testGetNodeModel",
  "sourceCode" : "/**\r\n * Tests whether a correct node model is returned for the sub configuration. This test is related to CONFIGURATION-670.\r\n */\r\n@Test\r\nvoid testGetNodeModel() {\r\n    setUpSubnodeConfig();\r\n    final InMemoryNodeModel nodeModel = config.getNodeModel();\r\n    assertEquals(\"table\", nodeModel.getNodeHandler().getRootNode().getNodeName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testGetProperties",
  "sourceCode" : "/**\r\n * Tests if properties of the sub node can be accessed.\r\n */\r\n@Test\r\nvoid testGetProperties() {\r\n    setUpSubnodeConfig();\r\n    checkSubConfigContent();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testInitSubNodeConfig",
  "sourceCode" : "/**\r\n * Tests creation of a subnode config.\r\n */\r\n@Test\r\nvoid testInitSubNodeConfig() {\r\n    setUpSubnodeConfig();\r\n    assertSame(NodeStructureHelper.nodeForKey(parent.getModel().getNodeHandler().getRootNode(), \"tables/table(0)\"), config.getModel().getNodeHandler().getRootNode());\r\n    assertSame(parent, config.getParent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testInitSubNodeConfigWithNullNode",
  "sourceCode" : "/**\r\n * Tests constructing a subnode configuration with a null node model. This should cause an exception.\r\n */\r\n@Test\r\nvoid testInitSubNodeConfigWithNullNode() {\r\n    assertThrows(IllegalArgumentException.class, () -> new SubnodeConfiguration(parent, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testInitSubNodeConfigWithNullParent",
  "sourceCode" : "/**\r\n * Tests constructing a subnode configuration with a null parent. This should cause an exception.\r\n */\r\n@Test\r\nvoid testInitSubNodeConfigWithNullParent() {\r\n    final TrackedNodeModel model = setUpTrackedModel(SELECTOR);\r\n    assertThrows(IllegalArgumentException.class, () -> new SubnodeConfiguration(null, model));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testInterpolation",
  "sourceCode" : "/**\r\n * Tests interpolation features. The subnode config should use its parent for interpolation.\r\n */\r\n@Test\r\nvoid testInterpolation() {\r\n    parent.addProperty(\"tablespaces.tablespace.name\", \"default\");\r\n    parent.addProperty(\"tablespaces.tablespace(-1).name\", \"test\");\r\n    parent.addProperty(\"tables.table(0).tablespace\", \"${tablespaces.tablespace(0).name}\");\r\n    assertEquals(\"default\", parent.getString(\"tables.table(0).tablespace\"));\r\n    setUpSubnodeConfig();\r\n    assertEquals(\"default\", config.getString(\"tablespace\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testInterpolationFromConfigurationAtNoUpdateSupport",
  "sourceCode" : "/**\r\n * Tests whether interpolation works for a sub configuration obtained via configurationAt() if updates are not\r\n * supported.\r\n */\r\n@Test\r\nvoid testInterpolationFromConfigurationAtNoUpdateSupport() {\r\n    checkInterpolationFromConfigurationAt(false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testInterpolationFromConfigurationAtWithUpdateSupport",
  "sourceCode" : "/**\r\n * Tests whether interpolation works for a sub configuration obtained via configurationAt() if updates are supported.\r\n */\r\n@Test\r\nvoid testInterpolationFromConfigurationAtWithUpdateSupport() {\r\n    checkInterpolationFromConfigurationAt(true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testInterpolator",
  "sourceCode" : "/**\r\n * Tests manipulating the interpolator.\r\n */\r\n@Test\r\nvoid testInterpolator() {\r\n    parent.addProperty(\"tablespaces.tablespace.name\", \"default\");\r\n    parent.addProperty(\"tablespaces.tablespace(-1).name\", \"test\");\r\n    setUpSubnodeConfig();\r\n    InterpolationTestHelper.testGetInterpolator(config);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testLocalInterpolationFromConfigurationAt",
  "sourceCode" : "/**\r\n * An additional test for interpolation when the configurationAt() method is involved for a local interpolation.\r\n */\r\n@Test\r\nvoid testLocalInterpolationFromConfigurationAt() {\r\n    parent.addProperty(\"base.dir\", \"/home/foo\");\r\n    parent.addProperty(\"test.absolute.dir.dir1\", \"${base.dir}/path1\");\r\n    parent.addProperty(\"test.absolute.dir.dir2\", \"${dir1}\");\r\n    final Configuration sub = parent.configurationAt(\"test.absolute.dir\");\r\n    assertEquals(\"/home/foo/path1\", sub.getString(\"dir1\"));\r\n    assertEquals(\"/home/foo/path1\", sub.getString(\"dir2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testLocalLookupsInInterpolatorAreInherited",
  "sourceCode" : "@Test\r\nvoid testLocalLookupsInInterpolatorAreInherited() {\r\n    parent.addProperty(\"tablespaces.tablespace.name\", \"default\");\r\n    parent.addProperty(\"tablespaces.tablespace(-1).name\", \"test\");\r\n    parent.addProperty(\"tables.table(0).var\", \"${brackets:x}\");\r\n    final ConfigurationInterpolator interpolator = parent.getInterpolator();\r\n    interpolator.registerLookup(\"brackets\", key -> \"(\" + key + \")\");\r\n    setUpSubnodeConfig();\r\n    assertEquals(\"(x)\", config.getString(\"var\", \"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testParentChangeDetach",
  "sourceCode" : "/**\r\n * Tests a manipulation of the parent configuration that causes the subnode configuration to become invalid. In this\r\n * case the sub config should be detached and keep its old values.\r\n */\r\n@Test\r\nvoid testParentChangeDetach() {\r\n    setUpSubnodeConfig();\r\n    parent.clear();\r\n    checkSubConfigContent();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testParentChangeDetatchException",
  "sourceCode" : "/**\r\n * Tests detaching a subnode configuration if an exception is thrown during reconstruction. This can happen for example if the\r\n * expression engine is changed for the parent.\r\n */\r\n@Test\r\nvoid testParentChangeDetatchException() {\r\n    setUpSubnodeConfig();\r\n    parent.setExpressionEngine(new XPathExpressionEngine());\r\n    parent.addProperty(\"newProp\", \"value\");\r\n    checkSubConfigContent();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testSetExpressionEngine",
  "sourceCode" : "/**\r\n * Tests changing the expression engine.\r\n */\r\n@Test\r\nvoid testSetExpressionEngine() {\r\n    parent.setExpressionEngine(new XPathExpressionEngine());\r\n    setUpSubnodeConfig(\"tables/table[1]\");\r\n    assertEquals(NodeStructureHelper.field(0, 1), config.getString(\"fields/field[2]/name\"));\r\n    final Set<String> keys = ConfigurationAssert.keysToSet(config);\r\n    assertEquals(new HashSet<>(Arrays.asList(\"name\", \"fields/field/name\")), keys);\r\n    config.setExpressionEngine(null);\r\n    assertInstanceOf(XPathExpressionEngine.class, parent.getExpressionEngine());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testSetListDelimiterHandler",
  "sourceCode" : "/**\r\n * Tests manipulating the list delimiter handler. This object is derived from the parent.\r\n */\r\n@Test\r\nvoid testSetListDelimiterHandler() {\r\n    final ListDelimiterHandler handler1 = new DefaultListDelimiterHandler('/');\r\n    final ListDelimiterHandler handler2 = new DefaultListDelimiterHandler(';');\r\n    parent.setListDelimiterHandler(handler1);\r\n    setUpSubnodeConfig();\r\n    parent.setListDelimiterHandler(handler2);\r\n    assertEquals(handler1, config.getListDelimiterHandler());\r\n    config.addProperty(\"newProp\", \"test1,test2/test3\");\r\n    assertEquals(\"test1,test2\", parent.getString(\"tables.table(0).newProp\"));\r\n    config.setListDelimiterHandler(DisabledListDelimiterHandler.INSTANCE);\r\n    assertEquals(handler2, parent.getListDelimiterHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testSetProperty",
  "sourceCode" : "/**\r\n * Tests setting of properties in both the parent and the subnode configuration and whether the changes are visible to\r\n * each other.\r\n */\r\n@Test\r\nvoid testSetProperty() {\r\n    setUpSubnodeConfig();\r\n    config.setProperty(null, \"testTable\");\r\n    config.setProperty(\"name\", NodeStructureHelper.table(0) + \"_tested\");\r\n    assertEquals(\"testTable\", parent.getString(\"tables.table(0)\"));\r\n    assertEquals(NodeStructureHelper.table(0) + \"_tested\", parent.getString(\"tables.table(0).name\"));\r\n    parent.setProperty(\"tables.table(0).fields.field(1).name\", \"testField\");\r\n    assertEquals(\"testField\", config.getString(\"fields.field(1).name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testSetThrowExceptionOnMissing",
  "sourceCode" : "/**\r\n * Tests setting the exception on missing flag. The subnode config obtains this flag from its parent.\r\n */\r\n@Test\r\nvoid testSetThrowExceptionOnMissing() {\r\n    parent.setThrowExceptionOnMissing(true);\r\n    setUpSubnodeConfig();\r\n    assertTrue(config.isThrowExceptionOnMissing());\r\n    assertThrows(NoSuchElementException.class, () -> config.getString(\"non existing key\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubnodeConfiguration.java",
  "methodName" : "testSetThrowExceptionOnMissingAffectsParent",
  "sourceCode" : "/**\r\n * Tests whether the exception flag can be set independently from the parent.\r\n */\r\n@Test\r\nvoid testSetThrowExceptionOnMissingAffectsParent() {\r\n    parent.setThrowExceptionOnMissing(true);\r\n    setUpSubnodeConfig();\r\n    config.setThrowExceptionOnMissing(false);\r\n    assertTrue(parent.isThrowExceptionOnMissing());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testClear",
  "sourceCode" : "@Test\r\nvoid testClear() {\r\n    final Configuration config = new BaseConfiguration();\r\n    config.setProperty(\"test.key1\", \"value1\");\r\n    config.setProperty(\"testing.key2\", \"value1\");\r\n    final Configuration subset = config.subset(\"test\");\r\n    subset.clear();\r\n    assertTrue(subset.isEmpty());\r\n    assertFalse(config.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testConstructNullParent",
  "sourceCode" : "/**\r\n * Tries to create an instance without a parent configuration.\r\n */\r\n@Test\r\nvoid testConstructNullParent() {\r\n    assertThrows(NullPointerException.class, () -> new SubsetConfiguration(null, \"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetChildKey",
  "sourceCode" : "@Test\r\nvoid testGetChildKey() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    // subset with delimiter\r\n    SubsetConfiguration subset = new SubsetConfiguration(conf, \"prefix\", \".\");\r\n    assertEquals(\"key\", subset.getChildKey(\"prefix.key\"));\r\n    assertEquals(\"\", subset.getChildKey(\"prefix\"));\r\n    // subset without delimiter\r\n    subset = new SubsetConfiguration(conf, \"prefix\", null);\r\n    assertEquals(\"key\", subset.getChildKey(\"prefixkey\"));\r\n    assertEquals(\"\", subset.getChildKey(\"prefix\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetKeys",
  "sourceCode" : "@Test\r\nvoid testGetKeys() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    conf.setProperty(\"test\", \"value0\");\r\n    conf.setProperty(\"test.key1\", \"value1\");\r\n    conf.setProperty(\"testing.key2\", \"value1\");\r\n    final Configuration subset = new SubsetConfiguration(conf, \"test\", \".\");\r\n    final Iterator<String> it = subset.getKeys();\r\n    assertEquals(\"\", it.next());\r\n    assertEquals(\"key1\", it.next());\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetKeysWithPrefix",
  "sourceCode" : "@Test\r\nvoid testGetKeysWithPrefix() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    conf.setProperty(\"test.abc\", \"value0\");\r\n    conf.setProperty(\"test.abc.key1\", \"value1\");\r\n    conf.setProperty(\"test.abcdef.key2\", \"value1\");\r\n    final Configuration subset = new SubsetConfiguration(conf, \"test\", \".\");\r\n    final Iterator<String> it = subset.getKeys(\"abc\");\r\n    assertEquals(\"abc\", it.next());\r\n    assertEquals(\"abc.key1\", it.next());\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetList",
  "sourceCode" : "@Test\r\nvoid testGetList() {\r\n    final BaseConfiguration conf = new BaseConfiguration();\r\n    conf.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    conf.setProperty(\"test.abc\", \"value0,value1\");\r\n    conf.addProperty(\"test.abc\", \"value3\");\r\n    final Configuration subset = new SubsetConfiguration(conf, \"test\", \".\");\r\n    final List<Object> list = subset.getList(\"abc\", new ArrayList<>());\r\n    assertEquals(3, list.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetListDelimiterHandlerFromParent",
  "sourceCode" : "/**\r\n * Tests whether the list delimiter handler from the parent configuration is used.\r\n */\r\n@Test\r\nvoid testGetListDelimiterHandlerFromParent() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    final AbstractConfiguration subset = (AbstractConfiguration) config.subset(\"prefix\");\r\n    final ListDelimiterHandler listHandler = new DefaultListDelimiterHandler(',');\r\n    config.setListDelimiterHandler(listHandler);\r\n    assertSame(listHandler, subset.getListDelimiterHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetParent",
  "sourceCode" : "@Test\r\nvoid testGetParent() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    final SubsetConfiguration subset = new SubsetConfiguration(conf, \"prefix\", \".\");\r\n    assertEquals(conf, subset.getParent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetParentKey",
  "sourceCode" : "@Test\r\nvoid testGetParentKey() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    // subset with delimiter\r\n    SubsetConfiguration subset = new SubsetConfiguration(conf, \"prefix\", \".\");\r\n    assertEquals(\"prefix.key\", subset.getParentKey(\"key\"));\r\n    assertEquals(\"prefix\", subset.getParentKey(\"\"));\r\n    // subset without delimiter\r\n    subset = new SubsetConfiguration(conf, \"prefix\", null);\r\n    assertEquals(\"prefixkey\", subset.getParentKey(\"key\"));\r\n    assertEquals(\"prefix\", subset.getParentKey(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetPrefix",
  "sourceCode" : "@Test\r\nvoid testGetPrefix() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    final SubsetConfiguration subset = new SubsetConfiguration(conf, \"prefix\", \".\");\r\n    assertEquals(\"prefix\", subset.getPrefix());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    conf.setProperty(\"test.key1\", \"value1\");\r\n    conf.setProperty(\"testing.key2\", \"value1\");\r\n    final Configuration subset = new SubsetConfiguration(conf, \"test\", \".\");\r\n    assertFalse(subset.isEmpty());\r\n    assertTrue(subset.containsKey(\"key1\"));\r\n    assertFalse(subset.containsKey(\"ng.key2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testInterpolationForKeysOfTheParent",
  "sourceCode" : "@Test\r\nvoid testInterpolationForKeysOfTheParent() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.setProperty(\"test\", \"junit\");\r\n    config.setProperty(\"prefix.key\", \"${test}\");\r\n    final AbstractConfiguration subset = (AbstractConfiguration) config.subset(\"prefix\");\r\n    assertEquals(\"junit\", subset.getString(\"key\", \"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testInterpolator",
  "sourceCode" : "/**\r\n * Tests manipulating the interpolator.\r\n */\r\n@Test\r\nvoid testInterpolator() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    final AbstractConfiguration subset = (AbstractConfiguration) config.subset(\"prefix\");\r\n    InterpolationTestHelper.testGetInterpolator(subset);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testListDelimiterHandling",
  "sourceCode" : "/**\r\n * Tests whether a list delimiter handler is used correctly.\r\n */\r\n@Test\r\nvoid testListDelimiterHandling() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    final Configuration subset = config.subset(\"prefix\");\r\n    config.setListDelimiterHandler(new DefaultListDelimiterHandler('/'));\r\n    subset.addProperty(\"list\", \"a/b/c\");\r\n    assertEquals(3, config.getList(\"prefix.list\").size());\r\n    ((AbstractConfiguration) subset).setListDelimiterHandler(new DefaultListDelimiterHandler(';'));\r\n    subset.addProperty(\"list2\", \"a;b;c\");\r\n    assertEquals(3, config.getList(\"prefix.list2\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testLocalLookupsInInterpolatorAreInherited",
  "sourceCode" : "@Test\r\nvoid testLocalLookupsInInterpolatorAreInherited() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    final ConfigurationInterpolator interpolator = config.getInterpolator();\r\n    interpolator.registerLookup(\"brackets\", key -> \"(\" + key + \")\");\r\n    config.setProperty(\"prefix.var\", \"${brackets:x}\");\r\n    final AbstractConfiguration subset = (AbstractConfiguration) config.subset(\"prefix\");\r\n    assertEquals(\"(x)\", subset.getString(\"var\", \"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testNested",
  "sourceCode" : "@Test\r\nvoid testNested() throws Exception {\r\n    final CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFile(ConfigurationAssert.getTestFile(TEST_FILE)));\r\n    final Configuration config = builder.getConfiguration();\r\n    final Configuration subConf = config.subset(\"tables.table(0)\");\r\n    assertTrue(subConf.getKeys().hasNext());\r\n    final Configuration subSubConf = subConf.subset(\"fields.field(1)\");\r\n    final Iterator<String> itKeys = subSubConf.getKeys();\r\n    final Set<String> keys = new HashSet<>();\r\n    keys.add(\"name\");\r\n    keys.add(\"type\");\r\n    while (itKeys.hasNext()) {\r\n        final String k = itKeys.next();\r\n        assertTrue(keys.contains(k));\r\n        keys.remove(k);\r\n    }\r\n    assertTrue(keys.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testPrefixDelimiter",
  "sourceCode" : "@Test\r\nvoid testPrefixDelimiter() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.setProperty(\"part1.part2@test.key1\", \"value1\");\r\n    config.setProperty(\"part1.part2\", \"value2\");\r\n    config.setProperty(\"part3.part4@testing.key2\", \"value3\");\r\n    final SubsetConfiguration subset = new SubsetConfiguration(config, \"part1.part2\", \"@\");\r\n    // Check subset properties\r\n    assertEquals(\"value1\", subset.getString(\"test.key1\"));\r\n    assertEquals(\"value2\", subset.getString(\"\"));\r\n    assertNull(subset.getString(\"testing.key2\"));\r\n    // Check for empty subset configuration and iterator\r\n    assertEquals(2, subset.size());\r\n    assertFalse(subset.isEmpty());\r\n    assertTrue(subset.getKeys().hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testPrefixDelimiterNegativeTest",
  "sourceCode" : "@Test\r\nvoid testPrefixDelimiterNegativeTest() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.setProperty(\"part1.part2@test.key1\", \"value1\");\r\n    config.setProperty(\"part3.part4@testing.key2\", \"value2\");\r\n    final SubsetConfiguration subset = new SubsetConfiguration(config, \"part1.part2\", \"@\") {\r\n\r\n        // Anonymous inner class declaration to override SubsetConfiguration.getKeysInternal() - Call\r\n        // ImutableConfiguration.getKeys(String) on the parent configuration of the SubsetConfiguration in order to\r\n        // not consequently pass the prefix delimiter\r\n        @Override\r\n        protected Iterator<String> getKeysInternal() {\r\n            Class<?> subsetIteratorClass;\r\n            try {\r\n                subsetIteratorClass = Class.forName(\"org.apache.commons.configuration2.SubsetConfiguration$SubsetIterator\");\r\n                final Constructor<?> ctor = subsetIteratorClass.getDeclaredConstructor(SubsetConfiguration.class, Iterator.class);\r\n                ctor.setAccessible(true);\r\n                return (Iterator<String>) ctor.newInstance(this, parent.getKeys(\"part1.part2\"));\r\n            } catch (final Exception ex) {\r\n                throw new IllegalArgumentException(ex);\r\n            }\r\n        }\r\n    };\r\n    // Check subset properties - contains one property\r\n    assertEquals(\"value1\", subset.getString(\"test.key1\"));\r\n    assertNull(subset.getString(\"testing.key2\"));\r\n    // Check for empty subset configuration and iterator - even if the SubsetConfiguration contains properties, like\r\n    // checked previously its states that it is empty\r\n    assertEquals(0, subset.size());\r\n    assertTrue(subset.isEmpty());\r\n    assertFalse(subset.getKeys().hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testSetListDelimiterHandlerInParent",
  "sourceCode" : "/**\r\n * Tests whether the list delimiter handler is also set for the parent configuration.\r\n */\r\n@Test\r\nvoid testSetListDelimiterHandlerInParent() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    final AbstractConfiguration subset = (AbstractConfiguration) config.subset(\"prefix\");\r\n    final ListDelimiterHandler listHandler = new DefaultListDelimiterHandler(',');\r\n    subset.setListDelimiterHandler(listHandler);\r\n    assertSame(listHandler, config.getListDelimiterHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testSetListDelimiterHandlerParentNotSupported",
  "sourceCode" : "/**\r\n * Tests the case that the parent configuration is not derived from AbstractConfiguration and thus does not support a\r\n * list delimiter handler.\r\n */\r\n@Test\r\nvoid testSetListDelimiterHandlerParentNotSupported() {\r\n    final Configuration config = mock(Configuration.class);\r\n    final SubsetConfiguration subset = new SubsetConfiguration(config, \"prefix\");\r\n    final ListDelimiterHandler listHandler = new DefaultListDelimiterHandler(',');\r\n    subset.setListDelimiterHandler(listHandler);\r\n    assertSame(listHandler, subset.getListDelimiterHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testSetPrefix",
  "sourceCode" : "@Test\r\nvoid testSetPrefix() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    final SubsetConfiguration subset = new SubsetConfiguration(conf, null, \".\");\r\n    subset.setPrefix(\"prefix\");\r\n    assertEquals(\"prefix\", subset.getPrefix());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testSetProperty",
  "sourceCode" : "@Test\r\nvoid testSetProperty() {\r\n    final Configuration conf = new BaseConfiguration();\r\n    final Configuration subset = new SubsetConfiguration(conf, \"test\", \".\");\r\n    // set a property in the subset and check the parent\r\n    subset.setProperty(\"key1\", \"value1\");\r\n    assertEquals(\"value1\", subset.getProperty(\"key1\"));\r\n    assertEquals(\"value1\", conf.getProperty(\"test.key1\"));\r\n    // set a property in the parent and check in the subset\r\n    conf.setProperty(\"test.key2\", \"value2\");\r\n    assertEquals(\"value2\", conf.getProperty(\"test.key2\"));\r\n    assertEquals(\"value2\", subset.getProperty(\"key2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration.java",
  "methodName" : "testThrowExceptionOnMissing",
  "sourceCode" : "@Test\r\nvoid testThrowExceptionOnMissing() {\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.setThrowExceptionOnMissing(true);\r\n    final SubsetConfiguration subset = new SubsetConfiguration(config, \"prefix\");\r\n    assertThrows(NoSuchElementException.class, () -> subset.getString(\"foo\"));\r\n    config.setThrowExceptionOnMissing(false);\r\n    assertNull(subset.getString(\"foo\"));\r\n    subset.setThrowExceptionOnMissing(true);\r\n    assertThrows(NoSuchElementException.class, () -> config.getString(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration848.java",
  "methodName" : "testSubsetConfigurationWithIndexAndDelimiter",
  "sourceCode" : "@Test\r\nvoid testSubsetConfigurationWithIndexAndDelimiter() throws ConfigurationException, IOException {\r\n    final JSONConfiguration jsonConfiguration = new JSONConfiguration();\r\n    try (FileReader in = new FileReader(ConfigurationAssert.getTestFile(\"test-configuration-848.json\").getAbsolutePath())) {\r\n        jsonConfiguration.read(in);\r\n    }\r\n    // 1. using composite configuration\r\n    final List<Configuration> list = new ArrayList<>();\r\n    list.add(jsonConfiguration);\r\n    list.add(jsonConfiguration);\r\n    final CompositeConfiguration composite = new CompositeConfiguration(list);\r\n    Configuration subset = composite.subset(\"books(0).details\");\r\n    assertFalse(subset.isEmpty());\r\n    assertEquals(2, subset.size());\r\n    assertEquals(\"No Longer Human\", subset.getString(\"title\"));\r\n    // 2. using '.' delimiter\r\n    subset = new SubsetConfiguration(jsonConfiguration, \"books(0).details\", \".\");\r\n    assertFalse(subset.isEmpty());\r\n    assertEquals(2, subset.size());\r\n    assertEquals(\"No Longer Human\", subset.getString(\"title\"));\r\n    // 3. using '@' delimiter\r\n    subset = new SubsetConfiguration(jsonConfiguration, \"books(1)@details\", \"@\");\r\n    assertFalse(subset.isEmpty());\r\n    assertEquals(2, subset.size());\r\n    // TODO New feature?\r\n    // assertEquals(\"White Nights\", subset.getString(\"title\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSubsetConfiguration848.java",
  "methodName" : "testSubsetWithJSONConfiguration",
  "sourceCode" : "@Test\r\nvoid testSubsetWithJSONConfiguration() throws ConfigurationException, IOException {\r\n    final JSONConfiguration jsonConfiguration = new JSONConfiguration();\r\n    try (FileReader in = new FileReader(ConfigurationAssert.getTestFile(\"test-configuration-848.json\").getAbsolutePath())) {\r\n        jsonConfiguration.read(in);\r\n    }\r\n    final SubsetConfiguration subset = new SubsetConfiguration(jsonConfiguration, \"capitals(0)\", \".\");\r\n    assertFalse(subset.isEmpty());\r\n    assertEquals(2, subset.size());\r\n    assertEquals(\"USA\", subset.getString(\"country\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSystemConfiguration.java",
  "methodName" : "testAppendWhileConcurrentAccess",
  "sourceCode" : "/**\r\n * Tests an append operation with a system configuration while system properties are modified from another thread. This\r\n * is related to CONFIGURATION-570.\r\n */\r\n@Test\r\nvoid testAppendWhileConcurrentAccess() throws InterruptedException {\r\n    final AtomicBoolean stop = new AtomicBoolean();\r\n    final String property = SystemConfiguration.class.getName() + \".testProperty\";\r\n    final Thread t = new Thread(() -> {\r\n        boolean setValue = true;\r\n        while (!stop.get()) {\r\n            if (setValue) {\r\n                System.setProperty(property, \"true\");\r\n            } else {\r\n                System.clearProperty(property);\r\n            }\r\n            setValue = !setValue;\r\n        }\r\n    });\r\n    try {\r\n        t.start();\r\n        final SystemConfiguration config = new SystemConfiguration();\r\n        final PropertiesConfiguration props = new PropertiesConfiguration();\r\n        props.append(config);\r\n        stop.set(true);\r\n        t.join();\r\n        for (final Iterator<String> keys = config.getKeys(); keys.hasNext(); ) {\r\n            final String key = keys.next();\r\n            if (!property.equals(key)) {\r\n                assertEquals(config.getString(key), props.getString(key), \"Wrong value for \" + key);\r\n            }\r\n        }\r\n    } finally {\r\n        System.clearProperty(property);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSystemConfiguration.java",
  "methodName" : "testChangeSystemProperties",
  "sourceCode" : "/**\r\n * Tests whether the configuration can be used to change system properties.\r\n */\r\n@Test\r\nvoid testChangeSystemProperties() {\r\n    final String testProperty = \"someTest\";\r\n    final SystemConfiguration config = new SystemConfiguration();\r\n    config.setProperty(testProperty, \"true\");\r\n    assertEquals(\"true\", System.getProperty(testProperty));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSystemConfiguration.java",
  "methodName" : "testSetSystemProperties",
  "sourceCode" : "@Test\r\nvoid testSetSystemProperties() {\r\n    final PropertiesConfiguration props = new PropertiesConfiguration();\r\n    props.addProperty(\"test.name\", \"Apache\");\r\n    SystemConfiguration.setSystemProperties(props);\r\n    assertEquals(\"Apache\", System.getProperty(\"test.name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSystemConfiguration.java",
  "methodName" : "testSetSystemPropertiesFromPropertiesFile",
  "sourceCode" : "/**\r\n * Tests whether system properties can be set from a configuration file.\r\n */\r\n@Test\r\nvoid testSetSystemPropertiesFromPropertiesFile() throws ConfigurationException, IOException {\r\n    final File file = newFile(\"sys.properties\", tempFolder);\r\n    final PropertiesConfiguration pconfig = new PropertiesConfiguration();\r\n    final FileHandler handler = new FileHandler(pconfig);\r\n    pconfig.addProperty(\"fromFile\", Boolean.TRUE);\r\n    handler.setFile(file);\r\n    handler.save();\r\n    SystemConfiguration.setSystemProperties(handler.getBasePath(), handler.getFileName());\r\n    final SystemConfiguration sconf = new SystemConfiguration();\r\n    assertTrue(sconf.getBoolean(\"fromFile\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestSystemConfiguration.java",
  "methodName" : "testSystemConfiguration",
  "sourceCode" : "@Test\r\nvoid testSystemConfiguration() {\r\n    final Properties props = System.getProperties();\r\n    props.put(\"test.number\", \"123\");\r\n    final Configuration conf = new SystemConfiguration();\r\n    assertEquals(123, conf.getInt(\"test.number\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestThreesomeConfiguration.java",
  "methodName" : "testList1",
  "sourceCode" : "@Test\r\nvoid testList1() throws Exception {\r\n    final List<Object> packages = conf.getList(\"test.threesome.one\");\r\n    // we should get 3 packages here\r\n    assertEquals(3, packages.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestThreesomeConfiguration.java",
  "methodName" : "testList2",
  "sourceCode" : "@Test\r\nvoid testList2() throws Exception {\r\n    final List<Object> packages = conf.getList(\"test.threesome.two\");\r\n    // we should get 3 packages here\r\n    assertEquals(3, packages.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestThreesomeConfiguration.java",
  "methodName" : "testList3",
  "sourceCode" : "@Test\r\nvoid testList3() throws Exception {\r\n    final List<Object> packages = conf.getList(\"test.threesome.three\");\r\n    // we should get 3 packages here\r\n    assertEquals(3, packages.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAddList",
  "sourceCode" : "@Test\r\nvoid testAddList() {\r\n    conf.addProperty(\"test.array\", \"value1\");\r\n    conf.addProperty(\"test.array\", \"value2\");\r\n    final List<Object> list = conf.getList(\"test.array\");\r\n    assertEquals(Arrays.asList(\"value1\", \"value2\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAddNodesAndSave",
  "sourceCode" : "/**\r\n * Tests saving a configuration after a node was added. Test for CONFIGURATION-294.\r\n */\r\n@Test\r\nvoid testAddNodesAndSave() throws ConfigurationException {\r\n    final ImmutableNode.Builder bldrNode = new ImmutableNode.Builder(1);\r\n    bldrNode.addChild(NodeStructureHelper.createNode(\"child\", null));\r\n    bldrNode.addAttribute(\"attr\", \"\");\r\n    final ImmutableNode node2 = NodeStructureHelper.createNode(\"test2\", null);\r\n    conf.addNodes(\"add.nodes\", Arrays.asList(bldrNode.name(\"test\").create(), node2));\r\n    saveTestConfig();\r\n    conf.setProperty(\"add.nodes.test\", \"true\");\r\n    conf.setProperty(\"add.nodes.test.child\", \"yes\");\r\n    conf.setProperty(\"add.nodes.test[@attr]\", \"existing\");\r\n    conf.setProperty(\"add.nodes.test2\", \"anotherValue\");\r\n    saveTestConfig();\r\n    final XMLConfiguration c2 = new XMLConfiguration();\r\n    load(c2, testSaveConf.getAbsolutePath());\r\n    assertEquals(\"true\", c2.getString(\"add.nodes.test\"));\r\n    assertEquals(\"yes\", c2.getString(\"add.nodes.test.child\"));\r\n    assertEquals(\"existing\", c2.getString(\"add.nodes.test[@attr]\"));\r\n    assertEquals(\"anotherValue\", c2.getString(\"add.nodes.test2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAddNodesCopy",
  "sourceCode" : "/**\r\n * Tests adding nodes from another configuration.\r\n */\r\n@Test\r\nvoid testAddNodesCopy() throws ConfigurationException {\r\n    final XMLConfiguration c2 = new XMLConfiguration();\r\n    load(c2, testProperties2);\r\n    conf.addNodes(\"copiedProperties\", c2.getModel().getNodeHandler().getRootNode().getChildren());\r\n    saveTestConfig();\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAddNodesToSubnodeConfiguration",
  "sourceCode" : "/**\r\n * Tests whether it is possible to add nodes to a XMLConfiguration through a SubnodeConfiguration and whether these\r\n * nodes have the correct type. This test is related to CONFIGURATION-472.\r\n */\r\n@Test\r\nvoid testAddNodesToSubnodeConfiguration() throws Exception {\r\n    final HierarchicalConfiguration<ImmutableNode> sub = conf.configurationAt(\"element2\", true);\r\n    sub.addProperty(\"newKey\", \"newvalue\");\r\n    assertEquals(\"newvalue\", conf.getString(\"element2.newKey\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAddObjectAttribute",
  "sourceCode" : "@Test\r\nvoid testAddObjectAttribute() {\r\n    conf.addProperty(\"test.boolean[@value]\", Boolean.TRUE);\r\n    assertTrue(conf.getBoolean(\"test.boolean[@value]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAddObjectProperty",
  "sourceCode" : "@Test\r\nvoid testAddObjectProperty() {\r\n    // add a non string property\r\n    conf.addProperty(\"test.boolean\", Boolean.TRUE);\r\n    assertTrue(conf.getBoolean(\"test.boolean\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAddProperty",
  "sourceCode" : "@Test\r\nvoid testAddProperty() {\r\n    // add a property to a non initialized XML configuration\r\n    final XMLConfiguration config = new XMLConfiguration();\r\n    config.addProperty(\"test.string\", \"hello\");\r\n    assertEquals(\"hello\", config.getString(\"test.string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAddPropertyListWithDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests whether list properties are added correctly if delimiter parsing is disabled. This test is related to\r\n * CONFIGURATION-495.\r\n */\r\n@Test\r\nvoid testAddPropertyListWithDelimiterParsingDisabled() throws ConfigurationException {\r\n    conf.clear();\r\n    final String prop = \"delimiterListProp\";\r\n    conf.setListDelimiterHandler(DisabledListDelimiterHandler.INSTANCE);\r\n    final List<String> list = Arrays.asList(\"val\", \"val2\", \"val3\");\r\n    conf.addProperty(prop, list);\r\n    saveTestConfig();\r\n    final XMLConfiguration conf2 = new XMLConfiguration();\r\n    load(conf2, testSaveConf.getAbsolutePath());\r\n    assertEquals(list, conf2.getProperty(prop));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAppend",
  "sourceCode" : "/**\r\n * Tests if a second file can be appended to a first.\r\n */\r\n@Test\r\nvoid testAppend() throws Exception {\r\n    load(conf, testProperties2);\r\n    assertEquals(\"value\", conf.getString(\"element\"));\r\n    assertEquals(\"tasks\", conf.getString(\"table.name\"));\r\n    saveTestConfig();\r\n    conf = createFromFile(testSaveConf.getAbsolutePath());\r\n    assertEquals(\"value\", conf.getString(\"element\"));\r\n    assertEquals(\"tasks\", conf.getString(\"table.name\"));\r\n    assertEquals(\"application\", conf.getString(\"table[@tableType]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAttributeKeyWithMultipleValues",
  "sourceCode" : "/**\r\n * Tries to create an attribute with multiple values. Only the first value is taken into account.\r\n */\r\n@Test\r\nvoid testAttributeKeyWithMultipleValues() throws ConfigurationException {\r\n    conf.addProperty(\"errorTest[@multiAttr]\", Arrays.asList(\"v1\", \"v2\"));\r\n    saveTestConfig();\r\n    final XMLConfiguration checkConfig = new XMLConfiguration();\r\n    load(checkConfig, testSaveConf.getAbsolutePath());\r\n    assertEquals(\"v1\", checkConfig.getString(\"errorTest[@multiAttr]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAutoSaveAddNodes",
  "sourceCode" : "/**\r\n * Tests whether the addNodes() method triggers an auto save.\r\n */\r\n@Test\r\nvoid testAutoSaveAddNodes() throws ConfigurationException {\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = new FileBasedConfigurationBuilder<>(XMLConfiguration.class);\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFileName(testProperties));\r\n    conf = builder.getConfiguration();\r\n    builder.getFileHandler().setFile(testSaveConf);\r\n    builder.setAutoSave(true);\r\n    final ImmutableNode node = NodeStructureHelper.createNode(\"addNodesTest\", Boolean.TRUE);\r\n    final Collection<ImmutableNode> nodes = new ArrayList<>(1);\r\n    nodes.add(node);\r\n    conf.addNodes(\"test.autosave\", nodes);\r\n    final XMLConfiguration c2 = new XMLConfiguration();\r\n    load(c2, testSaveConf.getAbsolutePath());\r\n    assertTrue(c2.getBoolean(\"test.autosave.addNodesTest\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAutoSaveWithSubnodeConfig",
  "sourceCode" : "/**\r\n * Tests whether the auto save mechanism is triggered by changes at a subnode configuration.\r\n */\r\n@Test\r\nvoid testAutoSaveWithSubnodeConfig() throws ConfigurationException {\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = new FileBasedConfigurationBuilder<>(XMLConfiguration.class);\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFileName(testProperties));\r\n    conf = builder.getConfiguration();\r\n    builder.getFileHandler().setFile(testSaveConf);\r\n    builder.setAutoSave(true);\r\n    final String newValue = \"I am autosaved\";\r\n    final Configuration sub = conf.configurationAt(\"element2.subelement\", true);\r\n    sub.setProperty(\"subsubelement\", newValue);\r\n    assertEquals(newValue, conf.getString(\"element2.subelement.subsubelement\"));\r\n    final XMLConfiguration conf2 = new XMLConfiguration();\r\n    load(conf2, testSaveConf.getAbsolutePath());\r\n    assertEquals(newValue, conf2.getString(\"element2.subelement.subsubelement\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testAutoSaveWithSubSubnodeConfig",
  "sourceCode" : "/**\r\n * Tests whether a subnode configuration created from another subnode configuration of a XMLConfiguration can trigger\r\n * the auto save mechanism.\r\n */\r\n@Test\r\nvoid testAutoSaveWithSubSubnodeConfig() throws ConfigurationException {\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = new FileBasedConfigurationBuilder<>(XMLConfiguration.class);\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFileName(testProperties));\r\n    conf = builder.getConfiguration();\r\n    builder.getFileHandler().setFile(testSaveConf);\r\n    builder.setAutoSave(true);\r\n    final String newValue = \"I am autosaved\";\r\n    final HierarchicalConfiguration<?> sub1 = conf.configurationAt(\"element2\", true);\r\n    final HierarchicalConfiguration<?> sub2 = sub1.configurationAt(\"subelement\", true);\r\n    sub2.setProperty(\"subsubelement\", newValue);\r\n    assertEquals(newValue, conf.getString(\"element2.subelement.subsubelement\"));\r\n    final XMLConfiguration conf2 = new XMLConfiguration();\r\n    load(conf2, testSaveConf.getAbsolutePath());\r\n    assertEquals(newValue, conf2.getString(\"element2.subelement.subsubelement\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearAttributeMultipleDisjoined",
  "sourceCode" : "@Test\r\nvoid testClearAttributeMultipleDisjoined() throws Exception {\r\n    String key = \"clear.list.item[@id]\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n    key = \"clear.list.item\";\r\n    assertNotNull(conf.getProperty(key));\r\n    assertNotNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearAttributeNonExisting",
  "sourceCode" : "@Test\r\nvoid testClearAttributeNonExisting() {\r\n    final String key = \"clear[@id]\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearAttributeSingle",
  "sourceCode" : "@Test\r\nvoid testClearAttributeSingle() {\r\n    String key = \"clear.element2[@id]\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n    key = \"clear.element2\";\r\n    assertNotNull(conf.getProperty(key));\r\n    assertNotNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearPropertyCData",
  "sourceCode" : "@Test\r\nvoid testClearPropertyCData() {\r\n    final String key = \"clear.cdata\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearPropertyMultipleDisjoined",
  "sourceCode" : "@Test\r\nvoid testClearPropertyMultipleDisjoined() throws Exception {\r\n    final String key = \"list.item\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearPropertyMultipleSiblings",
  "sourceCode" : "@Test\r\nvoid testClearPropertyMultipleSiblings() {\r\n    String key = \"clear.list.item\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n    key = \"clear.list.item[@id]\";\r\n    assertNotNull(conf.getProperty(key));\r\n    assertNotNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearPropertyNonText",
  "sourceCode" : "@Test\r\nvoid testClearPropertyNonText() {\r\n    final String key = \"clear.comment\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearPropertyNotExisting",
  "sourceCode" : "@Test\r\nvoid testClearPropertyNotExisting() {\r\n    final String key = \"clearly\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearPropertySingleElement",
  "sourceCode" : "@Test\r\nvoid testClearPropertySingleElement() {\r\n    final String key = \"clear.element\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearPropertySingleElementWithAttribute",
  "sourceCode" : "@Test\r\nvoid testClearPropertySingleElementWithAttribute() {\r\n    String key = \"clear.element2\";\r\n    conf.clearProperty(key);\r\n    assertNull(conf.getProperty(key));\r\n    assertNull(conf.getProperty(key));\r\n    key = \"clear.element2[@id]\";\r\n    assertNotNull(conf.getProperty(key));\r\n    assertNotNull(conf.getProperty(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClearTextRootElement",
  "sourceCode" : "/**\r\n * Tests removing the text of the root element.\r\n */\r\n@Test\r\nvoid testClearTextRootElement() throws ConfigurationException {\r\n    final String xml = \"<e a=\\\"v\\\">text</e>\";\r\n    conf.clear();\r\n    final StringReader in = new StringReader(xml);\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.load(in);\r\n    assertEquals(\"text\", conf.getString(\"\"));\r\n    conf.clearProperty(\"\");\r\n    saveTestConfig();\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testClone",
  "sourceCode" : "/**\r\n * Tests the clone() method.\r\n */\r\n@Test\r\nvoid testClone() {\r\n    final Configuration c = (Configuration) conf.clone();\r\n    final XMLConfiguration copy = assertInstanceOf(XMLConfiguration.class, c);\r\n    assertNotNull(conf.getDocument());\r\n    assertNull(copy.getDocument());\r\n    copy.setProperty(\"element3\", \"clonedValue\");\r\n    assertEquals(\"value\", conf.getString(\"element3\"));\r\n    conf.setProperty(\"element3[@name]\", \"originalFoo\");\r\n    assertEquals(\"foo\", copy.getString(\"element3[@name]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testCloneWithSave",
  "sourceCode" : "/**\r\n * Tests saving a configuration after cloning to ensure that the clone and the original are completely detached.\r\n */\r\n@Test\r\nvoid testCloneWithSave() throws ConfigurationException {\r\n    final XMLConfiguration c = (XMLConfiguration) conf.clone();\r\n    c.addProperty(\"test.newProperty\", Boolean.TRUE);\r\n    conf.addProperty(\"test.orgProperty\", Boolean.TRUE);\r\n    new FileHandler(c).save(testSaveConf);\r\n    final XMLConfiguration c2 = new XMLConfiguration();\r\n    load(c2, testSaveConf.getAbsolutePath());\r\n    assertTrue(c2.getBoolean(\"test.newProperty\"));\r\n    assertFalse(c2.containsKey(\"test.orgProperty\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testComplexNames",
  "sourceCode" : "/**\r\n * Tests access to tag names with delimiter characters.\r\n */\r\n@Test\r\nvoid testComplexNames() {\r\n    assertEquals(\"Name with dot\", conf.getString(\"complexNames.my..elem\"));\r\n    assertEquals(\"Another dot\", conf.getString(\"complexNames.my..elem.sub..elem\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testConcurrentGetAndReload",
  "sourceCode" : "@Test\r\nvoid testConcurrentGetAndReload() throws ConfigurationException, InterruptedException {\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = new FileBasedConfigurationBuilder<>(XMLConfiguration.class);\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFileName(testProperties));\r\n    XMLConfiguration config = builder.getConfiguration();\r\n    assertNotNull(config.getProperty(\"test.short\"));\r\n    final Thread[] testThreads = new Thread[THREAD_COUNT];\r\n    for (int i = 0; i < testThreads.length; ++i) {\r\n        testThreads[i] = new ReloadThread(builder);\r\n        testThreads[i].start();\r\n    }\r\n    for (int i = 0; i < LOOP_COUNT; i++) {\r\n        config = builder.getConfiguration();\r\n        assertNotNull(config.getProperty(\"test.short\"));\r\n    }\r\n    for (final Thread testThread : testThreads) {\r\n        testThread.join();\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testCopyNull",
  "sourceCode" : "/**\r\n * Tests the copy constructor for null input.\r\n */\r\n@Test\r\nvoid testCopyNull() {\r\n    conf = new XMLConfiguration(null);\r\n    assertTrue(conf.isEmpty());\r\n    assertEquals(\"configuration\", conf.getRootElementName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testCopyRootName",
  "sourceCode" : "/**\r\n * Tests whether the name of the root element is copied when a configuration is created using the copy constructor.\r\n */\r\n@Test\r\nvoid testCopyRootName() throws ConfigurationException {\r\n    final String rootName = \"rootElement\";\r\n    final String xml = \"<\" + rootName + \"><test>true</test></\" + rootName + \">\";\r\n    conf.clear();\r\n    new FileHandler(conf).load(new StringReader(xml));\r\n    XMLConfiguration copy = new XMLConfiguration(conf);\r\n    assertEquals(rootName, copy.getRootElementName());\r\n    new FileHandler(copy).save(testSaveConf);\r\n    copy = new XMLConfiguration();\r\n    load(copy, testSaveConf.getAbsolutePath());\r\n    assertEquals(rootName, copy.getRootElementName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testCopyRootNameNoDocument",
  "sourceCode" : "/**\r\n * Tests whether the name of the root element is copied for a configuration for which not yet a document exists.\r\n */\r\n@Test\r\nvoid testCopyRootNameNoDocument() throws ConfigurationException {\r\n    final String rootName = \"rootElement\";\r\n    conf = new XMLConfiguration();\r\n    conf.setRootElementName(rootName);\r\n    conf.setProperty(\"test\", Boolean.TRUE);\r\n    final XMLConfiguration copy = new XMLConfiguration(conf);\r\n    assertEquals(rootName, copy.getRootElementName());\r\n    new FileHandler(copy).save(testSaveConf);\r\n    load(copy, testSaveConf.getAbsolutePath());\r\n    assertEquals(rootName, copy.getRootElementName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testCustomDocBuilder",
  "sourceCode" : "/**\r\n * Tests setting a custom document builder.\r\n */\r\n@Test\r\nvoid testCustomDocBuilder() throws Exception {\r\n    // Load an invalid XML file with the default (non validating)\r\n    // doc builder. This should work...\r\n    conf = new XMLConfiguration();\r\n    load(conf, ConfigurationAssert.getTestFile(\"testValidateInvalid.xml\").getAbsolutePath());\r\n    assertEquals(\"customers\", conf.getString(\"table.name\"));\r\n    assertFalse(conf.containsKey(\"table.fields.field(1).type\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testCustomDocBuilderValidationError",
  "sourceCode" : "/**\r\n * Tests whether a validating document builder detects a validation error.\r\n */\r\n@Test\r\nvoid testCustomDocBuilderValidationError() throws Exception {\r\n    final DocumentBuilder builder = createValidatingDocBuilder();\r\n    conf = new XMLConfiguration();\r\n    conf.setDocumentBuilder(builder);\r\n    final String fileName = ConfigurationAssert.getTestFile(\"testValidateInvalid.xml\").getAbsolutePath();\r\n    assertThrows(ConfigurationException.class, () -> load(conf, fileName));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testCustomDocBuilderValidationSuccess",
  "sourceCode" : "/**\r\n * Tests whether a valid document can be loaded with a validating document builder.\r\n */\r\n@Test\r\nvoid testCustomDocBuilderValidationSuccess() throws Exception {\r\n    final DocumentBuilder builder = createValidatingDocBuilder();\r\n    conf = new XMLConfiguration();\r\n    conf.setDocumentBuilder(builder);\r\n    load(conf, ConfigurationAssert.getTestFile(\"testValidateValid.xml\").getAbsolutePath());\r\n    assertTrue(conf.containsKey(\"table.fields.field(1).type\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests string properties with list delimiters when delimiter parsing is disabled\r\n */\r\n@Test\r\nvoid testDelimiterParsingDisabled() throws ConfigurationException {\r\n    final XMLConfiguration conf2 = new XMLConfiguration();\r\n    load(conf2, testProperties);\r\n    assertEquals(\"a,b,c\", conf2.getString(\"split.list3[@values]\"));\r\n    assertEquals(0, conf2.getMaxIndex(\"split.list3[@values]\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", conf2.getString(\"split.list4[@values]\"));\r\n    assertEquals(\"a,b,c\", conf2.getString(\"split.list1\"));\r\n    assertEquals(0, conf2.getMaxIndex(\"split.list1\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", conf2.getString(\"split.list2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testDelimiterParsingDisabledXPath",
  "sourceCode" : "/**\r\n * Tests whether string properties with list delimiters can be accessed if delimiter parsing is disabled and the XPath\r\n * expression engine is used.\r\n */\r\n@Test\r\nvoid testDelimiterParsingDisabledXPath() throws ConfigurationException {\r\n    final XMLConfiguration conf2 = new XMLConfiguration();\r\n    conf2.setExpressionEngine(new XPathExpressionEngine());\r\n    load(conf2, testProperties);\r\n    assertEquals(\"a,b,c\", conf2.getString(\"split/list3/@values\"));\r\n    assertEquals(0, conf2.getMaxIndex(\"split/list3/@values\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", conf2.getString(\"split/list4/@values\"));\r\n    assertEquals(\"a,b,c\", conf2.getString(\"split/list1\"));\r\n    assertEquals(0, conf2.getMaxIndex(\"split/list1\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", conf2.getString(\"split/list2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testDtd",
  "sourceCode" : "/**\r\n * Tests whether a DTD can be accessed.\r\n */\r\n@Test\r\nvoid testDtd() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    load(conf, \"testDtd.xml\");\r\n    assertEquals(\"value1\", conf.getString(\"entry(0)\"));\r\n    assertEquals(\"test2\", conf.getString(\"entry(1)[@key]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testEmptyAttribute",
  "sourceCode" : "/**\r\n * Tests whether an attribute can be set to an empty string. This test is related to CONFIGURATION-446.\r\n */\r\n@Test\r\nvoid testEmptyAttribute() throws ConfigurationException {\r\n    final String key = \"element3[@value]\";\r\n    conf.setProperty(key, \"\");\r\n    assertTrue(conf.containsKey(key));\r\n    assertEquals(\"\", conf.getString(key));\r\n    saveTestConfig();\r\n    conf = new XMLConfiguration();\r\n    load(conf, testSaveConf.getAbsolutePath());\r\n    assertTrue(conf.containsKey(key));\r\n    assertEquals(\"\", conf.getString(key));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testEmptyElements",
  "sourceCode" : "/**\r\n * Tests handling of empty elements.\r\n */\r\n@Test\r\nvoid testEmptyElements() throws ConfigurationException {\r\n    assertTrue(conf.containsKey(\"empty\"));\r\n    assertEquals(\"\", conf.getString(\"empty\"));\r\n    conf.addProperty(\"empty2\", \"\");\r\n    conf.setProperty(\"empty\", \"no more empty\");\r\n    saveTestConfig();\r\n    conf = new XMLConfiguration();\r\n    load(conf, testSaveConf.getAbsolutePath());\r\n    assertEquals(\"no more empty\", conf.getString(\"empty\"));\r\n    assertEquals(\"\", conf.getProperty(\"empty2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testEmptyReload",
  "sourceCode" : "/**\r\n * Tests the isEmpty() method for an empty configuration that was reloaded.\r\n */\r\n@Test\r\nvoid testEmptyReload() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    assertTrue(conf.isEmpty());\r\n    saveTestConfig();\r\n    load(conf, testSaveConf.getAbsolutePath());\r\n    assertTrue(conf.isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testGetAttribute",
  "sourceCode" : "@Test\r\nvoid testGetAttribute() {\r\n    assertEquals(\"foo\", conf.getProperty(\"element3[@name]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testGetCommentedProperty",
  "sourceCode" : "@Test\r\nvoid testGetCommentedProperty() {\r\n    assertEquals(\"\", conf.getProperty(\"test.comment\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testGetComplexProperty",
  "sourceCode" : "@Test\r\nvoid testGetComplexProperty() {\r\n    assertEquals(\"I'm complex!\", conf.getProperty(\"element2.subelement.subsubelement\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testgetProperty",
  "sourceCode" : "@Test\r\nvoid testgetProperty() {\r\n    // test non-leaf element\r\n    Object property = conf.getProperty(\"clear\");\r\n    assertNull(property);\r\n    // test non-existent element\r\n    property = conf.getProperty(\"e\");\r\n    assertNull(property);\r\n    // test non-existent element\r\n    property = conf.getProperty(\"element3[@n]\");\r\n    assertNull(property);\r\n    // test single element\r\n    property = conf.getProperty(\"element\");\r\n    assertInstanceOf(String.class, property);\r\n    assertEquals(\"value\", property);\r\n    // test single attribute\r\n    property = conf.getProperty(\"element3[@name]\");\r\n    assertInstanceOf(String.class, property);\r\n    assertEquals(\"foo\", property);\r\n    // test non-text/cdata element\r\n    property = conf.getProperty(\"test.comment\");\r\n    assertEquals(\"\", property);\r\n    // test cdata element\r\n    property = conf.getProperty(\"test.cdata\");\r\n    assertInstanceOf(String.class, property);\r\n    assertEquals(\"<cdata value>\", property);\r\n    // test multiple sibling elements\r\n    property = conf.getProperty(\"list.sublist.item\");\r\n    List<?> list = assertInstanceOf(List.class, property);\r\n    assertEquals(Arrays.asList(\"five\", \"six\"), list);\r\n    // test multiple, disjoined elements\r\n    property = conf.getProperty(\"list.item\");\r\n    list = assertInstanceOf(List.class, property);\r\n    assertEquals(Arrays.asList(\"one\", \"two\", \"three\", \"four\"), list);\r\n    // test multiple, disjoined attributes\r\n    property = conf.getProperty(\"list.item[@name]\");\r\n    list = assertInstanceOf(List.class, property);\r\n    assertEquals(Arrays.asList(\"one\", \"three\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testGetProperty",
  "sourceCode" : "@Test\r\nvoid testGetProperty() {\r\n    assertEquals(\"value\", conf.getProperty(\"element\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testGetPropertyWithXMLEntity",
  "sourceCode" : "@Test\r\nvoid testGetPropertyWithXMLEntity() {\r\n    assertEquals(\"1<2\", conf.getProperty(\"test.entity\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testInitCopy",
  "sourceCode" : "/**\r\n * Tests the copy constructor.\r\n */\r\n@Test\r\nvoid testInitCopy() throws ConfigurationException {\r\n    final XMLConfiguration copy = new XMLConfiguration(conf);\r\n    copy.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\r\n    assertEquals(\"value\", copy.getProperty(\"element\"));\r\n    assertNull(copy.getDocument());\r\n    new FileHandler(copy).save(testSaveConf);\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testListWithAttributes",
  "sourceCode" : "/**\r\n * Tests list nodes with multiple values and attributes.\r\n */\r\n@Test\r\nvoid testListWithAttributes() {\r\n    assertEquals(6, conf.getList(\"attrList.a\").size());\r\n    assertEquals(\"ABC\", conf.getString(\"attrList.a(0)\"));\r\n    assertEquals(\"x\", conf.getString(\"attrList.a(0)[@name]\"));\r\n    assertEquals(6, conf.getList(\"attrList.a[@name]\").size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testListWithAttributesMultiValue",
  "sourceCode" : "/**\r\n * Tests a list node with attributes that has multiple values separated by the list delimiter. In this scenario the\r\n * attribute should be added to all list nodes.\r\n */\r\n@Test\r\nvoid testListWithAttributesMultiValue() {\r\n    assertEquals(\"1\", conf.getString(\"attrList.a(1)\"));\r\n    assertEquals(\"y\", conf.getString(\"attrList.a(1)[@name]\"));\r\n    for (int i = 1; i <= 3; i++) {\r\n        assertEquals(i, conf.getInt(\"attrList.a(\" + i + \")\"));\r\n        assertEquals(\"y\", conf.getString(\"attrList.a(\" + i + \")[@name]\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testListWithMultipleAttributesMultiValue",
  "sourceCode" : "/**\r\n * Tests a list node with multiple values and multiple attributes. All attribute values should be assigned to all list\r\n * nodes.\r\n */\r\n@Test\r\nvoid testListWithMultipleAttributesMultiValue() {\r\n    for (int i = 1; i <= 2; i++) {\r\n        final String idxStr = String.format(\"(%d)\", Integer.valueOf(i + 3));\r\n        final String nodeKey = \"attrList.a\" + idxStr;\r\n        assertEquals(\"value\" + i, conf.getString(nodeKey));\r\n        assertEquals(\"u\", conf.getString(nodeKey + \"[@name]\"));\r\n        assertEquals(\"yes\", conf.getString(nodeKey + \"[@test]\"));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testLoadAndSaveFromFile",
  "sourceCode" : "/**\r\n * Tests constructing an XMLConfiguration from a non existing file and later saving to this file.\r\n */\r\n@Test\r\nvoid testLoadAndSaveFromFile() throws Exception {\r\n    // If the file does not exist, an empty config is created\r\n    assertFalse(testSaveConf.exists());\r\n    final FileBasedConfigurationBuilder<XMLConfiguration> builder = new FileBasedConfigurationBuilder<>(XMLConfiguration.class, null, true);\r\n    builder.configure(new FileBasedBuilderParametersImpl().setFile(testSaveConf));\r\n    conf = builder.getConfiguration();\r\n    assertTrue(conf.isEmpty());\r\n    conf.addProperty(\"test\", \"yes\");\r\n    builder.save();\r\n    final XMLConfiguration checkConfig = createFromFile(testSaveConf.getAbsolutePath());\r\n    assertEquals(\"yes\", checkConfig.getString(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testLoadChildNamespace",
  "sourceCode" : "@Test\r\nvoid testLoadChildNamespace() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    new FileHandler(conf).load(ConfigurationAssert.getTestFile(\"testChildNamespace.xml\"));\r\n    assertEquals(\"http://example.com/\", conf.getString(\"foo:bar.[@xmlns:foo]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testLoadFromStream",
  "sourceCode" : "/**\r\n * Tests loading from a stream.\r\n */\r\n@Test\r\nvoid testLoadFromStream() throws Exception {\r\n    final String xml = \"<?xml version=\\\"1.0\\\"?><config><test>1</test></config>\";\r\n    conf = new XMLConfiguration();\r\n    FileHandler handler = new FileHandler(conf);\r\n    handler.load(new ByteArrayInputStream(xml.getBytes()));\r\n    assertEquals(1, conf.getInt(\"test\"));\r\n    conf = new XMLConfiguration();\r\n    handler = new FileHandler(conf);\r\n    handler.load(new ByteArrayInputStream(xml.getBytes()), \"UTF8\");\r\n    assertEquals(1, conf.getInt(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testLoadInvalidXML",
  "sourceCode" : "/**\r\n * Tests loading a non well formed XML from a string.\r\n */\r\n@Test\r\nvoid testLoadInvalidXML() throws Exception {\r\n    final String xml = \"<?xml version=\\\"1.0\\\"?><config><test>1</rest></config>\";\r\n    conf = new XMLConfiguration();\r\n    final FileHandler handler = new FileHandler(conf);\r\n    final StringReader reader = new StringReader(xml);\r\n    assertThrows(ConfigurationException.class, () -> handler.load(reader));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testLoadWithEncoding",
  "sourceCode" : "/**\r\n * Tests whether the encoding is correctly detected by the XML parser. This is done by loading an XML file with the\r\n * encoding \"UTF-16\". If this encoding is not detected correctly, an exception will be thrown that \"Content is not\r\n * allowed in prolog\". This test case is related to issue 34204.\r\n */\r\n@Test\r\nvoid testLoadWithEncoding() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    new FileHandler(conf).load(ConfigurationAssert.getTestFile(\"testEncoding.xml\"));\r\n    assertEquals(\"test3_yoge\", conf.getString(\"yoge\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testLoadWithRootNamespace",
  "sourceCode" : "@Test\r\nvoid testLoadWithRootNamespace() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    new FileHandler(conf).load(ConfigurationAssert.getTestFile(\"testRootNamespace.xml\"));\r\n    assertEquals(\"http://example.com/\", conf.getString(\"[@xmlns:foo]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testNoDelimiterParsingInAttrValues",
  "sourceCode" : "/**\r\n * Tests that attribute values are not split.\r\n */\r\n@Test\r\nvoid testNoDelimiterParsingInAttrValues() throws ConfigurationException {\r\n    conf.clear();\r\n    load(conf, testProperties);\r\n    final List<Object> expr = conf.getList(\"expressions[@value]\");\r\n    assertEquals(Arrays.asList(\"a || (b && c) | !d\"), expr);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testOverrideAttribute",
  "sourceCode" : "/**\r\n * Tests whether an attribute value can be overridden.\r\n */\r\n@Test\r\nvoid testOverrideAttribute() {\r\n    conf.addProperty(\"element3[@name]\", \"bar\");\r\n    final List<Object> list = conf.getList(\"element3[@name]\");\r\n    assertEquals(Arrays.asList(\"bar\"), list);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testPreserveSpace",
  "sourceCode" : "/**\r\n * Tests whether spaces are preserved when the xml:space attribute is set.\r\n */\r\n@Test\r\nvoid testPreserveSpace() {\r\n    assertEquals(\" \", conf.getString(\"space.blank\"));\r\n    assertEquals(\" * * \", conf.getString(\"space.stars\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testPreserveSpaceInvalid",
  "sourceCode" : "/**\r\n * Tests an xml:space attribute with an invalid value. This will be interpreted as default.\r\n */\r\n@Test\r\nvoid testPreserveSpaceInvalid() {\r\n    assertEquals(\"Some other text\", conf.getString(\"space.testInvalid\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testPreserveSpaceOnElement",
  "sourceCode" : "/**\r\n * Tests whether the xml:space attribute works directly on the current element. This test is related to\r\n * CONFIGURATION-555.\r\n */\r\n@Test\r\nvoid testPreserveSpaceOnElement() {\r\n    assertEquals(\" preserved \", conf.getString(\"spaceElement\"));\r\n    assertEquals(\"   \", conf.getString(\"spaceBlankElement\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testPreserveSpaceOverride",
  "sourceCode" : "/**\r\n * Tests whether the xml:space attribute can be overridden in nested elements.\r\n */\r\n@Test\r\nvoid testPreserveSpaceOverride() {\r\n    assertEquals(\"Some text\", conf.getString(\"space.description\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testPublicIdSynchronized",
  "sourceCode" : "/**\r\n * Tests whether the public ID is accessed in a synchronized manner.\r\n */\r\n@Test\r\nvoid testPublicIdSynchronized() {\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    conf.setSynchronizer(sync);\r\n    conf.setPublicID(PUBLIC_ID);\r\n    assertEquals(PUBLIC_ID, conf.getPublicID());\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE, Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testReadCalledDirectly",
  "sourceCode" : "/**\r\n * Tests a direct invocation of the read() method. This is not allowed because certain initializations have not been\r\n * done. This test is related to CONFIGURATION-641.\r\n */\r\n@Test\r\nvoid testReadCalledDirectly() {\r\n    conf = new XMLConfiguration();\r\n    final String content = \"<configuration><test>1</test></configuration>\";\r\n    final ByteArrayInputStream bis = new ByteArrayInputStream(content.getBytes());\r\n    final ConfigurationException e = assertThrows(ConfigurationException.class, () -> conf.read(bis));\r\n    assertTrue(e.getMessage().contains(\"FileHandler\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "@Test\r\nvoid testSave() throws Exception {\r\n    // add an array of strings to the configuration\r\n    conf.addProperty(\"string\", \"value1\");\r\n    for (int i = 1; i < 5; i++) {\r\n        conf.addProperty(\"test.array\", \"value\" + i);\r\n    }\r\n    // add comma delimited lists with escaped delimiters\r\n    conf.addProperty(\"split.list5\", \"a\\\\,b\\\\,c\");\r\n    conf.setProperty(\"element3\", \"value\\\\,value1\\\\,value2\");\r\n    conf.setProperty(\"element3[@name]\", \"foo\\\\,bar\");\r\n    // save the configuration\r\n    saveTestConfig();\r\n    // read the configuration and compare the properties\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveAfterCreateWithCopyConstructor",
  "sourceCode" : "/**\r\n * Tests saving a configuration that was created from a hierarchical configuration. This test exposes bug\r\n * CONFIGURATION-301.\r\n */\r\n@Test\r\nvoid testSaveAfterCreateWithCopyConstructor() throws ConfigurationException {\r\n    final HierarchicalConfiguration<ImmutableNode> hc = conf.configurationAt(\"element2\");\r\n    conf = new XMLConfiguration(hc);\r\n    saveTestConfig();\r\n    final XMLConfiguration checkConfig = checkSavedConfig();\r\n    assertEquals(\"element2\", checkConfig.getRootElementName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveAttributes",
  "sourceCode" : "/**\r\n * Tests saving attributes (related to issue 34442).\r\n */\r\n@Test\r\nvoid testSaveAttributes() throws Exception {\r\n    conf.clear();\r\n    load(conf, testProperties);\r\n    saveTestConfig();\r\n    conf = new XMLConfiguration();\r\n    load(conf, testSaveConf.getAbsolutePath());\r\n    assertEquals(\"foo\", conf.getString(\"element3[@name]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests saving and loading a configuration when delimiter parsing is disabled.\r\n */\r\n@Test\r\nvoid testSaveDelimiterParsingDisabled() throws ConfigurationException {\r\n    checkSaveDelimiterParsingDisabled(\"list.delimiter.test\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveToStream",
  "sourceCode" : "/**\r\n * Tests saving to a stream.\r\n */\r\n@Test\r\nvoid testSaveToStream() throws ConfigurationException, IOException {\r\n    final FileHandler handler = new FileHandler(conf);\r\n    try (FileOutputStream out = new FileOutputStream(testSaveConf)) {\r\n        handler.save(out, \"UTF8\");\r\n    }\r\n    checkSavedConfig(testSaveConf);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveToStreamWithEncoding",
  "sourceCode" : "/**\r\n * Tests whether a configuration can be saved to a stream with a specific encoding.\r\n */\r\n@Test\r\nvoid testSaveToStreamWithEncoding() throws ConfigurationException, IOException {\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setEncoding(\"UTF8\");\r\n    try (FileOutputStream out = new FileOutputStream(testSaveConf)) {\r\n        handler.save(out);\r\n    }\r\n    checkSavedConfig(testSaveConf);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveToURL",
  "sourceCode" : "/**\r\n * Tests saving to a URL.\r\n */\r\n@Test\r\nvoid testSaveToURL() throws Exception {\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.save(testSaveConf.toURI().toURL());\r\n    checkSavedConfig(testSaveConf);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWindowsPath",
  "sourceCode" : "/**\r\n * Tests whether a windows path can be saved correctly. This test is related to CONFIGURATION-428.\r\n */\r\n@Test\r\nvoid testSaveWindowsPath() throws ConfigurationException {\r\n    conf.clear();\r\n    conf.setListDelimiterHandler(new DisabledListDelimiterHandler());\r\n    conf.addProperty(\"path\", \"C:\\\\Temp\");\r\n    final StringWriter writer = new StringWriter();\r\n    new FileHandler(conf).save(writer);\r\n    final String content = writer.toString();\r\n    assertTrue(content.contains(\"<path>C:\\\\Temp</path>\"), \"Path not found: \");\r\n    saveTestConfig();\r\n    final XMLConfiguration conf2 = new XMLConfiguration();\r\n    load(conf2, testSaveConf.getAbsolutePath());\r\n    assertEquals(\"C:\\\\Temp\", conf2.getString(\"path\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests string properties with list delimiters when delimiter parsing is disabled\r\n */\r\n@Test\r\nvoid testSaveWithDelimiterParsingDisabled() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    conf.setExpressionEngine(new XPathExpressionEngine());\r\n    load(conf, testProperties);\r\n    assertEquals(\"a,b,c\", conf.getString(\"split/list3/@values\"));\r\n    assertEquals(0, conf.getMaxIndex(\"split/list3/@values\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", conf.getString(\"split/list4/@values\"));\r\n    assertEquals(\"a,b,c\", conf.getString(\"split/list1\"));\r\n    assertEquals(0, conf.getMaxIndex(\"split/list1\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", conf.getString(\"split/list2\"));\r\n    // save the configuration\r\n    saveTestConfig();\r\n    XMLConfiguration config = new XMLConfiguration();\r\n    // config.setExpressionEngine(new XPathExpressionEngine());\r\n    load(config, testFile2);\r\n    config.setProperty(\"Employee[@attr1]\", \"3,2,1\");\r\n    assertEquals(\"3,2,1\", config.getString(\"Employee[@attr1]\"));\r\n    new FileHandler(config).save(testSaveFile);\r\n    config = new XMLConfiguration();\r\n    // config.setExpressionEngine(new XPathExpressionEngine());\r\n    load(config, testSaveFile.getAbsolutePath());\r\n    config.setProperty(\"Employee[@attr1]\", \"1,2,3\");\r\n    assertEquals(\"1,2,3\", config.getString(\"Employee[@attr1]\"));\r\n    config.setProperty(\"Employee[@attr2]\", \"one, two, three\");\r\n    assertEquals(\"one, two, three\", config.getString(\"Employee[@attr2]\"));\r\n    config.setProperty(\"Employee.text\", \"a,b,d\");\r\n    assertEquals(\"a,b,d\", config.getString(\"Employee.text\"));\r\n    config.setProperty(\"Employee.Salary\", \"100,000\");\r\n    assertEquals(\"100,000\", config.getString(\"Employee.Salary\"));\r\n    new FileHandler(config).save(testSaveFile);\r\n    final XMLConfiguration checkConfig = new XMLConfiguration();\r\n    checkConfig.setExpressionEngine(new XPathExpressionEngine());\r\n    load(checkConfig, testSaveFile.getAbsolutePath());\r\n    assertEquals(\"1,2,3\", checkConfig.getString(\"Employee/@attr1\"));\r\n    assertEquals(\"one, two, three\", checkConfig.getString(\"Employee/@attr2\"));\r\n    assertEquals(\"a,b,d\", checkConfig.getString(\"Employee/text\"));\r\n    assertEquals(\"100,000\", checkConfig.getString(\"Employee/Salary\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithDoctype",
  "sourceCode" : "/**\r\n * Tests whether the DOCTYPE survives a save operation.\r\n */\r\n@Test\r\nvoid testSaveWithDoctype() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    load(conf, \"testDtdPublic.xml\");\r\n    assertEquals(PUBLIC_ID, conf.getPublicID());\r\n    assertEquals(SYSTEM_ID, conf.getSystemID());\r\n    final StringWriter out = new StringWriter();\r\n    new FileHandler(conf).save(out);\r\n    assertTrue(out.toString().contains(DOCTYPE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithDoctypeIDs",
  "sourceCode" : "/**\r\n * Tests setting public and system IDs for the DOCTYPE and then saving the configuration. This should generate a DOCTYPE\r\n * declaration.\r\n */\r\n@Test\r\nvoid testSaveWithDoctypeIDs() throws ConfigurationException {\r\n    assertNull(conf.getPublicID());\r\n    assertNull(conf.getSystemID());\r\n    conf.setPublicID(PUBLIC_ID);\r\n    conf.setSystemID(SYSTEM_ID);\r\n    final StringWriter out = new StringWriter();\r\n    new FileHandler(conf).save(out);\r\n    assertTrue(out.toString().contains(DOCTYPE + \"testconfig\" + DOCTYPE_DECL));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithEncoding",
  "sourceCode" : "/**\r\n * Tests whether the encoding is written to the generated XML file.\r\n */\r\n@Test\r\nvoid testSaveWithEncoding() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    conf.setProperty(\"test\", \"a value\");\r\n    final FileHandler handler = new FileHandler(conf);\r\n    handler.setEncoding(ENCODING);\r\n    final StringWriter out = new StringWriter();\r\n    handler.save(out);\r\n    assertTrue(out.toString().contains(\"encoding=\\\"\" + ENCODING + \"\\\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithInvalidTransformerFactory",
  "sourceCode" : "/**\r\n * Tests saving a configuration if an invalid transformer factory is specified. In this case an error is thrown by the\r\n * transformer factory. XMLConfiguration should not catch this error.\r\n */\r\n@Test\r\nvoid testSaveWithInvalidTransformerFactory() {\r\n    System.setProperty(PROP_FACTORY, \"an.invalid.Class\");\r\n    try {\r\n        assertThrows(TransformerFactoryConfigurationError.class, this::saveTestConfig);\r\n    } finally {\r\n        System.getProperties().remove(PROP_FACTORY);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithNullEncoding",
  "sourceCode" : "/**\r\n * Tests whether a default encoding is used if no specific encoding is set. According to the XSLT specification\r\n * (http://www.w3.org/TR/xslt#output) this should be either UTF-8 or UTF-16.\r\n */\r\n@Test\r\nvoid testSaveWithNullEncoding() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    conf.setProperty(\"testNoEncoding\", \"yes\");\r\n    final FileHandler handler = new FileHandler(conf);\r\n    final StringWriter out = new StringWriter();\r\n    handler.save(out);\r\n    assertTrue(out.toString().contains(\"encoding=\\\"UTF-\"), \"Encoding was written to file\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithRootAttributes",
  "sourceCode" : "@Test\r\nvoid testSaveWithRootAttributes() throws ConfigurationException {\r\n    conf.setProperty(\"[@xmlns:ex]\", \"http://example.com/\");\r\n    assertEquals(\"http://example.com/\", conf.getString(\"[@xmlns:ex]\"));\r\n    final FileHandler handler = new FileHandler(conf);\r\n    final StringWriter out = new StringWriter();\r\n    handler.save(out);\r\n    assertTrue(out.toString().contains(\"testconfig xmlns:ex=\\\"http://example.com/\\\"\"), \"Encoding was not written to file\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithRootAttributesByHand",
  "sourceCode" : "@Test\r\nvoid testSaveWithRootAttributesByHand() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    conf.addProperty(\"[@xmlns:foo]\", \"http://example.com/\");\r\n    assertEquals(\"http://example.com/\", conf.getString(\"[@xmlns:foo]\"));\r\n    final FileHandler handler = new FileHandler(conf);\r\n    final StringWriter out = new StringWriter();\r\n    handler.save(out);\r\n    assertTrue(out.toString().contains(\"configuration xmlns:foo=\\\"http://example.com/\\\"\"), \"Encoding was not written to file\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithValidation",
  "sourceCode" : "/**\r\n * Tests modifying an XML document and saving it with schema validation enabled.\r\n */\r\n@Test\r\nvoid testSaveWithValidation() throws Exception {\r\n    final CatalogResolver resolver = new CatalogResolver();\r\n    resolver.setCatalogFiles(CATALOG_FILES);\r\n    conf = new XMLConfiguration();\r\n    conf.setEntityResolver(resolver);\r\n    conf.setSchemaValidation(true);\r\n    load(conf, testFile2);\r\n    conf.setProperty(\"Employee.SSN\", \"123456789\");\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    conf.setSynchronizer(sync);\r\n    conf.validate();\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);\r\n    saveTestConfig();\r\n    conf = new XMLConfiguration();\r\n    load(conf, testSaveConf.getAbsolutePath());\r\n    assertEquals(\"123456789\", conf.getString(\"Employee.SSN\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSaveWithValidationFailure",
  "sourceCode" : "/**\r\n * Tests modifying an XML document and validating it against the schema.\r\n */\r\n@Test\r\nvoid testSaveWithValidationFailure() throws Exception {\r\n    final CatalogResolver resolver = new CatalogResolver();\r\n    resolver.setCatalogFiles(CATALOG_FILES);\r\n    conf = new XMLConfiguration();\r\n    conf.setEntityResolver(resolver);\r\n    conf.setSchemaValidation(true);\r\n    load(conf, testFile2);\r\n    conf.setProperty(\"Employee.Email\", \"JohnDoe@test.org\");\r\n    final Exception e = assertThrows(Exception.class, conf::validate);\r\n    final Throwable cause = e.getCause();\r\n    assertInstanceOf(SAXParseException.class, cause);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSetAttribute",
  "sourceCode" : "@Test\r\nvoid testSetAttribute() {\r\n    // replace an existing attribute\r\n    conf.setProperty(\"element3[@name]\", \"bar\");\r\n    assertEquals(\"bar\", conf.getProperty(\"element3[@name]\"));\r\n    // set a new attribute\r\n    conf.setProperty(\"foo[@bar]\", \"value\");\r\n    assertEquals(\"value\", conf.getProperty(\"foo[@bar]\"));\r\n    conf.setProperty(\"name1\", \"value1\");\r\n    assertEquals(\"value1\", conf.getProperty(\"name1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSetProperty",
  "sourceCode" : "@Test\r\nvoid testSetProperty() throws Exception {\r\n    conf.setProperty(\"element.string\", \"hello\");\r\n    assertEquals(\"hello\", conf.getString(\"element.string\"));\r\n    assertEquals(\"hello\", conf.getProperty(\"element.string\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSetPropertyListWithDelimiterParsingDisabled",
  "sourceCode" : "/**\r\n * Tests whether list properties are set correctly if delimiter parsing is disabled. This test is related to\r\n * CONFIGURATION-495.\r\n */\r\n@Test\r\nvoid testSetPropertyListWithDelimiterParsingDisabled() throws ConfigurationException {\r\n    final String prop = \"delimiterListProp\";\r\n    final List<String> list = Arrays.asList(\"val\", \"val2\", \"val3\");\r\n    conf.setProperty(prop, list);\r\n    saveTestConfig();\r\n    final XMLConfiguration conf2 = new XMLConfiguration();\r\n    load(conf2, testSaveConf.getAbsolutePath());\r\n    assertEquals(list, conf2.getProperty(prop));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSetRootAttribute",
  "sourceCode" : "/**\r\n * Tests setting an attribute on the root element.\r\n */\r\n@Test\r\nvoid testSetRootAttribute() throws ConfigurationException {\r\n    conf.setProperty(\"[@test]\", \"true\");\r\n    assertEquals(\"true\", conf.getString(\"[@test]\"));\r\n    saveTestConfig();\r\n    XMLConfiguration checkConf = checkSavedConfig();\r\n    assertTrue(checkConf.containsKey(\"[@test]\"));\r\n    checkConf.setProperty(\"[@test]\", \"newValue\");\r\n    conf = checkConf;\r\n    saveTestConfig();\r\n    checkConf = checkSavedConfig();\r\n    assertEquals(\"newValue\", checkConf.getString(\"[@test]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSetRootNamespace",
  "sourceCode" : "@Test\r\nvoid testSetRootNamespace() throws ConfigurationException {\r\n    conf.addProperty(\"[@xmlns:foo]\", \"http://example.com/\");\r\n    conf.addProperty(\"foo:bar\", \"foobar\");\r\n    assertEquals(\"http://example.com/\", conf.getString(\"[@xmlns:foo]\"));\r\n    saveTestConfig();\r\n    final XMLConfiguration checkConf = checkSavedConfig();\r\n    assertTrue(checkConf.containsKey(\"[@xmlns:foo]\"));\r\n    checkConf.setProperty(\"[@xmlns:foo]\", \"http://example.net/\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSetTextRootElement",
  "sourceCode" : "/**\r\n * Tests setting text of the root element.\r\n */\r\n@Test\r\nvoid testSetTextRootElement() throws ConfigurationException {\r\n    conf.setProperty(\"\", \"Root text\");\r\n    saveTestConfig();\r\n    checkSavedConfig();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSplitLists",
  "sourceCode" : "/**\r\n * Tests string properties with list delimiters and escaped delimiters.\r\n */\r\n@Test\r\nvoid testSplitLists() {\r\n    assertEquals(\"a,b,c\", conf.getString(\"split.list3[@values]\"));\r\n    assertEquals(0, conf.getMaxIndex(\"split.list3[@values]\"));\r\n    assertEquals(\"a\\\\,b\\\\,c\", conf.getString(\"split.list4[@values]\"));\r\n    assertEquals(\"a\", conf.getString(\"split.list1\"));\r\n    assertEquals(2, conf.getMaxIndex(\"split.list1\"));\r\n    assertEquals(\"a,b,c\", conf.getString(\"split.list2\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSubset",
  "sourceCode" : "/**\r\n * Tests the subset() method. There was a bug that calling subset() had undesired side effects.\r\n */\r\n@Test\r\nvoid testSubset() throws ConfigurationException {\r\n    conf = new XMLConfiguration();\r\n    load(conf, \"testHierarchicalXMLConfiguration.xml\");\r\n    conf.subset(\"tables.table(0)\");\r\n    saveTestConfig();\r\n    conf = new XMLConfiguration();\r\n    load(conf, \"testHierarchicalXMLConfiguration.xml\");\r\n    assertEquals(\"users\", conf.getString(\"tables.table(0).name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testSystemIdSynchronized",
  "sourceCode" : "/**\r\n * Tests whether the system ID is accessed in a synchronized manner.\r\n */\r\n@Test\r\nvoid testSystemIdSynchronized() {\r\n    final SynchronizerTestImpl sync = new SynchronizerTestImpl();\r\n    conf.setSynchronizer(sync);\r\n    conf.setSystemID(SYSTEM_ID);\r\n    assertEquals(SYSTEM_ID, conf.getSystemID());\r\n    sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE, Methods.BEGIN_READ, Methods.END_READ);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testValidating",
  "sourceCode" : "/**\r\n * Tests DTD validation using the setValidating() method.\r\n */\r\n@Test\r\nvoid testValidating() throws ConfigurationException {\r\n    final File nonValidFile = ConfigurationAssert.getTestFile(\"testValidateInvalid.xml\");\r\n    conf = new XMLConfiguration();\r\n    assertFalse(conf.isValidating());\r\n    // Load a non valid XML document. Should work for isValidating() == false\r\n    load(conf, nonValidFile.getAbsolutePath());\r\n    assertEquals(\"customers\", conf.getString(\"table.name\"));\r\n    assertFalse(conf.containsKey(\"table.fields.field(1).type\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testValidatingInvalidFile",
  "sourceCode" : "/**\r\n * Tests whether an invalid file is detected when validating is enabled.\r\n */\r\n@Test\r\nvoid testValidatingInvalidFile() {\r\n    conf = new XMLConfiguration();\r\n    conf.setValidating(true);\r\n    assertThrows(ConfigurationException.class, () -> load(conf, \"testValidateInvalid.xml\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testWrite",
  "sourceCode" : "@Test\r\nvoid testWrite() throws Exception {\r\n    final XMLConfiguration xmlConfig = new XMLConfiguration();\r\n    xmlConfig.setRootElementName(\"IAmRoot\");\r\n    final StringWriter sw = new StringWriter();\r\n    xmlConfig.write(sw);\r\n    // Check that we can parse the XML.\r\n    assertNotNull(parseXml(sw.toString()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testWriteIndentSize",
  "sourceCode" : "@Test\r\nvoid testWriteIndentSize() throws Exception {\r\n    final XMLConfiguration xmlConfig = new XMLConfiguration();\r\n    xmlConfig.setRootElementName(\"IAmRoot\");\r\n    final StringWriter sw = new StringWriter();\r\n    xmlConfig.setProperty(\"Child\", \"Alexander\");\r\n    xmlConfig.write(sw);\r\n    // Check that we can parse the XML.\r\n    final String xml = sw.toString();\r\n    assertNotNull(parseXml(xml));\r\n    final String indent = StringUtils.repeat(' ', XMLConfiguration.DEFAULT_INDENT_SIZE);\r\n    assertTrue(xml.contains(System.lineSeparator() + indent + \"<Child>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testWriteWithTransformer",
  "sourceCode" : "@Test\r\nvoid testWriteWithTransformer() throws Exception {\r\n    final XMLConfiguration xmlConfig = new XMLConfiguration();\r\n    xmlConfig.setRootElementName(\"IAmRoot\");\r\n    xmlConfig.setProperty(\"Child\", \"Alexander\");\r\n    final StringWriter sw = new StringWriter();\r\n    final Transformer transformer = xmlConfig.createTransformer();\r\n    final int indentSize = 8;\r\n    transformer.setOutputProperty(XMLConfiguration.INDENT_AMOUNT_PROPERTY, Integer.toString(indentSize));\r\n    xmlConfig.write(sw, transformer);\r\n    final String xml = sw.toString();\r\n    assertNotNull(parseXml(xml));\r\n    final String indent = StringUtils.repeat(' ', indentSize);\r\n    assertTrue(xml.contains(System.lineSeparator() + indent + \"<Child>\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration.java",
  "methodName" : "testXPathExpressionEngine",
  "sourceCode" : "/**\r\n * Tests accessing properties when the XPATH expression engine is set.\r\n */\r\n@Test\r\nvoid testXPathExpressionEngine() {\r\n    conf.setExpressionEngine(new XPathExpressionEngine());\r\n    assertEquals(\"foo\\\"bar\", conf.getString(\"test[1]/entity/@name\"));\r\n    conf.clear();\r\n    assertNull(conf.getString(\"test[1]/entity/@name\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration605.java",
  "methodName" : "testWithCommaSeparatedList",
  "sourceCode" : "@Test\r\nvoid testWithCommaSeparatedList() throws Exception {\r\n    final String source = \"<configuration><key0></key0><key1>a,b</key1><key2></key2><key3></key3></configuration>\";\r\n    checkConfiguration(create(source));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration605.java",
  "methodName" : "testWithNoComma",
  "sourceCode" : "@Test\r\nvoid testWithNoComma() throws Exception {\r\n    final String source = \"<configuration><key0></key0><key1></key1><key2></key2><key3></key3></configuration>\";\r\n    checkConfiguration(create(source));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration605.java",
  "methodName" : "testWithOnlyComma",
  "sourceCode" : "@Test\r\nvoid testWithOnlyComma() throws Exception {\r\n    final String source = \"<configuration><key0></key0><key1>,</key1><key2></key2><key3></key3></configuration>\";\r\n    checkConfiguration(create(source));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration605.java",
  "methodName" : "testWithOnlyCommaWithoutDelimiterParsing",
  "sourceCode" : "@Test\r\nvoid testWithOnlyCommaWithoutDelimiterParsing() throws Exception {\r\n    final String source = \"<configuration><key0></key0><key1>,</key1><key2></key2><key3></key3></configuration>\";\r\n    checkConfiguration(create(source, DisabledListDelimiterHandler.INSTANCE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration605.java",
  "methodName" : "testWithOnlyCommaWithStringBuilder",
  "sourceCode" : "@Test\r\nvoid testWithOnlyCommaWithStringBuilder() throws Exception {\r\n    final StringBuilder sourceBuilder = new StringBuilder(\"<configuration>\");\r\n    sourceBuilder.append(\"<key0></key0>\");\r\n    sourceBuilder.append(\"<key1>,</key1>\");\r\n    sourceBuilder.append(\"<key2></key2>\");\r\n    sourceBuilder.append(\"<key3></key3>\");\r\n    sourceBuilder.append(\"</configuration>\");\r\n    checkConfiguration(create(sourceBuilder.toString()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration605.java",
  "methodName" : "testWithOnlyCommaWithStringBuilderWithoutDelimiterParsing",
  "sourceCode" : "@Test\r\nvoid testWithOnlyCommaWithStringBuilderWithoutDelimiterParsing() throws Exception {\r\n    final StringBuilder sourceBuilder = new StringBuilder(\"<configuration>\");\r\n    sourceBuilder.append(\"<key0></key0>\");\r\n    sourceBuilder.append(\"<key1>,</key1>\");\r\n    sourceBuilder.append(\"<key2></key2>\");\r\n    sourceBuilder.append(\"<key3></key3>\");\r\n    sourceBuilder.append(\"</configuration>\");\r\n    checkConfiguration(create(sourceBuilder.toString(), DisabledListDelimiterHandler.INSTANCE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration605.java",
  "methodName" : "testWithSeparatingNonWhitespace",
  "sourceCode" : "@Test\r\nvoid testWithSeparatingNonWhitespace() throws Exception {\r\n    final String source = \"<configuration><key0></key0><key1>,</key1>A<key2></key2><key3></key3></configuration>\";\r\n    checkConfiguration(create(source));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLConfiguration605.java",
  "methodName" : "testWithSeparatingWhitespace",
  "sourceCode" : "@Test\r\nvoid testWithSeparatingWhitespace() throws Exception {\r\n    final String source = \"<configuration><key0></key0><key1>,</key1> <key2></key2><key3></key3></configuration>\";\r\n    checkConfiguration(create(source));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testCopyDocument",
  "sourceCode" : "/**\r\n * Tests whether a document can be copied.\r\n */\r\n@Test\r\nvoid testCopyDocument() throws Exception {\r\n    final XMLDocumentHelper helper = XMLDocumentHelper.forSourceDocument(loadDocument());\r\n    final XMLDocumentHelper copy = helper.createCopy();\r\n    assertNotSame(helper.getDocument(), copy.getDocument());\r\n    final String doc1 = documentToString(helper);\r\n    final String doc2 = documentToString(copy);\r\n    assertEquals(doc1, doc2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testCopyElementMapping",
  "sourceCode" : "/**\r\n * Tests the element mapping of a copied document.\r\n */\r\n@Test\r\nvoid testCopyElementMapping() throws Exception {\r\n    checkCopyElementMapping(TEST_FILE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testCopyElementMappingForComplexDocument",
  "sourceCode" : "/**\r\n * Tests whether the element is correctly constructed for a more complex document.\r\n */\r\n@Test\r\nvoid testCopyElementMappingForComplexDocument() throws Exception {\r\n    checkCopyElementMapping(\"test.xml\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testCreateDocumentBuilderFromFactoryException",
  "sourceCode" : "/**\r\n * Tests whether an exception thrown by a document builder factory is handled correctly.\r\n */\r\n@Test\r\nvoid testCreateDocumentBuilderFromFactoryException() throws ParserConfigurationException {\r\n    final DocumentBuilderFactory factory = mock(DocumentBuilderFactory.class);\r\n    final ParserConfigurationException pcex = new ParserConfigurationException();\r\n    when(factory.newDocumentBuilder()).thenThrow(pcex);\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> XMLDocumentHelper.createDocumentBuilder(factory));\r\n    assertEquals(pcex, cex.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testCreateTransformerFactory",
  "sourceCode" : "/**\r\n * Tests whether a correct transformer factory can be created.\r\n */\r\n@Test\r\nvoid testCreateTransformerFactory() {\r\n    assertNotNull(XMLDocumentHelper.createTransformerFactory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testCreateTransformerFactoryException",
  "sourceCode" : "/**\r\n * Tests whether exceptions while creating transformers are correctly handled.\r\n */\r\n@Test\r\nvoid testCreateTransformerFactoryException() throws TransformerConfigurationException {\r\n    final TransformerFactory factory = mock(TransformerFactory.class);\r\n    final TransformerConfigurationException cause = new TransformerConfigurationException();\r\n    when(factory.newTransformer()).thenThrow(cause);\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> XMLDocumentHelper.createTransformer(factory));\r\n    assertEquals(cause, cex.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testElementMappingForNewDocument",
  "sourceCode" : "/**\r\n * Tests the content of the element mapping for a newly created document.\r\n */\r\n@Test\r\nvoid testElementMappingForNewDocument() throws ConfigurationException {\r\n    final XMLDocumentHelper helper = XMLDocumentHelper.forNewDocument(ELEMENT);\r\n    assertTrue(helper.getElementMapping().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testElementMappingForSourceDocument",
  "sourceCode" : "/**\r\n * Tests the content of the element mapping for a source document.\r\n */\r\n@Test\r\nvoid testElementMappingForSourceDocument() throws Exception {\r\n    final Document doc = loadDocument();\r\n    final XMLDocumentHelper helper = XMLDocumentHelper.forSourceDocument(doc);\r\n    assertTrue(helper.getElementMapping().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testInitForNewDocument",
  "sourceCode" : "/**\r\n * Tests whether an instance can be created wrapping a new document.\r\n */\r\n@Test\r\nvoid testInitForNewDocument() throws ConfigurationException {\r\n    final XMLDocumentHelper helper = XMLDocumentHelper.forNewDocument(ELEMENT);\r\n    final Document doc = helper.getDocument();\r\n    final Element rootElement = doc.getDocumentElement();\r\n    assertEquals(ELEMENT, rootElement.getNodeName());\r\n    final NodeList childNodes = rootElement.getChildNodes();\r\n    assertEquals(0, childNodes.getLength());\r\n    assertNull(helper.getSourcePublicID());\r\n    assertNull(helper.getSourceSystemID());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testInitForSourceDocument",
  "sourceCode" : "/**\r\n * Tests whether an instance can be created based on a source document.\r\n */\r\n@Test\r\nvoid testInitForSourceDocument() throws Exception {\r\n    final Document doc = loadDocument();\r\n    final XMLDocumentHelper helper = XMLDocumentHelper.forSourceDocument(doc);\r\n    assertNotSame(doc, helper.getDocument());\r\n    assertEquals(documentToString(doc), documentToString(helper));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLDocumentHelper.java",
  "methodName" : "testTransformException",
  "sourceCode" : "/**\r\n * Tests whether transform() handles a TransformerException.\r\n */\r\n@Test\r\nvoid testTransformException() throws TransformerException {\r\n    final Transformer transformer = mock(Transformer.class);\r\n    final Source src = mock(Source.class);\r\n    final Result res = mock(Result.class);\r\n    final TransformerException tex = new TransformerException(\"Test Exception\");\r\n    doThrow(tex).when(transformer).transform(src, res);\r\n    final ConfigurationException cex = assertThrows(ConfigurationException.class, () -> XMLDocumentHelper.transform(transformer, src, res));\r\n    assertEquals(tex, cex.getCause());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLListHandling.java",
  "methodName" : "testAddListItem",
  "sourceCode" : "/**\r\n * Tests that a list item can be added without affecting the format.\r\n */\r\n@Test\r\nvoid testAddListItem() throws ConfigurationException {\r\n    config.addProperty(KEY_VALUES, \"d\");\r\n    config.addProperty(KEY_SPLIT, \"3\");\r\n    final String xml = saveToString();\r\n    checkSplit(xml, ELEM_SPLIT, \"1\", \"2\", \"3\");\r\n    checkCommaSeparated(xml, KEY_VALUES, \"a\", \"b\", \"c\", \"d\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLListHandling.java",
  "methodName" : "testIncompatibleListDelimiterOnSaving",
  "sourceCode" : "/**\r\n * Tries to save the configuration with a different list delimiter handler which does not support escaping of lists.\r\n * This should fail with a meaningful exception message.\r\n */\r\n@Test\r\nvoid testIncompatibleListDelimiterOnSaving() {\r\n    config.setListDelimiterHandler(DisabledListDelimiterHandler.INSTANCE);\r\n    assertThrows(ConfigurationRuntimeException.class, this::saveToString);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLListHandling.java",
  "methodName" : "testMixedList",
  "sourceCode" : "/**\r\n * Tests whether a list consisting of multiple elements where some elements define multiple values is handled correctly.\r\n */\r\n@Test\r\nvoid testMixedList() throws ConfigurationException {\r\n    final List<String> expected = Arrays.asList(\"foo\", \"blah\", \"bar\", \"baz\");\r\n    assertEquals(expected, config.getList(\"mixed.values\"));\r\n    final String xml = saveToString();\r\n    final XMLConfiguration c2 = readFromString(xml);\r\n    assertEquals(expected, c2.getList(\"mixed.values\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLListHandling.java",
  "methodName" : "testRemoveListItem",
  "sourceCode" : "/**\r\n * Tests that a list item can be removed without affecting the format.\r\n */\r\n@Test\r\nvoid testRemoveListItem() throws ConfigurationException {\r\n    config.clearProperty(KEY_VALUES + \"(2)\");\r\n    config.clearProperty(KEY_SPLIT + \"(1)\");\r\n    final String xml = saveToString();\r\n    checkSplit(xml, ELEM_SPLIT, \"1\");\r\n    checkCommaSeparated(xml, KEY_VALUES, \"a\", \"b\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLListHandling.java",
  "methodName" : "testSaveNoChanges",
  "sourceCode" : "/**\r\n * Tests that the list format is kept if properties are not touched,\r\n */\r\n@Test\r\nvoid testSaveNoChanges() throws ConfigurationException {\r\n    final String xml = saveToString();\r\n    checkSplit(xml, ELEM_SPLIT, \"1\", \"2\");\r\n    checkCommaSeparated(xml, KEY_VALUES, \"a\", \"b\", \"c\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLPropertiesConfiguration.java",
  "methodName" : "testDOMLoad",
  "sourceCode" : "@Test\r\nvoid testDOMLoad() throws Exception {\r\n    // Edge case\r\n    assertThrows(NullPointerException.class, () -> new XMLPropertiesConfiguration(null));\r\n    // Normal case\r\n    final URL location = ConfigurationAssert.getTestURL(TEST_PROPERTIES_FILE);\r\n    final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\r\n    final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\r\n    dBuilder.setEntityResolver((publicId, systemId) -> new InputSource(getClass().getClassLoader().getResourceAsStream(\"properties.dtd\")));\r\n    final File file = new File(location.toURI());\r\n    final Document doc = dBuilder.parse(file);\r\n    final XMLPropertiesConfiguration conf = new XMLPropertiesConfiguration(doc.getDocumentElement());\r\n    assertEquals(\"Description of the property list\", conf.getHeader());\r\n    assertFalse(conf.isEmpty());\r\n    assertEquals(\"value1\", conf.getProperty(\"key1\"));\r\n    assertEquals(\"value2\", conf.getProperty(\"key2\"));\r\n    assertEquals(\"value3\", conf.getProperty(\"key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLPropertiesConfiguration.java",
  "methodName" : "testDOMSave",
  "sourceCode" : "@Test\r\nvoid testDOMSave() throws Exception {\r\n    // load the configuration\r\n    final XMLPropertiesConfiguration conf = load(TEST_PROPERTIES_FILE);\r\n    // update the configuration\r\n    conf.addProperty(\"key4\", \"value4\");\r\n    conf.clearProperty(\"key2\");\r\n    conf.setHeader(\"Description of the new property list\");\r\n    // save the configuration\r\n    final File saveFile = newFile(\"test2.properties.xml\", tempFolder);\r\n    // save as DOM into saveFile\r\n    final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\r\n    final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\r\n    final Document document = dBuilder.newDocument();\r\n    conf.save(document, document);\r\n    final TransformerFactory tFactory = TransformerFactory.newInstance();\r\n    final Transformer transformer = tFactory.newTransformer();\r\n    final DOMSource source = new DOMSource(document);\r\n    final Result result = new StreamResult(saveFile);\r\n    transformer.transform(source, result);\r\n    // reload the configuration\r\n    final XMLPropertiesConfiguration conf2 = load(saveFile.getAbsolutePath());\r\n    // test the configuration\r\n    assertEquals(\"Description of the new property list\", conf2.getHeader());\r\n    assertFalse(conf2.isEmpty());\r\n    assertEquals(\"value1\", conf2.getProperty(\"key1\"));\r\n    assertEquals(\"value3\", conf2.getProperty(\"key3\"));\r\n    assertEquals(\"value4\", conf2.getProperty(\"key4\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLPropertiesConfiguration.java",
  "methodName" : "testLoad",
  "sourceCode" : "@Test\r\nvoid testLoad() throws Exception {\r\n    final XMLPropertiesConfiguration conf = load(TEST_PROPERTIES_FILE);\r\n    assertEquals(\"Description of the property list\", conf.getHeader());\r\n    assertFalse(conf.isEmpty());\r\n    assertEquals(\"value1\", conf.getProperty(\"key1\"));\r\n    assertEquals(\"value2\", conf.getProperty(\"key2\"));\r\n    assertEquals(\"value3\", conf.getProperty(\"key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestXMLPropertiesConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "@Test\r\nvoid testSave() throws Exception {\r\n    // load the configuration\r\n    final XMLPropertiesConfiguration conf = load(TEST_PROPERTIES_FILE);\r\n    // update the configuration\r\n    conf.addProperty(\"key4\", \"value4\");\r\n    conf.clearProperty(\"key2\");\r\n    conf.setHeader(\"Description of the new property list\");\r\n    // save the configuration\r\n    final File saveFile = newFile(\"test2.properties.xml\", tempFolder);\r\n    final FileHandler saveHandler = new FileHandler(conf);\r\n    saveHandler.save(saveFile);\r\n    // reload the configuration\r\n    final XMLPropertiesConfiguration conf2 = load(saveFile.getAbsolutePath());\r\n    // test the configuration\r\n    assertEquals(\"Description of the new property list\", conf2.getHeader());\r\n    assertFalse(conf2.isEmpty());\r\n    assertEquals(\"value1\", conf2.getProperty(\"key1\"));\r\n    assertEquals(\"value3\", conf2.getProperty(\"key3\"));\r\n    assertEquals(\"value4\", conf2.getProperty(\"key4\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testCopyConstructor",
  "sourceCode" : "@Test\r\nvoid testCopyConstructor() {\r\n    final BaseHierarchicalConfiguration c = new BaseHierarchicalConfiguration();\r\n    c.addProperty(\"foo\", \"bar\");\r\n    yamlConfiguration = new YAMLConfiguration(c);\r\n    assertEquals(\"bar\", yamlConfiguration.getString(\"foo\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testDoubleStringValues",
  "sourceCode" : "@Test\r\nvoid testDoubleStringValues() {\r\n    final Object property = yamlConfiguration.getProperty(\"key5.example\");\r\n    assertEquals(Arrays.asList(\"\", \"\", \"value\"), property);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testGetPropertyDictionary",
  "sourceCode" : "@Test\r\nvoid testGetPropertyDictionary() {\r\n    assertEquals(\"Martin D'vloper\", yamlConfiguration.getProperty(\"martin.name\"));\r\n    assertEquals(\"Developer\", yamlConfiguration.getProperty(\"martin.job\"));\r\n    assertEquals(\"Elite\", yamlConfiguration.getProperty(\"martin.skill\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testGetPropertyInteger",
  "sourceCode" : "@Test\r\nvoid testGetPropertyInteger() {\r\n    final Object property = yamlConfiguration.getProperty(\"int1\");\r\n    assertInstanceOf(Integer.class, property);\r\n    assertEquals(37, property);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testGetPropertyNested",
  "sourceCode" : "@Test\r\nvoid testGetPropertyNested() {\r\n    assertEquals(\"value23\", yamlConfiguration.getProperty(\"key2.key3\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testGetPropertyNestedWithList",
  "sourceCode" : "@Test\r\nvoid testGetPropertyNestedWithList() {\r\n    assertEquals(Arrays.asList(\"col1\", \"col2\"), yamlConfiguration.getProperty(\"key4.key5\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testGetPropertySimple",
  "sourceCode" : "@Test\r\nvoid testGetPropertySimple() {\r\n    assertEquals(\"value1\", yamlConfiguration.getProperty(\"key1\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testGetPropertySubset",
  "sourceCode" : "@Test\r\nvoid testGetPropertySubset() {\r\n    final Configuration subset = yamlConfiguration.subset(\"key4\");\r\n    assertEquals(Arrays.asList(\"col1\", \"col2\"), subset.getProperty(\"key5\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testGetPropertyVeryNestedProperties",
  "sourceCode" : "@Test\r\nvoid testGetPropertyVeryNestedProperties() {\r\n    final Object property = yamlConfiguration.getProperty(\"very.nested.properties\");\r\n    assertEquals(Arrays.asList(\"nested1\", \"nested2\", \"nested3\"), property);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testObjectCreationFromReader",
  "sourceCode" : "@Test\r\nvoid testObjectCreationFromReader() {\r\n    final File createdFile = new File(tempFolder, \"data.txt\");\r\n    final String yaml = \"!!java.io.FileOutputStream [\" + createdFile.getAbsolutePath() + \"]\";\r\n    final StringReader reader = new StringReader(yaml);\r\n    assertThrows(ConfigurationException.class, () -> yamlConfiguration.read(reader));\r\n    assertFalse(createdFile.exists());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testObjectCreationFromStream",
  "sourceCode" : "@Test\r\nvoid testObjectCreationFromStream() {\r\n    final File createdFile = new File(tempFolder, \"data.txt\");\r\n    final String yaml = \"!!java.io.FileOutputStream [\" + createdFile.getAbsolutePath() + \"]\";\r\n    final ByteArrayInputStream inputStream = new ByteArrayInputStream(yaml.getBytes(StandardCharsets.UTF_8));\r\n    assertThrows(ConfigurationException.class, () -> yamlConfiguration.read(inputStream));\r\n    assertFalse(createdFile.exists());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\TestYAMLConfiguration.java",
  "methodName" : "testSave",
  "sourceCode" : "@Test\r\nvoid testSave() throws IOException, ConfigurationException {\r\n    // save the YAMLConfiguration as a String...\r\n    final StringWriter sw = new StringWriter();\r\n    yamlConfiguration.write(sw);\r\n    final String output = sw.toString();\r\n    // ..and then try parsing it back as using SnakeYAML\r\n    final Map<?, ?> parsed = new Yaml().loadAs(output, Map.class);\r\n    assertEquals(7, parsed.entrySet().size());\r\n    assertEquals(\"value1\", parsed.get(\"key1\"));\r\n    final Map<?, ?> key2 = (Map<?, ?>) parsed.get(\"key2\");\r\n    assertEquals(\"value23\", key2.get(\"key3\"));\r\n    final List<?> key5 = (List<?>) ((Map<?, ?>) parsed.get(\"key4\")).get(\"key5\");\r\n    assertEquals(Arrays.asList(\"col1\", \"col2\"), key5);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractCombinerTest.java",
  "methodName" : "testInit",
  "sourceCode" : "/**\r\n * Tests a newly created combiner.\r\n */\r\n@Test\r\nvoid testInit() {\r\n    assertTrue(combiner.getListNodes().isEmpty());\r\n    assertFalse(combiner.isListNode(NodeStructureHelper.createNode(\"test\", null)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testGetParentForRoot",
  "sourceCode" : "/**\r\n * Tests whether the correct parent for the root node is returned.\r\n */\r\n@Test\r\nvoid testGetParentForRoot() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    assertNull(handler.getParent(ROOT_AUTHORS_TREE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testGetParentInvalidNode",
  "sourceCode" : "/**\r\n * Tries to query the parent node for a node which does not belong to the managed tree.\r\n */\r\n@Test\r\nvoid testGetParentInvalidNode() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode node = new ImmutableNode.Builder().name(\"unknown\").create();\r\n    assertThrows(IllegalArgumentException.class, () -> handler.getParent(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testGetParentNode",
  "sourceCode" : "/**\r\n * Tests whether the correct parent nodes are returned. All nodes in the tree are checked.\r\n */\r\n@Test\r\nvoid testGetParentNode() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    for (int authorIdx = 0; authorIdx < NodeStructureHelper.authorsLength(); authorIdx++) {\r\n        final ImmutableNode authorNode = nodeForKey(handler.getRootNode(), NodeStructureHelper.author(authorIdx));\r\n        assertSame(handler.getRootNode(), handler.getParent(authorNode), \"Wrong parent for \" + NodeStructureHelper.author(authorIdx));\r\n        for (int workIdx = 0; workIdx < NodeStructureHelper.worksLength(authorIdx); workIdx++) {\r\n            final String workKey = NodeStructureHelper.appendPath(NodeStructureHelper.author(authorIdx), NodeStructureHelper.work(authorIdx, workIdx));\r\n            final ImmutableNode workNode = nodeForKey(handler.getRootNode(), workKey);\r\n            assertSame(authorNode, handler.getParent(workNode), \"Wrong parent for \" + workKey);\r\n            for (int personaIdx = 0; personaIdx < NodeStructureHelper.personaeLength(authorIdx, workIdx); personaIdx++) {\r\n                final String personKey = NodeStructureHelper.appendPath(workKey, NodeStructureHelper.persona(authorIdx, workIdx, personaIdx));\r\n                final ImmutableNode personNode = nodeForKey(handler.getRootNode(), personKey);\r\n                assertSame(workNode, handler.getParent(personNode), \"Wrong parent for \" + personKey);\r\n            }\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetAttributes",
  "sourceCode" : "/**\r\n * Tests whether a node's attributes can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetAttributes() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final ImmutableNode node = nodeForKey(handler, \"Puck\");\r\n    assertEquals(node.getAttributes().keySet(), handler.getAttributes(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetAttributesImmutable",
  "sourceCode" : "/**\r\n * Tests that the keys of attributes cannot be modified.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetAttributesImmutable() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final ImmutableNode node = nodeForKey(handler, \"Puck\");\r\n    final Set<String> attributes = handler.getAttributes(node);\r\n    assertThrows(UnsupportedOperationException.class, () -> attributes.add(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetAttributeValue",
  "sourceCode" : "/**\r\n * Tests whether the value of an attribute can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetAttributeValue() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final ImmutableNode node = nodeForKey(handler, \"Prospero\");\r\n    assertEquals(\"Shakespeare\", handler.getAttributeValue(node, NodeStructureHelper.ATTR_AUTHOR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetChildAtIndex",
  "sourceCode" : "/**\r\n * Tests whether a child at a given index can be accessed.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetChildAtIndex() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode node = nodeForKey(handler, NodeStructureHelper.author(0));\r\n    assertSame(node.getChildren().get(1), handler.getChild(node, 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetChildren",
  "sourceCode" : "/**\r\n * Tests whether the children of a node can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetChildren() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode node = nodeForKey(handler, NodeStructureHelper.author(0));\r\n    assertSame(node.getChildren(), handler.getChildren(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetChildrenByName",
  "sourceCode" : "/**\r\n * Tests whether all children of a specific name can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetChildrenByName() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final String name = \"Achilles\";\r\n    final Set<ImmutableNode> children = new HashSet<>(handler.getChildren(ROOT_PERSONAE_TREE, name));\r\n    assertEquals(3, children.size());\r\n    for (final ImmutableNode c : children) {\r\n        assertEquals(name, c.getNodeName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetChildrenByNameImmutable",
  "sourceCode" : "/**\r\n * Tests whether the collection of children cannot be modified.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetChildrenByNameImmutable() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final List<ImmutableNode> children = handler.getChildren(ROOT_PERSONAE_TREE, \"Ajax\");\r\n    assertThrows(UnsupportedOperationException.class, () -> children.add(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetChildrenCountAll",
  "sourceCode" : "/**\r\n * Tests whether the number of all children can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetChildrenCountAll() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode node = nodeForKey(handler, NodeStructureHelper.author(0));\r\n    assertEquals(NodeStructureHelper.worksLength(0), handler.getChildrenCount(node, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetChildrenCountSpecific",
  "sourceCode" : "/**\r\n * Tests whether the number of all children with a given name can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetChildrenCountSpecific() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    assertEquals(3, handler.getChildrenCount(ROOT_PERSONAE_TREE, \"Achilles\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetMatchingChildren",
  "sourceCode" : "/**\r\n * Tests a filter operation on child nodes.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetMatchingChildren() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode target = NodeStructureHelper.nodeForKey(ROOT_AUTHORS_TREE, NodeStructureHelper.author(1));\r\n    final Set<String> encounteredAuthors = new HashSet<>();\r\n    final NodeMatcher<ImmutableNode> matcher = new NodeMatcher<ImmutableNode>() {\r\n\r\n        @Override\r\n        public <T> boolean matches(final T node, final NodeHandler<T> paramHandler, final ImmutableNode criterion) {\r\n            encounteredAuthors.add(paramHandler.nodeName(node));\r\n            return node == target;\r\n        }\r\n    };\r\n    final List<ImmutableNode> result = handler.getMatchingChildren(handler.getRootNode(), matcher, target);\r\n    assertEquals(1, result.size());\r\n    assertSame(target, result.get(0));\r\n    final Set<String> expectedAuthors = new HashSet<>();\r\n    for (int i = 0; i < NodeStructureHelper.authorsLength(); i++) {\r\n        expectedAuthors.add(NodeStructureHelper.author(i));\r\n    }\r\n    assertEquals(expectedAuthors, encounteredAuthors);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetMatchingChildrenCount",
  "sourceCode" : "/**\r\n * Tests whether filtered nodes can be counted.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetMatchingChildrenCount() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    assertEquals(NodeStructureHelper.authorsLength(), handler.getMatchingChildrenCount(handler.getRootNode(), new DummyNodeMatcher(), this));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerGetMatchingChildrenImmutable",
  "sourceCode" : "/**\r\n * Tests that the list returned by getMatchingChildren() cannot be modified.\r\n */\r\n@Test\r\nvoid testNodeHandlerGetMatchingChildrenImmutable() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final List<ImmutableNode> result = handler.getMatchingChildren(handler.getRootNode(), new DummyNodeMatcher(), this);\r\n    assertThrows(UnsupportedOperationException.class, result::clear);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerHasAttributesFalse",
  "sourceCode" : "/**\r\n * Tests a negative check whether a node has attributes.\r\n */\r\n@Test\r\nvoid testNodeHandlerHasAttributesFalse() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    assertFalse(handler.hasAttributes(ROOT_PERSONAE_TREE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerHasAttributesTrue",
  "sourceCode" : "/**\r\n * Tests a positive check whether a node has attributes.\r\n */\r\n@Test\r\nvoid testNodeHandlerHasAttributesTrue() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final ImmutableNode node = nodeForKey(handler, \"Puck\");\r\n    assertTrue(handler.hasAttributes(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerIndexOfChild",
  "sourceCode" : "/**\r\n * Tests whether the index of a given child can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerIndexOfChild() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final String key = \"Simmons/Hyperion\";\r\n    final ImmutableNode parent = nodeForKey(handler, key);\r\n    final ImmutableNode child = nodeForKey(handler, key + \"/Weintraub\");\r\n    assertEquals(3, handler.indexOfChild(parent, child));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerIndexOfUnknownChild",
  "sourceCode" : "/**\r\n * Tests the indexOfChild() method for an unknown child node.\r\n */\r\n@Test\r\nvoid testNodeHandlerIndexOfUnknownChild() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode parent = nodeForKey(handler, \"Homer/Ilias\");\r\n    final ImmutableNode child = nodeForKey(handler, \"Shakespeare/Troilus and Cressida/Achilles\");\r\n    assertEquals(-1, handler.indexOfChild(parent, child));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerIsDefinedAttributes",
  "sourceCode" : "/**\r\n * Tests whether a node with attributes is defined.\r\n */\r\n@Test\r\nvoid testNodeHandlerIsDefinedAttributes() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final ImmutableNode node = new ImmutableNode.Builder().addAttribute(NodeStructureHelper.ATTR_AUTHOR, NodeStructureHelper.author(0)).create();\r\n    assertTrue(handler.isDefined(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerIsDefinedChildren",
  "sourceCode" : "/**\r\n * Tests whether a node with children is defined.\r\n */\r\n@Test\r\nvoid testNodeHandlerIsDefinedChildren() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode node = nodeForKey(handler, NodeStructureHelper.author(2));\r\n    assertTrue(handler.isDefined(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerIsDefinedFalse",
  "sourceCode" : "/**\r\n * Tests whether an undefined node is correctly detected.\r\n */\r\n@Test\r\nvoid testNodeHandlerIsDefinedFalse() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final ImmutableNode node = new ImmutableNode.Builder().name(NodeStructureHelper.author(1)).create();\r\n    assertFalse(handler.isDefined(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerIsDefinedValue",
  "sourceCode" : "/**\r\n * Tests whether a node with a value is defined.\r\n */\r\n@Test\r\nvoid testNodeHandlerIsDefinedValue() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_PERSONAE_TREE);\r\n    final ImmutableNode node = new ImmutableNode.Builder().value(42).create();\r\n    assertTrue(handler.isDefined(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerName",
  "sourceCode" : "/**\r\n * Tests whether the name of a node can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerName() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode author = nodeForKey(handler, NodeStructureHelper.author(0));\r\n    assertEquals(NodeStructureHelper.author(0), handler.nodeName(author));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\AbstractImmutableNodeHandlerTest.java",
  "methodName" : "testNodeHandlerValue",
  "sourceCode" : "/**\r\n * Tests whether the value of a node can be queried.\r\n */\r\n@Test\r\nvoid testNodeHandlerValue() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler(ROOT_AUTHORS_TREE);\r\n    ImmutableNode work = nodeForKey(handler, \"Shakespeare/The Tempest\");\r\n    final int year = 1611;\r\n    work = work.setValue(year);\r\n    assertEquals(year, handler.getValue(work));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppend",
  "sourceCode" : "/**\r\n * Tests appending keys.\r\n */\r\n@Test\r\nvoid testAppend() {\r\n    key.append(\"tables\").append(\"table(0).\");\r\n    key.append(\"fields.\").append(\"field(1)\");\r\n    key.append(null).append(TESTATTR);\r\n    assertEquals(TESTKEY, key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppendAttribute",
  "sourceCode" : "/**\r\n * Tests appending attribute keys.\r\n */\r\n@Test\r\nvoid testAppendAttribute() {\r\n    key.appendAttribute(\"dataType\");\r\n    assertEquals(TESTATTR, key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppendComplexKey",
  "sourceCode" : "/**\r\n * Tests constructing a complex key by chaining multiple append operations.\r\n */\r\n@Test\r\nvoid testAppendComplexKey() {\r\n    key.append(\"tables\").append(\"table.\").appendIndex(0);\r\n    key.append(\"fields.\").append(\"field\").appendIndex(1);\r\n    key.appendAttribute(\"dataType\");\r\n    assertEquals(TESTKEY, key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppendDecoratedAttributeKey",
  "sourceCode" : "/**\r\n * Tests appending an attribute key that is already decorated-\r\n */\r\n@Test\r\nvoid testAppendDecoratedAttributeKey() {\r\n    key.appendAttribute(TESTATTR);\r\n    assertEquals(TESTATTR, key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppendDelimiters",
  "sourceCode" : "/**\r\n * Tests appending keys that contain delimiters.\r\n */\r\n@Test\r\nvoid testAppendDelimiters() {\r\n    key.append(\"key..\").append(\"test\").append(\".\");\r\n    key.append(\".more\").append(\"..tests\");\r\n    assertEquals(\"key...test.more...tests\", key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppendDelimitersWithoutEscaping",
  "sourceCode" : "/**\r\n * Tests appending keys that contain delimiters when no escaped delimiter is defined.\r\n */\r\n@Test\r\nvoid testAppendDelimitersWithoutEscaping() {\r\n    expressionEngine = new DefaultExpressionEngine(symbols().setEscapedDelimiter(null).create());\r\n    key = new DefaultConfigurationKey(expressionEngine);\r\n    key.append(\"key.......\").append(\"test\").append(\".\");\r\n    key.append(\".more\").append(\"..tests\");\r\n    assertEquals(\"key.test.more.tests\", key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppendIndex",
  "sourceCode" : "/**\r\n * Tests appending an index to a key.\r\n */\r\n@Test\r\nvoid testAppendIndex() {\r\n    key.append(\"test\").appendIndex(42);\r\n    assertEquals(\"test(42)\", key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppendNullAttributeKey",
  "sourceCode" : "/**\r\n * Tests appending a null attribute key.\r\n */\r\n@Test\r\nvoid testAppendNullAttributeKey() {\r\n    key.appendAttribute(null);\r\n    assertEquals(\"\", key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAppendWithEscapeFlag",
  "sourceCode" : "/**\r\n * Tests calling append with the escape flag.\r\n */\r\n@Test\r\nvoid testAppendWithEscapeFlag() {\r\n    key.append(\".key.test.\", true);\r\n    key.append(\".more\").append(\".tests\", true);\r\n    assertEquals(\"..key..test...more...tests\", key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAttributeKeyWithIndex",
  "sourceCode" : "/**\r\n * Tests iterating over an attribute key that has an index.\r\n */\r\n@Test\r\nvoid testAttributeKeyWithIndex() {\r\n    key.append(TESTATTR);\r\n    key.appendIndex(0);\r\n    assertEquals(TESTATTR + \"(0)\", key.toString());\r\n    final DefaultConfigurationKey.KeyIterator it = key.iterator();\r\n    assertTrue(it.hasNext());\r\n    it.next();\r\n    assertTrue(it.hasIndex());\r\n    assertEquals(0, it.getIndex());\r\n    assertTrue(it.isAttribute());\r\n    assertEquals(\"dataType\", it.currentKey(false));\r\n    assertEquals(TESTATTR, it.currentKey(true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testAttributeName",
  "sourceCode" : "/**\r\n * Tests determining an attribute key's name.\r\n */\r\n@Test\r\nvoid testAttributeName() {\r\n    assertEquals(\"test\", key.attributeName(\"test\"));\r\n    assertEquals(\"dataType\", key.attributeName(TESTATTR));\r\n    assertNull(key.attributeName(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testCommonKey",
  "sourceCode" : "/**\r\n * Tests whether common key parts can be extracted.\r\n */\r\n@Test\r\nvoid testCommonKey() {\r\n    final DefaultConfigurationKey k1 = key(TESTKEY);\r\n    DefaultConfigurationKey k2 = key(\"tables.table(0).name\");\r\n    DefaultConfigurationKey kc = k1.commonKey(k2);\r\n    assertEquals(key(\"tables.table(0)\"), kc);\r\n    assertEquals(kc, k2.commonKey(k1));\r\n    k2 = key(\"tables.table(1).fields.field(1)\");\r\n    kc = k1.commonKey(k2);\r\n    assertEquals(key(\"tables\"), kc);\r\n    k2 = key(\"completely.different.key\");\r\n    kc = k1.commonKey(k2);\r\n    assertEquals(0, kc.length());\r\n    kc = k1.commonKey(key);\r\n    assertEquals(0, kc.length());\r\n    kc = k1.commonKey(k1);\r\n    assertEquals(kc, k1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testCommonKeyNull",
  "sourceCode" : "/**\r\n * Tries to call commonKey() with null input.\r\n */\r\n@Test\r\nvoid testCommonKeyNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> key.commonKey(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testConstructAttributeKey",
  "sourceCode" : "/**\r\n * Tests constructing keys for attributes.\r\n */\r\n@Test\r\nvoid testConstructAttributeKey() {\r\n    assertEquals(TESTATTR, key.constructAttributeKey(\"dataType\"));\r\n    assertEquals(TESTATTR, key.constructAttributeKey(TESTATTR));\r\n    assertEquals(\"\", key.constructAttributeKey(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testConstructAttributeKeyWithoutEndMarkers",
  "sourceCode" : "/**\r\n * Tests constructing attribute keys when no end markers are defined. In this test case we use the property delimiter as\r\n * attribute prefix.\r\n */\r\n@Test\r\nvoid testConstructAttributeKeyWithoutEndMarkers() {\r\n    final DefaultExpressionEngineSymbols symbols = symbols().setAttributeEnd(null).setAttributeStart(expressionEngine.getSymbols().getPropertyDelimiter()).create();\r\n    expressionEngine = new DefaultExpressionEngine(symbols);\r\n    key = new DefaultConfigurationKey(expressionEngine);\r\n    assertEquals(\".test\", key.constructAttributeKey(\"test\"));\r\n    assertEquals(\".test\", key.constructAttributeKey(\".test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testDifferenceKey",
  "sourceCode" : "/**\r\n * Tests the differenceKey() method.\r\n */\r\n@Test\r\nvoid testDifferenceKey() {\r\n    final DefaultConfigurationKey k1 = key(TESTKEY);\r\n    DefaultConfigurationKey k2 = key(\"tables.table(0).name\");\r\n    DefaultConfigurationKey kd = k1.differenceKey(k2);\r\n    assertEquals(\"name\", kd.toString());\r\n    k2 = key(\"tables.table(1).fields.field(1)\");\r\n    kd = k1.differenceKey(k2);\r\n    assertEquals(\"table(1).fields.field(1)\", kd.toString());\r\n    k2 = key(\"completely.different.key\");\r\n    kd = k1.differenceKey(k2);\r\n    assertEquals(k2, kd);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testDifferenceKeySame",
  "sourceCode" : "/**\r\n * Tests differenceKey() on the same object.\r\n */\r\n@Test\r\nvoid testDifferenceKeySame() {\r\n    final DefaultConfigurationKey k1 = key(TESTKEY);\r\n    final DefaultConfigurationKey kd = k1.differenceKey(k1);\r\n    assertEquals(0, kd.length());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testEquals",
  "sourceCode" : "/**\r\n * Tests comparing configuration keys.\r\n */\r\n@Test\r\nvoid testEquals() {\r\n    final DefaultConfigurationKey k1 = key(TESTKEY);\r\n    assertEquals(k1, k1);\r\n    final DefaultConfigurationKey k2 = key(TESTKEY);\r\n    assertEquals(k1, k2);\r\n    assertEquals(k2, k1);\r\n    assertEquals(k1.hashCode(), k2.hashCode());\r\n    k2.append(\"anotherPart\");\r\n    assertNotEquals(k1, k2);\r\n    assertNotEquals(k2, k1);\r\n    assertNotEquals(null, k1);\r\n    assertNotEquals(TESTKEY, k1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIsAttributeKey",
  "sourceCode" : "/**\r\n * Tests the isAttributeKey() method with several keys.\r\n */\r\n@Test\r\nvoid testIsAttributeKey() {\r\n    assertTrue(key.isAttributeKey(TESTATTR));\r\n    assertFalse(key.isAttributeKey(TESTPROPS));\r\n    assertFalse(key.isAttributeKey(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIsAttributeKeyWithoutEndMarkers",
  "sourceCode" : "/**\r\n * Tests if attribute keys are correctly detected if no end markers are set. (In this test case we use the same\r\n * delimiter for attributes as for simple properties.)\r\n */\r\n@Test\r\nvoid testIsAttributeKeyWithoutEndMarkers() {\r\n    final DefaultExpressionEngineSymbols symbols = symbols().setAttributeEnd(null).setAttributeStart(DefaultExpressionEngineSymbols.DEFAULT_PROPERTY_DELIMITER).create();\r\n    expressionEngine = new DefaultExpressionEngine(symbols);\r\n    key = new DefaultConfigurationKey(expressionEngine);\r\n    assertTrue(key.isAttributeKey(DefaultExpressionEngineSymbols.DEFAULT_PROPERTY_DELIMITER + \"test\"));\r\n    assertFalse(key.isAttributeKey(TESTATTR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIterate",
  "sourceCode" : "/**\r\n * Tests to iterate over a simple key.\r\n */\r\n@Test\r\nvoid testIterate() {\r\n    key.append(TESTKEY);\r\n    final DefaultConfigurationKey.KeyIterator it = key.iterator();\r\n    assertTrue(it.hasNext());\r\n    assertEquals(\"tables\", it.nextKey());\r\n    assertEquals(\"table\", it.nextKey());\r\n    assertTrue(it.hasIndex());\r\n    assertEquals(0, it.getIndex());\r\n    assertEquals(\"fields\", it.nextKey());\r\n    assertFalse(it.hasIndex());\r\n    assertEquals(\"field\", it.nextKey(true));\r\n    assertEquals(1, it.getIndex());\r\n    assertFalse(it.isAttribute());\r\n    assertEquals(\"field\", it.currentKey(true));\r\n    assertEquals(\"dataType\", it.nextKey());\r\n    assertEquals(\"[@dataType]\", it.currentKey(true));\r\n    assertTrue(it.isAttribute());\r\n    assertFalse(it.hasNext());\r\n    assertThrows(NoSuchElementException.class, it::next);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIterateAlternativeEscapeDelimiter",
  "sourceCode" : "/**\r\n * Tests iterating over keys when a different escaped delimiter is used.\r\n */\r\n@Test\r\nvoid testIterateAlternativeEscapeDelimiter() {\r\n    expressionEngine = new DefaultExpressionEngine(symbols().setEscapedDelimiter(\"\\\\.\").create());\r\n    key = new DefaultConfigurationKey(expressionEngine);\r\n    key.append(\"\\\\.my\\\\.elem\");\r\n    key.append(\"trailing\\\\.dot\\\\.\");\r\n    key.append(\".strange\");\r\n    assertEquals(\"\\\\.my\\\\.elem.trailing\\\\.dot\\\\..strange\", key.toString());\r\n    final DefaultConfigurationKey.KeyIterator kit = key.iterator();\r\n    assertEquals(\".my.elem\", kit.nextKey());\r\n    assertEquals(\"trailing.dot.\", kit.nextKey());\r\n    assertEquals(\"strange\", kit.nextKey());\r\n    assertFalse(kit.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIterateAttributeEqualsPropertyDelimiter",
  "sourceCode" : "/**\r\n * Tests iteration when the attribute markers equals the property delimiter.\r\n */\r\n@Test\r\nvoid testIterateAttributeEqualsPropertyDelimiter() {\r\n    expressionEngine = new DefaultExpressionEngine(symbols().setAttributeEnd(null).setAttributeStart(DefaultExpressionEngineSymbols.DEFAULT_PROPERTY_DELIMITER).create());\r\n    key = new DefaultConfigurationKey(expressionEngine);\r\n    key.append(\"this.isa.key\");\r\n    final DefaultConfigurationKey.KeyIterator kit = key.iterator();\r\n    assertEquals(\"this\", kit.next());\r\n    assertFalse(kit.isAttribute());\r\n    assertTrue(kit.isPropertyKey());\r\n    assertEquals(\"isa\", kit.next());\r\n    assertFalse(kit.isAttribute());\r\n    assertTrue(kit.isPropertyKey());\r\n    assertEquals(\"key\", kit.next());\r\n    assertTrue(kit.isAttribute());\r\n    assertTrue(kit.isPropertyKey());\r\n    assertEquals(\"key\", kit.currentKey(true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIterateEscapedDelimiters",
  "sourceCode" : "/**\r\n * Tests iterating over keys with escaped delimiters.\r\n */\r\n@Test\r\nvoid testIterateEscapedDelimiters() {\r\n    key.append(\"my..elem\");\r\n    key.append(\"trailing..dot..\");\r\n    key.append(\".strange\");\r\n    assertEquals(\"my..elem.trailing..dot...strange\", key.toString());\r\n    final DefaultConfigurationKey.KeyIterator kit = key.iterator();\r\n    assertEquals(\"my.elem\", kit.nextKey());\r\n    assertEquals(\"trailing.dot.\", kit.nextKey());\r\n    assertEquals(\"strange\", kit.nextKey());\r\n    assertFalse(kit.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIterateStrangeKeys",
  "sourceCode" : "/**\r\n * Tests iterating over some funny keys.\r\n */\r\n@Test\r\nvoid testIterateStrangeKeys() {\r\n    key = new DefaultConfigurationKey(expressionEngine, \"key.\");\r\n    DefaultConfigurationKey.KeyIterator it = key.iterator();\r\n    assertTrue(it.hasNext());\r\n    assertEquals(\"key\", it.next());\r\n    assertFalse(it.hasNext());\r\n    key = new DefaultConfigurationKey(expressionEngine, \".\");\r\n    it = key.iterator();\r\n    assertFalse(it.hasNext());\r\n    key = new DefaultConfigurationKey(expressionEngine, \"key().index()undefined(0).test\");\r\n    it = key.iterator();\r\n    assertEquals(\"key()\", it.next());\r\n    assertFalse(it.hasIndex());\r\n    assertEquals(\"index()undefined\", it.nextKey(false));\r\n    assertTrue(it.hasIndex());\r\n    assertEquals(0, it.getIndex());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIterateWithBrackets",
  "sourceCode" : "/**\r\n * Tests whether a key with brackets in it can be iterated over.\r\n */\r\n@Test\r\nvoid testIterateWithBrackets() {\r\n    key.append(\"directory.platform(x86).path\");\r\n    final DefaultConfigurationKey.KeyIterator kit = key.iterator();\r\n    String part = kit.nextKey();\r\n    assertEquals(\"directory\", part);\r\n    assertFalse(kit.hasIndex());\r\n    part = kit.nextKey();\r\n    assertEquals(\"platform(x86)\", part);\r\n    assertFalse(kit.hasIndex());\r\n    part = kit.nextKey();\r\n    assertEquals(\"path\", part);\r\n    assertFalse(kit.hasIndex());\r\n    assertFalse(kit.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIterateWithoutEscapeDelimiter",
  "sourceCode" : "/**\r\n * Tests iterating when no escape delimiter is defined.\r\n */\r\n@Test\r\nvoid testIterateWithoutEscapeDelimiter() {\r\n    expressionEngine = new DefaultExpressionEngine(symbols().setEscapedDelimiter(null).create());\r\n    key = new DefaultConfigurationKey(expressionEngine);\r\n    key.append(\"..my..elem.trailing..dot...strange\");\r\n    assertEquals(\"my..elem.trailing..dot...strange\", key.toString());\r\n    final DefaultConfigurationKey.KeyIterator kit = key.iterator();\r\n    final String[] parts = { \"my\", \"elem\", \"trailing\", \"dot\", \"strange\" };\r\n    for (int i = 0; i < parts.length; i++) {\r\n        assertEquals(parts[i], kit.next(), \"Wrong key part \" + i);\r\n    }\r\n    assertFalse(kit.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testIterateWithRemove",
  "sourceCode" : "/**\r\n * Tests an iteration where the remove() method is called. This is not supported.\r\n */\r\n@Test\r\nvoid testIterateWithRemove() {\r\n    assertFalse(key.iterator().hasNext());\r\n    key.append(\"simple\");\r\n    final DefaultConfigurationKey.KeyIterator it = key.iterator();\r\n    assertTrue(it.hasNext());\r\n    assertEquals(\"simple\", it.next());\r\n    assertThrows(UnsupportedOperationException.class, it::remove);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testLength",
  "sourceCode" : "/**\r\n * Tests getting and setting the key's length.\r\n */\r\n@Test\r\nvoid testLength() {\r\n    key.append(TESTPROPS);\r\n    assertEquals(TESTPROPS.length(), key.length());\r\n    key.appendAttribute(\"dataType\");\r\n    assertEquals(TESTKEY.length(), key.length());\r\n    key.setLength(TESTPROPS.length());\r\n    assertEquals(TESTPROPS.length(), key.length());\r\n    assertEquals(TESTPROPS, key.toString());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testSetNullExpressionEngine",
  "sourceCode" : "/**\r\n * Tests setting the expression engine to null. This should not be allowed.\r\n */\r\n@Test\r\nvoid testSetNullExpressionEngine() {\r\n    assertThrows(IllegalArgumentException.class, () -> new DefaultConfigurationKey(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testTrim",
  "sourceCode" : "/**\r\n * Tests removing delimiters.\r\n */\r\n@Test\r\nvoid testTrim() {\r\n    assertEquals(\"test\", key.trim(\".test.\"));\r\n    assertEquals(\"\", key.trim(null));\r\n    assertEquals(\"\", key.trim(DefaultExpressionEngineSymbols.DEFAULT_PROPERTY_DELIMITER));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testTrimLeft",
  "sourceCode" : "/**\r\n * Tests removing leading delimiters.\r\n */\r\n@Test\r\nvoid testTrimLeft() {\r\n    assertEquals(\"test.\", key.trimLeft(\".test.\"));\r\n    assertEquals(\"..test.\", key.trimLeft(\"..test.\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultConfigurationKey.java",
  "methodName" : "testTrimRight",
  "sourceCode" : "/**\r\n * Tests removing trailing delimiters.\r\n */\r\n@Test\r\nvoid testTrimRight() {\r\n    assertEquals(\".test\", key.trimRight(\".test.\"));\r\n    assertEquals(\".test..\", key.trimRight(\".test..\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testAttributeKey",
  "sourceCode" : "/**\r\n * Tests obtaining keys for attribute nodes.\r\n */\r\n@Test\r\nvoid testAttributeKey() {\r\n    assertEquals(\"tables.table[@type]\", engine.attributeKey(\"tables.table\", \"type\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testAttributeKeyNoParent",
  "sourceCode" : "/**\r\n * Tests that a null parent key is ignored when constructing an attribute key.\r\n */\r\n@Test\r\nvoid testAttributeKeyNoParent() {\r\n    assertEquals(\"[@test]\", engine.attributeKey(null, \"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testAttributeKeyRoot",
  "sourceCode" : "/**\r\n * Tests whether an attribute key can be queried if the root node is involved.\r\n */\r\n@Test\r\nvoid testAttributeKeyRoot() {\r\n    assertEquals(\"[@test]\", engine.attributeKey(\"\", \"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testAttributeKeyWithAlternativeSyntax",
  "sourceCode" : "/**\r\n * Tests whether a correct attribute key with alternative syntax is generated.\r\n */\r\n@Test\r\nvoid testAttributeKeyWithAlternativeSyntax() {\r\n    setUpAlternativeSyntax();\r\n    assertEquals(\"@test\", engine.attributeKey(\"\", \"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testCanonicalKeyNoDuplicates",
  "sourceCode" : "/**\r\n * Tests whether a canonical key can be queried if all child nodes have different names.\r\n */\r\n@Test\r\nvoid testCanonicalKeyNoDuplicates() {\r\n    final ImmutableNode node = fetchNode(\"tables.table(0).name\");\r\n    assertEquals(\"table.name(0)\", engine.canonicalKey(node, \"table\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testCanonicalKeyNoParentKey",
  "sourceCode" : "/**\r\n * Tests whether the parent key can be undefined when querying a canonical key.\r\n */\r\n@Test\r\nvoid testCanonicalKeyNoParentKey() {\r\n    final ImmutableNode node = fetchNode(\"tables.table(0).fields.field(1).name\");\r\n    assertEquals(\"name(0)\", engine.canonicalKey(node, null, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testCanonicalKeyRootNoParentKey",
  "sourceCode" : "/**\r\n * Tests whether a canonical key for the parent node can be queried if no parent key was passed in.\r\n */\r\n@Test\r\nvoid testCanonicalKeyRootNoParentKey() {\r\n    assertEquals(\"\", engine.canonicalKey(root, null, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testCanonicalKeyRootWithParentKey",
  "sourceCode" : "/**\r\n * Tests whether a parent key is evaluated when determining the canonical key of the root node.\r\n */\r\n@Test\r\nvoid testCanonicalKeyRootWithParentKey() {\r\n    assertEquals(\"parent\", engine.canonicalKey(root, \"parent\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testCanonicalKeyWithDuplicates",
  "sourceCode" : "/**\r\n * Tests whether duplicates are correctly resolved when querying for canonical keys.\r\n */\r\n@Test\r\nvoid testCanonicalKeyWithDuplicates() {\r\n    final ImmutableNode tab1 = fetchNode(\"tables.table(0)\");\r\n    final ImmutableNode tab2 = fetchNode(\"tables.table(1)\");\r\n    assertEquals(\"tables.table(0)\", engine.canonicalKey(tab1, \"tables\", handler));\r\n    assertEquals(\"tables.table(1)\", engine.canonicalKey(tab2, \"tables\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testDefaultSymbols",
  "sourceCode" : "/**\r\n * Tests whether the default instance is initialized with default symbols.\r\n */\r\n@Test\r\nvoid testDefaultSymbols() {\r\n    assertSame(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS, engine.getSymbols());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testInitNoSymbols",
  "sourceCode" : "/**\r\n * Tries to create an instance without symbols.\r\n */\r\n@Test\r\nvoid testInitNoSymbols() {\r\n    assertThrows(IllegalArgumentException.class, () -> new DefaultExpressionEngine(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testNodeKey",
  "sourceCode" : "/**\r\n * Tests obtaining keys for nodes.\r\n */\r\n@Test\r\nvoid testNodeKey() {\r\n    final ImmutableNode node = root.getChildren().get(0);\r\n    assertEquals(\"tables\", engine.nodeKey(node, \"\", handler));\r\n    assertEquals(\"test.tables\", engine.nodeKey(node, \"test\", handler));\r\n    assertEquals(\"a.full.parent.key.tables\", engine.nodeKey(node, \"a.full.parent.key\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testNodeKeyWithAlternativeSyntax",
  "sourceCode" : "/**\r\n * Tests obtaining node keys if a different syntax is set.\r\n */\r\n@Test\r\nvoid testNodeKeyWithAlternativeSyntax() {\r\n    setUpAlternativeSyntax();\r\n    assertEquals(\"tables/table\", engine.nodeKey(root.getChildren().get(0).getChildren().get(0), \"tables\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testNodeKeyWithAlternativeSyntaxAttributePropertyDelimiter",
  "sourceCode" : "/**\r\n * Tests obtaining node keys if a different syntax is set and the same string is used as property delimiter and\r\n * attribute start marker.\r\n */\r\n@Test\r\nvoid testNodeKeyWithAlternativeSyntaxAttributePropertyDelimiter() {\r\n    setUpAlternativeSyntax();\r\n    final DefaultExpressionEngineSymbols symbols = new DefaultExpressionEngineSymbols.Builder(engine.getSymbols()).setAttributeStart(engine.getSymbols().getPropertyDelimiter()).create();\r\n    engine = new DefaultExpressionEngine(symbols);\r\n    assertEquals(\"/test\", engine.attributeKey(\"\", \"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testNodeKeyWithEscapedDelimiters",
  "sourceCode" : "/**\r\n * Tests obtaining keys for nodes that contain the delimiter character.\r\n */\r\n@Test\r\nvoid testNodeKeyWithEscapedDelimiters() {\r\n    final ImmutableNode node = root.getChildren().get(1);\r\n    assertEquals(\"connection..settings\", engine.nodeKey(node, \"\", handler));\r\n    assertEquals(\"connection..settings.usr..name\", engine.nodeKey(node.getChildren().get(0), engine.nodeKey(node, \"\", handler), handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testNodeKeyWithRoot",
  "sourceCode" : "/**\r\n * Tests obtaining keys if the root node is involved.\r\n */\r\n@Test\r\nvoid testNodeKeyWithRoot() {\r\n    assertEquals(\"\", engine.nodeKey(root, null, handler));\r\n    assertEquals(\"test\", engine.nodeKey(root, \"test\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddAttribute",
  "sourceCode" : "/**\r\n * Tests adding new attributes.\r\n */\r\n@Test\r\nvoid testPrepareAddAttribute() {\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \"tables.table(0)[@tableSpace]\", handler);\r\n    assertEquals(TABLES[0], data.getParent().getChildren().get(0).getValue());\r\n    assertEquals(\"tableSpace\", data.getNewNodeName());\r\n    assertTrue(data.isAttribute());\r\n    assertTrue(data.getPathNodes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddAttributeRoot",
  "sourceCode" : "/**\r\n * Tests whether an attribute to the root node can be added.\r\n */\r\n@Test\r\nvoid testPrepareAddAttributeRoot() {\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \"[@newAttr]\", handler);\r\n    assertSame(root, data.getParent());\r\n    assertEquals(\"newAttr\", data.getNewNodeName());\r\n    assertTrue(data.isAttribute());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddDirectly",
  "sourceCode" : "/**\r\n * Tests adding direct child nodes to the existing hierarchy.\r\n */\r\n@Test\r\nvoid testPrepareAddDirectly() {\r\n    NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \"newNode\", handler);\r\n    assertSame(root, data.getParent());\r\n    assertTrue(data.getPathNodes().isEmpty());\r\n    assertEquals(\"newNode\", data.getNewNodeName());\r\n    assertFalse(data.isAttribute());\r\n    data = engine.prepareAdd(root, \"tables.table.fields.field.name\", handler);\r\n    assertEquals(\"name\", data.getNewNodeName());\r\n    assertTrue(data.getPathNodes().isEmpty());\r\n    assertEquals(\"field\", data.getParent().getNodeName());\r\n    final ImmutableNode nd = data.getParent().getChildren().get(0);\r\n    assertEquals(\"name\", nd.getNodeName());\r\n    assertEquals(\"version\", nd.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddEmptyKey",
  "sourceCode" : "@Test\r\nvoid testPrepareAddEmptyKey() {\r\n    assertThrows(IllegalArgumentException.class, () -> engine.prepareAdd(root, \"\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddInvalidKey",
  "sourceCode" : "/**\r\n * Tests using invalid keys, for example if something should be added to attributes.\r\n */\r\n@Test\r\nvoid testPrepareAddInvalidKey() {\r\n    assertThrows(IllegalArgumentException.class, () -> engine.prepareAdd(root, \"tables.table(0)[@type].new\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddInvalidKeyAttribute",
  "sourceCode" : "@Test\r\nvoid testPrepareAddInvalidKeyAttribute() {\r\n    assertThrows(IllegalArgumentException.class, () -> engine.prepareAdd(root, \"a.complete.new.path.with.an[@attribute].at.a.non.allowed[@position]\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddNullKey",
  "sourceCode" : "@Test\r\nvoid testPrepareAddNullKey() {\r\n    assertThrows(IllegalArgumentException.class, () -> engine.prepareAdd(root, null, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddWithAlternativeMatcher",
  "sourceCode" : "/**\r\n * Tests whether the node matcher is used when adding keys.\r\n */\r\n@Test\r\nvoid testPrepareAddWithAlternativeMatcher() {\r\n    setUpAlternativeMatcher();\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \"tables_.table._fields__._field.name\", handler);\r\n    assertEquals(\"name\", data.getNewNodeName());\r\n    assertTrue(data.getPathNodes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddWithAlternativeSyntax",
  "sourceCode" : "/**\r\n * Tests add operations when an alternative syntax is set.\r\n */\r\n@Test\r\nvoid testPrepareAddWithAlternativeSyntax() {\r\n    setUpAlternativeSyntax();\r\n    NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \"tables/table[0]/test\", handler);\r\n    assertEquals(\"test\", data.getNewNodeName());\r\n    assertFalse(data.isAttribute());\r\n    assertEquals(TABLES[0], data.getParent().getChildren().get(0).getValue());\r\n    data = engine.prepareAdd(root, \"a/complete/new/path@attr\", handler);\r\n    assertEquals(\"attr\", data.getNewNodeName());\r\n    checkNodePath(data, \"a\", \"complete\", \"new\", \"path\");\r\n    assertSame(root, data.getParent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddWithIndex",
  "sourceCode" : "/**\r\n * Tests adding if indices are involved.\r\n */\r\n@Test\r\nvoid testPrepareAddWithIndex() {\r\n    NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \"tables.table(0).tableSpace\", handler);\r\n    assertEquals(\"tableSpace\", data.getNewNodeName());\r\n    assertTrue(data.getPathNodes().isEmpty());\r\n    assertEquals(\"table\", data.getParent().getNodeName());\r\n    final ImmutableNode node = data.getParent().getChildren().get(0);\r\n    assertEquals(TABLES[0], node.getValue());\r\n    data = engine.prepareAdd(root, \"tables.table(1).fields.field(2).alias\", handler);\r\n    assertEquals(\"alias\", data.getNewNodeName());\r\n    assertEquals(\"field\", data.getParent().getNodeName());\r\n    assertEquals(\"creationDate\", data.getParent().getChildren().get(0).getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddWithPath",
  "sourceCode" : "/**\r\n * Tests add operations where complete paths are added.\r\n */\r\n@Test\r\nvoid testPrepareAddWithPath() {\r\n    NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \"tables.table(1).fields.field(-1).name\", handler);\r\n    assertEquals(\"name\", data.getNewNodeName());\r\n    checkNodePath(data, \"field\");\r\n    assertEquals(\"fields\", data.getParent().getNodeName());\r\n    data = engine.prepareAdd(root, \"tables.table(-1).name\", handler);\r\n    assertEquals(\"name\", data.getNewNodeName());\r\n    checkNodePath(data, \"table\");\r\n    assertEquals(\"tables\", data.getParent().getNodeName());\r\n    data = engine.prepareAdd(root, \"a.complete.new.path\", handler);\r\n    assertEquals(\"path\", data.getNewNodeName());\r\n    checkNodePath(data, \"a\", \"complete\", \"new\");\r\n    assertSame(root, data.getParent());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testPrepareAddWithSameAttributeDelimiter",
  "sourceCode" : "/**\r\n * Tests add operations if property and attribute delimiters are equal. Then it is not possible to add new attribute\r\n * nodes.\r\n */\r\n@Test\r\nvoid testPrepareAddWithSameAttributeDelimiter() {\r\n    final DefaultExpressionEngineSymbols symbols = new DefaultExpressionEngineSymbols.Builder(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS).setAttributeEnd(null).setAttributeStart(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS.getPropertyDelimiter()).create();\r\n    engine = new DefaultExpressionEngine(symbols);\r\n    NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \"tables.table(0).test\", handler);\r\n    assertEquals(\"test\", data.getNewNodeName());\r\n    assertFalse(data.isAttribute());\r\n    assertEquals(\"table\", data.getParent().getNodeName());\r\n    data = engine.prepareAdd(root, \"a.complete.new.path\", handler);\r\n    assertFalse(data.isAttribute());\r\n    checkNodePath(data, \"a\", \"complete\", \"new\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryAlternativeSyntax",
  "sourceCode" : "/**\r\n * Tests a different query syntax. Sets other strings for the typical tokens used by the expression engine.\r\n */\r\n@Test\r\nvoid testQueryAlternativeSyntax() {\r\n    setUpAlternativeSyntax();\r\n    checkKeyValue(\"tables/table[1]/name\", \"name\", TABLES[1]);\r\n    checkAttributeValue(\"tables/table[0]@type\", \"type\", TAB_TYPES[0]);\r\n    checkAttributeValue(\"@test\", \"test\", \"true\");\r\n    checkKeyValue(\"connection.settings/usr.name\", \"usr.name\", \"scott\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryAttributeEmulation",
  "sourceCode" : "/**\r\n * Tests some queries when the same delimiter is used for properties and attributes.\r\n */\r\n@Test\r\nvoid testQueryAttributeEmulation() {\r\n    final DefaultExpressionEngineSymbols symbols = new DefaultExpressionEngineSymbols.Builder(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS).setAttributeEnd(null).setAttributeStart(DefaultExpressionEngineSymbols.DEFAULT_PROPERTY_DELIMITER).create();\r\n    engine = new DefaultExpressionEngine(symbols);\r\n    checkKeyValue(\"tables.table(0).name\", \"name\", TABLES[0]);\r\n    checkAttributeValue(\"tables.table(0).type\", \"type\", TAB_TYPES[0]);\r\n    checkKey(\"tables.table.type\", \"type\", 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryEscapedKeys",
  "sourceCode" : "/**\r\n * Tests querying nodes whose names contain a delimiter.\r\n */\r\n@Test\r\nvoid testQueryEscapedKeys() {\r\n    checkKeyValue(\"connection..settings.usr..name\", \"usr.name\", \"scott\");\r\n    checkKeyValue(\"connection..settings.usr..pwd\", \"usr.pwd\", \"tiger\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryKeys",
  "sourceCode" : "/**\r\n * Tests some simple queries.\r\n */\r\n@Test\r\nvoid testQueryKeys() {\r\n    checkKey(\"tables.table.name\", \"name\", 2);\r\n    checkKey(\"tables.table.fields.field.name\", \"name\", 10);\r\n    checkKey(\"tables.table[@type]\", \"type\", 2);\r\n    checkKey(\"tables.table(0).fields.field.name\", \"name\", 5);\r\n    checkKey(\"tables.table(1).fields.field.name\", \"name\", 5);\r\n    checkKey(\"tables.table.fields.field(1).name\", \"name\", 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryKeyWithAlternativeMatcher",
  "sourceCode" : "/**\r\n * Tests whether the node matcher is used when querying keys.\r\n */\r\n@Test\r\nvoid testQueryKeyWithAlternativeMatcher() {\r\n    setUpAlternativeMatcher();\r\n    checkKey(\"tables_._table_.name_\", \"name\", 2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryNodes",
  "sourceCode" : "/**\r\n * Performs some queries and evaluates the values of the result nodes.\r\n */\r\n@Test\r\nvoid testQueryNodes() {\r\n    for (int i = 0; i < TABLES.length; i++) {\r\n        checkKeyValue(\"tables.table(\" + i + \").name\", \"name\", TABLES[i]);\r\n        checkAttributeValue(\"tables.table(\" + i + \")[@type]\", \"type\", TAB_TYPES[i]);\r\n        for (int j = 0; j < FIELDS[i].length; j++) {\r\n            checkKeyValue(\"tables.table(\" + i + \").fields.field(\" + j + \").name\", \"name\", FIELDS[i][j]);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryNonExistingKeys",
  "sourceCode" : "/**\r\n * Tests querying keys that do not exist.\r\n */\r\n@Test\r\nvoid testQueryNonExistingKeys() {\r\n    checkKey(\"tables.tablespace.name\", null, 0);\r\n    checkKey(\"tables.table(2).name\", null, 0);\r\n    checkKey(\"a complete unknown key\", null, 0);\r\n    checkKey(\"tables.table(0).fields.field(-1).name\", null, 0);\r\n    checkKey(\"tables.table(0).fields.field(28).name\", null, 0);\r\n    checkKey(\"tables.table(0).fields.field().name\", null, 0);\r\n    checkKey(\"connection.settings.usr.name\", null, 0);\r\n    checkKey(\"tables.table(0)[@type].additional\", null, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryRootAttribute",
  "sourceCode" : "/**\r\n * Tests whether an attribute of the root node can be queried.\r\n */\r\n@Test\r\nvoid testQueryRootAttribute() {\r\n    checkAttributeValue(\"[@test]\", \"test\", \"true\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryRootNodeEmptyKey",
  "sourceCode" : "/**\r\n * Tests whether the root node can be retrieved using the empty key.\r\n */\r\n@Test\r\nvoid testQueryRootNodeEmptyKey() {\r\n    checkQueryRootNode(\"\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngine.java",
  "methodName" : "testQueryRootNodeNullKey",
  "sourceCode" : "/**\r\n * Tests whether the root node can be retrieved using the null key.\r\n */\r\n@Test\r\nvoid testQueryRootNodeNullKey() {\r\n    checkQueryRootNode(null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngineSymbols.java",
  "methodName" : "testDefaultSymbols",
  "sourceCode" : "/**\r\n * Tests the instance with default symbols.\r\n */\r\n@Test\r\nvoid testDefaultSymbols() {\r\n    assertEquals(\".\", DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS.getPropertyDelimiter());\r\n    assertEquals(\"..\", DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS.getEscapedDelimiter());\r\n    assertEquals(\"(\", DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS.getIndexStart());\r\n    assertEquals(\")\", DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS.getIndexEnd());\r\n    assertEquals(\"[@\", DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS.getAttributeStart());\r\n    assertEquals(\"]\", DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS.getAttributeEnd());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngineSymbols.java",
  "methodName" : "testEqualsFalse",
  "sourceCode" : "/**\r\n * Tests equals() if the expected result is false.\r\n */\r\n@Test\r\nvoid testEqualsFalse() {\r\n    final DefaultExpressionEngineSymbols s1 = DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS;\r\n    DefaultExpressionEngineSymbols s2 = builder().setPropertyDelimiter(\"/\").create();\r\n    expNE(s1, s2);\r\n    s2 = builder().setEscapedDelimiter(\"\\\\.\").create();\r\n    expNE(s1, s2);\r\n    s2 = builder().setIndexStart(\"[\").create();\r\n    expNE(s1, s2);\r\n    s2 = builder().setIndexEnd(\"]\").create();\r\n    expNE(s1, s2);\r\n    s2 = builder().setAttributeStart(\"#\").create();\r\n    expNE(s1, s2);\r\n    s2 = builder().setAttributeEnd(\"~\").create();\r\n    expNE(s1, s2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngineSymbols.java",
  "methodName" : "testEqualsNull",
  "sourceCode" : "/**\r\n * Tests equals for null input.\r\n */\r\n@Test\r\nvoid testEqualsNull() {\r\n    expNE(builder().create(), null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngineSymbols.java",
  "methodName" : "testEqualsOtherClass",
  "sourceCode" : "/**\r\n * Tests equals with an object of another class.\r\n */\r\n@Test\r\nvoid testEqualsOtherClass() {\r\n    expNE(builder().create(), this);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngineSymbols.java",
  "methodName" : "testEqualsTrue",
  "sourceCode" : "/**\r\n * Tests equals() if the expected result is true.\r\n */\r\n@Test\r\nvoid testEqualsTrue() {\r\n    expEqual(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS, DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS);\r\n    final DefaultExpressionEngineSymbols s2 = new DefaultExpressionEngineSymbols.Builder(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS).create();\r\n    expEqual(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS, s2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestDefaultExpressionEngineSymbols.java",
  "methodName" : "testToString",
  "sourceCode" : "/**\r\n * Tests the string representation.\r\n */\r\n@Test\r\nvoid testToString() {\r\n    final DefaultExpressionEngineSymbols symbols = builder().create();\r\n    final String s = symbols.toString();\r\n    assertTrue(s.contains(\"propertyDelimiter=\" + symbols.getPropertyDelimiter()));\r\n    assertTrue(s.contains(\"escapedDelimiter=\" + symbols.getEscapedDelimiter()));\r\n    assertTrue(s.contains(\"indexStart=\" + symbols.getIndexStart()));\r\n    assertTrue(s.contains(\"indexEnd=\" + symbols.getIndexEnd()));\r\n    assertTrue(s.contains(\"attributeStart=\" + symbols.getAttributeStart()));\r\n    assertTrue(s.contains(\"attributeEnd=\" + symbols.getAttributeEnd()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testAddAttributesNull",
  "sourceCode" : "/**\r\n * Tests whether addAttributes() handles null input.\r\n */\r\n@Test\r\nvoid testAddAttributesNull() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    builder.addAttributes(null);\r\n    final ImmutableNode node = builder.create();\r\n    assertTrue(node.getAttributes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testAddChild",
  "sourceCode" : "/**\r\n * Tests whether a child node can be added.\r\n */\r\n@Test\r\nvoid testAddChild() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode child2 = new ImmutableNode.Builder().name(\"child2\").create();\r\n    final ImmutableNode node2 = node.addChild(child2);\r\n    checkUpdatedNode(node, node2);\r\n    checkChildNodes(node2, node.getChildren().get(0), child2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testAddChildNull",
  "sourceCode" : "/**\r\n * Tests whether a new null child node is rejected.\r\n */\r\n@Test\r\nvoid testAddChildNull() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    assertThrows(IllegalArgumentException.class, () -> node.addChild(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testAddChildrenNull",
  "sourceCode" : "/**\r\n * Tests whether addChildren() can deal with null input.\r\n */\r\n@Test\r\nvoid testAddChildrenNull() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    builder.addChildren(null);\r\n    final ImmutableNode node = builder.create();\r\n    assertTrue(node.getChildren().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testAddChildrenNullElement",
  "sourceCode" : "/**\r\n * Tests whether null entries in a collection with new child nodes are ignored.\r\n */\r\n@Test\r\nvoid testAddChildrenNullElement() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    final List<ImmutableNode> children = Arrays.asList(createChild(), null, createChild());\r\n    builder.addChildren(children);\r\n    final ImmutableNode node = builder.create();\r\n    checkChildNodes(node, children.get(0), children.get(2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testAttributesImmutable",
  "sourceCode" : "/**\r\n * Tests that a node's attributes cannot be directly manipulated.\r\n */\r\n@Test\r\nvoid testAttributesImmutable() {\r\n    final ImmutableNode node = setUpBuilder().create();\r\n    final Map<String, Object> attributes = node.getAttributes();\r\n    assertThrows(UnsupportedOperationException.class, () -> attributes.put(\"test\", VALUE));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testChildrenImmutable",
  "sourceCode" : "/**\r\n * Tests that a node's children cannot be manipulated.\r\n */\r\n@Test\r\nvoid testChildrenImmutable() {\r\n    final ImmutableNode node = setUpBuilder().create();\r\n    final List<ImmutableNode> children = node.getChildren();\r\n    assertThrows(UnsupportedOperationException.class, () -> children.add(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testGetChildrenByMissingName",
  "sourceCode" : "/**\r\n * Tests getting named children.\r\n */\r\n@Test\r\nvoid testGetChildrenByMissingName() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode child2 = new ImmutableNode.Builder().name(\"child2\").create();\r\n    final ImmutableNode node2 = node.addChild(child2);\r\n    checkUpdatedNode(node, node2);\r\n    assertTrue(node2.getChildren(\"NotFound\").isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testGetChildrenByName",
  "sourceCode" : "/**\r\n * Tests getting named children.\r\n */\r\n@Test\r\nvoid testGetChildrenByName() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode child2 = new ImmutableNode.Builder().name(\"child2\").create();\r\n    final ImmutableNode node2 = node.addChild(child2);\r\n    checkUpdatedNode(node, node2);\r\n    assertEquals(\"child2\", node2.getChildren(\"child2\").get(0).getNodeName());\r\n    assertEquals(child2, node2.getChildren(\"child2\").get(0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testGetChildrenByNullName",
  "sourceCode" : "/**\r\n * Tests getting named children.\r\n */\r\n@Test\r\nvoid testGetChildrenByNullName() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode child2 = new ImmutableNode.Builder().name(\"child2\").create();\r\n    final ImmutableNode node2 = node.addChild(child2);\r\n    checkUpdatedNode(node, node2);\r\n    assertTrue(node2.getChildren(null).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testNodeWithAddMultipleChildren",
  "sourceCode" : "/**\r\n * Tests whether multiple child nodes can be added to a builder.\r\n */\r\n@Test\r\nvoid testNodeWithAddMultipleChildren() {\r\n    final int childCount = 4;\r\n    final List<ImmutableNode> childNodes = new ArrayList<>(childCount);\r\n    for (int i = 0; i < childCount; i++) {\r\n        final ImmutableNode.Builder childBuilder = new ImmutableNode.Builder();\r\n        final ImmutableNode child = childBuilder.name(NAME + i).value(i).create();\r\n        childNodes.add(child);\r\n    }\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    final ImmutableNode node = builder.addChildren(childNodes).create();\r\n    checkChildNodes(node, childNodes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testNodeWithAttributes",
  "sourceCode" : "/**\r\n * Tests whether a node with attributes can be created.\r\n */\r\n@Test\r\nvoid testNodeWithAttributes() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    final int attrCount = 4;\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    for (int i = 0; i < attrCount; i++) {\r\n        final String attrName = NAME + i;\r\n        attrs.put(attrName, i);\r\n        builder.addAttribute(attrName, i);\r\n    }\r\n    final ImmutableNode node = builder.create();\r\n    checkAttributes(node, attrs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testNodeWithAttributesManipulateLater",
  "sourceCode" : "/**\r\n * Tests that the map of attributes cannot be changed by a later manipulation of the builder.\r\n */\r\n@Test\r\nvoid testNodeWithAttributesManipulateLater() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    builder.addAttribute(ATTR, ATTR_VALUE);\r\n    final ImmutableNode node = builder.create();\r\n    builder.addAttribute(\"attr2\", \"a2\");\r\n    assertEquals(1, node.getAttributes().size());\r\n    assertEquals(ATTR_VALUE, node.getAttributes().get(ATTR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testNodeWithChildren",
  "sourceCode" : "/**\r\n * Tests whether child nodes can be added.\r\n */\r\n@Test\r\nvoid testNodeWithChildren() {\r\n    final int childCount = 8;\r\n    final List<ImmutableNode> childNodes = new ArrayList<>(childCount);\r\n    final ImmutableNode.Builder builder = new ImmutableNode.Builder(childCount);\r\n    for (int i = 0; i < childCount; i++) {\r\n        final ImmutableNode.Builder childBuilder = new ImmutableNode.Builder();\r\n        final ImmutableNode child = childBuilder.name(NAME + i).value(i).create();\r\n        builder.addChild(child);\r\n        childNodes.add(child);\r\n    }\r\n    final ImmutableNode node = builder.name(NAME).create();\r\n    checkChildNodes(node, childNodes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testNodeWithChildrenManipulateLater",
  "sourceCode" : "/**\r\n * Tests that the list of children cannot be changed by a later manipulation of the builder.\r\n */\r\n@Test\r\nvoid testNodeWithChildrenManipulateLater() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    final ImmutableNode child = new ImmutableNode.Builder().name(\"Child\").create();\r\n    final ImmutableNode node = builder.addChild(child).create();\r\n    builder.addChild(new ImmutableNode.Builder().name(\"AnotherChild\").create());\r\n    checkChildNodes(node, Collections.singletonList(child));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testNodeWithMultipleAttributes",
  "sourceCode" : "/**\r\n * Tests whether multiple attributes can be added in a single operation.\r\n */\r\n@Test\r\nvoid testNodeWithMultipleAttributes() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    final int attrCount = 4;\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    for (int i = 0; i < attrCount; i++) {\r\n        final String attrName = NAME + i;\r\n        attrs.put(attrName, i);\r\n    }\r\n    final ImmutableNode node = builder.addAttributes(attrs).create();\r\n    checkAttributes(node, attrs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testNodeWithNullChild",
  "sourceCode" : "/**\r\n * Tests whether the builder ignores a null child node.\r\n */\r\n@Test\r\nvoid testNodeWithNullChild() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    builder.addChild(null);\r\n    final ImmutableNode node = builder.create();\r\n    checkChildNodes(node);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testRemoveAttributeExisting",
  "sourceCode" : "/**\r\n * Tests whether an existing attribute can be removed.\r\n */\r\n@Test\r\nvoid testRemoveAttributeExisting() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final String attrName = node.getAttributes().keySet().iterator().next();\r\n    final ImmutableNode node2 = node.removeAttribute(attrName);\r\n    checkUpdatedNode(node, node2);\r\n    assertSame(node.getChildren(), node2.getChildren());\r\n    assertTrue(node2.getAttributes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testRemoveAttributeNotExisting",
  "sourceCode" : "/**\r\n * Tests removeAttribute() if the attribute does not exist.\r\n */\r\n@Test\r\nvoid testRemoveAttributeNotExisting() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    assertSame(node, node.removeAttribute(ATTR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testRemoveChildExisting",
  "sourceCode" : "/**\r\n * Tests whether a child node can be removed.\r\n */\r\n@Test\r\nvoid testRemoveChildExisting() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode child = node.getChildren().get(0);\r\n    final ImmutableNode node2 = node.removeChild(child);\r\n    checkUpdatedNode(node, node2);\r\n    checkChildNodes(node2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testRemoveChildMultiple",
  "sourceCode" : "/**\r\n * Tests whether the correct child node is removed if there are multiple.\r\n */\r\n@Test\r\nvoid testRemoveChildMultiple() {\r\n    final ImmutableNode childRemove = createChild();\r\n    final ImmutableNode node = createDefaultNode(VALUE).addChild(createChild()).addChild(childRemove).addChild(createChild());\r\n    final ImmutableNode node2 = node.removeChild(childRemove);\r\n    checkChildNodes(node2, node.getChildren().get(0), node.getChildren().get(1), node.getChildren().get(3));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testRemoveChildNodeNotExisting",
  "sourceCode" : "/**\r\n * Tests whether the behavior of removeChildNode() if the node in question is not found.\r\n */\r\n@Test\r\nvoid testRemoveChildNodeNotExisting() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    assertSame(node, node.removeChild(null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testReplaceChildExisting",
  "sourceCode" : "/**\r\n * Tests whether a child node can be replaced by another one.\r\n */\r\n@Test\r\nvoid testReplaceChildExisting() {\r\n    final ImmutableNode childRemove = createChild();\r\n    final ImmutableNode childReplace = createChild();\r\n    final ImmutableNode node = createDefaultNode(VALUE).addChild(childRemove);\r\n    final ImmutableNode node2 = node.replaceChild(childRemove, childReplace);\r\n    checkUpdatedNode(node, node2);\r\n    checkChildNodes(node2, node.getChildren().get(0), childReplace);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testReplaceChildNotExisting",
  "sourceCode" : "/**\r\n * Tests replaceChild() if the child node cannot be found.\r\n */\r\n@Test\r\nvoid testReplaceChildNotExisting() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    assertSame(node, node.replaceChild(createChild(), createChild()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testReplaceChildNull",
  "sourceCode" : "/**\r\n * Tries to replace a child node by null.\r\n */\r\n@Test\r\nvoid testReplaceChildNull() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode child = createChild();\r\n    assertThrows(IllegalArgumentException.class, () -> node.replaceChild(child, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testReplaceChildren",
  "sourceCode" : "/**\r\n * Tests whether all children can be replaced at once.\r\n */\r\n@Test\r\nvoid testReplaceChildren() {\r\n    final int childCount = 8;\r\n    final List<ImmutableNode> newChildren = new ArrayList<>(childCount);\r\n    for (int i = 0; i < childCount; i++) {\r\n        newChildren.add(createChild());\r\n    }\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode node2 = node.replaceChildren(newChildren);\r\n    checkUpdatedNode(node, node2);\r\n    checkChildNodes(node2, newChildren);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testReplaceChildrenNullCollection",
  "sourceCode" : "/**\r\n * Tests whether a node's children can be replaced by a null collection.\r\n */\r\n@Test\r\nvoid testReplaceChildrenNullCollection() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode node2 = node.replaceChildren(null);\r\n    checkUpdatedNode(node, node2);\r\n    checkChildNodes(node2);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testSetAttribute",
  "sourceCode" : "/**\r\n * Tests whether attribute values can be set.\r\n */\r\n@Test\r\nvoid testSetAttribute() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode node2 = node.setAttribute(\"attr\", ATTR_VALUE);\r\n    checkUpdatedNode(node, node2);\r\n    assertSame(node.getChildren(), node2.getChildren());\r\n    final Map<String, Object> newAttrs = new HashMap<>(node.getAttributes());\r\n    newAttrs.put(ATTR, ATTR_VALUE);\r\n    checkAttributes(node2, newAttrs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testSetAttributeOverride",
  "sourceCode" : "/**\r\n * Tests whether an attribute can be overridden.\r\n */\r\n@Test\r\nvoid testSetAttributeOverride() {\r\n    final ImmutableNode.Builder builder = setUpBuilder();\r\n    final String attr2 = ATTR + \"_other\";\r\n    final Map<String, Object> attrs = new HashMap<>();\r\n    attrs.put(ATTR, ATTR_VALUE);\r\n    attrs.put(attr2, \"someValue\");\r\n    final ImmutableNode node = builder.addAttributes(attrs).create();\r\n    final ImmutableNode node2 = node.setAttribute(attr2, VALUE);\r\n    attrs.put(attr2, VALUE);\r\n    checkAttributes(node2, attrs);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testSetAttributes",
  "sourceCode" : "/**\r\n * Tests whether multiple attributes can be set.\r\n */\r\n@Test\r\nvoid testSetAttributes() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final Map<String, Object> attributes = new HashMap<>();\r\n    attributes.put(\"newAttribute1\", \"value1\");\r\n    attributes.put(\"newAttribute2\", \"value2\");\r\n    final ImmutableNode node2 = node.setAttributes(attributes);\r\n    assertEquals(attributes.size() + node.getAttributes().size(), node2.getAttributes().size());\r\n    checkAttributesContained(node2, attributes);\r\n    checkAttributesContained(node2, node.getAttributes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testSetAttributesEmpty",
  "sourceCode" : "/**\r\n * Tests setAttributes() if an empty map is passed in.\r\n */\r\n@Test\r\nvoid testSetAttributesEmpty() {\r\n    checkSetAttributesNoOp(new HashMap<>());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testSetAttributesNull",
  "sourceCode" : "/**\r\n * Tests setAttributes() for null input.\r\n */\r\n@Test\r\nvoid testSetAttributesNull() {\r\n    checkSetAttributesNoOp(null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testSetName",
  "sourceCode" : "/**\r\n * Tests whether the name of a node can be changed for a new instance.\r\n */\r\n@Test\r\nvoid testSetName() {\r\n    final ImmutableNode node = createDefaultNode(\"anotherName\", VALUE);\r\n    final ImmutableNode node2 = node.setName(NAME);\r\n    checkUpdatedNode(node, node2);\r\n    assertSame(node.getChildren(), node2.getChildren());\r\n    assertSame(node.getAttributes(), node2.getAttributes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testSetValue",
  "sourceCode" : "/**\r\n * Tests whether a new node with a changed value can be created.\r\n */\r\n@Test\r\nvoid testSetValue() {\r\n    final ImmutableNode node = createDefaultNode(\"test\");\r\n    final ImmutableNode node2 = node.setValue(VALUE);\r\n    checkUpdatedNode(node, node2);\r\n    assertSame(node.getChildren(), node2.getChildren());\r\n    assertSame(node.getAttributes(), node2.getAttributes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testSimpleProperties",
  "sourceCode" : "/**\r\n * Tests whether a node with basic properties can be created.\r\n */\r\n@Test\r\nvoid testSimpleProperties() {\r\n    final ImmutableNode node = setUpBuilder().create();\r\n    assertEquals(NAME, node.getNodeName());\r\n    assertTrue(node.getChildren().isEmpty());\r\n    assertTrue(node.getAttributes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestImmutableNode.java",
  "methodName" : "testStream",
  "sourceCode" : "/**\r\n * Tests streaming children.\r\n */\r\n@Test\r\nvoid testStream() {\r\n    final ImmutableNode node = createDefaultNode(VALUE);\r\n    final ImmutableNode child2 = new ImmutableNode.Builder().name(\"child2\").create();\r\n    final ImmutableNode node2 = node.addChild(child2);\r\n    checkUpdatedNode(node, node2);\r\n    assertEquals(1, node.stream().count());\r\n    assertEquals(0, child2.stream().count());\r\n    assertEquals(2, node2.stream().count());\r\n    assertEquals(1, node.stream().count());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddNodesEmptyCollection",
  "sourceCode" : "/**\r\n * Tests an add nodes operation if an empty collection is passed in.\r\n */\r\n@Test\r\nvoid testAddNodesEmptyCollection() {\r\n    checkAddNodesNoNodes(Collections.<ImmutableNode>emptySet());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddNodesNullCollection",
  "sourceCode" : "/**\r\n * Tests an add nodes operation if a null collection is passed in.\r\n */\r\n@Test\r\nvoid testAddNodesNullCollection() {\r\n    checkAddNodesNoNodes(null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddNodesToAttribute",
  "sourceCode" : "/**\r\n * Tries to add new nodes if the key references an attribute.\r\n */\r\n@Test\r\nvoid testAddNodesToAttribute() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveKey(NodeStructureHelper.ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(QueryResult.createAttributeResult(nodeForKey(model, NodeStructureHelper.author(1)), \"test\")));\r\n    final ImmutableNode newNode = new ImmutableNode.Builder().name(\"newNode\").create();\r\n    final Set<ImmutableNode> nodes = Collections.singleton(newNode);\r\n    assertThrows(IllegalArgumentException.class, () -> model.addNodes(KEY, nodes, resolver));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddNodesToExistingNode",
  "sourceCode" : "/**\r\n * Tests whether new nodes can be added to an existing node in the model.\r\n */\r\n@Test\r\nvoid testAddNodesToExistingNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_AUTHORS_TREE);\r\n    final String key = NodeStructureHelper.author(0);\r\n    final ImmutableNode newWork1 = new ImmutableNode.Builder().name(\"King Lear\").create();\r\n    final ImmutableNode newWork2 = new ImmutableNode.Builder().name(\"The Taming of the Shrew\").create();\r\n    when(resolver.resolveKey(NodeStructureHelper.ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(QueryResult.createNodeResult(nodeForKey(model, key))));\r\n    model.addNodes(KEY, Arrays.asList(newWork1, newWork2), resolver);\r\n    final ImmutableNode node = nodeForKey(model, key);\r\n    final int size = node.getChildren().size();\r\n    assertSame(newWork1, node.getChildren().get(size - 2));\r\n    assertSame(newWork2, node.getChildren().get(size - 1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddNodesToNewAttributeKey",
  "sourceCode" : "/**\r\n * Tries to add new nodes to an non-existing key pointing to an attribute.\r\n */\r\n@Test\r\nvoid testAddNodesToNewAttributeKey() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveKey(NodeStructureHelper.ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(Collections.<QueryResult<ImmutableNode>>emptyList());\r\n    when(resolver.resolveAddKey(NodeStructureHelper.ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(new NodeAddData<>(NodeStructureHelper.ROOT_AUTHORS_TREE, \"test\", true, null));\r\n    final ImmutableNode newNode = new ImmutableNode.Builder().name(\"newNode\").create();\r\n    final Set<ImmutableNode> nodes = Collections.singleton(newNode);\r\n    assertThrows(IllegalArgumentException.class, () -> model.addNodes(KEY, nodes, resolver));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddNodesToNewNode",
  "sourceCode" : "/**\r\n * Tests whether nodes can be added to a node which has to be created.\r\n */\r\n@Test\r\nvoid testAddNodesToNewNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_AUTHORS_TREE);\r\n    final String newAuthor = \"Goethe\";\r\n    final String newWork = \"Faust\";\r\n    final String newPersona = \"Mephisto\";\r\n    when(resolver.resolveKey(NodeStructureHelper.ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(new ArrayList<>(0));\r\n    when(resolver.resolveAddKey(NodeStructureHelper.ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(new NodeAddData<>(NodeStructureHelper.ROOT_AUTHORS_TREE, newWork, false, Arrays.asList(newAuthor)));\r\n    final ImmutableNode personaNode = new ImmutableNode.Builder().name(newPersona).create();\r\n    model.addNodes(KEY, Collections.singleton(personaNode), resolver);\r\n    assertSame(personaNode, nodeForKey(model, newAuthor + \"/\" + newWork + \"/\" + newPersona));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddPropertyAttributeNoPathNodes",
  "sourceCode" : "/**\r\n * Tests whether an attribute property can be added if there are no path nodes.\r\n */\r\n@Test\r\nvoid testAddPropertyAttributeNoPathNodes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final NodeAddData<ImmutableNode> addData = new NodeAddData<>(nodeForKey(ROOT_AUTHORS_TREE, \"Shakespeare/The Tempest\"), \"year\", true, null);\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveAddKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(addData);\r\n    model.addProperty(KEY, Collections.singleton(1611), resolver);\r\n    final ImmutableNode node = nodeForKey(model, \"Shakespeare/The Tempest\");\r\n    assertEquals(1611, node.getAttributes().get(\"year\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddPropertyAttributeWithPathNodes",
  "sourceCode" : "/**\r\n * Tests whether an attribute can be added if there are some path nodes.\r\n */\r\n@Test\r\nvoid testAddPropertyAttributeWithPathNodes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final NodeAddData<ImmutableNode> addData = new NodeAddData<>(nodeForKey(ROOT_AUTHORS_TREE, \"Homer/Ilias\"), \"number\", true, Arrays.asList(\"scenes\", \"scene\"));\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveAddKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(addData);\r\n    model.addProperty(KEY, Collections.singleton(1), resolver);\r\n    final ImmutableNode node = nodeForKey(model, \"Homer/Ilias/scenes/scene\");\r\n    assertEquals(1, node.getAttributes().get(\"number\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddPropertyAttributeWithSinglePathNode",
  "sourceCode" : "/**\r\n * Tests the special case that an attribute is added with a single path node.\r\n */\r\n@Test\r\nvoid testAddPropertyAttributeWithSinglePathNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final NodeAddData<ImmutableNode> addData = new NodeAddData<>(nodeForKey(ROOT_AUTHORS_TREE, NodeStructureHelper.author(0)), \"year\", true, Arrays.asList(\"dateOfBirth\"));\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveAddKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(addData);\r\n    final Integer year = 1564;\r\n    model.addProperty(KEY, Collections.singleton(year), resolver);\r\n    final ImmutableNode node = nodeForKey(model, \"Shakespeare/dateOfBirth\");\r\n    assertEquals(year, node.getAttributes().get(\"year\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddPropertyNoPathNodes",
  "sourceCode" : "/**\r\n * Tests whether a property can be added if there are no intermediate path nodes.\r\n */\r\n@Test\r\nvoid testAddPropertyNoPathNodes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final NodeAddData<ImmutableNode> addData = new NodeAddData<>(nodeForKey(ROOT_AUTHORS_TREE, \"Homer\"), \"work\", false, null);\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveAddKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(addData);\r\n    model.addProperty(KEY, Collections.singleton(\"Odyssee\"), resolver);\r\n    final ImmutableNode node = nodeForKey(model, \"Homer/work\");\r\n    assertEquals(\"Odyssee\", node.getValue());\r\n    assertNotNull(nodeForKey(model, \"Homer/Ilias/Hektor\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddPropertyNoValues",
  "sourceCode" : "/**\r\n * Tests an addProperty() operation if no values are provided.\r\n */\r\n@Test\r\nvoid testAddPropertyNoValues() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    model.addProperty(KEY, Collections.emptySet(), resolver);\r\n    assertSame(ROOT_AUTHORS_TREE, model.getRootNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddPropertyUpdateParentReferences",
  "sourceCode" : "/**\r\n * Tests whether the parent node references are updated when nodes are added.\r\n */\r\n@Test\r\nvoid testAddPropertyUpdateParentReferences() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final NodeAddData<ImmutableNode> addData = new NodeAddData<>(nodeForKey(ROOT_AUTHORS_TREE, \"Homer/Ilias\"), \"location\", false, Collections.singleton(\"locations\"));\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveAddKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(addData);\r\n    final String[] locations = { \"Troja\", \"Beach\", \"Olympos\" };\r\n    model.addProperty(KEY, Arrays.asList(locations), resolver);\r\n    final String[] path = { \"Homer\", \"Ilias\", \"locations\" };\r\n    final ImmutableNode node = nodeForKey(model, nodePathWithEndNode(\"location(1)\", path));\r\n    checkPathToRoot(model, node, path);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testAddPropertyWithPathNodes",
  "sourceCode" : "/**\r\n * Tests whether a property can be added to the node model if there are some additional path nodes to be created.\r\n */\r\n@Test\r\nvoid testAddPropertyWithPathNodes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final NodeAddData<ImmutableNode> addData = new NodeAddData<>(nodeForKey(ROOT_AUTHORS_TREE, \"Homer/Ilias\"), \"location\", false, Collections.singleton(\"locations\"));\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveAddKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(addData);\r\n    final String[] locations = { \"Troja\", \"Beach\", \"Olympos\" };\r\n    model.addProperty(KEY, Arrays.asList(locations), resolver);\r\n    final ImmutableNode nodeLocs = nodeForKey(model, \"Homer/Ilias/locations\");\r\n    assertEquals(locations.length, nodeLocs.getChildren().size());\r\n    int idx = 0;\r\n    for (final ImmutableNode c : nodeLocs) {\r\n        assertEquals(\"location\", c.getNodeName());\r\n        assertEquals(locations[idx], c.getValue());\r\n        assertTrue(c.getChildren().isEmpty());\r\n        assertTrue(c.getAttributes().isEmpty());\r\n        idx++;\r\n    }\r\n    assertNotNull(nodeForKey(model, \"Homer/Ilias/Hektor\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClear",
  "sourceCode" : "/**\r\n * Tests whether the whole node structure can be cleared.\r\n */\r\n@Test\r\nvoid testClear() {\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    model.clear(createResolver());\r\n    assertFalse(model.getNodeHandler().isDefined(model.getRootNode()));\r\n    assertEquals(ROOT_AUTHORS_TREE.getNodeName(), model.getRootNode().getNodeName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearPropertyAttribute",
  "sourceCode" : "/**\r\n * Tests whether a property value stored as an attribute can be cleared.\r\n */\r\n@Test\r\nvoid testClearPropertyAttribute() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_PERSONAE_TREE);\r\n    final String nodeKey = \"Prospero/The Tempest/\" + NodeStructureHelper.ELEM_ORG_VALUE;\r\n    when(resolver.resolveKey(model.getRootNode(), KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(QueryResult.createAttributeResult(nodeForKey(model, nodeKey), NodeStructureHelper.ATTR_TESTED)));\r\n    model.clearProperty(KEY, resolver);\r\n    final ImmutableNode node = nodeForKey(model, nodeKey);\r\n    assertTrue(node.getAttributes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearPropertyNode",
  "sourceCode" : "/**\r\n * Tests whether a property value can be cleared on a node.\r\n */\r\n@Test\r\nvoid testClearPropertyNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_PERSONAE_TREE);\r\n    final String nodeKey = \"Ariel/The Tempest/\" + NodeStructureHelper.ELEM_ORG_VALUE;\r\n    when(resolver.resolveKey(model.getRootNode(), KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(QueryResult.createNodeResult(nodeForKey(model, nodeKey))));\r\n    model.clearProperty(KEY, resolver);\r\n    final ImmutableNode node = nodeForKey(model, nodeKey);\r\n    assertNull(node.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearPropertyNonExisting",
  "sourceCode" : "/**\r\n * Tests clearProperty() for a non existing property.\r\n */\r\n@Test\r\nvoid testClearPropertyNonExisting() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_PERSONAE_TREE);\r\n    when(resolver.resolveKey(model.getRootNode(), KEY, model.getNodeHandler())).thenReturn(Collections.<QueryResult<ImmutableNode>>emptyList());\r\n    final TreeData treeDataOld = model.getTreeData();\r\n    model.clearProperty(KEY, resolver);\r\n    assertNotNull(model.getNodeHandler().getRootNode());\r\n    assertSame(treeDataOld, model.getTreeData());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeAttribute",
  "sourceCode" : "/**\r\n * Tests whether attributes can be cleared with clearTree().\r\n */\r\n@Test\r\nvoid testClearTreeAttribute() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_PERSONAE_TREE);\r\n    final String nodeName = \"Puck\";\r\n    final QueryResult<ImmutableNode> result = QueryResult.createAttributeResult(nodeForKey(model, nodeName), NodeStructureHelper.ATTR_AUTHOR);\r\n    when(resolver.resolveKey(ROOT_PERSONAE_TREE, KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(result));\r\n    final List<QueryResult<ImmutableNode>> removed = model.clearTree(KEY, resolver);\r\n    final ImmutableNode node = nodeForKey(model, nodeName);\r\n    assertTrue(node.getAttributes().isEmpty());\r\n    assertEquals(1, removed.size());\r\n    assertTrue(removed.contains(result));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeChildrenRemovedFromParentMapping",
  "sourceCode" : "/**\r\n * Tests whether the children of removed nodes are also removed from the parent mapping.\r\n */\r\n@Test\r\nvoid testClearTreeChildrenRemovedFromParentMapping() {\r\n    final String path = \"Homer/Ilias\";\r\n    checkClearTreeUpdatedParentMapping(path, nodeForKey(ROOT_AUTHORS_TREE, path + \"/Achilles\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeNodeRemovedFromParentMapping",
  "sourceCode" : "/**\r\n * Tests whether a removed node can no longer be passed to getParent().\r\n */\r\n@Test\r\nvoid testClearTreeNodeRemovedFromParentMapping() {\r\n    final String path = \"Homer/Ilias/Achilles\";\r\n    checkClearTreeUpdatedParentMapping(path, nodeForKey(ROOT_AUTHORS_TREE, path));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeNodes",
  "sourceCode" : "/**\r\n * Tests whether a clearTree() operation can be performed if only nodes are involved.\r\n */\r\n@Test\r\nvoid testClearTreeNodes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    final QueryResult<ImmutableNode> result = QueryResult.createNodeResult(nodeForKey(model, \"Homer/Ilias/Achilles\"));\r\n    when(resolver.resolveKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(result));\r\n    final List<QueryResult<ImmutableNode>> removed = model.clearTree(KEY, resolver);\r\n    final ImmutableNode node = nodeForKey(model, \"Homer/Ilias\");\r\n    assertEquals(2, node.getChildren().size());\r\n    for (final ImmutableNode c : node) {\r\n        assertNotEquals(result.getNode().getNodeName(), c.getNodeName());\r\n    }\r\n    assertEquals(1, removed.size());\r\n    assertTrue(removed.contains(result));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeNodesAndAttributes",
  "sourceCode" : "/**\r\n * Tests whether both nodes and attributes can be removed by a clearTree() operation. We remove all attributes and\r\n * children from a node. The node becomes undefined and should be removed.\r\n */\r\n@Test\r\nvoid testClearTreeNodesAndAttributes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_PERSONAE_TREE);\r\n    final String nodeName = \"Puck\";\r\n    final ImmutableNode orgNode = nodeForKey(model, nodeName);\r\n    final List<QueryResult<ImmutableNode>> results = new ArrayList<>(2);\r\n    results.add(QueryResult.createAttributeResult(orgNode, NodeStructureHelper.ATTR_AUTHOR));\r\n    results.add(QueryResult.createNodeResult(orgNode.getChildren().get(0)));\r\n    when(resolver.resolveKey(ROOT_PERSONAE_TREE, KEY, model.getNodeHandler())).thenReturn(results);\r\n    model.clearTree(KEY, resolver);\r\n    assertThrows(NoSuchElementException.class, () -> nodeForKey(model, nodeName));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeNonExistingKey",
  "sourceCode" : "/**\r\n * Tests clearTree() if the passed in key does not exist.\r\n */\r\n@Test\r\nvoid testClearTreeNonExistingKey() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_PERSONAE_TREE);\r\n    when(resolver.resolveKey(ROOT_PERSONAE_TREE, KEY, model.getNodeHandler())).thenReturn(Collections.<QueryResult<ImmutableNode>>emptyList());\r\n    final TreeData treeDataOld = model.getTreeData();\r\n    assertTrue(model.clearTree(KEY, resolver).isEmpty());\r\n    assertNotNull(model.getNodeHandler().getRootNode());\r\n    assertSame(treeDataOld, model.getTreeData());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeRemoveUndefinedNodes",
  "sourceCode" : "/**\r\n * Tests whether undefined nodes are removed from the hierarchy when clearing properties.\r\n */\r\n@Test\r\nvoid testClearTreeRemoveUndefinedNodes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    final ImmutableNode node = nodeForKey(model, \"Homer/Ilias\");\r\n    final List<QueryResult<ImmutableNode>> results = new ArrayList<>(node.getChildren().size());\r\n    for (final ImmutableNode child : node) {\r\n        results.add(QueryResult.createNodeResult(child));\r\n    }\r\n    when(resolver.resolveKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(results);\r\n    model.clearTree(KEY, resolver);\r\n    assertEquals(NodeStructureHelper.authorsLength() - 1, model.getRootNode().getChildren().size());\r\n    for (final ImmutableNode child : model.getRootNode()) {\r\n        assertNotEquals(\"Homer\", child.getNodeName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeResultIsEmpty",
  "sourceCode" : "/**\r\n * Tests a clearTree() operation which should yield an empty tree structure.\r\n */\r\n@Test\r\nvoid testClearTreeResultIsEmpty() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final ImmutableNode child = new ImmutableNode.Builder().name(\"child\").value(\"test\").create();\r\n    final ImmutableNode root = new ImmutableNode.Builder(1).addChild(child).create();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(root);\r\n    when(resolver.resolveKey(root, KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(QueryResult.createNodeResult(child)));\r\n    model.clearTree(KEY, resolver);\r\n    assertFalse(model.getNodeHandler().isDefined(model.getRootNode()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeRootNode",
  "sourceCode" : "/**\r\n * Tests whether clearTree() handles the root node in a special way.\r\n */\r\n@Test\r\nvoid testClearTreeRootNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    final List<QueryResult<ImmutableNode>> results = new ArrayList<>(2);\r\n    results.add(QueryResult.createNodeResult(nodeForKey(model, NodeStructureHelper.author(0))));\r\n    results.add(QueryResult.createNodeResult(ROOT_AUTHORS_TREE));\r\n    when(resolver.resolveKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(results);\r\n    model.clearTree(KEY, resolver);\r\n    assertFalse(model.getNodeHandler().isDefined(model.getRootNode()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testClearTreeUpdateParentReferences",
  "sourceCode" : "/**\r\n * Tests whether references to parent nodes are updated correctly when clearing properties.\r\n */\r\n@Test\r\nvoid testClearTreeUpdateParentReferences() {\r\n    final String[] path = { \"Homer\", \"Ilias\" };\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    final QueryResult<ImmutableNode> result = QueryResult.createNodeResult(nodeForKey(model, nodePathWithEndNode(\"Achilles\", path)));\r\n    when(resolver.resolveKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(result));\r\n    model.clearTree(KEY, resolver);\r\n    checkPathToRoot(model, nodeForKey(model, nodePathWithEndNode(\"Hektor\", path)), path);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testCompactReplacementMapping",
  "sourceCode" : "/**\r\n * Tests whether the replacement mapping is automatically compacted if it gets too large.\r\n */\r\n@Test\r\nvoid testCompactReplacementMapping() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    final int numberOfOperations = 200;\r\n    final String key = \"Homer/Ilias\";\r\n    for (int i = 0; i < numberOfOperations; i++) {\r\n        final int index = i;\r\n        when(resolver.resolveAddKey(any(), eq(KEY), any())).thenAnswer(invocation -> {\r\n            assertSame(model.getRootNode(), invocation.getArgument(0));\r\n            final ImmutableNode addParent = nodeForKey(model, key);\r\n            return new NodeAddData<>(addParent, \"Warrior\" + index, false, null);\r\n        });\r\n    }\r\n    for (int i = 0; i < numberOfOperations; i++) {\r\n        model.addProperty(KEY, Collections.singleton(i), resolver);\r\n    }\r\n    final ImmutableNode orgNode = nodeForKey(ROOT_AUTHORS_TREE, key);\r\n    final ImmutableNode changedNode = nodeForKey(model, key);\r\n    assertEquals(orgNode.getChildren().size() + numberOfOperations, changedNode.getChildren().size());\r\n    final Map<ImmutableNode, ImmutableNode> replacementMapping = model.getTreeData().copyReplacementMapping();\r\n    assertTrue(replacementMapping.size() < numberOfOperations);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testConcurrentUpdate",
  "sourceCode" : "/**\r\n * Tests whether concurrent updates of the model are handled correctly. This test adds a number of authors in parallel.\r\n * Then it is checked whether all authors have been added correctly.\r\n */\r\n@Test\r\nvoid testConcurrentUpdate() throws InterruptedException {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveAddKey(any(), eq(KEY), any())).thenAnswer(invocation -> {\r\n        final ImmutableNode addParent = invocation.getArgument(0, ImmutableNode.class);\r\n        return new NodeAddData<>(addParent, \"name\", false, Collections.singleton(\"author\"));\r\n    });\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final String authorPrefix = \"newAuthor\";\r\n    final int threadCount = 32;\r\n    final Thread[] threads = new Thread[threadCount];\r\n    for (int i = 0; i < threadCount; i++) {\r\n        final String authorName = authorPrefix + i;\r\n        threads[i] = new Thread(() -> {\r\n            try {\r\n                latch.await();\r\n                model.addProperty(KEY, Collections.singleton(authorName), resolver);\r\n            } catch (final InterruptedException iex) {\r\n                // ignore\r\n            }\r\n        });\r\n        threads[i].start();\r\n    }\r\n    latch.countDown();\r\n    for (final Thread t : threads) {\r\n        t.join();\r\n    }\r\n    final Pattern patternAuthorName = Pattern.compile(Pattern.quote(authorPrefix) + \"(\\\\d+)\");\r\n    final Set<Integer> indices = new HashSet<>();\r\n    for (int i = 0; i < threadCount; i++) {\r\n        final ImmutableNode node = nodeForKey(model, \"author(\" + i + \")/name\");\r\n        final Matcher m = patternAuthorName.matcher(String.valueOf(node.getValue()));\r\n        assertTrue(m.matches(), \"Wrong value: \" + node.getValue());\r\n        final int idx = Integer.parseInt(m.group(1));\r\n        assertTrue(idx >= 0 && idx < threadCount, \"Invalid index: \" + idx);\r\n        indices.add(idx);\r\n    }\r\n    assertEquals(threadCount, indices.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testGetInMemoryRepresentation",
  "sourceCode" : "/**\r\n * Tests whether the model's data can be represented as immutable node objects (which is trivial in this case).\r\n */\r\n@Test\r\nvoid testGetInMemoryRepresentation() {\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_AUTHORS_TREE);\r\n    assertSame(NodeStructureHelper.ROOT_AUTHORS_TREE, model.getInMemoryRepresentation());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testGetNodeHandler",
  "sourceCode" : "/**\r\n * Tests whether the correct node handler is returned.\r\n */\r\n@Test\r\nvoid testGetNodeHandler() {\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_PERSONAE_TREE);\r\n    assertSame(model.getTreeData(), model.getNodeHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testGetRootNodeFromConstructor",
  "sourceCode" : "/**\r\n * Tests whether the correct root node is returned if a tree was passed at construction time.\r\n */\r\n@Test\r\nvoid testGetRootNodeFromConstructor() {\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    assertSame(ROOT_AUTHORS_TREE, model.getRootNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testInitDefaultRoot",
  "sourceCode" : "/**\r\n * Tests whether an undefined default root node is created if none is specified.\r\n */\r\n@Test\r\nvoid testInitDefaultRoot() {\r\n    final InMemoryNodeModel model = new InMemoryNodeModel();\r\n    final ImmutableNode root = model.getRootNode();\r\n    assertNull(root.getNodeName());\r\n    assertNull(root.getValue());\r\n    assertTrue(root.getChildren().isEmpty());\r\n    assertTrue(root.getAttributes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testSetPropertyChangedValues",
  "sourceCode" : "/**\r\n * Tests whether setProperty() can handle changes in node values.\r\n */\r\n@Test\r\nvoid testSetPropertyChangedValues() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_PERSONAE_TREE);\r\n    final String nodeKey = \"Ariel/The Tempest/\" + NodeStructureHelper.ELEM_ORG_VALUE;\r\n    final Map<QueryResult<ImmutableNode>, Object> changedValues = new HashMap<>();\r\n    final String newValue = \"of course\";\r\n    final ImmutableNode changedNode = nodeForKey(model, nodeKey);\r\n    changedValues.put(QueryResult.createAttributeResult(changedNode, NodeStructureHelper.ATTR_TESTED), newValue);\r\n    changedValues.put(QueryResult.createNodeResult(changedNode), newValue);\r\n    final NodeUpdateData<ImmutableNode> updateData = new NodeUpdateData<>(changedValues, null, null, null);\r\n    when(resolver.resolveUpdateKey(NodeStructureHelper.ROOT_PERSONAE_TREE, KEY, this, model.getNodeHandler())).thenReturn(updateData);\r\n    model.setProperty(KEY, this, resolver);\r\n    final ImmutableNode node = nodeForKey(model, nodeKey);\r\n    assertEquals(newValue, node.getAttributes().get(NodeStructureHelper.ATTR_TESTED));\r\n    assertEquals(newValue, node.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testSetPropertyClearValues",
  "sourceCode" : "/**\r\n * Tests whether setProperty() can handle nodes to be cleared.\r\n */\r\n@Test\r\nvoid testSetPropertyClearValues() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_PERSONAE_TREE);\r\n    final String nodeKey = \"Ariel/The Tempest/\" + NodeStructureHelper.ELEM_ORG_VALUE;\r\n    final NodeUpdateData<ImmutableNode> updateData = new NodeUpdateData<>(null, null, Collections.singletonList(QueryResult.createNodeResult(nodeForKey(model, nodeKey))), null);\r\n    when(resolver.resolveUpdateKey(NodeStructureHelper.ROOT_PERSONAE_TREE, KEY, this, model.getNodeHandler())).thenReturn(updateData);\r\n    model.setProperty(KEY, this, resolver);\r\n    final ImmutableNode node = nodeForKey(model, nodeKey);\r\n    assertNull(node.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testSetPropertyNewValues",
  "sourceCode" : "/**\r\n * Tests whether setProperty() can handle newly added values.\r\n */\r\n@Test\r\nvoid testSetPropertyNewValues() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final NodeAddData<ImmutableNode> addData = new NodeAddData<>(nodeForKey(ROOT_AUTHORS_TREE, \"Homer\"), \"work\", false, null);\r\n    final NodeUpdateData<ImmutableNode> updateData = new NodeUpdateData<>(null, Collections.<Object>singleton(\"Odyssee\"), null, KEY);\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(ROOT_AUTHORS_TREE);\r\n    when(resolver.resolveUpdateKey(ROOT_AUTHORS_TREE, KEY, this, model.getNodeHandler())).thenReturn(updateData);\r\n    when(resolver.resolveAddKey(ROOT_AUTHORS_TREE, KEY, model.getNodeHandler())).thenReturn(addData);\r\n    model.setProperty(KEY, this, resolver);\r\n    final ImmutableNode node = nodeForKey(model, \"Homer/work\");\r\n    assertEquals(\"Odyssee\", node.getValue());\r\n    assertNotNull(nodeForKey(model, \"Homer/Ilias/Hektor\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testSetPropertyNoChanges",
  "sourceCode" : "/**\r\n * Tests a set property operation which is a no-op.\r\n */\r\n@Test\r\nvoid testSetPropertyNoChanges() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_PERSONAE_TREE);\r\n    when(resolver.resolveUpdateKey(NodeStructureHelper.ROOT_PERSONAE_TREE, KEY, this, model.getNodeHandler())).thenReturn(new NodeUpdateData<>(null, null, null, null));\r\n    model.setProperty(KEY, this, resolver);\r\n    assertSame(NodeStructureHelper.ROOT_PERSONAE_TREE, model.getRootNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testSetRoot",
  "sourceCode" : "/**\r\n * Tests whether a new root node can be set.\r\n */\r\n@Test\r\nvoid testSetRoot() {\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_PERSONAE_TREE);\r\n    model.setRootNode(NodeStructureHelper.ROOT_AUTHORS_TREE);\r\n    assertSame(NodeStructureHelper.ROOT_AUTHORS_TREE, model.getRootNode());\r\n    final ImmutableNode node = nodeForKey(model, \"Homer/Ilias\");\r\n    assertEquals(nodeForKey(model, \"Homer\"), model.getNodeHandler().getParent(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModel.java",
  "methodName" : "testSetRootNull",
  "sourceCode" : "/**\r\n * Tests whether the root node can be set to null.\r\n */\r\n@Test\r\nvoid testSetRootNull() {\r\n    final InMemoryNodeModel model = new InMemoryNodeModel(NodeStructureHelper.ROOT_PERSONAE_TREE);\r\n    model.setRootNode(null);\r\n    final ImmutableNode rootNode = model.getRootNode();\r\n    assertTrue(rootNode.getChildren().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testMergeRootOverrideName",
  "sourceCode" : "/**\r\n * Tests whether the name of the root node can be changed during a merge operation.\r\n */\r\n@Test\r\nvoid testMergeRootOverrideName() {\r\n    final ImmutableNode node = NodeStructureHelper.createNode(\"newNode\", null);\r\n    final String newName = \"newRootNode\";\r\n    model.mergeRoot(node, newName, null, null, resolver);\r\n    final ImmutableNode root = model.getNodeHandler().getRootNode();\r\n    assertEquals(newName, root.getNodeName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testMergeRootReference",
  "sourceCode" : "/**\r\n * Tests whether mergeRoot() handles an explicit reference object for the root node correctly.\r\n */\r\n@Test\r\nvoid testMergeRootReference() {\r\n    final Object rootRef = 20140404210508L;\r\n    final ImmutableNode node = NodeStructureHelper.createNode(\"newNode\", null);\r\n    model.mergeRoot(node, null, null, rootRef, resolver);\r\n    final ReferenceNodeHandler refHandler = model.getReferenceNodeHandler();\r\n    final ImmutableNode checkNode = NodeStructureHelper.nodeForKey(model, \"Simmons/Ilium\");\r\n    assertEquals(checkNode.getNodeName(), refHandler.getReference(checkNode));\r\n    assertEquals(rootRef, refHandler.getReference(refHandler.getRootNode()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testMergeRootWithAttributes",
  "sourceCode" : "/**\r\n * Tests whether attributes are taken into account by a merge operation.\r\n */\r\n@Test\r\nvoid testMergeRootWithAttributes() {\r\n    final ImmutableNode node = new ImmutableNode.Builder().addAttribute(\"key\", \"value\").create();\r\n    model.mergeRoot(node, null, null, null, resolver);\r\n    final ImmutableNode root = model.getNodeHandler().getRootNode();\r\n    assertEquals(Collections.singletonMap(\"key\", \"value\"), root.getAttributes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testMergeRootWithValue",
  "sourceCode" : "/**\r\n * Tests whether a value is taken into account when the root node is merged.\r\n */\r\n@Test\r\nvoid testMergeRootWithValue() {\r\n    final ImmutableNode node = NodeStructureHelper.createNode(\"newNode\", \"test\");\r\n    model.mergeRoot(node, null, null, null, resolver);\r\n    final ImmutableNode root = model.getNodeHandler().getRootNode();\r\n    assertEquals(NodeStructureHelper.ROOT_AUTHORS_TREE.getNodeName(), root.getNodeName());\r\n    assertEquals(\"test\", root.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testQueryReferences",
  "sourceCode" : "/**\r\n * Tests whether the stored references can be queried.\r\n */\r\n@Test\r\nvoid testQueryReferences() {\r\n    final ReferenceNodeHandler handler = model.getReferenceNodeHandler();\r\n    final Collection<ImmutableNode> nodes = collectNodes(handler.getRootNode());\r\n    for (final ImmutableNode node : nodes) {\r\n        assertEquals(node.getNodeName(), handler.getReference(node));\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testQueryReferencesAfterUpdate",
  "sourceCode" : "/**\r\n * Tests whether references can be queried after an update operation.\r\n */\r\n@Test\r\nvoid testQueryReferencesAfterUpdate() {\r\n    model.addProperty(\"Simmons.Hyperion\", Collections.singleton(\"Lamia\"), resolver);\r\n    final ReferenceNodeHandler handler = model.getReferenceNodeHandler();\r\n    assertEquals(\"Hyperion\", handler.getReference(NodeStructureHelper.nodeForKey(model, \"Simmons/Hyperion\")));\r\n    assertEquals(\"Simmons\", handler.getReference(NodeStructureHelper.nodeForKey(model, \"Simmons\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testQueryReferenceUnknown",
  "sourceCode" : "/**\r\n * Tests the reference returned for an unknown node.\r\n */\r\n@Test\r\nvoid testQueryReferenceUnknown() {\r\n    final ReferenceNodeHandler handler = model.getReferenceNodeHandler();\r\n    assertNull(handler.getReference(new ImmutableNode.Builder().create()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testQueryRemovedReferencesAfterRemove",
  "sourceCode" : "/**\r\n * Tests whether removed references can be queried.\r\n */\r\n@Test\r\nvoid testQueryRemovedReferencesAfterRemove() {\r\n    model.clearTree(\"Simmons\", resolver);\r\n    final ReferenceNodeHandler handler = model.getReferenceNodeHandler();\r\n    final List<Object> removedRefs = handler.removedReferences();\r\n    final int authorIdx = 2;\r\n    for (int i = 0; i < NodeStructureHelper.worksLength(authorIdx); i++) {\r\n        assertTrue(removedRefs.contains(NodeStructureHelper.work(authorIdx, i)), \"Work not found: \" + i);\r\n        for (int j = 0; j < NodeStructureHelper.personaeLength(authorIdx, i); j++) {\r\n            assertTrue(removedRefs.contains(NodeStructureHelper.persona(authorIdx, i, j)), \"Persona not found: \" + j);\r\n        }\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testQueryRemovedReferencesEmpty",
  "sourceCode" : "/**\r\n * Tests whether the removed references can be queried if there are none.\r\n */\r\n@Test\r\nvoid testQueryRemovedReferencesEmpty() {\r\n    final ReferenceNodeHandler handler = model.getReferenceNodeHandler();\r\n    assertTrue(handler.removedReferences().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testRemovedReferencesModify",
  "sourceCode" : "/**\r\n * Tests that the list with removed references cannot be modified.\r\n */\r\n@Test\r\nvoid testRemovedReferencesModify() {\r\n    model.clearTree(\"Simmons\", resolver);\r\n    final ReferenceNodeHandler handler = model.getReferenceNodeHandler();\r\n    final List<Object> removedRefs = handler.removedReferences();\r\n    assertThrows(UnsupportedOperationException.class, () -> removedRefs.add(\"another one\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testReplaceRoot",
  "sourceCode" : "/**\r\n * Tests whether the root node of the model can be replaced.\r\n */\r\n@Test\r\nvoid testReplaceRoot() {\r\n    final NodeSelector selector = new NodeSelector(\"Simmons.Hyperion\");\r\n    model.trackNode(selector, resolver);\r\n    final ImmutableNode trackedNode = model.getTrackedNode(selector);\r\n    model.addProperty(\"Simmons.Hyperion.Lamia\", Collections.singleton(\"new person\"), resolver);\r\n    model.replaceRoot(NodeStructureHelper.ROOT_AUTHORS_TREE, resolver);\r\n    final ImmutableNode node = model.getTrackedNode(selector);\r\n    assertEquals(trackedNode, node);\r\n    assertFalse(model.isTrackedNodeDetached(selector));\r\n    assertNull(model.getReferenceNodeHandler().getReference(trackedNode));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelReferences.java",
  "methodName" : "testReplaceRootNull",
  "sourceCode" : "/**\r\n * Tries to call replaceRoot() with a null node.\r\n */\r\n@Test\r\nvoid testReplaceRootNull() {\r\n    assertThrows(IllegalArgumentException.class, () -> model.replaceRoot(null, resolver));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testAddNodesOnDetachedNode",
  "sourceCode" : "/**\r\n * Tests an addNodes() operation on a tracked node that is detached.\r\n */\r\n@Test\r\nvoid testAddNodesOnDetachedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    NodeStructureHelper.prepareResolveAddKeys(resolver);\r\n    model.trackNode(selector, resolver);\r\n    initDetachedNode(resolver);\r\n    final ImmutableNode rootNode = model.getRootNode();\r\n    model.addNodes(\"fields\", selector, Collections.singleton(NodeStructureHelper.createFieldNode(NEW_FIELD)), resolver);\r\n    assertSame(rootNode, model.getRootNode());\r\n    checkForAddedField(fieldsNodeFromTrackedNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testAddNodesOnTrackedNode",
  "sourceCode" : "/**\r\n * Tests whether an addNodes() operation works on a tracked node.\r\n */\r\n@Test\r\nvoid testAddNodesOnTrackedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    NodeStructureHelper.prepareResolveAddKeys(resolver);\r\n    model.trackNode(selector, resolver);\r\n    model.addNodes(\"fields\", selector, Collections.singleton(NodeStructureHelper.createFieldNode(NEW_FIELD)), resolver);\r\n    checkForAddedField(fieldsNodeFromModel());\r\n    checkForAddedField(fieldsNodeFromTrackedNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testAddPropertyOnDetachedNode",
  "sourceCode" : "/**\r\n * Tests an addProperty() operation on a tracked node that is detached.\r\n */\r\n@Test\r\nvoid testAddPropertyOnDetachedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    NodeStructureHelper.prepareResolveAddKeys(resolver);\r\n    model.trackNode(selector, resolver);\r\n    initDetachedNode(resolver);\r\n    final ImmutableNode rootNode = model.getRootNode();\r\n    model.addProperty(\"fields.field(-1).name\", selector, Collections.singleton(NEW_FIELD), resolver);\r\n    assertSame(rootNode, model.getRootNode());\r\n    checkForAddedField(fieldsNodeFromTrackedNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testAddPropertyOnTrackedNode",
  "sourceCode" : "/**\r\n * Tests whether an addProperty() operation works on a tracked node.\r\n */\r\n@Test\r\nvoid testAddPropertyOnTrackedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    NodeStructureHelper.prepareResolveAddKeys(resolver);\r\n    model.trackNode(selector, resolver);\r\n    model.addProperty(\"fields.field(-1).name\", selector, Collections.singleton(NEW_FIELD), resolver);\r\n    checkForAddedField(fieldsNodeFromModel());\r\n    checkForAddedField(fieldsNodeFromTrackedNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testClearPropertyOnDetachedNode",
  "sourceCode" : "/**\r\n * Tests a clearProperty() operation on a tracked node which is detached.\r\n */\r\n@Test\r\nvoid testClearPropertyOnDetachedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    initDetachedNode(resolver);\r\n    final ImmutableNode rootNode = model.getRootNode();\r\n    model.clearProperty(\"fields.field(0).name\", selector, resolver);\r\n    assertSame(rootNode, model.getRootNode());\r\n    final ImmutableNode nodeFields = fieldsNodeFromTrackedNode();\r\n    checkForRemovedField(nodeFields, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testClearPropertyOnTrackedNode",
  "sourceCode" : "/**\r\n * Tests whether clearProperty() can operate on a tracked node.\r\n */\r\n@Test\r\nvoid testClearPropertyOnTrackedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.clearProperty(\"fields.field(0).name\", selector, resolver);\r\n    final ImmutableNode nodeFields = fieldsNodeFromModel();\r\n    checkForRemovedField(nodeFields, 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testClearTreeOnDetachedNode",
  "sourceCode" : "/**\r\n * Tests a clearTree() operation on a tracked node which is detached.\r\n */\r\n@Test\r\nvoid testClearTreeOnDetachedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    initDetachedNode(resolver);\r\n    final ImmutableNode rootNode = model.getRootNode();\r\n    model.clearTree(\"fields.field(1)\", selector, resolver);\r\n    assertSame(rootNode, model.getRootNode());\r\n    final ImmutableNode nodeFields = fieldsNodeFromTrackedNode();\r\n    checkForRemovedField(nodeFields, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testClearTreeOnTrackedNode",
  "sourceCode" : "/**\r\n * Tests whether clearTree() can operate on a tracked node.\r\n */\r\n@Test\r\nvoid testClearTreeOnTrackedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.clearTree(\"fields.field(1)\", selector, resolver);\r\n    final ImmutableNode nodeFields = fieldsNodeFromModel();\r\n    checkForRemovedField(nodeFields, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testGetTrackedNodeAfterClear",
  "sourceCode" : "/**\r\n * Tests whether a tracked node can be queried even after the model was cleared.\r\n */\r\n@Test\r\nvoid testGetTrackedNodeAfterClear() {\r\n    final ImmutableNode node = NodeStructureHelper.nodeForKey(model, \"tables/table(1)\");\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.clear(resolver);\r\n    assertSame(node, model.getTrackedNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testGetTrackedNodeAfterSetRootNode",
  "sourceCode" : "/**\r\n * Tests whether a tracked node can be queried after the root node was changed.\r\n */\r\n@Test\r\nvoid testGetTrackedNodeAfterSetRootNode() {\r\n    final ImmutableNode node = NodeStructureHelper.nodeForKey(model, \"tables/table(1)\");\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.setRootNode(root);\r\n    assertSame(node, model.getTrackedNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testGetTrackedNodeAfterUpdate",
  "sourceCode" : "/**\r\n * Tests whether a tracked node survives updates of the node model.\r\n */\r\n@Test\r\nvoid testGetTrackedNodeAfterUpdate() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.clearProperty(\"tables.table(1).fields.field(1).name\", resolver);\r\n    final ImmutableNode node = model.getTrackedNode(selector);\r\n    assertEquals(NodeStructureHelper.table(1), node.getChildren().get(0).getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testGetTrackedNodeAfterUpdateNoLongerExisting",
  "sourceCode" : "/**\r\n * Tests whether a tracked node can be queried even if it was removed from the structure.\r\n */\r\n@Test\r\nvoid testGetTrackedNodeAfterUpdateNoLongerExisting() {\r\n    final ImmutableNode node = NodeStructureHelper.nodeForKey(model, \"tables/table(1)\");\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    initDetachedNode(resolver);\r\n    assertSame(node, model.getTrackedNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testGetTrackedNodeExisting",
  "sourceCode" : "/**\r\n * Tests whether a tracked node can be queried.\r\n */\r\n@Test\r\nvoid testGetTrackedNodeExisting() {\r\n    final ImmutableNode node = NodeStructureHelper.nodeForKey(model, \"tables/table(1)\");\r\n    model.trackNode(selector, createResolver());\r\n    assertSame(node, model.getTrackedNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testGetTrackedNodeHandlerActive",
  "sourceCode" : "/**\r\n * Tests whether a node handler for a tracked node can be queried which is still active.\r\n */\r\n@Test\r\nvoid testGetTrackedNodeHandlerActive() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    final NodeHandler<ImmutableNode> handler = model.getTrackedNodeHandler(selector);\r\n    final TrackedNodeHandler tnh = assertInstanceOf(TrackedNodeHandler.class, handler);\r\n    assertSame(model.getTrackedNode(selector), handler.getRootNode());\r\n    assertSame(model.getTreeData(), tnh.getParentHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testGetTrackedNodeHandlerDetached",
  "sourceCode" : "/**\r\n * Tests whether a node handler for a detached tracked node can be queried.\r\n */\r\n@Test\r\nvoid testGetTrackedNodeHandlerDetached() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    initDetachedNode(resolver);\r\n    final NodeHandler<ImmutableNode> handler = model.getTrackedNodeHandler(selector);\r\n    assertSame(model.getTrackedNode(selector), handler.getRootNode());\r\n    assertInstanceOf(TreeData.class, handler);\r\n    assertNotSame(model.getNodeHandler(), handler);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testGetTrackedNodeNonExisting",
  "sourceCode" : "/**\r\n * Tries to obtain a tracked node which is unknown.\r\n */\r\n@Test\r\nvoid testGetTrackedNodeNonExisting() {\r\n    assertThrows(ConfigurationRuntimeException.class, () -> model.getTrackedNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testIsDetachedAfterClear",
  "sourceCode" : "/**\r\n * Tests whether a clear() operation causes nodes to be detached.\r\n */\r\n@Test\r\nvoid testIsDetachedAfterClear() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.clear(resolver);\r\n    assertTrue(model.isTrackedNodeDetached(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testIsDetachedAfterSetRoot",
  "sourceCode" : "/**\r\n * Tests whether tracked nodes become detached when a new root node is set.\r\n */\r\n@Test\r\nvoid testIsDetachedAfterSetRoot() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.clearProperty(\"tables.table(1).fields.field(1).name\", resolver);\r\n    model.setRootNode(root);\r\n    assertTrue(model.isTrackedNodeDetached(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testIsDetachedFalseAfterUpdate",
  "sourceCode" : "/**\r\n * Tests isDetached() for a life node.\r\n */\r\n@Test\r\nvoid testIsDetachedFalseAfterUpdate() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.clearProperty(\"tables.table(1).fields.field(1).name\", resolver);\r\n    assertFalse(model.isTrackedNodeDetached(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testIsDetachedFalseNoUpdates",
  "sourceCode" : "/**\r\n * Tests isDetached() for a node which has just been tracked.\r\n */\r\n@Test\r\nvoid testIsDetachedFalseNoUpdates() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    assertFalse(model.isTrackedNodeDetached(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testIsDetachedTrue",
  "sourceCode" : "/**\r\n * Tests isDetached() for an actually detached node.\r\n */\r\n@Test\r\nvoid testIsDetachedTrue() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    initDetachedNode(resolver);\r\n    assertTrue(model.isTrackedNodeDetached(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testReplaceTrackedNodeForActiveTrackedNode",
  "sourceCode" : "/**\r\n * Tests whether an active tracked node can be replaced.\r\n */\r\n@Test\r\nvoid testReplaceTrackedNodeForActiveTrackedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    checkReplaceTrackedNode();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testReplaceTrackedNodeForDetachedNode",
  "sourceCode" : "/**\r\n * Tests whether a detached tracked node can be replaced.\r\n */\r\n@Test\r\nvoid testReplaceTrackedNodeForDetachedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    initDetachedNode(resolver);\r\n    checkReplaceTrackedNode();\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testReplaceTrackedNodeNull",
  "sourceCode" : "/**\r\n * Tries to replace a tracked node with a null node.\r\n */\r\n@Test\r\nvoid testReplaceTrackedNodeNull() {\r\n    model.trackNode(selector, createResolver());\r\n    assertThrows(IllegalArgumentException.class, () -> model.replaceTrackedNode(selector, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testSelectAndTrackNodes",
  "sourceCode" : "/**\r\n * Tests whether tracked nodes can be created from a key.\r\n */\r\n@Test\r\nvoid testSelectAndTrackNodes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final String nodeKey1 = \"tables/table(0)\";\r\n    final String nodeKey2 = \"tables/table(1)\";\r\n    final ImmutableNode node1 = NodeStructureHelper.nodeForKey(root, nodeKey1);\r\n    final ImmutableNode node2 = NodeStructureHelper.nodeForKey(root, nodeKey2);\r\n    when(resolver.resolveNodeKey(root, TEST_KEY, model.getNodeHandler())).thenReturn(Arrays.asList(node1, node2));\r\n    prepareNodeKey(resolver, node1, nodeKey1);\r\n    prepareNodeKey(resolver, node2, nodeKey2);\r\n    final Collection<NodeSelector> selectors = model.selectAndTrackNodes(TEST_KEY, resolver);\r\n    final Iterator<NodeSelector> it = selectors.iterator();\r\n    NodeSelector sel = it.next();\r\n    assertEquals(new NodeSelector(nodeKey1), sel);\r\n    assertSame(node1, model.getTrackedNode(sel));\r\n    sel = it.next();\r\n    assertEquals(new NodeSelector(nodeKey2), sel);\r\n    assertSame(node2, model.getTrackedNode(sel));\r\n    assertFalse(it.hasNext());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testSelectAndTrackNodesNodeAlreadyTracked",
  "sourceCode" : "/**\r\n * Tests whether selectAndTrackNodes() works for nodes that are already tracked.\r\n */\r\n@Test\r\nvoid testSelectAndTrackNodesNodeAlreadyTracked() {\r\n    NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    resolver = createResolver();\r\n    final ImmutableNode node = model.getTrackedNode(selector);\r\n    when(resolver.resolveNodeKey(root, TEST_KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(node));\r\n    prepareNodeKey(resolver, node, SELECTOR_KEY);\r\n    final Collection<NodeSelector> selectors = model.selectAndTrackNodes(TEST_KEY, resolver);\r\n    assertEquals(1, selectors.size());\r\n    assertEquals(selector, selectors.iterator().next());\r\n    model.untrackNode(selector);\r\n    assertSame(node, model.getTrackedNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testSelectAndTrackNodesNoSelection",
  "sourceCode" : "/**\r\n * Tests selectAndTrackNodes() if the key does not select any nodes.\r\n */\r\n@Test\r\nvoid testSelectAndTrackNodesNoSelection() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    when(resolver.resolveNodeKey(root, TEST_KEY, model.getNodeHandler())).thenReturn(Collections.<ImmutableNode>emptyList());\r\n    assertTrue(model.selectAndTrackNodes(TEST_KEY, resolver).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testSetPropertyOnDetachedNode",
  "sourceCode" : "/**\r\n * Tests a setProperty() operation on a tracked node that is detached.\r\n */\r\n@Test\r\nvoid testSetPropertyOnDetachedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    prepareResolverForUpdateKeys(resolver);\r\n    model.trackNode(selector, resolver);\r\n    initDetachedNode(resolver);\r\n    final ImmutableNode rootNode = model.getRootNode();\r\n    model.setProperty(\"fields.field(0).name\", selector, NEW_FIELD, resolver);\r\n    assertSame(rootNode, model.getRootNode());\r\n    checkedForChangedField(fieldsNodeFromTrackedNode(), 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testSetPropertyOnTrackedNode",
  "sourceCode" : "/**\r\n * Tests whether a setProperty() operation works on a tracked node.\r\n */\r\n@Test\r\nvoid testSetPropertyOnTrackedNode() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    prepareResolverForUpdateKeys(resolver);\r\n    model.trackNode(selector, resolver);\r\n    model.setProperty(\"fields.field(0).name\", selector, NEW_FIELD, resolver);\r\n    checkedForChangedField(fieldsNodeFromModel(), 0);\r\n    checkedForChangedField(fieldsNodeFromTrackedNode(), 0);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackChildNodes",
  "sourceCode" : "/**\r\n * Tests whether all children of a node can be tracked at once.\r\n */\r\n@Test\r\nvoid testTrackChildNodes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final ImmutableNode node = NodeStructureHelper.nodeForKey(root, \"tables\");\r\n    final String[] keys = new String[node.getChildren().size()];\r\n    for (int i = 0; i < keys.length; i++) {\r\n        final ImmutableNode child = node.getChildren().get(i);\r\n        keys[i] = String.format(\"%s.%s(%d)\", node.getNodeName(), child.getNodeName(), i);\r\n        prepareNodeKey(resolver, child, keys[i]);\r\n    }\r\n    when(resolver.resolveNodeKey(root, TEST_KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(node));\r\n    final Collection<NodeSelector> selectors = model.trackChildNodes(TEST_KEY, resolver);\r\n    assertEquals(node.getChildren().size(), selectors.size());\r\n    int idx = 0;\r\n    for (final NodeSelector sel : selectors) {\r\n        assertEquals(new NodeSelector(keys[idx]), sel);\r\n        assertEquals(node.getChildren().get(idx), model.getTrackedNode(sel), \"Wrong tracked node for \" + sel);\r\n        idx++;\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackChildNodesMultipleResults",
  "sourceCode" : "/**\r\n * Tests trackChildNodes() for a key that returns more than a single result.\r\n */\r\n@Test\r\nvoid testTrackChildNodesMultipleResults() {\r\n    checkTrackChildNodesNoResult(Arrays.asList(NodeStructureHelper.nodeForKey(root, \"tables/table(0)\"), NodeStructureHelper.nodeForKey(root, \"tables/table(1)\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackChildNodesNodeWithNoChildren",
  "sourceCode" : "/**\r\n * Tests trackChildNodes() for a key pointing to a node with no children.\r\n */\r\n@Test\r\nvoid testTrackChildNodesNodeWithNoChildren() {\r\n    checkTrackChildNodesNoResult(Collections.singletonList(NodeStructureHelper.nodeForKey(root, \"tables/table(0)/name\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackChildNodesNoResults",
  "sourceCode" : "/**\r\n * Tests trackChildNodes() for a key that does not return any results.\r\n */\r\n@Test\r\nvoid testTrackChildNodesNoResults() {\r\n    checkTrackChildNodesNoResult(Collections.<ImmutableNode>emptyList());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackChildNodeWithCreationExisting",
  "sourceCode" : "/**\r\n * Tests whether an existing child of a selected node can be tracked.\r\n */\r\n@Test\r\nvoid testTrackChildNodeWithCreationExisting() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final String childName = \"name\";\r\n    final String parentKey = \"tables/table(0)\";\r\n    final String childKey = parentKey + \"/\" + childName;\r\n    final ImmutableNode node = NodeStructureHelper.nodeForKey(model, parentKey);\r\n    final ImmutableNode child = NodeStructureHelper.nodeForKey(node, childName);\r\n    when(resolver.resolveNodeKey(root, TEST_KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(node));\r\n    prepareNodeKey(resolver, child, childKey);\r\n    final NodeSelector childSelector = model.trackChildNodeWithCreation(TEST_KEY, childName, resolver);\r\n    assertEquals(new NodeSelector(childKey), childSelector);\r\n    assertSame(child, model.getTrackedNode(childSelector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackChildNodeWithCreationMultipleResults",
  "sourceCode" : "/**\r\n * Tests trackChildNodeWithCreation() if the passed in key selects multiple nodes.\r\n */\r\n@Test\r\nvoid testTrackChildNodeWithCreationMultipleResults() {\r\n    final List<ImmutableNode> nodes = Arrays.asList(NodeStructureHelper.nodeForKey(root, \"tables/table(0)\"), NodeStructureHelper.nodeForKey(root, \"tables/table(1)\"));\r\n    checkTrackChildNodeWithCreationInvalidKey(nodes);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackChildNodeWithCreationNonExisting",
  "sourceCode" : "/**\r\n * Tests whether a child node to be tracked is created if necessary.\r\n */\r\n@Test\r\nvoid testTrackChildNodeWithCreationNonExisting() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    final String childName = \"space\";\r\n    final String parentKey = \"tables/table(0)\";\r\n    final String childKey = parentKey + \"/\" + childName;\r\n    final ImmutableNode node = NodeStructureHelper.nodeForKey(model, parentKey);\r\n    when(resolver.resolveNodeKey(root, TEST_KEY, model.getNodeHandler())).thenReturn(Collections.singletonList(node));\r\n    when(resolver.nodeKey(any(), eq(new HashMap<>()), any())).thenReturn(childKey);\r\n    final NodeSelector childSelector = model.trackChildNodeWithCreation(TEST_KEY, childName, resolver);\r\n    assertEquals(new NodeSelector(childKey), childSelector);\r\n    final ImmutableNode child = model.getTrackedNode(childSelector);\r\n    assertEquals(childName, child.getNodeName());\r\n    assertNull(child.getValue());\r\n    final ImmutableNode parent = model.getNodeHandler().getParent(child);\r\n    assertEquals(\"table\", parent.getNodeName());\r\n    assertEquals(child, NodeStructureHelper.nodeForKey(model, childKey));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackChildNodeWithCreationNoResults",
  "sourceCode" : "/**\r\n * Tests trackChildNodeWithCreation() if the passed in key does not select a node.\r\n */\r\n@Test\r\nvoid testTrackChildNodeWithCreationNoResults() {\r\n    checkTrackChildNodeWithCreationInvalidKey(new ArrayList<>());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackedNodeClearedInOperation",
  "sourceCode" : "/**\r\n * Tests whether a tracked node is handled correctly if an operation is executed on this node which causes the node to\r\n * be detached. In this case, the node should be cleared (it makes no sense to use the last defined node instance).\r\n */\r\n@Test\r\nvoid testTrackedNodeClearedInOperation() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.clearTree(null, selector, resolver);\r\n    assertTrue(model.isTrackedNodeDetached(selector));\r\n    final ImmutableNode node = model.getTrackedNode(selector);\r\n    assertEquals(\"table\", node.getNodeName());\r\n    assertFalse(model.getNodeHandler().isDefined(node));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackNodeKeyMultipleResults",
  "sourceCode" : "/**\r\n * Tries to call trackNode() with a key that selects multiple results.\r\n */\r\n@Test\r\nvoid testTrackNodeKeyMultipleResults() {\r\n    final NodeSelector nodeSelector = new NodeSelector(\"tables.table.fields.field.name\");\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    assertThrows(ConfigurationRuntimeException.class, () -> model.trackNode(nodeSelector, resolver));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackNodeKeyNoResults",
  "sourceCode" : "/**\r\n * Tries to call trackNode() with a key that does not yield any results.\r\n */\r\n@Test\r\nvoid testTrackNodeKeyNoResults() {\r\n    final NodeSelector nodeSelector = new NodeSelector(\"tables.unknown\");\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    assertThrows(ConfigurationRuntimeException.class, () -> model.trackNode(nodeSelector, resolver));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testTrackNodeMultipleTimes",
  "sourceCode" : "/**\r\n * Tests whether a single node can be tracked multiple times.\r\n */\r\n@Test\r\nvoid testTrackNodeMultipleTimes() {\r\n    final NodeKeyResolver<ImmutableNode> resolver = createResolver();\r\n    model.trackNode(selector, resolver);\r\n    model.trackNode(selector, resolver);\r\n    model.untrackNode(selector);\r\n    assertNotNull(model.getTrackedNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testUntrackNode",
  "sourceCode" : "/**\r\n * Tests whether tracking of a node can be stopped.\r\n */\r\n@Test\r\nvoid testUntrackNode() {\r\n    model.trackNode(selector, createResolver());\r\n    model.untrackNode(selector);\r\n    assertThrows(ConfigurationRuntimeException.class, () -> model.getTrackedNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestInMemoryNodeModelTrackedNodes.java",
  "methodName" : "testUntrackNodeNonExisting",
  "sourceCode" : "/**\r\n * Tries to stop tracking of a node which is not tracked.\r\n */\r\n@Test\r\nvoid testUntrackNodeNonExisting() {\r\n    assertThrows(ConfigurationRuntimeException.class, () -> model.untrackNode(selector));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestMergeCombiner.java",
  "methodName" : "testAttributes",
  "sourceCode" : "/**\r\n * Tests combination of attributes.\r\n */\r\n@Test\r\nvoid testAttributes() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(1, config.getInt(\"gui.level[@min]\"));\r\n    assertEquals(2, config.getInt(\"gui.level[@default]\"));\r\n    assertEquals(0, config.getMaxIndex(\"database.tables.table(0)[@id]\"));\r\n    assertEquals(1, config.getInt(\"database.tables.table(0)[@id]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestMergeCombiner.java",
  "methodName" : "testCombinedTable",
  "sourceCode" : "/**\r\n * Tests the combination of the table structure. With the merge combiner both table 1 and table 2 should be present.\r\n */\r\n@Test\r\nvoid testCombinedTable() throws ConfigurationException {\r\n    checkTable(createCombinedConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestMergeCombiner.java",
  "methodName" : "testListFromFirstStructure",
  "sourceCode" : "/**\r\n * Tests if a list from the first node structure overrides a list in the second structure.\r\n */\r\n@Test\r\nvoid testListFromFirstStructure() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(0, config.getMaxIndex(\"net.service.url\"));\r\n    assertEquals(\"http://service1.org\", config.getString(\"net.service.url\"));\r\n    assertFalse(config.containsKey(\"net.service.url[@type]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestMergeCombiner.java",
  "methodName" : "testListFromSecondStructure",
  "sourceCode" : "/**\r\n * Tests if a list from the second structure is added if it is not defined in the first structure.\r\n */\r\n@Test\r\nvoid testListFromSecondStructure() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(3, config.getMaxIndex(\"net.server.url\"));\r\n    assertEquals(\"http://testsvr.com\", config.getString(\"net.server.url(2)\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestMergeCombiner.java",
  "methodName" : "testMerge",
  "sourceCode" : "@Test\r\nvoid testMerge() throws ConfigurationException {\r\n    // combiner.setDebugStream(System.out);\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    config.setExpressionEngine(new XPathExpressionEngine());\r\n    assertEquals(3, config.getMaxIndex(\"Channels/Channel\"));\r\n    assertEquals(\"My Channel\", config.getString(\"Channels/Channel[@id='1']/Name\"));\r\n    assertEquals(\"half\", config.getString(\"Channels/Channel[@id='1']/@type\"));\r\n    assertEquals(\"Channel 2\", config.getString(\"Channels/Channel[@id='2']/Name\"));\r\n    assertEquals(\"full\", config.getString(\"Channels/Channel[@id='2']/@type\"));\r\n    assertEquals(\"test 1 data\", config.getString(\"Channels/Channel[@id='1']/ChannelData\"));\r\n    assertEquals(\"test 2 data\", config.getString(\"Channels/Channel[@id='2']/ChannelData\"));\r\n    assertEquals(\"more test 2 data\", config.getString(\"Channels/Channel[@id='2']/MoreChannelData\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestMergeCombiner.java",
  "methodName" : "testOverrideValues",
  "sourceCode" : "/**\r\n * Tests whether property values are correctly overridden.\r\n */\r\n@Test\r\nvoid testOverrideValues() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(\"Admin\", config.getString(\"base.services.security.login.user\"));\r\n    assertEquals(\"default\", config.getString(\"base.services.security.login.user[@type]\"));\r\n    assertNull(config.getString(\"base.services.security.login.passwd\"));\r\n    assertEquals(\"secret\", config.getString(\"base.services.security.login.passwd[@type]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestMergeCombiner.java",
  "methodName" : "testSimpleValues",
  "sourceCode" : "/**\r\n * Tests combination of simple elements.\r\n */\r\n@Test\r\nvoid testSimpleValues() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(0, config.getMaxIndex(\"gui.bgcolor\"));\r\n    assertEquals(\"green\", config.getString(\"gui.bgcolor\"));\r\n    assertEquals(\"yellow\", config.getString(\"gui.selcolor\"));\r\n    assertEquals(\"blue\", config.getString(\"gui.fgcolor\"));\r\n    assertEquals(1, config.getInt(\"gui.level\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeAddData.java",
  "methodName" : "testInitPathNodesDefensiveCopy",
  "sourceCode" : "/**\r\n * Tests whether a defensive copy of the collection with path nodes is created.\r\n */\r\n@Test\r\nvoid testInitPathNodesDefensiveCopy() {\r\n    final List<String> pathNodes = new ArrayList<>();\r\n    pathNodes.add(PATH_NODE_NAME);\r\n    final NodeAddData<ImmutableNode> data = new NodeAddData<>(parentNode, TEST_NODENAME, false, pathNodes);\r\n    pathNodes.add(\"anotherNode\");\r\n    assertEquals(Arrays.asList(PATH_NODE_NAME), data.getPathNodes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeAddData.java",
  "methodName" : "testPathNodesDefinedModify",
  "sourceCode" : "/**\r\n * Tests that the collection with path nodes cannot be modified if data is available.\r\n */\r\n@Test\r\nvoid testPathNodesDefinedModify() {\r\n    final NodeAddData<ImmutableNode> data = new NodeAddData<>(parentNode, TEST_NODENAME, false, Collections.singleton(PATH_NODE_NAME));\r\n    final List<String> pathNodes = data.getPathNodes();\r\n    assertThrows(UnsupportedOperationException.class, () -> pathNodes.add(\"anotherNode\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeAddData.java",
  "methodName" : "testPathNodesNull",
  "sourceCode" : "/**\r\n * Tests whether the constructor can handle a null collection of path nodes.\r\n */\r\n@Test\r\nvoid testPathNodesNull() {\r\n    final NodeAddData<ImmutableNode> data = new NodeAddData<>(parentNode, TEST_NODENAME, false, null);\r\n    assertTrue(data.getPathNodes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeAddData.java",
  "methodName" : "testPathNodesNullModify",
  "sourceCode" : "/**\r\n * Tests whether the collection with path nodes cannot be modified if no data is available.\r\n */\r\n@Test\r\nvoid testPathNodesNullModify() {\r\n    final NodeAddData<ImmutableNode> data = new NodeAddData<>(parentNode, TEST_NODENAME, false, null);\r\n    final List<String> pathNodes = data.getPathNodes();\r\n    assertThrows(UnsupportedOperationException.class, () -> pathNodes.add(\"test\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeNameMatchers.java",
  "methodName" : "testEqualsIgnoreCaseMatch",
  "sourceCode" : "/**\r\n * Tests the equalsIgnoreCase mather if the expected result is true.\r\n */\r\n@Test\r\nvoid testEqualsIgnoreCaseMatch() {\r\n    final ImmutableNode node = createNode(NODE_NAME);\r\n    assertTrue(NodeNameMatchers.EQUALS_IGNORE_CASE.matches(node, handler, NODE_NAME));\r\n    assertTrue(NodeNameMatchers.EQUALS_IGNORE_CASE.matches(node, handler, StringUtils.toRootLowerCase(NODE_NAME)));\r\n    assertTrue(NodeNameMatchers.EQUALS_IGNORE_CASE.matches(node, handler, StringUtils.toRootUpperCase(NODE_NAME)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeNameMatchers.java",
  "methodName" : "testEqualsIgnoreCaseNoMatch",
  "sourceCode" : "/**\r\n * Tests the equalsIgnoreCase matcher if the expected result is false.\r\n */\r\n@Test\r\nvoid testEqualsIgnoreCaseNoMatch() {\r\n    final ImmutableNode node = createNode(NODE_NAME);\r\n    assertFalse(NodeNameMatchers.EQUALS_IGNORE_CASE.matches(node, handler, NODE_NAME + \"_other\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeNameMatchers.java",
  "methodName" : "testEqualsIgnoreCaseNullCriterion",
  "sourceCode" : "/**\r\n * Tests whether the equalsIgnoreCase matcher is null-safe.\r\n */\r\n@Test\r\nvoid testEqualsIgnoreCaseNullCriterion() {\r\n    checkMatcherWithNullInput(NodeNameMatchers.EQUALS_IGNORE_CASE);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeNameMatchers.java",
  "methodName" : "testEqualsMatch",
  "sourceCode" : "/**\r\n * Tests the equals matcher if the expected result is true.\r\n */\r\n@Test\r\nvoid testEqualsMatch() {\r\n    final ImmutableNode node = createNode(NODE_NAME);\r\n    assertTrue(NodeNameMatchers.EQUALS.matches(node, handler, NODE_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeNameMatchers.java",
  "methodName" : "testEqualsNoMatch",
  "sourceCode" : "/**\r\n * Tests the equals matcher for a non matching name.\r\n */\r\n@Test\r\nvoid testEqualsNoMatch() {\r\n    final ImmutableNode node = createNode(NODE_NAME);\r\n    assertFalse(NodeNameMatchers.EQUALS.matches(node, handler, NODE_NAME + \"_other\"));\r\n    assertFalse(NodeNameMatchers.EQUALS.matches(node, handler, StringUtils.toRootLowerCase(NODE_NAME)));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeNameMatchers.java",
  "methodName" : "testEqualsNullCriterion",
  "sourceCode" : "/**\r\n * Tests whether the equals matcher can handle a null criterion.\r\n */\r\n@Test\r\nvoid testEqualsNullCriterion() {\r\n    checkMatcherWithNullInput(NodeNameMatchers.EQUALS);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testEqualsFalse",
  "sourceCode" : "/**\r\n * Tests equals() if the expected result is false.\r\n */\r\n@Test\r\nvoid testEqualsFalse() {\r\n    final NodeSelector selector = new NodeSelector(KEY);\r\n    NodeSelector sel2 = new NodeSelector(\"other\" + KEY);\r\n    ConfigurationAssert.checkEquals(selector, sel2, false);\r\n    sel2 = new NodeSelector(KEY).subSelector(KEY);\r\n    ConfigurationAssert.checkEquals(selector, sel2, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testEqualsOtherObjects",
  "sourceCode" : "/**\r\n * Tests equals() with other objects.\r\n */\r\n@Test\r\nvoid testEqualsOtherObjects() {\r\n    final NodeSelector selector = new NodeSelector(KEY);\r\n    ConfigurationAssert.checkEquals(selector, null, false);\r\n    ConfigurationAssert.checkEquals(selector, this, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testEqualsTrue",
  "sourceCode" : "/**\r\n * Tests equals() if the expected result is true.\r\n */\r\n@Test\r\nvoid testEqualsTrue() {\r\n    final NodeSelector selector = new NodeSelector(KEY);\r\n    ConfigurationAssert.checkEquals(selector, selector, true);\r\n    final NodeSelector sel2 = new NodeSelector(KEY);\r\n    ConfigurationAssert.checkEquals(selector, sel2, true);\r\n    final NodeSelector sub1 = selector.subSelector(\"k2\");\r\n    final NodeSelector sub2 = sel2.subSelector(\"k2\");\r\n    ConfigurationAssert.checkEquals(sub1, sub2, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testSelectIgnoreAttributeResults",
  "sourceCode" : "/**\r\n * Tests whether attribute results are ignored when evaluating the key.\r\n */\r\n@Test\r\nvoid testSelectIgnoreAttributeResults() {\r\n    final NodeKeyResolver<ImmutableNode> resolverMock = NodeStructureHelper.createResolverMock();\r\n    final List<QueryResult<ImmutableNode>> results = new LinkedList<>();\r\n    results.add(QueryResult.createAttributeResult(NodeStructureHelper.nodeForKey(root, \"tables/table(0)\"), \"type\"));\r\n    final ImmutableNode target = NodeStructureHelper.nodeForKey(root, \"tables/table(1)\");\r\n    results.add(QueryResult.createNodeResult(target));\r\n    results.add(QueryResult.createAttributeResult(NodeStructureHelper.nodeForKey(root, \"tables/table(0)/fields/field(1)\"), \"type\"));\r\n    when(resolverMock.resolveKey(root, KEY, handler)).thenReturn(results);\r\n    final NodeSelector selector = new NodeSelector(KEY);\r\n    assertSame(target, selector.select(root, resolverMock, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testSelectMultipleTargets",
  "sourceCode" : "/**\r\n * Tests a select operation with a key yielding multiple target nodes.\r\n */\r\n@Test\r\nvoid testSelectMultipleTargets() {\r\n    final NodeSelector selector = new NodeSelector(\"tables.table.name\");\r\n    assertNull(selector.select(root, resolver, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testSelectSingleAttributeKey",
  "sourceCode" : "/**\r\n * Tests a select operation if the key selects an attribute node.\r\n */\r\n@Test\r\nvoid testSelectSingleAttributeKey() {\r\n    final NodeKeyResolver<ImmutableNode> resolverMock = NodeStructureHelper.createResolverMock();\r\n    when(resolverMock.resolveKey(root, KEY, handler)).thenReturn(Collections.singletonList(QueryResult.createAttributeResult(root, KEY)));\r\n    final NodeSelector selector = new NodeSelector(KEY);\r\n    assertNull(selector.select(root, resolverMock, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testSelectSingleKeySuccess",
  "sourceCode" : "/**\r\n * Tests a successful select operation for a single key.\r\n */\r\n@Test\r\nvoid testSelectSingleKeySuccess() {\r\n    final NodeSelector selector = new NodeSelector(\"tables.table(0).name\");\r\n    final ImmutableNode target = selector.select(root, resolver, handler);\r\n    assertEquals(\"name\", target.getNodeName());\r\n    assertEquals(NodeStructureHelper.table(0), target.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testSelectSubKey",
  "sourceCode" : "/**\r\n * Tests a select operation with a sub key.\r\n */\r\n@Test\r\nvoid testSelectSubKey() {\r\n    final NodeSelector selectorParent = new NodeSelector(\"tables.table(0)\");\r\n    final NodeSelector selector = selectorParent.subSelector(\"fields.field(1).name\");\r\n    final ImmutableNode target = selector.select(root, resolver, handler);\r\n    assertEquals(NodeStructureHelper.field(0, 1), target.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testSelectSubKeyComplexEvaluation",
  "sourceCode" : "/**\r\n * Tests a select operation with a sub key which requires complex processing: The first kes produce multiple results;\r\n * the final key reduces the result set to a single node.\r\n */\r\n@Test\r\nvoid testSelectSubKeyComplexEvaluation() {\r\n    final NodeSelector first = new NodeSelector(\"tables.table\");\r\n    final NodeSelector second = first.subSelector(\"fields\");\r\n    final int fldIdx = NodeStructureHelper.fieldsLength(1) - 1;\r\n    final NodeSelector selector = second.subSelector(\"field(\" + fldIdx + \").name\");\r\n    final ImmutableNode target = selector.select(root, resolver, handler);\r\n    assertEquals(NodeStructureHelper.field(1, fldIdx), target.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testSelectSubKeyMultipleResults",
  "sourceCode" : "/**\r\n * Tests a select operation with a sub key which produces multiple results.\r\n */\r\n@Test\r\nvoid testSelectSubKeyMultipleResults() {\r\n    final NodeSelector selectorParent = new NodeSelector(\"tables.table\");\r\n    final NodeSelector selector = selectorParent.subSelector(\"fields.field(1).name\");\r\n    assertNull(selector.select(root, resolver, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testSelectSubKeyUnknown",
  "sourceCode" : "/**\r\n * Tests select() if a key is used which does not yield any results.\r\n */\r\n@Test\r\nvoid testSelectSubKeyUnknown() {\r\n    final NodeSelector selectorParent = new NodeSelector(\"tables.unknown\");\r\n    final NodeSelector selector = selectorParent.subSelector(\"fields.field(1).name\");\r\n    assertNull(selector.select(root, resolver, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeSelector.java",
  "methodName" : "testToString",
  "sourceCode" : "/**\r\n * Tests the string representation.\r\n */\r\n@Test\r\nvoid testToString() {\r\n    final String key2 = \"anotherSelectionKey\";\r\n    final NodeSelector selector = new NodeSelector(KEY).subSelector(key2);\r\n    final String s = selector.toString();\r\n    assertTrue(s.contains(KEY));\r\n    assertTrue(s.contains(key2));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeTreeWalker.java",
  "methodName" : "testWalkBFS",
  "sourceCode" : "/**\r\n * Tests a traversal in BFS mode.\r\n */\r\n@Test\r\nvoid testWalkBFS() {\r\n    final List<String> expected = expectBFS();\r\n    final TestVisitor visitor = new TestVisitor();\r\n    NodeTreeWalker.INSTANCE.walkBFS(NodeStructureHelper.ROOT_AUTHORS_TREE, visitor, createHandler());\r\n    assertEquals(expected, visitor.getVisitedNodes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeTreeWalker.java",
  "methodName" : "testWalkBFSNoNode",
  "sourceCode" : "/**\r\n * Tests a BFS walk if node is passed in.\r\n */\r\n@Test\r\nvoid testWalkBFSNoNode() {\r\n    final ConfigurationNodeVisitor<ImmutableNode> visitor = visitorMock();\r\n    final NodeHandler<ImmutableNode> handler = handlerMock();\r\n    NodeTreeWalker.INSTANCE.walkBFS(null, visitor, handler);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeTreeWalker.java",
  "methodName" : "testWalkBFSTerminate",
  "sourceCode" : "/**\r\n * Tests whether the terminate flag is evaluated in BFS mode.\r\n */\r\n@Test\r\nvoid testWalkBFSTerminate() {\r\n    final TestVisitor visitor = new TestVisitor();\r\n    final int nodeCount = 9;\r\n    visitor.setMaxNodeCount(nodeCount);\r\n    NodeTreeWalker.INSTANCE.walkBFS(NodeStructureHelper.ROOT_AUTHORS_TREE, visitor, createHandler());\r\n    assertEquals(nodeCount, visitor.getVisitedNodes().size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeTreeWalker.java",
  "methodName" : "testWalkDFS",
  "sourceCode" : "/**\r\n * Tests a DFS traversal.\r\n */\r\n@Test\r\nvoid testWalkDFS() {\r\n    final List<String> expected = expectDFS();\r\n    final TestVisitor visitor = new TestVisitor();\r\n    NodeTreeWalker.INSTANCE.walkDFS(NodeStructureHelper.ROOT_AUTHORS_TREE, visitor, createHandler());\r\n    assertEquals(expected, visitor.getVisitedNodes());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeTreeWalker.java",
  "methodName" : "testWalkDFSNoNode",
  "sourceCode" : "/**\r\n * Tests whether walkDFS() can handle a null node.\r\n */\r\n@Test\r\nvoid testWalkDFSNoNode() {\r\n    final ConfigurationNodeVisitor<ImmutableNode> visitor = visitorMock();\r\n    final NodeHandler<ImmutableNode> handler = handlerMock();\r\n    NodeTreeWalker.INSTANCE.walkDFS(null, visitor, handler);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeTreeWalker.java",
  "methodName" : "testWalkDFSTerminate",
  "sourceCode" : "/**\r\n * Tests whether the terminate flag is taken into account during a DFS walk.\r\n */\r\n@Test\r\nvoid testWalkDFSTerminate() {\r\n    final TestVisitor visitor = new TestVisitor();\r\n    final int nodeCount = 5;\r\n    visitor.setMaxNodeCount(nodeCount);\r\n    NodeTreeWalker.INSTANCE.walkDFS(NodeStructureHelper.ROOT_AUTHORS_TREE, visitor, createHandler());\r\n    assertEquals(nodeCount, visitor.getVisitedNodes().size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeTreeWalker.java",
  "methodName" : "testWalkNoNodeHandler",
  "sourceCode" : "/**\r\n * Tries a walk() operation without a node handler.\r\n */\r\n@Test\r\nvoid testWalkNoNodeHandler() {\r\n    final TestVisitor visitor = new TestVisitor();\r\n    assertThrows(IllegalArgumentException.class, () -> NodeTreeWalker.INSTANCE.walkDFS(NodeStructureHelper.ROOT_AUTHORS_TREE, visitor, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeTreeWalker.java",
  "methodName" : "testWalkNoVisitor",
  "sourceCode" : "/**\r\n * Tries a walk operation without a visitor.\r\n */\r\n@Test\r\nvoid testWalkNoVisitor() {\r\n    final NodeHandler<ImmutableNode> handler = createHandler();\r\n    assertThrows(IllegalArgumentException.class, () -> NodeTreeWalker.INSTANCE.walkDFS(NodeStructureHelper.ROOT_AUTHORS_TREE, null, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeUpdateData.java",
  "methodName" : "testGetChangedValuesModify",
  "sourceCode" : "/**\r\n * Tests that the map with changed values cannot be modified.\r\n */\r\n@Test\r\nvoid testGetChangedValuesModify() {\r\n    final Map<QueryResult<Object>, Object> map = new HashMap<>();\r\n    map.put(result(\"n1\"), 42);\r\n    final NodeUpdateData<Object> data = new NodeUpdateData<>(map, null, null, null);\r\n    final Map<QueryResult<Object>, Object> changedValues = data.getChangedValues();\r\n    final QueryResult<Object> result = result(\"n2\");\r\n    assertThrows(UnsupportedOperationException.class, () -> changedValues.put(result, 43));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeUpdateData.java",
  "methodName" : "testGetNewValuesModify",
  "sourceCode" : "/**\r\n * Tests that the collection with new values cannot be modified.\r\n */\r\n@Test\r\nvoid testGetNewValuesModify() {\r\n    final Collection<Object> col = new LinkedList<>();\r\n    col.add(42);\r\n    final NodeUpdateData<Object> data = new NodeUpdateData<>(null, col, null, null);\r\n    final Collection<Object> newValues = data.getNewValues();\r\n    assertThrows(UnsupportedOperationException.class, () -> newValues.add(43));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeUpdateData.java",
  "methodName" : "testGetRemovedNodesModify",
  "sourceCode" : "/**\r\n * Tests that the collection with removed nodes cannot be modified.\r\n */\r\n@Test\r\nvoid testGetRemovedNodesModify() {\r\n    final Collection<QueryResult<Object>> col = new LinkedList<>();\r\n    col.add(result(\"n1\"));\r\n    final NodeUpdateData<Object> data = new NodeUpdateData<>(null, null, col, null);\r\n    final Collection<QueryResult<Object>> removedNodes = data.getRemovedNodes();\r\n    final QueryResult<Object> result = result(\"newNode\");\r\n    assertThrows(UnsupportedOperationException.class, () -> removedNodes.add(result));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeUpdateData.java",
  "methodName" : "testInitChangedValuesDefensiveCopy",
  "sourceCode" : "/**\r\n * Tests whether a defensive copy is created from the changed values.\r\n */\r\n@Test\r\nvoid testInitChangedValuesDefensiveCopy() {\r\n    final Map<QueryResult<Object>, Object> map = new HashMap<>();\r\n    map.put(result(\"test\"), \"value\");\r\n    final NodeUpdateData<Object> data = new NodeUpdateData<>(map, null, null, null);\r\n    map.put(result(\"anotherTest\"), \"anotherValue\");\r\n    final Map<QueryResult<Object>, Object> changedValues = data.getChangedValues();\r\n    assertEquals(Collections.singletonMap(result(\"test\"), \"value\"), changedValues);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeUpdateData.java",
  "methodName" : "testInitNewValuesDefensiveCopy",
  "sourceCode" : "/**\r\n * Tests whether a defensive copy is created from the new values.\r\n */\r\n@Test\r\nvoid testInitNewValuesDefensiveCopy() {\r\n    final Collection<Object> col = new LinkedList<>();\r\n    col.add(42);\r\n    final NodeUpdateData<Object> data = new NodeUpdateData<>(null, col, null, null);\r\n    col.add(\"anotherValue\");\r\n    final Collection<Object> newValues = data.getNewValues();\r\n    assertEquals(1, newValues.size());\r\n    assertEquals(42, newValues.iterator().next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeUpdateData.java",
  "methodName" : "testInitNoData",
  "sourceCode" : "/**\r\n * Tests whether null parameters for collections are converted to empty collections.\r\n */\r\n@Test\r\nvoid testInitNoData() {\r\n    final NodeUpdateData<Object> data = new NodeUpdateData<>(null, null, null, null);\r\n    assertTrue(data.getChangedValues().isEmpty());\r\n    assertTrue(data.getNewValues().isEmpty());\r\n    assertTrue(data.getRemovedNodes().isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestNodeUpdateData.java",
  "methodName" : "testInitRemovedNodesDefensiveCopy",
  "sourceCode" : "/**\r\n * Tests whether a defensive copy is created from the removed nodes.\r\n */\r\n@Test\r\nvoid testInitRemovedNodesDefensiveCopy() {\r\n    final Collection<QueryResult<Object>> col = new LinkedList<>();\r\n    col.add(result(\"n1\"));\r\n    final NodeUpdateData<Object> data = new NodeUpdateData<>(null, null, col, null);\r\n    col.add(result(\"n2\"));\r\n    final Collection<QueryResult<Object>> removedNodes = data.getRemovedNodes();\r\n    assertEquals(1, removedNodes.size());\r\n    assertEquals(result(\"n1\"), removedNodes.iterator().next());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestOverrideCombiner.java",
  "methodName" : "testAttributes",
  "sourceCode" : "/**\r\n * Tests combination of attributes.\r\n */\r\n@Test\r\nvoid testAttributes() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(1, config.getInt(\"gui.level[@min]\"));\r\n    assertEquals(2, config.getInt(\"gui.level[@default]\"));\r\n    assertEquals(0, config.getMaxIndex(\"database.tables.table(0)[@id]\"));\r\n    assertEquals(1, config.getInt(\"database.tables.table(0)[@id]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestOverrideCombiner.java",
  "methodName" : "testCombinedTableList",
  "sourceCode" : "/**\r\n * Tests the combination of the table structure if the table node is declared as a list node. In this case the first\r\n * table structure completely overrides the second and will be directly added to the resulting structure.\r\n */\r\n@Test\r\nvoid testCombinedTableList() throws ConfigurationException {\r\n    combiner.addListNode(\"table\");\r\n    checkTable(createCombinedConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestOverrideCombiner.java",
  "methodName" : "testCombinedTableNoList",
  "sourceCode" : "/**\r\n * Tests the combination of the table structure. Because the table node is not declared as a list node the structures\r\n * will be combined. But this won't make any difference because the values in the first table override the values in the\r\n * second table.\r\n */\r\n@Test\r\nvoid testCombinedTableNoList() throws ConfigurationException {\r\n    checkTable(createCombinedConfiguration());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestOverrideCombiner.java",
  "methodName" : "testCombineProperties",
  "sourceCode" : "/**\r\n * Tests a combine operation of non-hierarchical properties. This test is related to CONFIGURATION-604.\r\n */\r\n@Test\r\nvoid testCombineProperties() {\r\n    final PropertiesConfiguration c1 = new PropertiesConfiguration();\r\n    c1.addProperty(\"x.y.simpleCase\", false);\r\n    c1.addProperty(\"x.y.between\", false);\r\n    c1.addProperty(\"x.y.isDistinctFrom\", false);\r\n    c1.addProperty(\"x.y\", false);\r\n    final PropertiesConfiguration c2 = new PropertiesConfiguration();\r\n    c2.addProperty(\"x.y\", true);\r\n    c2.addProperty(\"x.y.between\", true);\r\n    c2.addProperty(\"x.y.comparison\", true);\r\n    c2.addProperty(\"x.y.in\", true);\r\n    c2.addProperty(\"x.y.isDistinctFrom\", true);\r\n    c2.addProperty(\"x.y.simpleCase\", true);\r\n    final CombinedConfiguration config = new CombinedConfiguration(new OverrideCombiner());\r\n    config.addConfiguration(c1);\r\n    config.addConfiguration(c2);\r\n    assertFalse(config.getBoolean(\"x.y\"));\r\n    assertFalse(config.getBoolean(\"x.y.between\"));\r\n    assertFalse(config.getBoolean(\"x.y.isDistinctFrom\"));\r\n    assertFalse(config.getBoolean(\"x.y.simpleCase\"));\r\n    assertTrue(config.getBoolean(\"x.y.in\"));\r\n    assertTrue(config.getBoolean(\"x.y.comparison\"));\r\n    assertEquals(6, config.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestOverrideCombiner.java",
  "methodName" : "testListFromFirstStructure",
  "sourceCode" : "/**\r\n * Tests if a list from the first node structure overrides a list in the second structure.\r\n */\r\n@Test\r\nvoid testListFromFirstStructure() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(0, config.getMaxIndex(\"net.service.url\"));\r\n    assertEquals(\"http://service1.org\", config.getString(\"net.service.url\"));\r\n    assertFalse(config.containsKey(\"net.service.url[@type]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestOverrideCombiner.java",
  "methodName" : "testListFromSecondStructure",
  "sourceCode" : "/**\r\n * Tests if a list from the second structure is added if it is not defined in the first structure.\r\n */\r\n@Test\r\nvoid testListFromSecondStructure() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(3, config.getMaxIndex(\"net.server.url\"));\r\n    assertEquals(\"http://testsvr.com\", config.getString(\"net.server.url(2)\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestOverrideCombiner.java",
  "methodName" : "testOverrideValues",
  "sourceCode" : "/**\r\n * Tests whether property values are correctly overridden.\r\n */\r\n@Test\r\nvoid testOverrideValues() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(\"Admin\", config.getString(\"base.services.security.login.user\"));\r\n    assertEquals(\"default\", config.getString(\"base.services.security.login.user[@type]\"));\r\n    assertEquals(\"BeamMeUp\", config.getString(\"base.services.security.login.passwd\"));\r\n    assertEquals(\"secret\", config.getString(\"base.services.security.login.passwd[@type]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestOverrideCombiner.java",
  "methodName" : "testSimpleValues",
  "sourceCode" : "/**\r\n * Tests combination of simple elements.\r\n */\r\n@Test\r\nvoid testSimpleValues() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(0, config.getMaxIndex(\"gui.bgcolor\"));\r\n    assertEquals(\"green\", config.getString(\"gui.bgcolor\"));\r\n    assertEquals(\"yellow\", config.getString(\"gui.selcolor\"));\r\n    assertEquals(\"blue\", config.getString(\"gui.fgcolor\"));\r\n    assertEquals(1, config.getInt(\"gui.level\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testEqualsFalse",
  "sourceCode" : "/**\r\n * Tests equals() if the expected result is false.\r\n */\r\n@Test\r\nvoid testEqualsFalse() {\r\n    final QueryResult<ImmutableNode> nodeRes = QueryResult.createNodeResult(resultNode);\r\n    final QueryResult<ImmutableNode> attrRes = QueryResult.createAttributeResult(attributeNode, ATTR);\r\n    checkEquals(nodeRes, attrRes, false);\r\n    QueryResult<ImmutableNode> res = QueryResult.createNodeResult(attributeNode);\r\n    checkEquals(nodeRes, res, false);\r\n    res = QueryResult.createAttributeResult(attributeNode, \"otherAttr\");\r\n    checkEquals(attrRes, res, false);\r\n    res = QueryResult.createAttributeResult(resultNode, ATTR);\r\n    checkEquals(attrRes, res, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testEqualsOtherObjects",
  "sourceCode" : "/**\r\n * Tests equals() with other objects.\r\n */\r\n@Test\r\nvoid testEqualsOtherObjects() {\r\n    final QueryResult<ImmutableNode> result = QueryResult.createNodeResult(resultNode);\r\n    checkEquals(result, null, false);\r\n    checkEquals(result, this, false);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testEqualsTrue",
  "sourceCode" : "/**\r\n * Tests equals() if the expected result is true.\r\n */\r\n@Test\r\nvoid testEqualsTrue() {\r\n    QueryResult<ImmutableNode> r1 = QueryResult.createNodeResult(resultNode);\r\n    checkEquals(r1, r1, true);\r\n    QueryResult<ImmutableNode> r2 = QueryResult.createNodeResult(resultNode);\r\n    checkEquals(r1, r2, true);\r\n    r1 = QueryResult.createAttributeResult(attributeNode, ATTR);\r\n    r2 = QueryResult.createAttributeResult(attributeNode, ATTR);\r\n    checkEquals(r1, r2, true);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testGetAttributeValue",
  "sourceCode" : "/**\r\n * Tests whether the attribute's value can be queried.\r\n */\r\n@Test\r\nvoid testGetAttributeValue() {\r\n    final QueryResult<ImmutableNode> result = QueryResult.createAttributeResult(attributeNode, ATTR);\r\n    assertEquals(VALUE, result.getAttributeValue(new InMemoryNodeModel().getNodeHandler()));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testGetAttributeValueNoAttributeResult",
  "sourceCode" : "/**\r\n * Tries to query an attribute value for a non-attribute result.\r\n */\r\n@Test\r\nvoid testGetAttributeValueNoAttributeResult() {\r\n    final QueryResult<ImmutableNode> result = QueryResult.createNodeResult(resultNode);\r\n    final NodeHandler<ImmutableNode> nodeHandler = new InMemoryNodeModel().getNodeHandler();\r\n    assertThrows(IllegalStateException.class, () -> result.getAttributeValue(nodeHandler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testIsAttributeResultFalse",
  "sourceCode" : "/**\r\n * Tests is attributeResult() if the expected result is false.\r\n */\r\n@Test\r\nvoid testIsAttributeResultFalse() {\r\n    final QueryResult<ImmutableNode> result = QueryResult.createNodeResult(resultNode);\r\n    assertFalse(result.isAttributeResult());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testIsAttributeResultTrue",
  "sourceCode" : "/**\r\n * Tests isAttributeResult() if the expected result is true.\r\n */\r\n@Test\r\nvoid testIsAttributeResultTrue() {\r\n    final QueryResult<ImmutableNode> result = QueryResult.createAttributeResult(attributeNode, ATTR);\r\n    assertTrue(result.isAttributeResult());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testToStringAttributeResult",
  "sourceCode" : "/**\r\n * Tests the string representation of an attribute result.\r\n */\r\n@Test\r\nvoid testToStringAttributeResult() {\r\n    final QueryResult<ImmutableNode> result = QueryResult.createAttributeResult(attributeNode, ATTR);\r\n    final String s = result.toString();\r\n    assertTrue(s.contains(\"attribute=\" + ATTR));\r\n    assertTrue(s.contains(\"parentNode=\" + attributeNode));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestQueryResult.java",
  "methodName" : "testToStringNodeResult",
  "sourceCode" : "/**\r\n * Tests the string representation of a node result.\r\n */\r\n@Test\r\nvoid testToStringNodeResult() {\r\n    final QueryResult<ImmutableNode> result = QueryResult.createNodeResult(resultNode);\r\n    assertTrue(result.toString().contains(\"resultNode=\" + resultNode));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeHandler.java",
  "methodName" : "testGetParent",
  "sourceCode" : "/**\r\n * Tests whether a parent node can be queried.\r\n */\r\n@Test\r\nvoid testGetParent() {\r\n    final ImmutableNode node = new ImmutableNode.Builder().name(\"node\").create();\r\n    final ImmutableNode parent = new ImmutableNode.Builder().name(\"parent\").create();\r\n    when(parentHandler.getParent(node)).thenReturn(parent);\r\n    assertSame(parent, handler.getParent(node));\r\n    verify(parentHandler).getParent(node);\r\n    verifyNoMoreInteractions(parentHandler);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeHandler.java",
  "methodName" : "testGetRootNode",
  "sourceCode" : "/**\r\n * Tests whether the correct root node is returned.\r\n */\r\n@Test\r\nvoid testGetRootNode() {\r\n    assertSame(root, handler.getRootNode());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testAddNodes",
  "sourceCode" : "/**\r\n * Tests whether nodes can be added.\r\n */\r\n@Test\r\nvoid testAddNodes() {\r\n    final List<ImmutableNode> nodes = Arrays.asList(NodeStructureHelper.createNode(\"n1\", 1), NodeStructureHelper.createNode(\"n2\", 2));\r\n    setUpModel().addNodes(KEY, nodes, resolver);\r\n    verify(parentModel).addNodes(KEY, selector, nodes, resolver);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testAddProperty",
  "sourceCode" : "/**\r\n * Tests whether properties can be added.\r\n */\r\n@Test\r\nvoid testAddProperty() {\r\n    final Iterable<?> values = mock(Iterable.class);\r\n    setUpModel().addProperty(KEY, values, resolver);\r\n    verify(parentModel).addProperty(KEY, selector, values, resolver);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testClear",
  "sourceCode" : "/**\r\n * Tests whether the whole model can be cleared.\r\n */\r\n@Test\r\nvoid testClear() {\r\n    when(parentModel.clearTree(null, selector, resolver)).thenReturn(null);\r\n    setUpModel().clear(resolver);\r\n    verify(parentModel).clearTree(null, selector, resolver);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "/**\r\n * Tests whether a property can be cleared.\r\n */\r\n@Test\r\nvoid testClearProperty() {\r\n    setUpModel().clearProperty(KEY, resolver);\r\n    verify(parentModel).clearProperty(KEY, selector, resolver);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testClearTree",
  "sourceCode" : "/**\r\n * Tests whether a sub tree can be cleared.\r\n */\r\n@Test\r\nvoid testClearTree() {\r\n    final QueryResult<ImmutableNode> result = QueryResult.createNodeResult(NodeStructureHelper.createNode(\"test\", null));\r\n    final List<QueryResult<ImmutableNode>> removed = Collections.singletonList(result);\r\n    when(parentModel.clearTree(KEY, selector, resolver)).thenReturn(removed);\r\n    assertSame(removed, setUpModel().clearTree(KEY, resolver));\r\n    verify(parentModel).clearTree(KEY, selector, resolver);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testClose",
  "sourceCode" : "/**\r\n * Tests whether the model can be closed.\r\n */\r\n@Test\r\nvoid testClose() {\r\n    setUpModel().close();\r\n    verify(parentModel).untrackNode(selector);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testCloseMultipleTimes",
  "sourceCode" : "/**\r\n * Tests whether close can be called multiple times.\r\n */\r\n@Test\r\nvoid testCloseMultipleTimes() {\r\n    final TrackedNodeModel model = setUpModel();\r\n    model.close();\r\n    model.close();\r\n    verify(parentModel).untrackNode(selector);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testGetInMemoryRepresentation",
  "sourceCode" : "/**\r\n * Tests whether the correct in-memory representation can be queried.\r\n */\r\n@Test\r\nvoid testGetInMemoryRepresentation() {\r\n    final NodeHandler<ImmutableNode> handler = prepareGetNodeHandler();\r\n    final ImmutableNode root = NodeStructureHelper.createNode(\"Root\", null);\r\n    when(handler.getRootNode()).thenReturn(root);\r\n    final TrackedNodeModel model = setUpModel();\r\n    assertSame(root, model.getInMemoryRepresentation());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testGetNodeHandler",
  "sourceCode" : "/**\r\n * Tests whether a node handler can be queried.\r\n */\r\n@Test\r\nvoid testGetNodeHandler() {\r\n    final NodeHandler<ImmutableNode> handler = prepareGetNodeHandler();\r\n    assertSame(handler, setUpModel().getNodeHandler());\r\n    verify(parentModel).getTrackedNodeHandler(selector);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testInitNoParentModel",
  "sourceCode" : "/**\r\n * Tries to create an instance without a parent model.\r\n */\r\n@Test\r\nvoid testInitNoParentModel() {\r\n    assertThrows(IllegalArgumentException.class, () -> new TrackedNodeModel(null, selector, true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testInitNoSelector",
  "sourceCode" : "/**\r\n * Tries to create an instance without a selector.\r\n */\r\n@Test\r\nvoid testInitNoSelector() {\r\n    assertThrows(IllegalArgumentException.class, () -> new TrackedNodeModel(modelSupport, null, true));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testSetProperty",
  "sourceCode" : "/**\r\n * Tests whether a property can be set.\r\n */\r\n@Test\r\nvoid testSetProperty() {\r\n    final Object value = 42;\r\n    setUpModel().setProperty(KEY, value, resolver);\r\n    verify(parentModel).setProperty(KEY, selector, value, resolver);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestTrackedNodeModel.java",
  "methodName" : "testSetRootNode",
  "sourceCode" : "/**\r\n * Tests whether the root node can be changed.\r\n */\r\n@Test\r\nvoid testSetRootNode() {\r\n    final ImmutableNode root = NodeStructureHelper.createNode(\"root\", null);\r\n    final TrackedNodeModel model = setUpModel();\r\n    model.setRootNode(root);\r\n    verify(parentModel).replaceTrackedNode(selector, root);\r\n    verifyNoMoreInteractions(parentModel);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestUnionCombiner.java",
  "methodName" : "testAttributes",
  "sourceCode" : "/**\r\n * Tests combination of attributes.\r\n */\r\n@Test\r\nvoid testAttributes() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(0, config.getMaxIndex(\"database.tables.table(0)[@id]\"));\r\n    assertEquals(1, config.getInt(\"database.tables.table(0)[@id](0)\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestUnionCombiner.java",
  "methodName" : "testLists",
  "sourceCode" : "/**\r\n * Tests combination of lists.\r\n */\r\n@Test\r\nvoid testLists() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(2, config.getMaxIndex(\"net.service.url\"));\r\n    assertEquals(\"http://service1.org\", config.getString(\"net.service.url(0)\"));\r\n    assertEquals(\"http://service2.org\", config.getString(\"net.service.url(1)\"));\r\n    assertEquals(2, config.getInt(\"net.service.url(2)[@type]\"));\r\n    assertEquals(3, config.getMaxIndex(\"net.server.url\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestUnionCombiner.java",
  "methodName" : "testSimpleValues",
  "sourceCode" : "/**\r\n * Tests combination of simple values (no lists).\r\n */\r\n@Test\r\nvoid testSimpleValues() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(1, config.getMaxIndex(\"gui.bgcolor\"));\r\n    assertEquals(\"green\", config.getString(\"gui.bgcolor(0)\"));\r\n    assertEquals(\"black\", config.getString(\"gui.bgcolor(1)\"));\r\n    assertEquals(0, config.getMaxIndex(\"gui.selcolor\"));\r\n    assertEquals(\"yellow\", config.getString(\"gui.selcolor\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestUnionCombiner.java",
  "methodName" : "testSimpleValuesWithAttributes",
  "sourceCode" : "/**\r\n * Tests combinations of elements with attributes.\r\n */\r\n@Test\r\nvoid testSimpleValuesWithAttributes() throws ConfigurationException {\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(1, config.getMaxIndex(\"gui.level\"));\r\n    assertEquals(1, config.getInt(\"gui.level(0)\"));\r\n    assertEquals(4, config.getInt(\"gui.level(1)\"));\r\n    assertEquals(2, config.getInt(\"gui.level(0)[@default]\"));\r\n    assertFalse(config.containsKey(\"gui.level(0)[@min]\"));\r\n    assertEquals(1, config.getInt(\"gui.level(1)[@min]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\TestUnionCombiner.java",
  "methodName" : "testTableList",
  "sourceCode" : "/**\r\n * Tests combining a list of tables. Per default the table elements will be combined. But if they are defined as list\r\n * elements, the resulting tree should contain two table nodes.\r\n */\r\n@Test\r\nvoid testTableList() throws ConfigurationException {\r\n    combiner.addListNode(\"table\");\r\n    final BaseHierarchicalConfiguration config = createCombinedConfiguration();\r\n    assertEquals(\"documents\", config.getString(\"database.tables.table(0).name\"));\r\n    assertEquals(1, config.getInt(\"database.tables.table(0)[@id]\"));\r\n    assertEquals(\"tasks\", config.getString(\"database.tables.table(1).name\"));\r\n    assertEquals(2, config.getInt(\"database.tables.table(1)[@id]\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testAttributeIterator",
  "sourceCode" : "/**\r\n * Tests querying an iterator for attributes. Result should be null.\r\n */\r\n@Test\r\nvoid testAttributeIterator() {\r\n    assertNull(pointer.attributeIterator(new QName(null, \"test\")));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testChildIterator",
  "sourceCode" : "/**\r\n * Tests querying an iterator for children. Result should be null.\r\n */\r\n@Test\r\nvoid testChildIterator() {\r\n    assertNull(pointer.childIterator(null, false, null));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testGetBaseValue",
  "sourceCode" : "/**\r\n * Tests querying the base value.\r\n */\r\n@Test\r\nvoid testGetBaseValue() {\r\n    assertEquals(ATTR_VALUE, pointer.getBaseValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testGetImmediateNode",
  "sourceCode" : "/**\r\n * Tests querying the immediate node. Here a proxy for an attribute node should be returned.\r\n */\r\n@Test\r\nvoid testGetImmediateNode() {\r\n    final Object node = pointer.getImmediateNode();\r\n    final QueryResult<?> proxy = assertInstanceOf(QueryResult.class, node);\r\n    assertTrue(proxy.isAttributeResult());\r\n    assertEquals(parent.getConfigurationNode(), proxy.getNode());\r\n    assertEquals(ATTR_NAME, proxy.getAttributeName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testGetLength",
  "sourceCode" : "/**\r\n * Tests the length.\r\n */\r\n@Test\r\nvoid testGetLength() {\r\n    assertEquals(1, pointer.getLength());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testGetName",
  "sourceCode" : "/**\r\n * Tests querying the node name.\r\n */\r\n@Test\r\nvoid testGetName() {\r\n    final QName qName = pointer.getName();\r\n    assertEquals(ATTR_NAME, qName.getName());\r\n    assertNull(qName.getPrefix());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testGetParentPointer",
  "sourceCode" : "/**\r\n * Tests whether the correct pointer is returned.\r\n */\r\n@Test\r\nvoid testGetParentPointer() {\r\n    assertSame(parent, pointer.getParentPointer());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testGetValue",
  "sourceCode" : "/**\r\n * Tests querying the attribute's value.\r\n */\r\n@Test\r\nvoid testGetValue() {\r\n    assertEquals(ATTR_VALUE, pointer.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testIsAttribute",
  "sourceCode" : "/**\r\n * Tests the attribute flag.\r\n */\r\n@Test\r\nvoid testIsAttribute() {\r\n    assertTrue(pointer.isAttribute());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testIsCollection",
  "sourceCode" : "/**\r\n * Tests the collection flag.\r\n */\r\n@Test\r\nvoid testIsCollection() {\r\n    assertFalse(pointer.isCollection());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testIsLeaf",
  "sourceCode" : "/**\r\n * Tests the leaf flag.\r\n */\r\n@Test\r\nvoid testIsLeaf() {\r\n    assertTrue(pointer.isLeaf());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testSetValue",
  "sourceCode" : "/**\r\n * Tries to set a new value.\r\n */\r\n@Test\r\nvoid testSetValue() {\r\n    assertThrows(UnsupportedOperationException.class, () -> pointer.setValue(\"newValue\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationAttributePointer.java",
  "methodName" : "testTestNode",
  "sourceCode" : "/**\r\n * Tests the testNode() method.\r\n */\r\n@Test\r\nvoid testTestNode() {\r\n    NodeTest test = new NodeTypeTest(Compiler.NODE_TYPE_TEXT);\r\n    assertTrue(pointer.testNode(test));\r\n    test = new NodeTypeTest(Compiler.NODE_TYPE_COMMENT);\r\n    assertFalse(pointer.testNode(test));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationIteratorAttributes.java",
  "methodName" : "testIterateAllAttributes",
  "sourceCode" : "/**\r\n * Tests to iterate over all attributes.\r\n */\r\n@Test\r\nvoid testIterateAllAttributes() {\r\n    final ConfigurationNodeIteratorAttribute<ImmutableNode> it = new ConfigurationNodeIteratorAttribute<>(pointer, new QName(null, \"*\"));\r\n    assertEquals(3, iteratorSize(it));\r\n    final List<NodePointer> attrs = iterationElements(it);\r\n    final Set<String> attrNames = new HashSet<>();\r\n    for (final NodePointer np : attrs) {\r\n        attrNames.add(np.getName().getName());\r\n    }\r\n    assertTrue(attrNames.contains(ATTR_NAME));\r\n    assertTrue(attrNames.contains(TEST_ATTR));\r\n    assertTrue(attrNames.contains(NS_ATTR));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationIteratorAttributes.java",
  "methodName" : "testIterateNamespaceAttribute",
  "sourceCode" : "/**\r\n * Tests whether a specific attribute with a namespace can be selected.\r\n */\r\n@Test\r\nvoid testIterateNamespaceAttribute() {\r\n    final ConfigurationNodeIteratorAttribute<ImmutableNode> it = new ConfigurationNodeIteratorAttribute<>(pointer, new QName(NAMESPACE, \"attr\"));\r\n    assertEquals(1, iteratorSize(it));\r\n    assertEquals(NS_ATTR, iterationElements(it).get(0).getName().getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationIteratorAttributes.java",
  "methodName" : "testIterateNamespaceUnknown",
  "sourceCode" : "/**\r\n * Tests iteration if an unknown namespace is specified.\r\n */\r\n@Test\r\nvoid testIterateNamespaceUnknown() {\r\n    final ConfigurationNodeIteratorAttribute<ImmutableNode> it = new ConfigurationNodeIteratorAttribute<>(pointer, new QName(\"test\", \"*\"));\r\n    assertEquals(0, iteratorSize(it));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationIteratorAttributes.java",
  "methodName" : "testIterateNamespaceWildcard",
  "sourceCode" : "/**\r\n * Tests whether a wildcard can be used together with a namespace.\r\n */\r\n@Test\r\nvoid testIterateNamespaceWildcard() {\r\n    final ConfigurationNodeIteratorAttribute<ImmutableNode> it = new ConfigurationNodeIteratorAttribute<>(pointer, new QName(NAMESPACE, \"*\"));\r\n    assertEquals(1, iteratorSize(it));\r\n    assertEquals(NS_ATTR, iterationElements(it).get(0).getName().getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationIteratorAttributes.java",
  "methodName" : "testIterateSpecificAttribute",
  "sourceCode" : "/**\r\n * Tests to iterate over attributes with a specific name.\r\n */\r\n@Test\r\nvoid testIterateSpecificAttribute() {\r\n    final ConfigurationNodeIteratorAttribute<ImmutableNode> it = new ConfigurationNodeIteratorAttribute<>(pointer, new QName(null, TEST_ATTR));\r\n    assertEquals(1, iteratorSize(it));\r\n    assertEquals(TEST_ATTR, iterationElements(it).get(0).getName().getName());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationIteratorAttributes.java",
  "methodName" : "testIterateUnknownAttribute",
  "sourceCode" : "/**\r\n * Tests to iterate over non existing attributes.\r\n */\r\n@Test\r\nvoid testIterateUnknownAttribute() {\r\n    final ConfigurationNodeIteratorAttribute<ImmutableNode> it = new ConfigurationNodeIteratorAttribute<>(pointer, new QName(null, \"unknown\"));\r\n    assertEquals(0, iteratorSize(it));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateAllChildren",
  "sourceCode" : "/**\r\n * Tests to iterate over all children of the root node.\r\n */\r\n@Test\r\nvoid testIterateAllChildren() {\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, null, false, null);\r\n    assertEquals(CHILD_COUNT, iteratorSize(it));\r\n    checkValues(it, 1, 2, 3, 4, 5);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateReverse",
  "sourceCode" : "/**\r\n * Tests a reverse iteration.\r\n */\r\n@Test\r\nvoid testIterateReverse() {\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, null, true, null);\r\n    assertEquals(CHILD_COUNT, iteratorSize(it));\r\n    checkValues(it, 5, 4, 3, 2, 1);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateStartsWith",
  "sourceCode" : "/**\r\n * Tests defining a start node for the iteration.\r\n */\r\n@Test\r\nvoid testIterateStartsWith() {\r\n    final ConfigurationNodePointer<ImmutableNode> childPointer = new ConfigurationNodePointer<>(rootPointer, root.getChildren().get(2), handler);\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, null, false, childPointer);\r\n    assertEquals(0, it.getPosition());\r\n    final List<NodePointer> nodes = iterationElements(it);\r\n    assertEquals(CHILD_COUNT - 3, nodes.size());\r\n    int index = 4;\r\n    for (final NodePointer np : nodes) {\r\n        final ImmutableNode node = (ImmutableNode) np.getImmediateNode();\r\n        assertEquals(String.valueOf(index), node.getValue());\r\n        index++;\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateStartsWithInvalid",
  "sourceCode" : "/**\r\n * Tests iteration with an invalid start node. This should cause the iteration to start at the first position.\r\n */\r\n@Test\r\nvoid testIterateStartsWithInvalid() {\r\n    final ConfigurationNodePointer<ImmutableNode> childPointer = new ConfigurationNodePointer<>(rootPointer, new ImmutableNode.Builder().name(\"newNode\").create(), handler);\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, null, false, childPointer);\r\n    assertEquals(CHILD_COUNT, iteratorSize(it));\r\n    it.setPosition(1);\r\n    final ImmutableNode node = (ImmutableNode) it.getNodePointer().getNode();\r\n    assertEquals(\"1\", node.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateStartsWithReverse",
  "sourceCode" : "/**\r\n * Tests defining a start node for a reverse iteration.\r\n */\r\n@Test\r\nvoid testIterateStartsWithReverse() {\r\n    final ConfigurationNodePointer<ImmutableNode> childPointer = new ConfigurationNodePointer<>(rootPointer, root.getChildren().get(3), handler);\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, null, true, childPointer);\r\n    int value = 3;\r\n    for (int index = 1; it.setPosition(index); index++, value--) {\r\n        final ImmutableNode node = (ImmutableNode) it.getNodePointer().getNode();\r\n        assertEquals(String.valueOf(value), node.getValue(), \"Incorrect value at index \" + index);\r\n    }\r\n    assertEquals(0, value);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateWithMatchingPrefixTest",
  "sourceCode" : "/**\r\n * Tests whether nodes with a matching namespace prefix can be obtained.\r\n */\r\n@Test\r\nvoid testIterateWithMatchingPrefixTest() {\r\n    final NodeNameTest test = new NodeNameTest(new QName(PREFIX, PREFIX_NODE));\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(createPointerWithNamespace(), test, false, null);\r\n    assertEquals(1, iteratorSize(it));\r\n    for (final NodePointer p : iterationElements(it)) {\r\n        assertEquals(PREFIX + ':' + PREFIX_NODE, p.getName().getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateWithNameTest",
  "sourceCode" : "/**\r\n * Tests using a node test that selects a certain sub node name.\r\n */\r\n@Test\r\nvoid testIterateWithNameTest() {\r\n    final NodeNameTest test = new NodeNameTest(new QName(null, CHILD_NAME2));\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, test, false, null);\r\n    assertTrue(iteratorSize(it) > 0);\r\n    for (final NodePointer nd : iterationElements(it)) {\r\n        assertEquals(CHILD_NAME2, nd.getName().getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateWithNodeType",
  "sourceCode" : "/**\r\n * Tests using a type test for nodes. This should return all nodes.\r\n */\r\n@Test\r\nvoid testIterateWithNodeType() {\r\n    final NodeTypeTest test = new NodeTypeTest(Compiler.NODE_TYPE_NODE);\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, test, false, null);\r\n    assertEquals(CHILD_COUNT, iteratorSize(it));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateWithPrefixTest",
  "sourceCode" : "/**\r\n * Tests using a node test that defines a namespace prefix. Because namespaces are not supported, no elements should be\r\n * in the iteration.\r\n */\r\n@Test\r\nvoid testIterateWithPrefixTest() {\r\n    final NodeNameTest test = new NodeNameTest(new QName(\"prefix\", \"*\"));\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, test, false, null);\r\n    assertNull(it.getNodePointer());\r\n    assertEquals(0, iteratorSize(it));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateWithUnknownTest",
  "sourceCode" : "/**\r\n * Tests using a not supported test class. This should yield an empty iteration.\r\n */\r\n@Test\r\nvoid testIterateWithUnknownTest() {\r\n    final NodeTest test = new ProcessingInstructionTest(\"test\");\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, test, false, null);\r\n    assertEquals(0, iteratorSize(it));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateWithUnknownType",
  "sourceCode" : "/**\r\n * Tests using a type test for a non supported type. This should return an empty iteration.\r\n */\r\n@Test\r\nvoid testIterateWithUnknownType() {\r\n    final NodeTypeTest test = new NodeTypeTest(Compiler.NODE_TYPE_COMMENT);\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, test, false, null);\r\n    assertEquals(0, iteratorSize(it));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateWithWildcardTest",
  "sourceCode" : "/**\r\n * Tests using a node test with a wildcard name.\r\n */\r\n@Test\r\nvoid testIterateWithWildcardTest() {\r\n    final NodeNameTest test = new NodeNameTest(new QName(null, \"*\"));\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(rootPointer, test, false, null);\r\n    assertEquals(CHILD_COUNT, iteratorSize(it));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodeIteratorChildren.java",
  "methodName" : "testIterateWithWildcardTestPrefix",
  "sourceCode" : "/**\r\n * Tests whether all nodes with a specific prefix can be obtained.\r\n */\r\n@Test\r\nvoid testIterateWithWildcardTestPrefix() {\r\n    final NodeNameTest test = new NodeNameTest(new QName(PREFIX, \"*\"));\r\n    final ConfigurationNodeIteratorChildren<ImmutableNode> it = new ConfigurationNodeIteratorChildren<>(createPointerWithNamespace(), test, false, null);\r\n    assertEquals(1, iteratorSize(it));\r\n    for (final NodePointer p : iterationElements(it)) {\r\n        assertEquals(PREFIX + ':' + PREFIX_NODE, p.getName().getName());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointer.java",
  "methodName" : "testCompareChildNodePointersAttributes",
  "sourceCode" : "/**\r\n * Tests whether a comparison of child node pointers handle the case that the child nodes are unknown. (This should not\r\n * happen in practice.)\r\n */\r\n@Test\r\nvoid testCompareChildNodePointersAttributes() {\r\n    final ImmutableNode n1 = new ImmutableNode.Builder().name(\"n1\").create();\r\n    final ImmutableNode n2 = new ImmutableNode.Builder().name(\"n2\").create();\r\n    final NodePointer p1 = new ConfigurationNodePointer<>(pointer, n1, handler);\r\n    final NodePointer p2 = new ConfigurationNodePointer<>(pointer, n2, handler);\r\n    assertEquals(0, pointer.compareChildNodePointers(p1, p2));\r\n    assertEquals(0, pointer.compareChildNodePointers(p2, p1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointer.java",
  "methodName" : "testCompareChildNodePointersChildren",
  "sourceCode" : "/**\r\n * Tests comparing child node pointers for child nodes.\r\n */\r\n@Test\r\nvoid testCompareChildNodePointersChildren() {\r\n    final NodePointer p1 = new ConfigurationNodePointer<>(pointer, root.getChildren().get(1), handler);\r\n    final NodePointer p2 = new ConfigurationNodePointer<>(pointer, root.getChildren().get(3), handler);\r\n    assertEquals(-1, pointer.compareChildNodePointers(p1, p2));\r\n    assertEquals(1, pointer.compareChildNodePointers(p2, p1));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointer.java",
  "methodName" : "testIsAttribute",
  "sourceCode" : "/**\r\n * Tests the attribute flag.\r\n */\r\n@Test\r\nvoid testIsAttribute() {\r\n    assertFalse(pointer.isAttribute());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointer.java",
  "methodName" : "testIsLeafTrue",
  "sourceCode" : "/**\r\n * Tests the leaf flag for a real leaf node.\r\n */\r\n@Test\r\nvoid testIsLeafTrue() {\r\n    final ImmutableNode leafNode = new ImmutableNode.Builder().name(\"leafNode\").create();\r\n    pointer = new ConfigurationNodePointer<>(pointer, leafNode, handler);\r\n    assertTrue(pointer.isLeaf());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointer.java",
  "methodName" : "testIsLeave",
  "sourceCode" : "/**\r\n * Tests if leaves in the tree are correctly detected.\r\n */\r\n@Test\r\nvoid testIsLeave() {\r\n    assertFalse(pointer.isLeaf());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointer.java",
  "methodName" : "testIterators",
  "sourceCode" : "/**\r\n * Tests the iterators returned by the node pointer.\r\n */\r\n@Test\r\nvoid testIterators() {\r\n    checkIterators(pointer);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointer.java",
  "methodName" : "testSetValue",
  "sourceCode" : "/**\r\n * Tests that no new value can be set.\r\n */\r\n@Test\r\nvoid testSetValue() {\r\n    assertThrows(UnsupportedOperationException.class, () -> pointer.setValue(\"newValue\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointerFactory.java",
  "methodName" : "testFollowingSiblingAxis",
  "sourceCode" : "/**\r\n * Tests accessing the following sibling axis.\r\n */\r\n@Test\r\nvoid testFollowingSiblingAxis() {\r\n    final List<?> nodes = context.selectNodes(\"/\" + CHILD_NAME1 + \"[2]/following-sibling::*\");\r\n    assertEquals(1, nodes.size());\r\n    final ImmutableNode node = (ImmutableNode) nodes.get(0);\r\n    assertEquals(CHILD_NAME2, node.getNodeName());\r\n    assertEquals(String.valueOf(CHILD_COUNT), node.getValue());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointerFactory.java",
  "methodName" : "testIndices",
  "sourceCode" : "/**\r\n * Tests using indices to specify elements.\r\n */\r\n@Test\r\nvoid testIndices() {\r\n    assertEquals(\"1.2.3\", context.getValue(\"/\" + CHILD_NAME2 + \"[1]/\" + CHILD_NAME1 + \"[1]/\" + CHILD_NAME2 + \"[2]\"));\r\n    assertEquals(String.valueOf(CHILD_COUNT), context.getValue(CHILD_NAME2 + \"[last()]\"));\r\n    final List<?> nodes = context.selectNodes(\"/\" + CHILD_NAME1 + \"[1]/*\");\r\n    assertEquals(CHILD_COUNT, nodes.size());\r\n    int index = 1;\r\n    for (final Iterator<?> it = nodes.iterator(); it.hasNext(); index++) {\r\n        final ImmutableNode node = (ImmutableNode) it.next();\r\n        assertEquals(\"2.\" + index, node.getValue(), \"Wrong node value for child \" + index);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointerFactory.java",
  "methodName" : "testParentAxis",
  "sourceCode" : "/**\r\n * Tests accessing the parent axis.\r\n */\r\n@Test\r\nvoid testParentAxis() {\r\n    final List<?> nodes = context.selectNodes(\"/\" + CHILD_NAME2 + \"/parent::*\");\r\n    assertEquals(1, nodes.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointerFactory.java",
  "methodName" : "testPrecedingSiblingAxis",
  "sourceCode" : "/**\r\n * Tests accessing the preceding sibling axis.\r\n */\r\n@Test\r\nvoid testPrecedingSiblingAxis() {\r\n    final List<?> nodes = context.selectNodes(\"/\" + CHILD_NAME1 + \"[2]/preceding-sibling::*\");\r\n    assertEquals(3, nodes.size());\r\n    for (int index = 0, value = 3; index < nodes.size(); index++, value--) {\r\n        assertEquals(String.valueOf(value), ((ImmutableNode) nodes.get(index)).getValue());\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointerFactory.java",
  "methodName" : "testQueryAttribute",
  "sourceCode" : "/**\r\n * Tests whether the attribute of a node can be queried.\r\n */\r\n@Test\r\nvoid testQueryAttribute() {\r\n    assertEquals(\"1\", context.getValue(\"/\" + CHILD_NAME2 + \"[1]/@\" + ATTR_NAME));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointerFactory.java",
  "methodName" : "testQueryRootAttribute",
  "sourceCode" : "/**\r\n * Tests whether an attribute of the root node can be queried.\r\n */\r\n@Test\r\nvoid testQueryRootAttribute() {\r\n    assertEquals(\"true\", context.getValue(\"@\" + ATTR_ROOT));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointerFactory.java",
  "methodName" : "testSimpleXPath",
  "sourceCode" : "/**\r\n * Tests simple XPath expressions.\r\n */\r\n@Test\r\nvoid testSimpleXPath() {\r\n    List<?> results = context.selectNodes(CHILD_NAME1);\r\n    assertEquals(2, results.size());\r\n    for (final Object result : results) {\r\n        final ImmutableNode node = (ImmutableNode) result;\r\n        assertEquals(CHILD_NAME1, node.getNodeName());\r\n    }\r\n    results = context.selectNodes(\"/\" + CHILD_NAME1);\r\n    assertEquals(2, results.size());\r\n    results = context.selectNodes(CHILD_NAME2 + \"/\" + CHILD_NAME1 + \"/\" + CHILD_NAME2);\r\n    assertEquals(18, results.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestConfigurationNodePointerFactory.java",
  "methodName" : "testText",
  "sourceCode" : "/**\r\n * Tests accessing a node's text.\r\n */\r\n@Test\r\nvoid testText() {\r\n    final List<?> nodes = context.selectNodes(\"//\" + CHILD_NAME2 + \"[text()='1.1.1']\");\r\n    assertEquals(1, nodes.size());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathContextFactory.java",
  "methodName" : "testCreateContext",
  "sourceCode" : "/**\r\n * Tests whether a correct context is created.\r\n */\r\n@Test\r\nvoid testCreateContext() {\r\n    final ImmutableNode node = new ImmutableNode.Builder().name(\"testRoot\").create();\r\n    final NodeHandler<ImmutableNode> handler = new InMemoryNodeModel(node).getNodeHandler();\r\n    final JXPathContext context = factory.createContext(node, handler);\r\n    assertTrue(context.isLenient());\r\n    final ConfigurationNodePointerFactory.NodeWrapper<?> wrapper = (ConfigurationNodePointerFactory.NodeWrapper<?>) context.getContextBean();\r\n    assertSame(node, wrapper.getNode());\r\n    assertSame(handler, wrapper.getNodeHandler());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testAttributeKeyOfRootNode",
  "sourceCode" : "/**\r\n * Tests the key of an attribute which belongs to the root node.\r\n */\r\n@Test\r\nvoid testAttributeKeyOfRootNode() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"@child\", engine.attributeKey(null, \"child\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testCanonicalKeyNoDuplicates",
  "sourceCode" : "/**\r\n * Tests whether a canonical key can be queried if all child nodes have different names.\r\n */\r\n@Test\r\nvoid testCanonicalKeyNoDuplicates() {\r\n    final ImmutableNode.Builder parentBuilder = new ImmutableNode.Builder(2);\r\n    final ImmutableNode c1 = new ImmutableNode.Builder().name(\"child\").create();\r\n    final ImmutableNode c2 = new ImmutableNode.Builder().name(\"child_other\").create();\r\n    parentBuilder.addChildren(Arrays.asList(c2, c1));\r\n    final ImmutableNode parent = parentBuilder.create();\r\n    final NodeHandler<ImmutableNode> testHandler = new InMemoryNodeModel(parent).getNodeHandler();\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"parent/child[1]\", engine.canonicalKey(c1, \"parent\", testHandler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testCanonicalKeyNoParentKey",
  "sourceCode" : "/**\r\n * Tests whether the parent key can be undefined when querying a canonical key.\r\n */\r\n@Test\r\nvoid testCanonicalKeyNoParentKey() {\r\n    final ImmutableNode.Builder parentBuilder = new ImmutableNode.Builder(1);\r\n    final ImmutableNode c1 = new ImmutableNode.Builder().name(\"child\").create();\r\n    final ImmutableNode parent = parentBuilder.addChild(c1).create();\r\n    final NodeHandler<ImmutableNode> testHandler = new InMemoryNodeModel(parent).getNodeHandler();\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"child[1]\", engine.canonicalKey(c1, null, testHandler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testCanonicalKeyRootNoParentKey",
  "sourceCode" : "/**\r\n * Tests whether a canonical key for the parent node can be queried if no parent key was passed in.\r\n */\r\n@Test\r\nvoid testCanonicalKeyRootNoParentKey() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"\", engine.canonicalKey(root, null, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testCanonicalKeyRootWithParentKey",
  "sourceCode" : "/**\r\n * Tests whether a parent key is evaluated when determining the canonical key of the root node.\r\n */\r\n@Test\r\nvoid testCanonicalKeyRootWithParentKey() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"parent\", engine.canonicalKey(root, \"parent\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testCanonicalKeyWithDuplicates",
  "sourceCode" : "/**\r\n * Tests whether duplicates are correctly resolved when querying for canonical keys.\r\n */\r\n@Test\r\nvoid testCanonicalKeyWithDuplicates() {\r\n    final ImmutableNode.Builder parentBuilder = new ImmutableNode.Builder(3);\r\n    final ImmutableNode c1 = new ImmutableNode.Builder().name(\"child\").create();\r\n    final ImmutableNode c2 = new ImmutableNode.Builder().name(\"child\").create();\r\n    final ImmutableNode c3 = new ImmutableNode.Builder().name(\"child_other\").create();\r\n    parentBuilder.addChildren(Arrays.asList(c1, c2, c3));\r\n    final ImmutableNode parent = parentBuilder.create();\r\n    final NodeHandler<ImmutableNode> testHandler = new InMemoryNodeModel(parent).getNodeHandler();\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"parent/child[1]\", engine.canonicalKey(c1, \"parent\", testHandler));\r\n    assertEquals(\"parent/child[2]\", engine.canonicalKey(c2, \"parent\", testHandler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testDefaultContextFactory",
  "sourceCode" : "/**\r\n * Tests whether a correct default context factory is created.\r\n */\r\n@Test\r\nvoid testDefaultContextFactory() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertNotNull(engine.getContextFactory());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testNodeKeyAttribute",
  "sourceCode" : "/**\r\n * Tests whether the key of an attribute can be generated.\r\n */\r\n@Test\r\nvoid testNodeKeyAttribute() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"node/@attr\", engine.attributeKey(\"node\", \"attr\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testNodeKeyForRootChild",
  "sourceCode" : "/**\r\n * Tests node key() for direct children of the root node.\r\n */\r\n@Test\r\nvoid testNodeKeyForRootChild() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(ROOT_NAME, engine.nodeKey(root, \"\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testNodeKeyForRootNode",
  "sourceCode" : "/**\r\n * Tests nodeKey() for the root node.\r\n */\r\n@Test\r\nvoid testNodeKeyForRootNode() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"\", engine.nodeKey(root, null, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testNodeKeyNoNodeName",
  "sourceCode" : "/**\r\n * Tests a node key if the node does not have a name.\r\n */\r\n@Test\r\nvoid testNodeKeyNoNodeName() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"test\", engine.nodeKey(new ImmutableNode.Builder().create(), \"test\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testNodeKeyNormal",
  "sourceCode" : "/**\r\n * Tests a normal call of nodeKey().\r\n */\r\n@Test\r\nvoid testNodeKeyNormal() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertEquals(\"parent/\" + ROOT_NAME, engine.nodeKey(root, \"parent\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testNodePointerFactory",
  "sourceCode" : "/**\r\n * Tests if the JXPathContext is correctly initialized with the node pointer factory.\r\n */\r\n@Test\r\nvoid testNodePointerFactory() {\r\n    JXPathContext.newContext(this);\r\n    final NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();\r\n    boolean found = false;\r\n    for (final NodePointerFactory factory : factories) {\r\n        if (factory instanceof ConfigurationNodePointerFactory) {\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n    assertTrue(found);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddAttribute",
  "sourceCode" : "/**\r\n * Tests adding a new attribute node.\r\n */\r\n@Test\r\nvoid testPrepareAddAttribute() {\r\n    final JXPathContext ctx = expectSelect(root);\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, TEST_KEY + \"\\t@newAttr\", handler);\r\n    checkAddPath(data, true, \"newAttr\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddAttributePath",
  "sourceCode" : "/**\r\n * Tests adding a complete path whose final node is an attribute.\r\n */\r\n@Test\r\nvoid testPrepareAddAttributePath() {\r\n    final JXPathContext ctx = expectSelect(root);\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, TEST_KEY + \" a/full/path@attr\", handler);\r\n    checkAddPath(data, true, \"a\", \"full\", \"path\", \"attr\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddEmptyKey",
  "sourceCode" : "/**\r\n * Tests an add operation where the key is empty.\r\n */\r\n@Test\r\nvoid testPrepareAddEmptyKey() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertThrows(IllegalArgumentException.class, () -> engine.prepareAdd(root, \"\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddEmptyPath",
  "sourceCode" : "/**\r\n * Tests an add operation with an empty path for the new node.\r\n */\r\n@Test\r\nvoid testPrepareAddEmptyPath() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertThrows(IllegalArgumentException.class, () -> engine.prepareAdd(root, TEST_KEY + \" \", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddInvalidAttributePath",
  "sourceCode" : "/**\r\n * Tests an add operation with an invalid path: the path contains an attribute in the middle part.\r\n */\r\n@Test\r\nvoid testPrepareAddInvalidAttributePath() {\r\n    checkInvalidAddPath(\"a/path/with@an/attribute\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddInvalidAttributePath2",
  "sourceCode" : "/**\r\n * Tests an add operation with an invalid path: the path contains an attribute after a slash.\r\n */\r\n@Test\r\nvoid testPrepareAddInvalidAttributePath2() {\r\n    checkInvalidAddPath(\"a/path/with/@attribute\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddInvalidParent",
  "sourceCode" : "/**\r\n * Tests an add operation with a query that does not return a single node.\r\n */\r\n@Test\r\nvoid testPrepareAddInvalidParent() {\r\n    final JXPathContext ctx = expectSelect();\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    assertThrows(IllegalArgumentException.class, () -> engine.prepareAdd(root, TEST_KEY + \" test\", handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddInvalidPath",
  "sourceCode" : "/**\r\n * Tests an add operation with an invalid path.\r\n */\r\n@Test\r\nvoid testPrepareAddInvalidPath() {\r\n    checkInvalidAddPath(\"an/invalid//path\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddInvalidPathMultipleAttributes",
  "sourceCode" : "/**\r\n * Tests an add operation with an invalid path that contains multiple attribute components.\r\n */\r\n@Test\r\nvoid testPrepareAddInvalidPathMultipleAttributes() {\r\n    checkInvalidAddPath(\"an@attribute@path\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddInvalidPathWithSlash",
  "sourceCode" : "/**\r\n * Tests an add operation with an invalid path that starts with a slash.\r\n */\r\n@Test\r\nvoid testPrepareAddInvalidPathWithSlash() {\r\n    checkInvalidAddPath(\"/a/path/node\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddNode",
  "sourceCode" : "/**\r\n * Tests adding a single child node.\r\n */\r\n@Test\r\nvoid testPrepareAddNode() {\r\n    final JXPathContext ctx = expectSelect(root);\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, TEST_KEY + \"  newNode\", handler);\r\n    checkAddPath(data, false, \"newNode\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddNullKey",
  "sourceCode" : "/**\r\n * Tests an add operation where the key is null.\r\n */\r\n@Test\r\nvoid testPrepareAddNullKey() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    assertThrows(IllegalArgumentException.class, () -> engine.prepareAdd(root, null, handler));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddPath",
  "sourceCode" : "/**\r\n * Tests adding a complete path.\r\n */\r\n@Test\r\nvoid testPrepareAddPath() {\r\n    final JXPathContext ctx = expectSelect(root);\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, TEST_KEY + \" \\t a/full/path/node\", handler);\r\n    checkAddPath(data, false, \"a\", \"full\", \"path\", \"node\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddRootAttribute",
  "sourceCode" : "/**\r\n * Tests adding a new attribute to the root.\r\n */\r\n@Test\r\nvoid testPrepareAddRootAttribute() {\r\n    final JXPathContext ctx = expectSelect(root);\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \" @attr\", handler);\r\n    checkAddPath(data, true, \"attr\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddRootChild",
  "sourceCode" : "/**\r\n * Tests adding a new node to the root.\r\n */\r\n@Test\r\nvoid testPrepareAddRootChild() {\r\n    final JXPathContext ctx = expectSelect(root);\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    final NodeAddData<ImmutableNode> data = engine.prepareAdd(root, \" newNode\", handler);\r\n    checkAddPath(data, false, \"newNode\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testPrepareAddToAttributeResult",
  "sourceCode" : "/**\r\n * Tests that it is not possible to add nodes to an attribute.\r\n */\r\n@Test\r\nvoid testPrepareAddToAttributeResult() {\r\n    final XPathExpressionEngine engine = new XPathExpressionEngine();\r\n    final QueryResult<ImmutableNode> result = QueryResult.createAttributeResult(root, TEST_KEY);\r\n    assertThrows(IllegalArgumentException.class, () -> engine.createNodeAddData(\"path\", result));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testQueryAttributeExpression",
  "sourceCode" : "/**\r\n * Tests a query which yields an attribute result.\r\n */\r\n@Test\r\nvoid testQueryAttributeExpression() {\r\n    final QueryResult<ImmutableNode> attrResult = QueryResult.createAttributeResult(root, \"attr\");\r\n    final JXPathContext ctx = expectSelect(attrResult);\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    final List<QueryResult<ImmutableNode>> result = engine.query(root, TEST_KEY, handler);\r\n    assertEquals(1, result.size());\r\n    assertSame(attrResult, result.get(0));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testQueryNodeExpression",
  "sourceCode" : "/**\r\n * Tests the query() method with an expression yielding a node.\r\n */\r\n@Test\r\nvoid testQueryNodeExpression() {\r\n    final JXPathContext ctx = expectSelect(root);\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    final List<QueryResult<ImmutableNode>> result = engine.query(root, TEST_KEY, handler);\r\n    assertEquals(1, result.size());\r\n    assertSame(root, result.get(0).getNode());\r\n    assertFalse(result.get(0).isAttributeResult());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testQueryWithEmptyKey",
  "sourceCode" : "/**\r\n * Tests a query with an empty key. This should directly return the root node without invoking the JXPathContext.\r\n */\r\n@Test\r\nvoid testQueryWithEmptyKey() {\r\n    checkEmptyKey(\"\");\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testQueryWithNullKey",
  "sourceCode" : "/**\r\n * Tests a query with a null key. Same as an empty key.\r\n */\r\n@Test\r\nvoid testQueryWithNullKey() {\r\n    checkEmptyKey(null);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngine.java",
  "methodName" : "testQueryWithoutResult",
  "sourceCode" : "/**\r\n * Tests a query that has no results. This should return an empty list.\r\n */\r\n@Test\r\nvoid testQueryWithoutResult() {\r\n    final JXPathContext ctx = expectSelect();\r\n    final XPathExpressionEngine engine = setUpEngine(ctx);\r\n    assertTrue(engine.query(root, TEST_KEY, handler).isEmpty());\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngineInConfig.java",
  "methodName" : "testAddPropertyComplexStructures",
  "sourceCode" : "/**\r\n * Tests whether addProperty() can be used to create more complex hierarchical structures.\r\n */\r\n@Test\r\nvoid testAddPropertyComplexStructures() {\r\n    config.addProperty(\"tables/table/name\", \"tasks\");\r\n    config.addProperty(\"tables/table[last()]/@type\", \"system\");\r\n    config.addProperty(\"tables/table[last()]/fields/field/name\", \"taskid\");\r\n    config.addProperty(\"tables/table[last()]/fields/field[last()]/@type\", \"int\");\r\n    config.addProperty(\"tables table/name\", \"documents\");\r\n    assertEquals(\"tasks\", config.getString(\"tables/table[1]/name\"));\r\n    assertEquals(\"documents\", config.getString(\"tables/table[2]/name\"));\r\n    assertEquals(\"int\", config.getString(\"tables/table[1]/fields/field[1]/@type\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngineInConfig.java",
  "methodName" : "testPropertiesWithNamespace",
  "sourceCode" : "/**\r\n * Tests whether configuration properties with a namespace can be handled.\r\n */\r\n@Test\r\nvoid testPropertiesWithNamespace() throws ConfigurationException {\r\n    // @formatter:off\r\n    final String xml = \"<Config>\\n\" + \"<dsig:Transforms xmlns:dsig=\\\"http://www.w3.org/2000/09/xmldsig#\\\">\\n\" + \"  <dsig:Transform Algorithm=\\\"http://www.w3.org/TR/1999/REC-xpath-19991116\\\">\\n\" + \"    <dsig:XPath xmlns:ietf=\\\"http://www.ietf.org\\\" xmlns:pl=\\\"http://test.test\\\">self::pl:policy1</dsig:XPath>\\n\" + \"  </dsig:Transform>\\n\" + \"  <dsig:Transform Algorithm=\\\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\\\"/>\\n\" + \"</dsig:Transforms></Config>\";\r\n    // @formatter:on\r\n    final FileHandler handler = new FileHandler(config);\r\n    handler.load(new StringReader(xml));\r\n    for (final Iterator<String> it = config.getKeys(); it.hasNext(); ) {\r\n        final String key = it.next();\r\n        assertNotNull(config.getString(key), \"No value for \" + key);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngineInConfig.java",
  "methodName" : "testSetPropertyExisting",
  "sourceCode" : "/**\r\n * Tests whether an already existing property can be changed using setProperty().\r\n */\r\n@Test\r\nvoid testSetPropertyExisting() {\r\n    config.addProperty(\" \" + KEY, \"failure\");\r\n    config.setProperty(KEY, VALUE);\r\n    assertEquals(VALUE, config.getString(KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngineInConfig.java",
  "methodName" : "testSetPropertyNewAttribute",
  "sourceCode" : "/**\r\n * Tests whether setProperty() can be used to add a new attribute.\r\n */\r\n@Test\r\nvoid testSetPropertyNewAttribute() {\r\n    final String keyAttr = KEY + \"/@attr\";\r\n    config.addProperty(\" \" + KEY, \"test\");\r\n    config.setProperty(keyAttr, VALUE);\r\n    assertEquals(VALUE, config.getString(keyAttr));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngineInConfig.java",
  "methodName" : "testSetPropertyNewKey",
  "sourceCode" : "/**\r\n * Tests whether setProperty() can be used to create a completely new key.\r\n */\r\n@Test\r\nvoid testSetPropertyNewKey() {\r\n    config.setProperty(KEY, VALUE);\r\n    assertEquals(VALUE, config.getString(KEY));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\tree\\xpath\\TestXPathExpressionEngineInConfig.java",
  "methodName" : "testSetPropertyPartlyExisting",
  "sourceCode" : "/**\r\n * Tests setProperty() if the specified path partly exists.\r\n */\r\n@Test\r\nvoid testSetPropertyPartlyExisting() {\r\n    final String testKey = KEY + \"/sub\";\r\n    config.addProperty(\" \" + KEY, \"test\");\r\n    config.setProperty(testKey, VALUE);\r\n    assertEquals(VALUE, config.getString(testKey));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestAppletConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    if (supportsApplet) {\r\n        assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestAppletConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    if (supportsApplet) {\r\n        assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n    }\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestAppletConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletContextConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletContextConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletContextConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletFilterConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletFilterConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletFilterConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletRequestConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletRequestConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletRequestConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestJakartaServletRequestConfiguration.java",
  "methodName" : "testListWithEscapedElements",
  "sourceCode" : "/**\r\n * Tests a list with elements that contain an escaped list delimiter.\r\n */\r\n@Test\r\nvoid testListWithEscapedElements() {\r\n    final String[] values = { \"test1\", \"test2\\\\,test3\", \"test4\\\\,test5\" };\r\n    final String listKey = \"test.list\";\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.addProperty(listKey, values);\r\n    assertEquals(values.length, config.getList(listKey).size());\r\n    final Configuration c = createConfiguration(config);\r\n    final List<?> v = c.getList(listKey);\r\n    final List<String> expected = new ArrayList<>();\r\n    for (final String value : values) {\r\n        expected.add(value.replace(\"\\\\\", \"\"));\r\n    }\r\n    assertEquals(expected, v);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletContextConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletContextConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletContextConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletFilterConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletFilterConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletFilterConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletRequestConfiguration.java",
  "methodName" : "testAddPropertyDirect",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testAddPropertyDirect() {\r\n    assertThrows(UnsupportedOperationException.class, super::testAddPropertyDirect);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletRequestConfiguration.java",
  "methodName" : "testClearProperty",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testClearProperty() {\r\n    assertThrows(UnsupportedOperationException.class, super::testClearProperty);\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletRequestConfiguration.java",
  "methodName" : "testContainsValue",
  "sourceCode" : "@Override\r\n@Test\r\npublic void testContainsValue() {\r\n    assertFalse(getConfiguration().containsValue(null));\r\n    assertFalse(getConfiguration().containsValue(\"\"));\r\n}",
  "annotations" : [ "Test" ]
}, {
  "filePath" : "d:\\chenhao\\test project\\commons-configuration\\src\\test\\java\\org\\apache\\commons\\configuration2\\web\\TestServletRequestConfiguration.java",
  "methodName" : "testListWithEscapedElements",
  "sourceCode" : "/**\r\n * Tests a list with elements that contain an escaped list delimiter.\r\n */\r\n@Test\r\nvoid testListWithEscapedElements() {\r\n    final String[] values = { \"test1\", \"test2\\\\,test3\", \"test4\\\\,test5\" };\r\n    final String listKey = \"test.list\";\r\n    final BaseConfiguration config = new BaseConfiguration();\r\n    config.addProperty(listKey, values);\r\n    assertEquals(values.length, config.getList(listKey).size());\r\n    final Configuration c = createConfiguration(config);\r\n    final List<?> v = c.getList(listKey);\r\n    final List<String> expected = new ArrayList<>();\r\n    for (final String value : values) {\r\n        expected.add(value.replace(\"\\\\\", \"\"));\r\n    }\r\n    assertEquals(expected, v);\r\n}",
  "annotations" : [ "Test" ]
} ]